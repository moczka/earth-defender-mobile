/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	window.addEventListener('load', onWindowLoad, false);
	
	function onWindowLoad(){
	    
	    
	    canvasApp();
	    
	}
	
	
	function canvasApp(){	
		
			var ResourceLoader = __webpack_require__(1),
	            PubSub = __webpack_require__(3),
	            Consctructors = __webpack_require__(4),
	            UIController = __webpack_require__(6),
	            Game = __webpack_require__(7);
	    
				//sets up game engine
			window.requestAnimFrame = (function(){
		return  window.requestAnimationFrame   ||
				window.webkitRequestAnimationFrame ||
				window.mozRequestAnimationFrame    ||
				window.oRequestAnimationFrame      ||
				window.msRequestAnimationFrame     ||
				function(/* function */ callback, /* DOMElement */ element){
					window.setTimeout(callback, FRAME_RATE);
				};
	        })(); 
	    
	    var state = {
	            INIT : -1,
	            LOADING: 0,
	            STORY_LINE : 1,
	            TITLE_SCREEN : 2,
	            GAME_PLAY : 3,
	            LEVEL_TRANSITION : 4,
	            BEAT_GAME : 5,
	            GAME_OVER : 6,
	            CREDITS : 7,
	            HOW_TO_PLAY : 8,
	            PAUSED : 9,
	            SHIP_JUMP : 10,
	            SET_UP_LEVEL: 11,
	
	            CURRENT : -1 
	    };
	    
	    
	    window.ResourceLoader = ResourceLoader;
		//adding the state object to the keyboardControl state property
	    var preloadImage = document.getElementById('preload');
	    
	    preloadImage.setAttribute('style', 'display: none;');
		
		//frame, assets counter and audio support
		var frameRate = new FrameRateCounter();
	
		
	    var loadBar = document.getElementById('loadBar');
	    
		//set up loader
		var loaderOptions = {
				assets : {
					imgs : {
	                    earthSprite : "assets/sprites/earth.png",
	                    playerSpriteSheet : "assets/sprites/playerShip.png",
	                    enemySpriteSheet : "assets/sprites/enemyShips.png",
	                    MothershipSpriteSheet : "assets/sprites/motherships.png",
	                    backgroundSprite : "assets/sprites/background.png",
	                    meteorSprite : "assets/sprites/meteorSprite.png",
	                    perkSprite : "assets/sprites/perks.png"
					},
	                sounds : {
	                    soundTrack : {
	                        src: ['assets/sounds/soundtrack.mp3','assets/sounds/soundtrack.wav'],
	                        volume: 0.5,
	                        loop: false
	                        },
	                    lastLevelSound : {
	                         src: ['assets/sounds/finalLevelSound.mp3','assets/sounds/finalLevelSound.wav'],
	                         volume: 1,
	                        },
	                    meteorExplosionSound : {
	                        src: ['assets/sounds/meteorExplosion.mp3','assets/sounds/meteorExplosion.wav'],
	                        volume: 1,
	                        },
	                    playerShootSound : {
	                        src: ['assets/sounds/shoot.mp3','assets/sounds/shoot.wav'],
	                        volume: 0.3,
	                        },
	                    explosionSound : {
	                        src: ['assets/sounds/explosion.mp3','assets/sounds/explosion.wav'],
	                        volume: 0.2,
	                        },
	                    perkSound : {
	                        src: ['assets/sounds/perk.mp3','assets/sounds/perk.wav'],
	                        volume: 1.0,
	                        },
	                    victorySound : {
	                        src: ['assets/sounds/victory.mp3','assets/sounds/victory.wav'],
	                        volume: 1.0,
	                        },
	                    gameOverSound : {
	                        src: ['assets/sounds/gameover.mp3','assets/sounds/gameover.wav'],
	                        volume: 1.0,
	                        }
	                }
				},
	            useHowl : true,
	        
				onload : function(item){
					loadBar.setAttribute('style', 'width: '+ResourceLoader.loaded*100+'%;');
				},
	        
				final : function(){
	                Game.init();
					PubSub.publish('statechange', {from:state.LOADING, to:state.STORY_LINE});
				}
			};
	    
	    UIController.init();
	    ResourceLoader.init(loaderOptions);
	    ResourceLoader.downloadAll();
	    
	    
	   
	    
	    
	    
	    //PubSub.publish('statechange', {from: state.LOADING, to: state.STORY_LINE});
	    
		
		//counters
		var scoreCounter = document.getElementById('scoreCounter');
		var levelCounter = document.getElementById('levelCounter');
		var livesCounter = document.getElementById('livesCounter');
		var frameRateCounter = document.getElementById('frameRate');
	    var reportEnemiesKilled = document.getElementById('reportCarnage');
	    var reportRocksDestroyed = document.getElementById('eportAsteroids');
	    var reportScore = document.getElementById('reportScore');
	    var beatGameScore = document.getElementById('beatGameScore');
		
	
		
	
	        
	    //game score tracker
	    
	    function recordCollision(objectType){
	        switch(objectType){
	            case "largeRock":
	                currentScore += 20;
	                updateCounter('score');
	                rocksDestroyed++;
	                break;
	                
	            case "mediumRock":
	                currentScore += 10;
	                updateCounter('score');
	                rocksDestroyed++;
	                break;
	                
	            case "smallRock":
	                currentScore += 5;
	                updateCounter('score');
	                rocksDestroyed++;
	                break;
	                
	            case "humanShip":
	                shipLives--;
	                currentScore -= 50;
	                updateCounter('score');
	                updateCounter('life');
	                break;
	                
	            case "enemy":
	                currentScore += 50;
	                updateCounter('score');
	                levelEnemies--;
	                enemiesKilled++;
	                break;
	                
	            case "life":
	                shipLives++;
	                updateCounter('life');
	                break;
	                
	            case "shield":
	                playerShip.shield.reset();
	                break;
	            case "cash":
	                break;
	        }
	        
	    }
	    
		//handles the mousemove interaction at title screen.
		function onMouseMove(event){
	        
			if(state.CURRENT != state.TITLE_SCREEN){
	            return;
	        }
	        
			if ( event.layerX ||  event.layerX == 0) { // Firefox
	   			mouse.x = event.layerX ;
	    		mouse.y = event.layerY;
	  		} else if (event.offsetX || event.offsetX == 0) { // Opera
	    		mouse.x = event.offsetX;
	    		mouse.y = event.offsetY;
	  		}
			
		}
		
		//Checks for device orientation
		function onOrientationChange(e){
	
			if(window.innerHeight>= window.innerWidth){
				userAgent.portrait = true;
				orientationMessageHolder.setAttribute('style', 'display: block;');
				canvasHolder.setAttribute('style', 'display:none;');
	            interfaceWrapper.setAttribute('style', 'display: none;');
			}else if(window.innerHeight<=window.innerWidth){
				orientationMessageHolder.setAttribute('style', '');
				canvasHolder.setAttribute('style', '');
	            interfaceWrapper.setAttribute('style', '');
				userAgent.portrait = false;
			}
			
		}
		
		//removes the default behavior of pinching zoom on Mobile
		function onTouchMove(e){
			
			e.preventDefault();
		}
	
		//FramRate Class
		
		function FrameRateCounter() {
	
	        this.lastFrameCount = 0;
	        var dateTemp = new Date();
	        this.frameLast = dateTemp.getTime();
	        delete dateTemp;
	        this.frameCtr = 0;
	    }
	
	    FrameRateCounter.prototype.countFrames=function() {
	       var dateTemp = new Date();
	       this.frameCtr++;
	
	       if (dateTemp.getTime() >=this.frameLast+1000) {
	          //ConsoleLog.log("frame event");
	          this.lastFrameCount = this.frameCtr;
	          this.frameLast = dateTemp.getTime();
	          this.frameCtr = 0;
	       }
	
	       delete dateTemp;
	    }
	
	}


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	var Howl = __webpack_require__(2).Howl;
	var PubSub = __webpack_require__(3);
	
	
	var ResourceLoader = (function(){
		
		var totalAssets = 0,
			loadedAssets = 0,
			assetsDownloaded = false,
			UserOptions,
			percentageLoaded,
			audioSupport,
			assets = {};
		
			//default options if no option argument is passed by user.
			var defaultOptions = {
						  onload: function(){ 
							console.log('No callback was passed in..');
							},
						  final : function(){
							  console.log('No final function to call was passed in..');
						  },
						 assets : []
						 };
		
		/* Example of options:
		
		{
			assets : {
			
				imgs : {
					//img names with URLs
					bg_black : "assets/img/background.png,
					meteorSprite : "assets/img/meteor.png,
					enemiesSprite : "assets/img/enemies.png,
					enemyShipSprites: "assets/img/enemyShips.png
				},
				sounds : {
					//sounds name with URLs
					soundtrack : ["assets/sounds/player.mp3", "assets/sounds/player.wav"],
					endSound : ["assets/sounds/gameover.mp3", "assets/sounds/gameover.wav"]
				}
			}
	        useHowl : false,
				//function that is called on every item loaded
			onload : updateLoaderDisplayer,
				//function that is called once all have loaded
			final : finalFunctionToCall
		}
	
		*/
			
		function init(options){
			UserOptions = options || defaultOptions;
		}
		
		function download(){
			
			//return if all assets have already loaded and indexed.
			if(assetsDownloaded) return;
	        
	        PubSub.publish('statechange', {from: state.INIT, to: state.LOADING});
			
			//sets to true so this method (downloadAll()) is called only onced.
			assetsDownloaded = true;
			//creates the sound and image elements for each asset in the options argument.
			for(var item in UserOptions.assets.imgs){
				assets[item] = new Image();
				assets[item].src = UserOptions.assets.imgs[item];
				assets[item].addEventListener('load', onLoad, false);
				totalAssets++;
			}
			//arrays are passed for each sound asset containing the source to the sound.
	        if(!UserOptions.useHowl){
	            for(var item in UserOptions.assets.sounds){
	                for(var i=0, j=UserOptions.assets.sounds[item].length; i<j; i++){
	                var currentSound = UserOptions.assets.sounds[item][i];
	                    //analyzes the extension and picks the first one that is supported by the browser.
	                    if(isAudioSupport(currentSound.slice(-3))){
	                        assets[item] = new Audio();
	                        assets[item].src = UserOptions.assets.sounds[item][i];
	                        assets[item].addEventListener('canplaythrough', onLoad, false);
	                        totalAssets++;
	                        break;
	                    }
	                }
	
	            }
	        }else{
	            //creates howl instance and passes in howl options given by the user.
	            for(var item in UserOptions.assets.sounds){
	                var howlOptions = UserOptions.assets.sounds[item];
	                howlOptions.onload = onLoad;
	                assets[item] = new Howl(howlOptions); 
	                totalAssets++;
	                
	            }
	        }
			
		}
		
		function onLoad(item){
	        
	        //increments load count and remove listeners.
			loadedAssets++;
	        
	        var itemLoaded;
	
	        if(item){
	            if(item.target.tagName === "AUDIO"){
	                itemLoaded = item.target;
	                item.target.removeEventListener('canplaythrough', onLoad, false);
	            }else if (item.target.tagName === "IMG"){
	                itemLoaded = item.target;
	                item.target.removeEventListener('load', onLoad, false);
	            }
	        }else{
	            itemLoaded = {name: "Howl sound", src: "Howl sound check sound"};   
	        }
	        
			//calculates the decimal value from ratio
			percentageLoaded = Math.floor((loadedAssets / totalAssets)*100)/100;
			
			//call the appropriate callback function given the ammount of assets loaded.
			if(UserOptions.onload){
				UserOptions.onload(itemLoaded);
			}
			if(loadedAssets >= totalAssets && UserOptions.final){
				UserOptions.final(itemLoaded);
			}
			
		}
		
		//gets the appropriate supported audio format.
		function isAudioSupport(extension){
			
			var audio = new Audio();
			var supportValue = audio.canPlayType("audio/"+extension);
			if( supportValue === "maybe" || supportValue === "probably" ){
				return true;
			}else{
				return false;
			}
		}
		
		return {
			init : init,
			assets : assets,
			get loaded(){
				return percentageLoaded;
			},
	    	downloadAll : download
		}
		
	})();
	
	module.exports = ResourceLoader;

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(global) {/*!
	 *  howler.js v2.0.0
	 *  howlerjs.com
	 *
	 *  (c) 2013-2016, James Simpson of GoldFire Studios
	 *  goldfirestudios.com
	 *
	 *  MIT License
	 */
	
	(function() {
	
	  'use strict';
	
	  /** Global Methods **/
	  /***************************************************************************/
	
	  /**
	   * Create the global controller. All contained methods and properties apply
	   * to all sounds that are currently playing or will be in the future.
	   */
	  var HowlerGlobal = function() {
	    this.init();
	  };
	  HowlerGlobal.prototype = {
	    /**
	     * Initialize the global Howler object.
	     * @return {Howler}
	     */
	    init: function() {
	      var self = this || Howler;
	
	      // Internal properties.
	      self._codecs = {};
	      self._howls = [];
	      self._muted = false;
	      self._volume = 1;
	      self._canPlayEvent = 'canplaythrough';
	      self._navigator = (typeof window !== 'undefined' && window.navigator) ? window.navigator : null;
	
	      // Public properties.
	      self.masterGain = null;
	      self.noAudio = false;
	      self.usingWebAudio = true;
	      self.autoSuspend = true;
	      self.ctx = null;
	
	      // Set to false to disable the auto iOS enabler.
	      self.mobileAutoEnable = true;
	
	      // Setup the various state values for global tracking.
	      self._setup();
	
	      return self;
	    },
	
	    /**
	     * Get/set the global volume for all sounds.
	     * @param  {Float} vol Volume from 0.0 to 1.0.
	     * @return {Howler/Float}     Returns self or current volume.
	     */
	    volume: function(vol) {
	      var self = this || Howler;
	      vol = parseFloat(vol);
	
	      // If we don't have an AudioContext created yet, run the setup.
	      if (!self.ctx) {
	        setupAudioContext();
	      }
	
	      if (typeof vol !== 'undefined' && vol >= 0 && vol <= 1) {
	        self._volume = vol;
	
	        // Don't update any of the nodes if we are muted.
	        if (self._muted) {
	          return self;
	        }
	
	        // When using Web Audio, we just need to adjust the master gain.
	        if (self.usingWebAudio) {
	          self.masterGain.gain.value = vol;
	        }
	
	        // Loop through and change volume for all HTML5 audio nodes.
	        for (var i=0; i<self._howls.length; i++) {
	          if (!self._howls[i]._webAudio) {
	            // Get all of the sounds in this Howl group.
	            var ids = self._howls[i]._getSoundIds();
	
	            // Loop through all sounds and change the volumes.
	            for (var j=0; j<ids.length; j++) {
	              var sound = self._howls[i]._soundById(ids[j]);
	
	              if (sound && sound._node) {
	                sound._node.volume = sound._volume * vol;
	              }
	            }
	          }
	        }
	
	        return self;
	      }
	
	      return self._volume;
	    },
	
	    /**
	     * Handle muting and unmuting globally.
	     * @param  {Boolean} muted Is muted or not.
	     */
	    mute: function(muted) {
	      var self = this || Howler;
	
	      // If we don't have an AudioContext created yet, run the setup.
	      if (!self.ctx) {
	        setupAudioContext();
	      }
	
	      self._muted = muted;
	
	      // With Web Audio, we just need to mute the master gain.
	      if (self.usingWebAudio) {
	        self.masterGain.gain.value = muted ? 0 : self._volume;
	      }
	
	      // Loop through and mute all HTML5 Audio nodes.
	      for (var i=0; i<self._howls.length; i++) {
	        if (!self._howls[i]._webAudio) {
	          // Get all of the sounds in this Howl group.
	          var ids = self._howls[i]._getSoundIds();
	
	          // Loop through all sounds and mark the audio node as muted.
	          for (var j=0; j<ids.length; j++) {
	            var sound = self._howls[i]._soundById(ids[j]);
	
	            if (sound && sound._node) {
	              sound._node.muted = (muted) ? true : sound._muted;
	            }
	          }
	        }
	      }
	
	      return self;
	    },
	
	    /**
	     * Unload and destroy all currently loaded Howl objects.
	     * @return {Howler}
	     */
	    unload: function() {
	      var self = this || Howler;
	
	      for (var i=self._howls.length-1; i>=0; i--) {
	        self._howls[i].unload();
	      }
	
	      // Create a new AudioContext to make sure it is fully reset.
	      if (self.usingWebAudio && typeof self.ctx.close !== 'undefined') {
	        self.ctx.close();
	        self.ctx = null;
	        setupAudioContext();
	      }
	
	      return self;
	    },
	
	    /**
	     * Check for codec support of specific extension.
	     * @param  {String} ext Audio file extention.
	     * @return {Boolean}
	     */
	    codecs: function(ext) {
	      return (this || Howler)._codecs[ext];
	    },
	
	    /**
	     * Setup various state values for global tracking.
	     * @return {Howler}
	     */
	    _setup: function() {
	      var self = this || Howler;
	
	      // Keeps track of the suspend/resume state of the AudioContext.
	      self.state = self.ctx ? self.ctx.state || 'running' : 'running';
	
	      // Automatically begin the 30-second suspend process
	      self._autoSuspend();
	
	      // Check for supported codecs.
	      if (!self.noAudio) {
	        self._setupCodecs();
	      }
	
	      return self;
	    },
	
	    /**
	     * Check for browser support for various codecs and cache the results.
	     * @return {Howler}
	     */
	    _setupCodecs: function() {
	      var self = this || Howler;
	      var audioTest = (typeof Audio !== 'undefined') ? new Audio() : null;
	
	      if (!audioTest || typeof audioTest.canPlayType !== 'function') {
	        return self;
	      }
	
	      var mpegTest = audioTest.canPlayType('audio/mpeg;').replace(/^no$/, '');
	
	      // Opera version <33 has mixed MP3 support, so we need to check for and block it.
	      var checkOpera = self._navigator && self._navigator.userAgent.match(/OPR\/([0-6].)/g);
	      var isOldOpera = (checkOpera && parseInt(checkOpera[0].split('/')[1], 10) < 33);
	
	      self._codecs = {
	        mp3: !!(!isOldOpera && (mpegTest || audioTest.canPlayType('audio/mp3;').replace(/^no$/, ''))),
	        mpeg: !!mpegTest,
	        opus: !!audioTest.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/, ''),
	        ogg: !!audioTest.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ''),
	        oga: !!audioTest.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ''),
	        wav: !!audioTest.canPlayType('audio/wav; codecs="1"').replace(/^no$/, ''),
	        aac: !!audioTest.canPlayType('audio/aac;').replace(/^no$/, ''),
	        caf: !!audioTest.canPlayType('audio/x-caf;').replace(/^no$/, ''),
	        m4a: !!(audioTest.canPlayType('audio/x-m4a;') || audioTest.canPlayType('audio/m4a;') || audioTest.canPlayType('audio/aac;')).replace(/^no$/, ''),
	        mp4: !!(audioTest.canPlayType('audio/x-mp4;') || audioTest.canPlayType('audio/mp4;') || audioTest.canPlayType('audio/aac;')).replace(/^no$/, ''),
	        weba: !!audioTest.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, ''),
	        webm: !!audioTest.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, ''),
	        dolby: !!audioTest.canPlayType('audio/mp4; codecs="ec-3"').replace(/^no$/, '')
	      };
	
	      return self;
	    },
	
	    /**
	     * Mobile browsers will only allow audio to be played after a user interaction.
	     * Attempt to automatically unlock audio on the first user interaction.
	     * Concept from: http://paulbakaus.com/tutorials/html5/web-audio-on-ios/
	     * @return {Howler}
	     */
	    _enableMobileAudio: function() {
	      var self = this || Howler;
	
	      // Only run this on mobile devices if audio isn't already eanbled.
	      var isMobile = /iPhone|iPad|iPod|Android|BlackBerry|BB10|Silk|Mobi/i.test(self._navigator && self._navigator.userAgent);
	      var isTouch = !!(('ontouchend' in window) || (self._navigator && self._navigator.maxTouchPoints > 0) || (self._navigator && self._navigator.msMaxTouchPoints > 0));
	      if (self._mobileEnabled || !self.ctx || (!isMobile && !isTouch)) {
	        return;
	      }
	
	      self._mobileEnabled = false;
	
	      // Some mobile devices/platforms have distortion issues when opening/closing tabs and/or web views.
	      // Bugs in the browser (especially Mobile Safari) can cause the sampleRate to change from 44100 to 48000.
	      // By calling Howler.unload(), we create a new AudioContext with the correct sampleRate.
	      if (!self._mobileUnloaded && self.ctx.sampleRate !== 44100) {
	        self._mobileUnloaded = true;
	        self.unload();
	      }
	
	      // Scratch buffer for enabling iOS to dispose of web audio buffers correctly, as per:
	      // http://stackoverflow.com/questions/24119684
	      self._scratchBuffer = self.ctx.createBuffer(1, 1, 22050);
	
	      // Call this method on touch start to create and play a buffer,
	      // then check if the audio actually played to determine if
	      // audio has now been unlocked on iOS, Android, etc.
	      var unlock = function() {
	        // Create an empty buffer.
	        var source = self.ctx.createBufferSource();
	        source.buffer = self._scratchBuffer;
	        source.connect(self.ctx.destination);
	
	        // Play the empty buffer.
	        if (typeof source.start === 'undefined') {
	          source.noteOn(0);
	        } else {
	          source.start(0);
	        }
	
	        // Setup a timeout to check that we are unlocked on the next event loop.
	        source.onended = function() {
	          source.disconnect(0);
	
	          // Update the unlocked state and prevent this check from happening again.
	          self._mobileEnabled = true;
	          self.mobileAutoEnable = false;
	
	          // Remove the touch start listener.
	          document.removeEventListener('touchend', unlock, true);
	        };
	      };
	
	      // Setup a touch start listener to attempt an unlock in.
	      document.addEventListener('touchend', unlock, true);
	
	      return self;
	    },
	
	    /**
	     * Automatically suspend the Web Audio AudioContext after no sound has played for 30 seconds.
	     * This saves processing/energy and fixes various browser-specific bugs with audio getting stuck.
	     * @return {Howler}
	     */
	    _autoSuspend: function() {
	      var self = this;
	
	      if (!self.autoSuspend || !self.ctx || typeof self.ctx.suspend === 'undefined' || !Howler.usingWebAudio) {
	        return;
	      }
	
	      // Check if any sounds are playing.
	      for (var i=0; i<self._howls.length; i++) {
	        if (self._howls[i]._webAudio) {
	          for (var j=0; j<self._howls[i]._sounds.length; j++) {
	            if (!self._howls[i]._sounds[j]._paused) {
	              return self;
	            }
	          }
	        }
	      }
	
	      if (self._suspendTimer) {
	        clearTimeout(self._suspendTimer);
	      }
	
	      // If no sound has played after 30 seconds, suspend the context.
	      self._suspendTimer = setTimeout(function() {
	        if (!self.autoSuspend) {
	          return;
	        }
	
	        self._suspendTimer = null;
	        self.state = 'suspending';
	        self.ctx.suspend().then(function() {
	          self.state = 'suspended';
	
	          if (self._resumeAfterSuspend) {
	            delete self._resumeAfterSuspend;
	            self._autoResume();
	          }
	        });
	      }, 30000);
	
	      return self;
	    },
	
	    /**
	     * Automatically resume the Web Audio AudioContext when a new sound is played.
	     * @return {Howler}
	     */
	    _autoResume: function() {
	      var self = this;
	
	      if (!self.ctx || typeof self.ctx.resume === 'undefined' || !Howler.usingWebAudio) {
	        return;
	      }
	
	      if (self.state === 'running' && self._suspendTimer) {
	        clearTimeout(self._suspendTimer);
	        self._suspendTimer = null;
	      } else if (self.state === 'suspended') {
	        self.state = 'resuming';
	        self.ctx.resume().then(function() {
	          self.state = 'running';
	        });
	
	        if (self._suspendTimer) {
	          clearTimeout(self._suspendTimer);
	          self._suspendTimer = null;
	        }
	      } else if (self.state === 'suspending') {
	        self._resumeAfterSuspend = true;
	      }
	
	      return self;
	    }
	  };
	
	  // Setup the global audio controller.
	  var Howler = new HowlerGlobal();
	
	  /** Group Methods **/
	  /***************************************************************************/
	
	  /**
	   * Create an audio group controller.
	   * @param {Object} o Passed in properties for this group.
	   */
	  var Howl = function(o) {
	    var self = this;
	
	    // Throw an error if no source is provided.
	    if (!o.src || o.src.length === 0) {
	      console.error('An array of source files must be passed with any new Howl.');
	      return;
	    }
	
	    self.init(o);
	  };
	  Howl.prototype = {
	    /**
	     * Initialize a new Howl group object.
	     * @param  {Object} o Passed in properties for this group.
	     * @return {Howl}
	     */
	    init: function(o) {
	      var self = this;
	
	      // If we don't have an AudioContext created yet, run the setup.
	      if (!Howler.ctx) {
	        setupAudioContext();
	      }
	
	      // Setup user-defined default properties.
	      self._autoplay = o.autoplay || false;
	      self._format = (typeof o.format !== 'string') ? o.format : [o.format];
	      self._html5 = o.html5 || false;
	      self._muted = o.mute || false;
	      self._loop = o.loop || false;
	      self._pool = o.pool || 5;
	      self._preload = (typeof o.preload === 'boolean') ? o.preload : true;
	      self._rate = o.rate || 1;
	      self._sprite = o.sprite || {};
	      self._src = (typeof o.src !== 'string') ? o.src : [o.src];
	      self._volume = o.volume !== undefined ? o.volume : 1;
	
	      // Setup all other default properties.
	      self._duration = 0;
	      self._state = 'unloaded';
	      self._sounds = [];
	      self._endTimers = {};
	      self._queue = [];
	
	      // Setup event listeners.
	      self._onend = o.onend ? [{fn: o.onend}] : [];
	      self._onfade = o.onfade ? [{fn: o.onfade}] : [];
	      self._onload = o.onload ? [{fn: o.onload}] : [];
	      self._onloaderror = o.onloaderror ? [{fn: o.onloaderror}] : [];
	      self._onpause = o.onpause ? [{fn: o.onpause}] : [];
	      self._onplay = o.onplay ? [{fn: o.onplay}] : [];
	      self._onstop = o.onstop ? [{fn: o.onstop}] : [];
	      self._onmute = o.onmute ? [{fn: o.onmute}] : [];
	      self._onvolume = o.onvolume ? [{fn: o.onvolume}] : [];
	      self._onrate = o.onrate ? [{fn: o.onrate}] : [];
	      self._onseek = o.onseek ? [{fn: o.onseek}] : [];
	
	      // Web Audio or HTML5 Audio?
	      self._webAudio = Howler.usingWebAudio && !self._html5;
	
	      // Automatically try to enable audio on iOS.
	      if (typeof Howler.ctx !== 'undefined' && Howler.ctx && Howler.mobileAutoEnable) {
	        Howler._enableMobileAudio();
	      }
	
	      // Keep track of this Howl group in the global controller.
	      Howler._howls.push(self);
	
	      // Load the source file unless otherwise specified.
	      if (self._preload) {
	        self.load();
	      }
	
	      return self;
	    },
	
	    /**
	     * Load the audio file.
	     * @return {Howler}
	     */
	    load: function() {
	      var self = this;
	      var url = null;
	
	      // If no audio is available, quit immediately.
	      if (Howler.noAudio) {
	        self._emit('loaderror', null, 'No audio support.');
	        return;
	      }
	
	      // Make sure our source is in an array.
	      if (typeof self._src === 'string') {
	        self._src = [self._src];
	      }
	
	      // Loop through the sources and pick the first one that is compatible.
	      for (var i=0; i<self._src.length; i++) {
	        var ext, str;
	
	        if (self._format && self._format[i]) {
	          // If an extension was specified, use that instead.
	          ext = self._format[i];
	        } else {
	          // Make sure the source is a string.
	          str = self._src[i];
	          if (typeof str !== 'string') {
	            self._emit('loaderror', null, 'Non-string found in selected audio sources - ignoring.');
	            continue;
	          }
	
	          // Extract the file extension from the URL or base64 data URI.
	          ext = /^data:audio\/([^;,]+);/i.exec(str);
	          if (!ext) {
	            ext = /\.([^.]+)$/.exec(str.split('?', 1)[0]);
	          }
	
	          if (ext) {
	            ext = ext[1].toLowerCase();
	          }
	        }
	
	        // Check if this extension is available.
	        if (Howler.codecs(ext)) {
	          url = self._src[i];
	          break;
	        }
	      }
	
	      if (!url) {
	        self._emit('loaderror', null, 'No codec support for selected audio sources.');
	        return;
	      }
	
	      self._src = url;
	      self._state = 'loading';
	
	      // If the hosting page is HTTPS and the source isn't,
	      // drop down to HTML5 Audio to avoid Mixed Content errors.
	      if (window.location.protocol === 'https:' && url.slice(0, 5) === 'http:') {
	        self._html5 = true;
	        self._webAudio = false;
	      }
	
	      // Create a new sound object and add it to the pool.
	      new Sound(self);
	
	      // Load and decode the audio data for playback.
	      if (self._webAudio) {
	        loadBuffer(self);
	      }
	
	      return self;
	    },
	
	    /**
	     * Play a sound or resume previous playback.
	     * @param  {String/Number} sprite   Sprite name for sprite playback or sound id to continue previous.
	     * @param  {Boolean} internal Internal Use: true prevents event firing.
	     * @return {Number}          Sound ID.
	     */
	    play: function(sprite, internal) {
	      var self = this;
	      var id = null;
	
	      // Determine if a sprite, sound id or nothing was passed
	      if (typeof sprite === 'number') {
	        id = sprite;
	        sprite = null;
	      } else if (typeof sprite === 'string' && self._state === 'loaded' && !self._sprite[sprite]) {
	        // If the passed sprite doesn't exist, do nothing.
	        return null;
	      } else if (typeof sprite === 'undefined') {
	        // Use the default sound sprite (plays the full audio length).
	        sprite = '__default';
	
	        // Check if there is a single paused sound that isn't ended.
	        // If there is, play that sound. If not, continue as usual.
	        var num = 0;
	        for (var i=0; i<self._sounds.length; i++) {
	          if (self._sounds[i]._paused && !self._sounds[i]._ended) {
	            num++;
	            id = self._sounds[i]._id;
	          }
	        }
	
	        if (num === 1) {
	          sprite = null;
	        } else {
	          id = null;
	        }
	      }
	
	      // Get the selected node, or get one from the pool.
	      var sound = id ? self._soundById(id) : self._inactiveSound();
	
	      // If the sound doesn't exist, do nothing.
	      if (!sound) {
	        return null;
	      }
	
	      // Select the sprite definition.
	      if (id && !sprite) {
	        sprite = sound._sprite || '__default';
	      }
	
	      // If we have no sprite and the sound hasn't loaded, we must wait
	      // for the sound to load to get our audio's duration.
	      if (self._state !== 'loaded' && !self._sprite[sprite]) {
	        self._queue.push({
	          event: 'play',
	          action: function() {
	            self.play(self._soundById(sound._id) ? sound._id : undefined);
	          }
	        });
	
	        return sound._id;
	      }
	
	      // Don't play the sound if an id was passed and it is already playing.
	      if (id && !sound._paused) {
	        // Trigger the play event, in order to keep iterating through queue.
	        if (!internal) {
	          setTimeout(function() {
	            self._emit('play', sound._id);
	          }, 0);
	        }
	
	        return sound._id;
	      }
	
	      // Make sure the AudioContext isn't suspended, and resume it if it is.
	      if (self._webAudio) {
	        Howler._autoResume();
	      }
	
	      // Determine how long to play for and where to start playing.
	      var seek = sound._seek > 0 ? sound._seek : self._sprite[sprite][0] / 1000;
	      var duration = ((self._sprite[sprite][0] + self._sprite[sprite][1]) / 1000) - seek;
	      var timeout = (duration * 1000) / Math.abs(sound._rate);
	
	      // Update the parameters of the sound
	      sound._paused = false;
	      sound._ended = false;
	      sound._sprite = sprite;
	      sound._seek = seek;
	      sound._start = self._sprite[sprite][0] / 1000;
	      sound._stop = (self._sprite[sprite][0] + self._sprite[sprite][1]) / 1000;
	      sound._loop = !!(sound._loop || self._sprite[sprite][2]);
	
	      // Begin the actual playback.
	      var node = sound._node;
	      if (self._webAudio) {
	        // Fire this when the sound is ready to play to begin Web Audio playback.
	        var playWebAudio = function() {
	          self._refreshBuffer(sound);
	
	          // Setup the playback params.
	          var vol = (sound._muted || self._muted) ? 0 : sound._volume;
	          node.gain.setValueAtTime(vol, Howler.ctx.currentTime);
	          sound._playStart = Howler.ctx.currentTime;
	
	          // Play the sound using the supported method.
	          if (typeof node.bufferSource.start === 'undefined') {
	            sound._loop ? node.bufferSource.noteGrainOn(0, seek, 86400) : node.bufferSource.noteGrainOn(0, seek, duration);
	          } else {
	            sound._loop ? node.bufferSource.start(0, seek, 86400) : node.bufferSource.start(0, seek, duration);
	          }
	
	          // Start a new timer if none is present.
	          if (timeout !== Infinity) {
	            self._endTimers[sound._id] = setTimeout(self._ended.bind(self, sound), timeout);
	          }
	
	          if (!internal) {
	            setTimeout(function() {
	              self._emit('play', sound._id);
	            }, 0);
	          }
	        };
	
	        if (self._state === 'loaded') {
	          playWebAudio();
	        } else {
	          // Wait for the audio to load and then begin playback.
	          self.once('load', playWebAudio, sound._id);
	
	          // Cancel the end timer.
	          self._clearTimer(sound._id);
	        }
	      } else {
	        // Fire this when the sound is ready to play to begin HTML5 Audio playback.
	        var playHtml5 = function() {
	          node.currentTime = seek;
	          node.muted = sound._muted || self._muted || Howler._muted || node.muted;
	          node.volume = sound._volume * Howler.volume();
	          node.playbackRate = sound._rate;
	
	          setTimeout(function() {
	            node.play();
	
	            // Setup the new end timer.
	            if (timeout !== Infinity) {
	              self._endTimers[sound._id] = setTimeout(self._ended.bind(self, sound), timeout);
	            }
	
	            if (!internal) {
	              self._emit('play', sound._id);
	            }
	          }, 0);
	        };
	
	        // Play immediately if ready, or wait for the 'canplaythrough'e vent.
	        var loadedNoReadyState = (self._state === 'loaded' && (window && window.ejecta || !node.readyState && Howler._navigator.isCocoonJS));
	        if (node.readyState === 4 || loadedNoReadyState) {
	          playHtml5();
	        } else {
	          var listener = function() {
	            // Begin playback.
	            playHtml5();
	
	            // Clear this listener.
	            node.removeEventListener(Howler._canPlayEvent, listener, false);
	          };
	          node.addEventListener(Howler._canPlayEvent, listener, false);
	
	          // Cancel the end timer.
	          self._clearTimer(sound._id);
	        }
	      }
	
	      return sound._id;
	    },
	
	    /**
	     * Pause playback and save current position.
	     * @param  {Number} id The sound ID (empty to pause all in group).
	     * @return {Howl}
	     */
	    pause: function(id) {
	      var self = this;
	
	      // If the sound hasn't loaded, add it to the load queue to pause when capable.
	      if (self._state !== 'loaded') {
	        self._queue.push({
	          event: 'pause',
	          action: function() {
	            self.pause(id);
	          }
	        });
	
	        return self;
	      }
	
	      // If no id is passed, get all ID's to be paused.
	      var ids = self._getSoundIds(id);
	
	      for (var i=0; i<ids.length; i++) {
	        // Clear the end timer.
	        self._clearTimer(ids[i]);
	
	        // Get the sound.
	        var sound = self._soundById(ids[i]);
	
	        if (sound && !sound._paused) {
	          // Reset the seek position.
	          sound._seek = self.seek(ids[i]);
	          sound._rateSeek = 0;
	          sound._paused = true;
	
	          // Stop currently running fades.
	          self._stopFade(ids[i]);
	
	          if (sound._node) {
	            if (self._webAudio) {
	              // make sure the sound has been created
	              if (!sound._node.bufferSource) {
	                return self;
	              }
	
	              if (typeof sound._node.bufferSource.stop === 'undefined') {
	                sound._node.bufferSource.noteOff(0);
	              } else {
	                sound._node.bufferSource.stop(0);
	              }
	
	              // Clean up the buffer source.
	              self._cleanBuffer(sound._node);
	            } else if (!isNaN(sound._node.duration) || sound._node.duration === Infinity) {
	              sound._node.pause();
	            }
	          }
	
	          // Fire the pause event, unless `true` is passed as the 2nd argument.
	          if (!arguments[1]) {
	            self._emit('pause', sound._id);
	          }
	        }
	      }
	
	      return self;
	    },
	
	    /**
	     * Stop playback and reset to start.
	     * @param  {Number} id The sound ID (empty to stop all in group).
	     * @param  {Boolean} internal Internal Use: true prevents event firing.
	     * @return {Howl}
	     */
	    stop: function(id, internal) {
	      var self = this;
	
	      // If the sound hasn't loaded, add it to the load queue to stop when capable.
	      if (self._state !== 'loaded') {
	        self._queue.push({
	          event: 'stop',
	          action: function() {
	            self.stop(id);
	          }
	        });
	
	        return self;
	      }
	
	      // If no id is passed, get all ID's to be stopped.
	      var ids = self._getSoundIds(id);
	
	      for (var i=0; i<ids.length; i++) {
	        // Clear the end timer.
	        self._clearTimer(ids[i]);
	
	        // Get the sound.
	        var sound = self._soundById(ids[i]);
	
	        if (sound && !sound._paused) {
	          // Reset the seek position.
	          sound._seek = sound._start || 0;
	          sound._rateSeek = 0;
	          sound._paused = true;
	          sound._ended = true;
	
	          // Stop currently running fades.
	          self._stopFade(ids[i]);
	
	          if (sound._node) {
	            if (self._webAudio) {
	              // make sure the sound has been created
	              if (!sound._node.bufferSource) {
	                return self;
	              }
	
	              if (typeof sound._node.bufferSource.stop === 'undefined') {
	                sound._node.bufferSource.noteOff(0);
	              } else {
	                sound._node.bufferSource.stop(0);
	              }
	
	              // Clean up the buffer source.
	              self._cleanBuffer(sound._node);
	            } else if (!isNaN(sound._node.duration) || sound._node.duration === Infinity) {
	              sound._node.currentTime = sound._start || 0;
	              sound._node.pause();
	            }
	          }
	        }
	
	        if (sound && !internal) {
	          self._emit('stop', sound._id);
	        }
	      }
	
	      return self;
	    },
	
	    /**
	     * Mute/unmute a single sound or all sounds in this Howl group.
	     * @param  {Boolean} muted Set to true to mute and false to unmute.
	     * @param  {Number} id    The sound ID to update (omit to mute/unmute all).
	     * @return {Howl}
	     */
	    mute: function(muted, id) {
	      var self = this;
	
	      // If the sound hasn't loaded, add it to the load queue to mute when capable.
	      if (self._state !== 'loaded') {
	        self._queue.push({
	          event: 'mute',
	          action: function() {
	            self.mute(muted, id);
	          }
	        });
	
	        return self;
	      }
	
	      // If applying mute/unmute to all sounds, update the group's value.
	      if (typeof id === 'undefined') {
	        if (typeof muted === 'boolean') {
	          self._muted = muted;
	        } else {
	          return self._muted;
	        }
	      }
	
	      // If no id is passed, get all ID's to be muted.
	      var ids = self._getSoundIds(id);
	
	      for (var i=0; i<ids.length; i++) {
	        // Get the sound.
	        var sound = self._soundById(ids[i]);
	
	        if (sound) {
	          sound._muted = muted;
	
	          if (self._webAudio && sound._node) {
	            sound._node.gain.setValueAtTime(muted ? 0 : sound._volume, Howler.ctx.currentTime);
	          } else if (sound._node) {
	            sound._node.muted = Howler._muted ? true : muted;
	          }
	
	          self._emit('mute', sound._id);
	        }
	      }
	
	      return self;
	    },
	
	    /**
	     * Get/set the volume of this sound or of the Howl group. This method can optionally take 0, 1 or 2 arguments.
	     *   volume() -> Returns the group's volume value.
	     *   volume(id) -> Returns the sound id's current volume.
	     *   volume(vol) -> Sets the volume of all sounds in this Howl group.
	     *   volume(vol, id) -> Sets the volume of passed sound id.
	     * @return {Howl/Number} Returns self or current volume.
	     */
	    volume: function() {
	      var self = this;
	      var args = arguments;
	      var vol, id;
	
	      // Determine the values based on arguments.
	      if (args.length === 0) {
	        // Return the value of the groups' volume.
	        return self._volume;
	      } else if (args.length === 1) {
	        // First check if this is an ID, and if not, assume it is a new volume.
	        var ids = self._getSoundIds();
	        var index = ids.indexOf(args[0]);
	        if (index >= 0) {
	          id = parseInt(args[0], 10);
	        } else {
	          vol = parseFloat(args[0]);
	        }
	      } else if (args.length >= 2) {
	        vol = parseFloat(args[0]);
	        id = parseInt(args[1], 10);
	      }
	
	      // Update the volume or return the current volume.
	      var sound;
	      if (typeof vol !== 'undefined' && vol >= 0 && vol <= 1) {
	        // If the sound hasn't loaded, add it to the load queue to change volume when capable.
	        if (self._state !== 'loaded') {
	          self._queue.push({
	            event: 'volume',
	            action: function() {
	              self.volume.apply(self, args);
	            }
	          });
	
	          return self;
	        }
	
	        // Set the group volume.
	        if (typeof id === 'undefined') {
	          self._volume = vol;
	        }
	
	        // Update one or all volumes.
	        id = self._getSoundIds(id);
	        for (var i=0; i<id.length; i++) {
	          // Get the sound.
	          sound = self._soundById(id[i]);
	
	          if (sound) {
	            sound._volume = vol;
	
	            // Stop currently running fades.
	            if (!args[2]) {
	              self._stopFade(id[i]);
	            }
	
	            if (self._webAudio && sound._node && !sound._muted) {
	              sound._node.gain.setValueAtTime(vol, Howler.ctx.currentTime);
	            } else if (sound._node && !sound._muted) {
	              sound._node.volume = vol * Howler.volume();
	            }
	
	            self._emit('volume', sound._id);
	          }
	        }
	      } else {
	        sound = id ? self._soundById(id) : self._sounds[0];
	        return sound ? sound._volume : 0;
	      }
	
	      return self;
	    },
	
	    /**
	     * Fade a currently playing sound between two volumes (if no id is passsed, all sounds will fade).
	     * @param  {Number} from The value to fade from (0.0 to 1.0).
	     * @param  {Number} to   The volume to fade to (0.0 to 1.0).
	     * @param  {Number} len  Time in milliseconds to fade.
	     * @param  {Number} id   The sound id (omit to fade all sounds).
	     * @return {Howl}
	     */
	    fade: function(from, to, len, id) {
	      var self = this;
	      var diff = Math.abs(from - to);
	      var dir = from > to ? 'out' : 'in';
	      var steps = diff / 0.01;
	      var stepLen = len / steps;
	
	      // If the sound hasn't loaded, add it to the load queue to fade when capable.
	      if (self._state !== 'loaded') {
	        self._queue.push({
	          event: 'fade',
	          action: function() {
	            self.fade(from, to, len, id);
	          }
	        });
	
	        return self;
	      }
	
	      // Set the volume to the start position.
	      self.volume(from, id);
	
	      // Fade the volume of one or all sounds.
	      var ids = self._getSoundIds(id);
	      for (var i=0; i<ids.length; i++) {
	        // Get the sound.
	        var sound = self._soundById(ids[i]);
	
	        // Create a linear fade or fall back to timeouts with HTML5 Audio.
	        if (sound) {
	          // Stop the previous fade if no sprite is being used (otherwise, volume handles this).
	          if (!id) {
	            self._stopFade(ids[i]);
	          }
	
	          // If we are using Web Audio, let the native methods do the actual fade.
	          if (self._webAudio && !sound._muted) {
	            var currentTime = Howler.ctx.currentTime;
	            var end = currentTime + (len / 1000);
	            sound._volume = from;
	            sound._node.gain.setValueAtTime(from, currentTime);
	            sound._node.gain.linearRampToValueAtTime(to, end);
	          }
	
	          var vol = from;
	          sound._interval = setInterval(function(soundId, sound) {
	            // Update the volume amount.
	            vol += (dir === 'in' ? 0.01 : -0.01);
	
	            // Make sure the volume is in the right bounds.
	            vol = Math.max(0, vol);
	            vol = Math.min(1, vol);
	
	            // Round to within 2 decimal points.
	            vol = Math.round(vol * 100) / 100;
	
	            // Change the volume.
	            if (self._webAudio) {
	              if (typeof id === 'undefined') {
	                self._volume = vol;
	              }
	
	              sound._volume = vol;
	            } else {
	              self.volume(vol, soundId, true);
	            }
	
	            // When the fade is complete, stop it and fire event.
	            if (vol === to) {
	              clearInterval(sound._interval);
	              sound._interval = null;
	              self.volume(vol, soundId);
	              self._emit('fade', soundId);
	            }
	          }.bind(self, ids[i], sound), stepLen);
	        }
	      }
	
	      return self;
	    },
	
	    /**
	     * Internal method that stops the currently playing fade when
	     * a new fade starts, volume is changed or the sound is stopped.
	     * @param  {Number} id The sound id.
	     * @return {Howl}
	     */
	    _stopFade: function(id) {
	      var self = this;
	      var sound = self._soundById(id);
	
	      if (sound && sound._interval) {
	        if (self._webAudio) {
	          sound._node.gain.cancelScheduledValues(Howler.ctx.currentTime);
	        }
	
	        clearInterval(sound._interval);
	        sound._interval = null;
	        self._emit('fade', id);
	      }
	
	      return self;
	    },
	
	    /**
	     * Get/set the loop parameter on a sound. This method can optionally take 0, 1 or 2 arguments.
	     *   loop() -> Returns the group's loop value.
	     *   loop(id) -> Returns the sound id's loop value.
	     *   loop(loop) -> Sets the loop value for all sounds in this Howl group.
	     *   loop(loop, id) -> Sets the loop value of passed sound id.
	     * @return {Howl/Boolean} Returns self or current loop value.
	     */
	    loop: function() {
	      var self = this;
	      var args = arguments;
	      var loop, id, sound;
	
	      // Determine the values for loop and id.
	      if (args.length === 0) {
	        // Return the grou's loop value.
	        return self._loop;
	      } else if (args.length === 1) {
	        if (typeof args[0] === 'boolean') {
	          loop = args[0];
	          self._loop = loop;
	        } else {
	          // Return this sound's loop value.
	          sound = self._soundById(parseInt(args[0], 10));
	          return sound ? sound._loop : false;
	        }
	      } else if (args.length === 2) {
	        loop = args[0];
	        id = parseInt(args[1], 10);
	      }
	
	      // If no id is passed, get all ID's to be looped.
	      var ids = self._getSoundIds(id);
	      for (var i=0; i<ids.length; i++) {
	        sound = self._soundById(ids[i]);
	
	        if (sound) {
	          sound._loop = loop;
	          if (self._webAudio && sound._node && sound._node.bufferSource) {
	            sound._node.bufferSource.loop = loop;
	          }
	        }
	      }
	
	      return self;
	    },
	
	    /**
	     * Get/set the playback rate of a sound. This method can optionally take 0, 1 or 2 arguments.
	     *   rate() -> Returns the first sound node's current playback rate.
	     *   rate(id) -> Returns the sound id's current playback rate.
	     *   rate(rate) -> Sets the playback rate of all sounds in this Howl group.
	     *   rate(rate, id) -> Sets the playback rate of passed sound id.
	     * @return {Howl/Number} Returns self or the current playback rate.
	     */
	    rate: function() {
	      var self = this;
	      var args = arguments;
	      var rate, id;
	
	      // Determine the values based on arguments.
	      if (args.length === 0) {
	        // We will simply return the current rate of the first node.
	        id = self._sounds[0]._id;
	      } else if (args.length === 1) {
	        // First check if this is an ID, and if not, assume it is a new rate value.
	        var ids = self._getSoundIds();
	        var index = ids.indexOf(args[0]);
	        if (index >= 0) {
	          id = parseInt(args[0], 10);
	        } else {
	          rate = parseFloat(args[0]);
	        }
	      } else if (args.length === 2) {
	        rate = parseFloat(args[0]);
	        id = parseInt(args[1], 10);
	      }
	
	      // Update the playback rate or return the current value.
	      var sound;
	      if (typeof rate === 'number') {
	        // If the sound hasn't loaded, add it to the load queue to change playback rate when capable.
	        if (self._state !== 'loaded') {
	          self._queue.push({
	            event: 'rate',
	            action: function() {
	              self.rate.apply(self, args);
	            }
	          });
	
	          return self;
	        }
	
	        // Set the group rate.
	        if (typeof id === 'undefined') {
	          self._rate = rate;
	        }
	
	        // Update one or all volumes.
	        id = self._getSoundIds(id);
	        for (var i=0; i<id.length; i++) {
	          // Get the sound.
	          sound = self._soundById(id[i]);
	
	          if (sound) {
	            // Keep track of our position when the rate changed and update the playback
	            // start position so we can properly adjust the seek position for time elapsed.
	            sound._rateSeek = self.seek(id[i]);
	            sound._playStart = self._webAudio ? Howler.ctx.currentTime : sound._playStart;
	            sound._rate = rate;
	
	            // Change the playback rate.
	            if (self._webAudio && sound._node && sound._node.bufferSource) {
	              sound._node.bufferSource.playbackRate.value = rate;
	            } else if (sound._node) {
	              sound._node.playbackRate = rate;
	            }
	
	            // Reset the timers.
	            var seek = self.seek(id[i]);
	            var duration = ((self._sprite[sound._sprite][0] + self._sprite[sound._sprite][1]) / 1000) - seek;
	            var timeout = (duration * 1000) / Math.abs(sound._rate);
	
	            // Start a new end timer if sound is already playing.
	            if (self._endTimers[id[i]] || !sound._paused) {
	              self._clearTimer(id[i]);
	              self._endTimers[id[i]] = setTimeout(self._ended.bind(self, sound), timeout);
	            }
	
	            self._emit('rate', sound._id);
	          }
	        }
	      } else {
	        sound = self._soundById(id);
	        return sound ? sound._rate : self._rate;
	      }
	
	      return self;
	    },
	
	    /**
	     * Get/set the seek position of a sound. This method can optionally take 0, 1 or 2 arguments.
	     *   seek() -> Returns the first sound node's current seek position.
	     *   seek(id) -> Returns the sound id's current seek position.
	     *   seek(seek) -> Sets the seek position of the first sound node.
	     *   seek(seek, id) -> Sets the seek position of passed sound id.
	     * @return {Howl/Number} Returns self or the current seek position.
	     */
	    seek: function() {
	      var self = this;
	      var args = arguments;
	      var seek, id;
	
	      // Determine the values based on arguments.
	      if (args.length === 0) {
	        // We will simply return the current position of the first node.
	        id = self._sounds[0]._id;
	      } else if (args.length === 1) {
	        // First check if this is an ID, and if not, assume it is a new seek position.
	        var ids = self._getSoundIds();
	        var index = ids.indexOf(args[0]);
	        if (index >= 0) {
	          id = parseInt(args[0], 10);
	        } else {
	          id = self._sounds[0]._id;
	          seek = parseFloat(args[0]);
	        }
	      } else if (args.length === 2) {
	        seek = parseFloat(args[0]);
	        id = parseInt(args[1], 10);
	      }
	
	      // If there is no ID, bail out.
	      if (typeof id === 'undefined') {
	        return self;
	      }
	
	      // If the sound hasn't loaded, add it to the load queue to seek when capable.
	      if (self._state !== 'loaded') {
	        self._queue.push({
	          event: 'seek',
	          action: function() {
	            self.seek.apply(self, args);
	          }
	        });
	
	        return self;
	      }
	
	      // Get the sound.
	      var sound = self._soundById(id);
	
	      if (sound) {
	        if (typeof seek === 'number' && seek >= 0) {
	          // Pause the sound and update position for restarting playback.
	          var playing = self.playing(id);
	          if (playing) {
	            self.pause(id, true);
	          }
	
	          // Move the position of the track and cancel timer.
	          sound._seek = seek;
	          sound._ended = false;
	          self._clearTimer(id);
	
	          // Restart the playback if the sound was playing.
	          if (playing) {
	            self.play(id, true);
	          }
	
	          // Update the seek position for HTML5 Audio.
	          if (!self._webAudio && sound._node) {
	            sound._node.currentTime = seek;
	          }
	
	          self._emit('seek', id);
	        } else {
	          if (self._webAudio) {
	            var realTime = self.playing(id) ? Howler.ctx.currentTime - sound._playStart : 0;
	            var rateSeek = sound._rateSeek ? sound._rateSeek - sound._seek : 0;
	            return sound._seek + (rateSeek + realTime * Math.abs(sound._rate));
	          } else {
	            return sound._node.currentTime;
	          }
	        }
	      }
	
	      return self;
	    },
	
	    /**
	     * Check if a specific sound is currently playing or not (if id is provided), or check if at least one of the sounds in the group is playing or not.
	     * @param  {Number}  id The sound id to check. If none is passed, the whole sound group is checked.
	     * @return {Boolean} True if playing and false if not.
	     */
	    playing: function(id) {
	      var self = this;
	
	      // Check the passed sound ID (if any).
	      if (typeof id === 'number') {
	        var sound = self._soundById(id);
	        return sound ? !sound._paused : false;
	      }
	
	      // Otherwise, loop through all sounds and check if any are playing.
	      for (var i=0; i<self._sounds.length; i++) {
	        if (!self._sounds[i]._paused) {
	          return true;
	        }
	      }
	
	      return false;
	    },
	
	    /**
	     * Get the duration of this sound. Passing a sound id will return the sprite duration.
	     * @param  {Number} id The sound id to check. If none is passed, return full source duration.
	     * @return {Number} Audio duration in seconds.
	     */
	    duration: function(id) {
	      var self = this;
	      var duration = self._duration;
	
	      // If we pass an ID, get the sound and return the sprite length.
	      var sound = self._soundById(id);
	      if (sound) {
	        duration = self._sprite[sound._sprite][1] / 1000;
	      }
	
	      return duration;
	    },
	
	    /**
	     * Returns the current loaded state of this Howl.
	     * @return {String} 'unloaded', 'loading', 'loaded'
	     */
	    state: function() {
	      return this._state;
	    },
	
	    /**
	     * Unload and destroy the current Howl object.
	     * This will immediately stop all sound instances attached to this group.
	     */
	    unload: function() {
	      var self = this;
	
	      // Stop playing any active sounds.
	      var sounds = self._sounds;
	      for (var i=0; i<sounds.length; i++) {
	        // Stop the sound if it is currently playing.
	        if (!sounds[i]._paused) {
	          self.stop(sounds[i]._id);
	          self._emit('end', sounds[i]._id);
	        }
	
	        // Remove the source or disconnect.
	        if (!self._webAudio) {
	          // Set the source to 0-second silence to stop any downloading.
	          sounds[i]._node.src = 'data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQAAAAA=';
	
	          // Remove any event listeners.
	          sounds[i]._node.removeEventListener('error', sounds[i]._errorFn, false);
	          sounds[i]._node.removeEventListener(Howler._canPlayEvent, sounds[i]._loadFn, false);
	        }
	
	        // Empty out all of the nodes.
	        delete sounds[i]._node;
	
	        // Make sure all timers are cleared out.
	        self._clearTimer(sounds[i]._id);
	
	        // Remove the references in the global Howler object.
	        var index = Howler._howls.indexOf(self);
	        if (index >= 0) {
	          Howler._howls.splice(index, 1);
	        }
	      }
	
	      // Delete this sound from the cache (if no other Howl is using it).
	      var remCache = true;
	      for (i=0; i<Howler._howls.length; i++) {
	        if (Howler._howls[i]._src === self._src) {
	          remCache = false;
	          break;
	        }
	      }
	
	      if (cache && remCache) {
	        delete cache[self._src];
	      }
	
	      // Clear out `self`.
	      self._state = 'unloaded';
	      self._sounds = [];
	      self = null;
	
	      return null;
	    },
	
	    /**
	     * Listen to a custom event.
	     * @param  {String}   event Event name.
	     * @param  {Function} fn    Listener to call.
	     * @param  {Number}   id    (optional) Only listen to events for this sound.
	     * @param  {Number}   once  (INTERNAL) Marks event to fire only once.
	     * @return {Howl}
	     */
	    on: function(event, fn, id, once) {
	      var self = this;
	      var events = self['_on' + event];
	
	      if (typeof fn === 'function') {
	        events.push(once ? {id: id, fn: fn, once: once} : {id: id, fn: fn});
	      }
	
	      return self;
	    },
	
	    /**
	     * Remove a custom event. Call without parameters to remove all events.
	     * @param  {String}   event Event name.
	     * @param  {Function} fn    Listener to remove. Leave empty to remove all.
	     * @param  {Number}   id    (optional) Only remove events for this sound.
	     * @return {Howl}
	     */
	    off: function(event, fn, id) {
	      var self = this;
	      var events = self['_on' + event];
	      var i = 0;
	
	      if (fn) {
	        // Loop through event store and remove the passed function.
	        for (i=0; i<events.length; i++) {
	          if (fn === events[i].fn && id === events[i].id) {
	            events.splice(i, 1);
	            break;
	          }
	        }
	      } else if (event) {
	        // Clear out all events of this type.
	        self['_on' + event] = [];
	      } else {
	        // Clear out all events of every type.
	        var keys = Object.keys(self);
	        for (i=0; i<keys.length; i++) {
	          if ((keys[i].indexOf('_on') === 0) && Array.isArray(self[keys[i]])) {
	            self[keys[i]] = [];
	          }
	        }
	      }
	
	      return self;
	    },
	
	    /**
	     * Listen to a custom event and remove it once fired.
	     * @param  {String}   event Event name.
	     * @param  {Function} fn    Listener to call.
	     * @param  {Number}   id    (optional) Only listen to events for this sound.
	     * @return {Howl}
	     */
	    once: function(event, fn, id) {
	      var self = this;
	
	      // Setup the event listener.
	      self.on(event, fn, id, 1);
	
	      return self;
	    },
	
	    /**
	     * Emit all events of a specific type and pass the sound id.
	     * @param  {String} event Event name.
	     * @param  {Number} id    Sound ID.
	     * @param  {Number} msg   Message to go with event.
	     * @return {Howl}
	     */
	    _emit: function(event, id, msg) {
	      var self = this;
	      var events = self['_on' + event];
	
	      // Loop through event store and fire all functions.
	      for (var i=events.length-1; i>=0; i--) {
	        if (!events[i].id || events[i].id === id || event === 'load') {
	          setTimeout(function(fn) {
	            fn.call(this, id, msg);
	          }.bind(self, events[i].fn), 0);
	
	          // If this event was setup with `once`, remove it.
	          if (events[i].once) {
	            self.off(event, events[i].fn, events[i].id);
	          }
	        }
	      }
	
	      return self;
	    },
	
	    /**
	     * Queue of actions initiated before the sound has loaded.
	     * These will be called in sequence, with the next only firing
	     * after the previous has finished executing (even if async like play).
	     * @return {Howl}
	     */
	    _loadQueue: function() {
	      var self = this;
	
	      if (self._queue.length > 0) {
	        var task = self._queue[0];
	
	        // don't move onto the next task until this one is done
	        self.once(task.event, function() {
	          self._queue.shift();
	          self._loadQueue();
	        });
	
	        task.action();
	      }
	
	      return self;
	    },
	
	    /**
	     * Fired when playback ends at the end of the duration.
	     * @param  {Sound} sound The sound object to work with.
	     * @return {Howl}
	     */
	    _ended: function(sound) {
	      var self = this;
	      var sprite = sound._sprite;
	
	      // Should this sound loop?
	      var loop = !!(sound._loop || self._sprite[sprite][2]);
	
	      // Fire the ended event.
	      self._emit('end', sound._id);
	
	      // Restart the playback for HTML5 Audio loop.
	      if (!self._webAudio && loop) {
	        self.stop(sound._id, true).play(sound._id);
	      }
	
	      // Restart this timer if on a Web Audio loop.
	      if (self._webAudio && loop) {
	        self._emit('play', sound._id);
	        sound._seek = sound._start || 0;
	        sound._rateSeek = 0;
	        sound._playStart = Howler.ctx.currentTime;
	
	        var timeout = ((sound._stop - sound._start) * 1000) / Math.abs(sound._rate);
	        self._endTimers[sound._id] = setTimeout(self._ended.bind(self, sound), timeout);
	      }
	
	      // Mark the node as paused.
	      if (self._webAudio && !loop) {
	        sound._paused = true;
	        sound._ended = true;
	        sound._seek = sound._start || 0;
	        sound._rateSeek = 0;
	        self._clearTimer(sound._id);
	
	        // Clean up the buffer source.
	        self._cleanBuffer(sound._node);
	
	        // Attempt to auto-suspend AudioContext if no sounds are still playing.
	        Howler._autoSuspend();
	      }
	
	      // When using a sprite, end the track.
	      if (!self._webAudio && !loop) {
	        self.stop(sound._id);
	      }
	
	      return self;
	    },
	
	    /**
	     * Clear the end timer for a sound playback.
	     * @param  {Number} id The sound ID.
	     * @return {Howl}
	     */
	    _clearTimer: function(id) {
	      var self = this;
	
	      if (self._endTimers[id]) {
	        clearTimeout(self._endTimers[id]);
	        delete self._endTimers[id];
	      }
	
	      return self;
	    },
	
	    /**
	     * Return the sound identified by this ID, or return null.
	     * @param  {Number} id Sound ID
	     * @return {Object}    Sound object or null.
	     */
	    _soundById: function(id) {
	      var self = this;
	
	      // Loop through all sounds and find the one with this ID.
	      for (var i=0; i<self._sounds.length; i++) {
	        if (id === self._sounds[i]._id) {
	          return self._sounds[i];
	        }
	      }
	
	      return null;
	    },
	
	    /**
	     * Return an inactive sound from the pool or create a new one.
	     * @return {Sound} Sound playback object.
	     */
	    _inactiveSound: function() {
	      var self = this;
	
	      self._drain();
	
	      // Find the first inactive node to recycle.
	      for (var i=0; i<self._sounds.length; i++) {
	        if (self._sounds[i]._ended) {
	          return self._sounds[i].reset();
	        }
	      }
	
	      // If no inactive node was found, create a new one.
	      return new Sound(self);
	    },
	
	    /**
	     * Drain excess inactive sounds from the pool.
	     */
	    _drain: function() {
	      var self = this;
	      var limit = self._pool;
	      var cnt = 0;
	      var i = 0;
	
	      // If there are less sounds than the max pool size, we are done.
	      if (self._sounds.length < limit) {
	        return;
	      }
	
	      // Count the number of inactive sounds.
	      for (i=0; i<self._sounds.length; i++) {
	        if (self._sounds[i]._ended) {
	          cnt++;
	        }
	      }
	
	      // Remove excess inactive sounds, going in reverse order.
	      for (i=self._sounds.length - 1; i>=0; i--) {
	        if (cnt <= limit) {
	          return;
	        }
	
	        if (self._sounds[i]._ended) {
	          // Disconnect the audio source when using Web Audio.
	          if (self._webAudio && self._sounds[i]._node) {
	            self._sounds[i]._node.disconnect(0);
	          }
	
	          // Remove sounds until we have the pool size.
	          self._sounds.splice(i, 1);
	          cnt--;
	        }
	      }
	    },
	
	    /**
	     * Get all ID's from the sounds pool.
	     * @param  {Number} id Only return one ID if one is passed.
	     * @return {Array}    Array of IDs.
	     */
	    _getSoundIds: function(id) {
	      var self = this;
	
	      if (typeof id === 'undefined') {
	        var ids = [];
	        for (var i=0; i<self._sounds.length; i++) {
	          ids.push(self._sounds[i]._id);
	        }
	
	        return ids;
	      } else {
	        return [id];
	      }
	    },
	
	    /**
	     * Load the sound back into the buffer source.
	     * @param  {Sound} sound The sound object to work with.
	     * @return {Howl}
	     */
	    _refreshBuffer: function(sound) {
	      var self = this;
	
	      // Setup the buffer source for playback.
	      sound._node.bufferSource = Howler.ctx.createBufferSource();
	      sound._node.bufferSource.buffer = cache[self._src];
	
	      // Connect to the correct node.
	      if (sound._panner) {
	        sound._node.bufferSource.connect(sound._panner);
	      } else {
	        sound._node.bufferSource.connect(sound._node);
	      }
	
	      // Setup looping and playback rate.
	      sound._node.bufferSource.loop = sound._loop;
	      if (sound._loop) {
	        sound._node.bufferSource.loopStart = sound._start || 0;
	        sound._node.bufferSource.loopEnd = sound._stop;
	      }
	      sound._node.bufferSource.playbackRate.value = sound._rate;
	
	      return self;
	    },
	
	    /**
	     * Prevent memory leaks by cleaning up the buffer source after playback.
	     * @param  {Object} node Sound's audio node containing the buffer source.
	     * @return {Howl}
	     */
	    _cleanBuffer: function(node) {
	      var self = this;
	
	      if (self._scratchBuffer) {
	        node.bufferSource.onended = null;
	        node.bufferSource.disconnect(0);
	        try { node.bufferSource.buffer = self._scratchBuffer; } catch(e) {}
	      }
	      node.bufferSource = null;
	
	      return self;
	    }
	  };
	
	  /** Single Sound Methods **/
	  /***************************************************************************/
	
	  /**
	   * Setup the sound object, which each node attached to a Howl group is contained in.
	   * @param {Object} howl The Howl parent group.
	   */
	  var Sound = function(howl) {
	    this._parent = howl;
	    this.init();
	  };
	  Sound.prototype = {
	    /**
	     * Initialize a new Sound object.
	     * @return {Sound}
	     */
	    init: function() {
	      var self = this;
	      var parent = self._parent;
	
	      // Setup the default parameters.
	      self._muted = parent._muted;
	      self._loop = parent._loop;
	      self._volume = parent._volume;
	      self._muted = parent._muted;
	      self._rate = parent._rate;
	      self._seek = 0;
	      self._paused = true;
	      self._ended = true;
	      self._sprite = '__default';
	
	      // Generate a unique ID for this sound.
	      self._id = Math.round(Date.now() * Math.random());
	
	      // Add itself to the parent's pool.
	      parent._sounds.push(self);
	
	      // Create the new node.
	      self.create();
	
	      return self;
	    },
	
	    /**
	     * Create and setup a new sound object, whether HTML5 Audio or Web Audio.
	     * @return {Sound}
	     */
	    create: function() {
	      var self = this;
	      var parent = self._parent;
	      var volume = (Howler._muted || self._muted || self._parent._muted) ? 0 : self._volume;
	
	      if (parent._webAudio) {
	        // Create the gain node for controlling volume (the source will connect to this).
	        self._node = (typeof Howler.ctx.createGain === 'undefined') ? Howler.ctx.createGainNode() : Howler.ctx.createGain();
	        self._node.gain.setValueAtTime(volume, Howler.ctx.currentTime);
	        self._node.paused = true;
	        self._node.connect(Howler.masterGain);
	      } else {
	        self._node = new Audio();
	
	        // Listen for errors (http://dev.w3.org/html5/spec-author-view/spec.html#mediaerror).
	        self._errorFn = self._errorListener.bind(self);
	        self._node.addEventListener('error', self._errorFn, false);
	
	        // Listen for 'canplaythrough' event to let us know the sound is ready.
	        self._loadFn = self._loadListener.bind(self);
	        self._node.addEventListener(Howler._canPlayEvent, self._loadFn, false);
	
	        // Setup the new audio node.
	        self._node.src = parent._src;
	        self._node.preload = 'auto';
	        self._node.volume = volume * Howler.volume();
	
	        // Begin loading the source.
	        self._node.load();
	      }
	
	      return self;
	    },
	
	    /**
	     * Reset the parameters of this sound to the original state (for recycle).
	     * @return {Sound}
	     */
	    reset: function() {
	      var self = this;
	      var parent = self._parent;
	
	      // Reset all of the parameters of this sound.
	      self._muted = parent._muted;
	      self._loop = parent._loop;
	      self._volume = parent._volume;
	      self._muted = parent._muted;
	      self._rate = parent._rate;
	      self._seek = 0;
	      self._rateSeek = 0;
	      self._paused = true;
	      self._ended = true;
	      self._sprite = '__default';
	
	      // Generate a new ID so that it isn't confused with the previous sound.
	      self._id = Math.round(Date.now() * Math.random());
	
	      return self;
	    },
	
	    /**
	     * HTML5 Audio error listener callback.
	     */
	    _errorListener: function() {
	      var self = this;
	
	      if (self._node.error && self._node.error.code === 4) {
	        Howler.noAudio = true;
	      }
	
	      // Fire an error event and pass back the code.
	      self._parent._emit('loaderror', self._id, self._node.error ? self._node.error.code : 0);
	
	      // Clear the event listener.
	      self._node.removeEventListener('error', self._errorListener, false);
	    },
	
	    /**
	     * HTML5 Audio canplaythrough listener callback.
	     */
	    _loadListener: function() {
	      var self = this;
	      var parent = self._parent;
	
	      // Round up the duration to account for the lower precision in HTML5 Audio.
	      parent._duration = Math.ceil(self._node.duration * 10) / 10;
	
	      // Setup a sprite if none is defined.
	      if (Object.keys(parent._sprite).length === 0) {
	        parent._sprite = {__default: [0, parent._duration * 1000]};
	      }
	
	      if (parent._state !== 'loaded') {
	        parent._state = 'loaded';
	        parent._emit('load');
	        parent._loadQueue();
	      }
	
	      if (parent._autoplay) {
	        parent.play();
	      }
	
	      // Clear the event listener.
	      self._node.removeEventListener(Howler._canPlayEvent, self._loadFn, false);
	    }
	  };
	
	  /** Helper Methods **/
	  /***************************************************************************/
	
	  var cache = {};
	
	  /**
	   * Buffer a sound from URL, Data URI or cache and decode to audio source (Web Audio API).
	   * @param  {Howl} self
	   */
	  var loadBuffer = function(self) {
	    var url = self._src;
	
	    // Check if the buffer has already been cached and use it instead.
	    if (cache[url]) {
	      // Set the duration from the cache.
	      self._duration = cache[url].duration;
	
	      // Load the sound into this Howl.
	      loadSound(self);
	
	      return;
	    }
	
	    if (/^data:[^;]+;base64,/.test(url)) {
	      // Decode the base64 data URI without XHR, since some browsers don't support it.
	      var data = atob(url.split(',')[1]);
	      var dataView = new Uint8Array(data.length);
	      for (var i=0; i<data.length; ++i) {
	        dataView[i] = data.charCodeAt(i);
	      }
	
	      decodeAudioData(dataView.buffer, self);
	    } else {
	      // Load the buffer from the URL.
	      var xhr = new XMLHttpRequest();
	      xhr.open('GET', url, true);
	      xhr.responseType = 'arraybuffer';
	      xhr.onload = function() {
	        // Make sure we get a successful response back.
	        var code = (xhr.status + '')[0];
	        if (code !== '0' && code !== '2' && code !== '3') {
	          self._emit('loaderror', null, 'Failed loading audio file with status: ' + xhr.status + '.');
	          return;
	        }
	
	        decodeAudioData(xhr.response, self);
	      };
	      xhr.onerror = function() {
	        // If there is an error, switch to HTML5 Audio.
	        if (self._webAudio) {
	          self._html5 = true;
	          self._webAudio = false;
	          self._sounds = [];
	          delete cache[url];
	          self.load();
	        }
	      };
	      safeXhrSend(xhr);
	    }
	  };
	
	  /**
	   * Send the XHR request wrapped in a try/catch.
	   * @param  {Object} xhr XHR to send.
	   */
	  var safeXhrSend = function(xhr) {
	    try {
	      xhr.send();
	    } catch (e) {
	      xhr.onerror();
	    }
	  };
	
	  /**
	   * Decode audio data from an array buffer.
	   * @param  {ArrayBuffer} arraybuffer The audio data.
	   * @param  {Howl}        self
	   */
	  var decodeAudioData = function(arraybuffer, self) {
	    // Decode the buffer into an audio source.
	    Howler.ctx.decodeAudioData(arraybuffer, function(buffer) {
	      if (buffer && self._sounds.length > 0) {
	        cache[self._src] = buffer;
	        loadSound(self, buffer);
	      }
	    }, function() {
	      self._emit('loaderror', null, 'Decoding audio data failed.');
	    });
	  };
	
	  /**
	   * Sound is now loaded, so finish setting everything up and fire the loaded event.
	   * @param  {Howl} self
	   * @param  {Object} buffer The decoded buffer sound source.
	   */
	  var loadSound = function(self, buffer) {
	    // Set the duration.
	    if (buffer && !self._duration) {
	      self._duration = buffer.duration;
	    }
	
	    // Setup a sprite if none is defined.
	    if (Object.keys(self._sprite).length === 0) {
	      self._sprite = {__default: [0, self._duration * 1000]};
	    }
	
	    // Fire the loaded event.
	    if (self._state !== 'loaded') {
	      self._state = 'loaded';
	      self._emit('load');
	      self._loadQueue();
	    }
	
	    // Begin playback if specified.
	    if (self._autoplay) {
	      self.play();
	    }
	  };
	
	  /**
	   * Setup the audio context when available, or switch to HTML5 Audio mode.
	   */
	  var setupAudioContext = function() {
	    Howler.noAudio = false;
	
	    // Check if we are using Web Audio and setup the AudioContext if we are.
	    try {
	      if (typeof AudioContext !== 'undefined') {
	        Howler.ctx = new AudioContext();
	      } else if (typeof webkitAudioContext !== 'undefined') {
	        Howler.ctx = new webkitAudioContext();
	      } else {
	        Howler.usingWebAudio = false;
	      }
	    } catch(e) {
	      Howler.usingWebAudio = false;
	    }
	
	    if (!Howler.usingWebAudio) {
	      // No audio is available on this system if noAudio is set to true.
	      if (typeof Audio !== 'undefined') {
	        try {
	          var test = new Audio();
	
	          // Check if the canplaythrough event is available.
	          if (typeof test.oncanplaythrough === 'undefined') {
	            Howler._canPlayEvent = 'canplay';
	          }
	        } catch(e) {
	          Howler.noAudio = true;
	        }
	      } else {
	        Howler.noAudio = true;
	      }
	    }
	
	    // Test to make sure audio isn't disabled in Internet Explorer
	    try {
	      var test = new Audio();
	      if (test.muted) {
	        Howler.noAudio = true;
	      }
	    } catch (e) {}
	
	    // Check if a webview is being used on iOS8 or earlier (rather than the browser).
	    // If it is, disable Web Audio as it causes crashing.
	    var iOS = (/iP(hone|od|ad)/.test(Howler._navigator && Howler._navigator.platform));
	    var appVersion = Howler._navigator && Howler._navigator.appVersion.match(/OS (\d+)_(\d+)_?(\d+)?/);
	    var version = appVersion ? parseInt(appVersion[1], 10) : null;
	    if (iOS && version && version < 9) {
	      var safari = /safari/.test(Howler._navigator && Howler._navigator.userAgent.toLowerCase());
	      if (Howler._navigator && Howler._navigator.standalone && !safari || Howler._navigator && !Howler._navigator.standalone && !safari) {
	        Howler.usingWebAudio = false;
	      }
	    }
	
	    // Create and expose the master GainNode when using Web Audio (useful for plugins or advanced usage).
	    if (Howler.usingWebAudio) {
	      Howler.masterGain = (typeof Howler.ctx.createGain === 'undefined') ? Howler.ctx.createGainNode() : Howler.ctx.createGain();
	      Howler.masterGain.gain.value = 1;
	      Howler.masterGain.connect(Howler.ctx.destination);
	    }
	
	    // Re-run the setup on Howler.
	    Howler._setup();
	  };
	
	  // Add support for AMD (Asynchronous Module Definition) libraries such as require.js.
	  if (true) {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {
	      return {
	        Howler: Howler,
	        Howl: Howl
	      };
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  }
	
	  // Add support for CommonJS libraries such as browserify.
	  if (true) {
	    exports.Howler = Howler;
	    exports.Howl = Howl;
	  }
	
	  // Define globally in case AMD is not available or unused.
	  if (typeof window !== 'undefined') {
	    window.HowlerGlobal = HowlerGlobal;
	    window.Howler = Howler;
	    window.Howl = Howl;
	    window.Sound = Sound;
	  } else if (typeof global !== 'undefined') { // Add to global in Node.js (for testing, etc).
	    global.HowlerGlobal = HowlerGlobal;
	    global.Howler = Howler;
	    global.Howl = Howl;
	    global.Sound = Sound;
	  }
	})();
	
	
	/*!
	 *  Spatial Plugin - Adds support for stereo and 3D audio where Web Audio is supported.
	 *  
	 *  howler.js v2.0.0
	 *  howlerjs.com
	 *
	 *  (c) 2013-2016, James Simpson of GoldFire Studios
	 *  goldfirestudios.com
	 *
	 *  MIT License
	 */
	
	(function() {
	
	  'use strict';
	
	  // Setup default properties.
	  HowlerGlobal.prototype._pos = [0, 0, 0];
	  HowlerGlobal.prototype._orientation = [0, 0, -1, 0, 1, 0];
	  
	  /** Global Methods **/
	  /***************************************************************************/
	
	  /**
	   * Helper method to update the stereo panning position of all current Howls.
	   * Future Howls will not use this value unless explicitely set.
	   * @param  {Number} pan A value of -1.0 is all the way left and 1.0 is all the way right.
	   * @return {Howler/Number}     Self or current stereo panning value.
	   */
	  HowlerGlobal.prototype.stereo = function(pan) {
	    var self = this;
	
	    // Stop right here if not using Web Audio.
	    if (!self.ctx || !self.ctx.listener) {
	      return self;
	    }
	
	    // Loop through all Howls and update their stereo panning.
	    for (var i=self._howls.length-1; i>=0; i--) {
	      self._howls[i].stereo(pan);
	    }
	
	    return self;
	  };
	
	  /**
	   * Get/set the position of the listener in 3D cartesian space. Sounds using
	   * 3D position will be relative to the listener's position.
	   * @param  {Number} x The x-position of the listener.
	   * @param  {Number} y The y-position of the listener.
	   * @param  {Number} z The z-position of the listener.
	   * @return {Howler/Array}   Self or current listener position.
	   */
	  HowlerGlobal.prototype.pos = function(x, y, z) {
	    var self = this;
	
	    // Stop right here if not using Web Audio.
	    if (!self.ctx || !self.ctx.listener) {
	      return self;
	    }
	
	    // Set the defaults for optional 'y' & 'z'.
	    y = (typeof y !== 'number') ? self._pos[1] : y;
	    z = (typeof z !== 'number') ? self._pos[2] : z;
	
	    if (typeof x === 'number') {
	      self._pos = [x, y, z];
	      self.ctx.listener.setPosition(self._pos[0], self._pos[1], self._pos[2]);
	    } else {
	      return self._pos;
	    }
	
	    return self;
	  };
	
	  /**
	   * Get/set the direction the listener is pointing in the 3D cartesian space.
	   * A front and up vector must be provided. The front is the direction the
	   * face of the listener is pointing, and up is the direction the top of the
	   * listener is pointing. Thus, these values are expected to be at right angles
	   * from each other.
	   * @param  {Number} x   The x-orientation of the listener.
	   * @param  {Number} y   The y-orientation of the listener.
	   * @param  {Number} z   The z-orientation of the listener.
	   * @param  {Number} xUp The x-orientation of the top of the listener.
	   * @param  {Number} yUp The y-orientation of the top of the listener.
	   * @param  {Number} zUp The z-orientation of the top of the listener.
	   * @return {Howler/Array}     Returns self or the current orientation vectors.
	   */
	  HowlerGlobal.prototype.orientation = function(x, y, z, xUp, yUp, zUp) {
	    var self = this;
	
	    // Stop right here if not using Web Audio.
	    if (!self.ctx || !self.ctx.listener) {
	      return self;
	    }
	
	    // Set the defaults for optional 'y' & 'z'.
	    var or = self._orientation;
	    y = (typeof y !== 'number') ? or[1] : y;
	    z = (typeof z !== 'number') ? or[2] : z;
	    xUp = (typeof xUp !== 'number') ? or[3] : xUp;
	    yUp = (typeof yUp !== 'number') ? or[4] : yUp;
	    zUp = (typeof zUp !== 'number') ? or[5] : zUp;
	
	    if (typeof x === 'number') {
	      self._orientation = [x, y, z, xUp, yUp, zUp];
	      self.ctx.listener.setOrientation(x, y, z, xUp, yUp, zUp);
	    } else {
	      return or;
	    }
	
	    return self;
	  };
	
	  /** Group Methods **/
	  /***************************************************************************/
	
	  /**
	   * Add new properties to the core init.
	   * @param  {Function} _super Core init method.
	   * @return {Howl}
	   */
	  Howl.prototype.init = (function(_super) {
	    return function(o) {
	      var self = this;
	
	      // Setup user-defined default properties.
	      self._orientation = o.orientation || [1, 0, 0];
	      self._stereo = o.stereo || null;
	      self._pos = o.pos || null;
	      self._pannerAttr = {
	        coneInnerAngle: typeof o.coneInnerAngle !== 'undefined' ? o.coneInnerAngle : 360,
	        coneOuterAngle: typeof o.coneOuterAngle !== 'undefined' ? o.coneOuterAngle : 360,
	        coneOuterGain: typeof o.coneOuterGain !== 'undefined' ? o.coneOuterGain : 0,
	        distanceModel: typeof o.distanceModel !== 'undefined' ? o.distanceModel : 'inverse',
	        maxDistance: typeof o.maxDistance !== 'undefined' ? o.maxDistance : 10000,
	        panningModel: typeof o.panningModel !== 'undefined' ? o.panningModel : 'HRTF',
	        refDistance: typeof o.refDistance !== 'undefined' ? o.refDistance : 1,
	        rolloffFactor: typeof o.rolloffFactor !== 'undefined' ? o.rolloffFactor : 1
	      };
	
	      // Setup event listeners.
	      self._onstereo = o.onstereo ? [{fn: o.onstereo}] : [];
	      self._onpos = o.onpos ? [{fn: o.onpos}] : [];
	      self._onorientation = o.onorientation ? [{fn: o.onorientation}] : [];
	
	      // Complete initilization with howler.js core's init function.
	      return _super.call(this, o);
	    };
	  })(Howl.prototype.init);
	
	  /**
	   * Get/set the stereo panning of the audio source for this sound or all in the group.
	   * @param  {Number} pan  A value of -1.0 is all the way left and 1.0 is all the way right.
	   * @param  {Number} id (optional) The sound ID. If none is passed, all in group will be updated.
	   * @return {Howl/Number}    Returns self or the current stereo panning value.
	   */
	  Howl.prototype.stereo = function(pan, id) {
	    var self = this;
	
	    // Stop right here if not using Web Audio.
	    if (!self._webAudio) {
	      return self;
	    }
	
	    // If the sound hasn't loaded, add it to the load queue to change stereo pan when capable.
	    if (self._state !== 'loaded') {
	      self._queue.push({
	        event: 'stereo',
	        action: function() {
	          self.stereo(pan, id);
	        }
	      });
	
	      return self;
	    }
	
	    // Check for PannerStereoNode support and fallback to PannerNode if it doesn't exist.
	    var pannerType = (typeof Howler.ctx.createStereoPanner === 'undefined') ? 'spatial' : 'stereo';
	
	    // Setup the group's stereo panning if no ID is passed.
	    if (typeof id === 'undefined') {
	      // Return the group's stereo panning if no parameters are passed.
	      if (typeof pan === 'number') {
	        self._stereo = pan;
	        self._pos = [pan, 0, 0];
	      } else {
	        return self._stereo;
	      }
	    }
	
	    // Change the streo panning of one or all sounds in group.
	    var ids = self._getSoundIds(id);
	    for (var i=0; i<ids.length; i++) {
	      // Get the sound.
	      var sound = self._soundById(ids[i]);
	
	      if (sound) {
	        if (typeof pan === 'number') {
	          sound._stereo = pan;
	          sound._pos = [pan, 0, 0];
	
	          if (sound._node) {
	            // If we are falling back, make sure the panningModel is equalpower.
	            sound._pannerAttr.panningModel = 'equalpower';
	
	            // Check if there is a panner setup and create a new one if not.
	            if (!sound._panner || !sound._panner.pan) {
	              setupPanner(sound, pannerType);
	            }
	
	            if (pannerType === 'spatial') {
	              sound._panner.setPosition(pan, 0, 0);
	            } else {
	              sound._panner.pan.value = pan;
	            }
	          }
	
	          self._emit('stereo', sound._id);
	        } else {
	          return sound._stereo;
	        }
	      }
	    }
	
	    return self;
	  };
	
	  /**
	   * Get/set the 3D spatial position of the audio source for this sound or
	   * all in the group. The most common usage is to set the 'x' position for
	   * left/right panning. Setting any value higher than 1.0 will begin to
	   * decrease the volume of the sound as it moves further away.
	   * @param  {Number} x  The x-position of the audio from -1000.0 to 1000.0.
	   * @param  {Number} y  The y-position of the audio from -1000.0 to 1000.0.
	   * @param  {Number} z  The z-position of the audio from -1000.0 to 1000.0.
	   * @param  {Number} id (optional) The sound ID. If none is passed, all in group will be updated.
	   * @return {Howl/Array}    Returns self or the current 3D spatial position: [x, y, z].
	   */
	  Howl.prototype.pos = function(x, y, z, id) {
	    var self = this;
	
	    // Stop right here if not using Web Audio.
	    if (!self._webAudio) {
	      return self;
	    }
	
	    // If the sound hasn't loaded, add it to the load queue to change position when capable.
	    if (self._state !== 'loaded') {
	      self._queue.push({
	        event: 'pos',
	        action: function() {
	          self.pos(x, y, z, id);
	        }
	      });
	
	      return self;
	    }
	
	    // Set the defaults for optional 'y' & 'z'.
	    y = (typeof y !== 'number') ? 0 : y;
	    z = (typeof z !== 'number') ? -0.5 : z;
	
	    // Setup the group's spatial position if no ID is passed.
	    if (typeof id === 'undefined') {
	      // Return the group's spatial position if no parameters are passed.
	      if (typeof x === 'number') {
	        self._pos = [x, y, z];
	      } else {
	        return self._pos;
	      }
	    }
	
	    // Change the spatial position of one or all sounds in group.
	    var ids = self._getSoundIds(id);
	    for (var i=0; i<ids.length; i++) {
	      // Get the sound.
	      var sound = self._soundById(ids[i]);
	
	      if (sound) {
	        if (typeof x === 'number') {
	          sound._pos = [x, y, z];
	
	          if (sound._node) {
	            // Check if there is a panner setup and create a new one if not.
	            if (!sound._panner || sound._panner.pan) {
	              setupPanner(sound, 'spatial');
	            }
	
	            sound._panner.setPosition(x, y, z);
	          }
	
	          self._emit('pos', sound._id);
	        } else {
	          return sound._pos;
	        }
	      }
	    }
	
	    return self;
	  };
	
	  /**
	   * Get/set the direction the audio source is pointing in the 3D cartesian coordinate
	   * space. Depending on how direction the sound is, based on the `cone` attributes,
	   * a sound pointing away from the listener can be quiet or silent.
	   * @param  {Number} x  The x-orientation of the source.
	   * @param  {Number} y  The y-orientation of the source.
	   * @param  {Number} z  The z-orientation of the source.
	   * @param  {Number} id (optional) The sound ID. If none is passed, all in group will be updated.
	   * @return {Howl/Array}    Returns self or the current 3D spatial orientation: [x, y, z].
	   */
	  Howl.prototype.orientation = function(x, y, z, id) {
	    var self = this;
	
	    // Stop right here if not using Web Audio.
	    if (!self._webAudio) {
	      return self;
	    }
	
	    // If the sound hasn't loaded, add it to the load queue to change orientation when capable.
	    if (self._state !== 'loaded') {
	      self._queue.push({
	        event: 'orientation',
	        action: function() {
	          self.orientation(x, y, z, id);
	        }
	      });
	
	      return self;
	    }
	
	    // Set the defaults for optional 'y' & 'z'.
	    y = (typeof y !== 'number') ? self._orientation[1] : y;
	    z = (typeof z !== 'number') ? self._orientation[2] : z;
	
	    // Setup the group's spatial orientation if no ID is passed.
	    if (typeof id === 'undefined') {
	      // Return the group's spatial orientation if no parameters are passed.
	      if (typeof x === 'number') {
	        self._orientation = [x, y, z];
	      } else {
	        return self._orientation;
	      }
	    }
	
	    // Change the spatial orientation of one or all sounds in group.
	    var ids = self._getSoundIds(id);
	    for (var i=0; i<ids.length; i++) {
	      // Get the sound.
	      var sound = self._soundById(ids[i]);
	
	      if (sound) {
	        if (typeof x === 'number') {
	          sound._orientation = [x, y, z];
	
	          if (sound._node) {
	            // Check if there is a panner setup and create a new one if not.
	            if (!sound._panner) {
	              // Make sure we have a position to setup the node with.
	              if (!sound._pos) {
	                sound._pos = self._pos || [0, 0, -0.5];
	              }
	
	              setupPanner(sound, 'spatial');
	            }
	
	            sound._panner.setOrientation(x, y, z);
	          }
	
	          self._emit('orientation', sound._id);
	        } else {
	          return sound._orientation;
	        }
	      }
	    }
	
	    return self;
	  };
	
	  /**
	   * Get/set the panner node's attributes for a sound or group of sounds.
	   * This method can optionall take 0, 1 or 2 arguments.
	   *   pannerAttr() -> Returns the group's values.
	   *   pannerAttr(id) -> Returns the sound id's values.
	   *   pannerAttr(o) -> Set's the values of all sounds in this Howl group.
	   *   pannerAttr(o, id) -> Set's the values of passed sound id.
	   *
	   *   Attributes:
	   *     coneInnerAngle - (360 by default) There will be no volume reduction inside this angle.
	   *     coneOuterAngle - (360 by default) The volume will be reduced to a constant value of
	   *                      `coneOuterGain` outside this angle.
	   *     coneOuterGain - (0 by default) The amount of volume reduction outside of `coneOuterAngle`.
	   *     distanceModel - ('inverse' by default) Determines algorithm to use to reduce volume as audio moves
	   *                      away from listener. Can be `linear`, `inverse` or `exponential`.
	   *     maxDistance - (10000 by default) Volume won't reduce between source/listener beyond this distance.
	   *     panningModel - ('HRTF' by default) Determines which spatialization algorithm is used to position audio.
	   *                     Can be `HRTF` or `equalpower`.
	   *     refDistance - (1 by default) A reference distance for reducing volume as the source
	   *                    moves away from the listener.
	   *     rolloffFactor - (1 by default) How quickly the volume reduces as source moves from listener.
	   * 
	   * @return {Howl/Object} Returns self or current panner attributes.
	   */
	  Howl.prototype.pannerAttr = function() {
	    var self = this;
	    var args = arguments;
	    var o, id, sound;
	
	    // Stop right here if not using Web Audio.
	    if (!self._webAudio) {
	      return self;
	    }
	
	    // Determine the values based on arguments.
	    if (args.length === 0) {
	      // Return the group's panner attribute values.
	      return self._pannerAttr;
	    } else if (args.length === 1) {
	      if (typeof args[0] === 'object') {
	        o = args[0];
	
	        // Set the grou's panner attribute values.
	        if (typeof id === 'undefined') {
	          self._pannerAttr = {
	            coneInnerAngle: typeof o.coneInnerAngle !== 'undefined' ? o.coneInnerAngle : self._coneInnerAngle,
	            coneOuterAngle: typeof o.coneOuterAngle !== 'undefined' ? o.coneOuterAngle : self._coneOuterAngle,
	            coneOuterGain: typeof o.coneOuterGain !== 'undefined' ? o.coneOuterGain : self._coneOuterGain,
	            distanceModel: typeof o.distanceModel !== 'undefined' ? o.distanceModel : self._distanceModel,
	            maxDistance: typeof o.maxDistance !== 'undefined' ? o.maxDistance : self._maxDistance,
	            panningModel: typeof o.panningModel !== 'undefined' ? o.panningModel : self._panningModel,
	            refDistance: typeof o.refDistance !== 'undefined' ? o.refDistance : self._refDistance,
	            rolloffFactor: typeof o.rolloffFactor !== 'undefined' ? o.rolloffFactor : self._rolloffFactor
	          };
	        }
	      } else {
	        // Return this sound's panner attribute values.
	        sound = self._soundById(parseInt(args[0], 10));
	        return sound ? sound._pannerAttr : self._pannerAttr;
	      }
	    } else if (args.length === 2) {
	      o = args[0];
	      id = parseInt(args[1], 10);
	    }
	
	    // Update the values of the specified sounds.
	    var ids = self._getSoundIds(id);
	    for (var i=0; i<ids.length; i++) {
	      sound = self._soundById(ids[i]);
	
	      if (sound) {
	        // Merge the new values into the sound.
	        var pa = sound._pannerAttr;
	        pa = {
	          coneInnerAngle: typeof o.coneInnerAngle !== 'undefined' ? o.coneInnerAngle : pa.coneInnerAngle,
	          coneOuterAngle: typeof o.coneOuterAngle !== 'undefined' ? o.coneOuterAngle : pa.coneOuterAngle,
	          coneOuterGain: typeof o.coneOuterGain !== 'undefined' ? o.coneOuterGain : pa.coneOuterGain,
	          distanceModel: typeof o.distanceModel !== 'undefined' ? o.distanceModel : pa.distanceModel,
	          maxDistance: typeof o.maxDistance !== 'undefined' ? o.maxDistance : pa.maxDistance,
	          panningModel: typeof o.panningModel !== 'undefined' ? o.panningModel : pa.panningModel,
	          refDistance: typeof o.refDistance !== 'undefined' ? o.refDistance : pa.refDistance,
	          rolloffFactor: typeof o.rolloffFactor !== 'undefined' ? o.rolloffFactor : pa.rolloffFactor
	        };
	
	        // Update the panner values or create a new panner if none exists.
	        var panner = sound._panner;
	        if (panner) {
	          panner.coneInnerAngle = pa.coneInnerAngle;
	          panner.coneOuterAngle = pa.coneOuterAngle;
	          panner.coneOuterGain = pa.coneOuterGain;
	          panner.distanceModel = pa.distanceModel;
	          panner.maxDistance = pa.maxDistance;
	          panner.panningModel = pa.panningModel;
	          panner.refDistance = pa.refDistance;
	          panner.rolloffFactor = pa.rolloffFactor;
	        } else {
	          // Make sure we have a position to setup the node with.
	          if (!sound._pos) {
	            sound._pos = self._pos || [0, 0, -0.5];
	          }
	
	          // Create a new panner node.
	          setupPanner(sound, 'spatial');
	        }
	      }
	    }
	
	    return self;
	  };
	
	  /** Single Sound Methods **/
	  /***************************************************************************/
	
	  /**
	   * Add new properties to the core Sound init.
	   * @param  {Function} _super Core Sound init method.
	   * @return {Sound}
	   */
	  Sound.prototype.init = (function(_super) {
	    return function() {
	      var self = this;
	      var parent = self._parent;
	
	      // Setup user-defined default properties.
	      self._orientation = parent._orientation;
	      self._stereo = parent._stereo;
	      self._pos = parent._pos;
	      self._pannerAttr = parent._pannerAttr;
	
	      // Complete initilization with howler.js core Sound's init function.
	      _super.call(this);
	
	      // If a stereo or position was specified, set it up.
	      if (self._stereo) {
	        parent.stereo(self._stereo);
	      } else if (self._pos) {
	        parent.pos(self._pos[0], self._pos[1], self._pos[2], self._id);
	      }
	    };
	  })(Sound.prototype.init);
	
	  /**
	   * Override the Sound.reset method to clean up properties from the spatial plugin.
	   * @param  {Function} _super Sound reset method.
	   * @return {Sound}
	   */
	  Sound.prototype.reset = (function(_super) {
	    return function() {
	      var self = this;
	      var parent = self._parent;
	
	      // Reset all spatial plugin properties on this sound.
	      self._orientation = parent._orientation;
	      self._pos = parent._pos;
	      self._pannerAttr = parent._pannerAttr;
	
	      // Complete resetting of the sound.
	      return _super.call(this);
	    };
	  })(Sound.prototype.reset);
	
	  /** Helper Methods **/
	  /***************************************************************************/
	
	  /**
	   * Create a new panner node and save it on the sound.
	   * @param  {Sound} sound Specific sound to setup panning on.
	   * @param {String} type Type of panner to create: 'stereo' or 'spatial'.
	   */
	  var setupPanner = function(sound, type) {
	    type = type || 'spatial';
	
	    // Create the new panner node.
	    if (type === 'spatial') {
	      sound._panner = Howler.ctx.createPanner();
	      sound._panner.coneInnerAngle = sound._pannerAttr.coneInnerAngle;
	      sound._panner.coneOuterAngle = sound._pannerAttr.coneOuterAngle;
	      sound._panner.coneOuterGain = sound._pannerAttr.coneOuterGain;
	      sound._panner.distanceModel = sound._pannerAttr.distanceModel;
	      sound._panner.maxDistance = sound._pannerAttr.maxDistance;
	      sound._panner.panningModel = sound._pannerAttr.panningModel;
	      sound._panner.refDistance = sound._pannerAttr.refDistance;
	      sound._panner.rolloffFactor = sound._pannerAttr.rolloffFactor;
	      sound._panner.setPosition(sound._pos[0], sound._pos[1], sound._pos[2]);
	      sound._panner.setOrientation(sound._orientation[0], sound._orientation[1], sound._orientation[2]);
	    } else {
	      sound._panner = Howler.ctx.createStereoPanner();
	      sound._panner.pan.value = sound._stereo;
	    }
	
	    sound._panner.connect(sound._node);
	
	    // Update the connections.
	    if (!sound._paused) {
	      sound._parent.pause(sound._id, true).play(sound._id);
	    }
	  };
	})();
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 3 */
/***/ function(module, exports) {

	
	
	
		
		var events = {},
			idRegistry = 9100;
		
		
		function Subscribe(event, func){
			if(!events.hasOwnProperty(event)){
				events[event] = [];
			}
			
			var eventID = ++idRegistry;
			
			events[event].push({
				
				id : eventID,
				handler : func
							   
				});
			
			return eventID;
	
		}
		
		function Publish(){
	        
	        
	        
	        var event = arguments[0],
	            data = arguments[1],
	            realOne = arguments[2];
			
	        
	        
				if(!events.hasOwnProperty(event)){
					return false;
				}
				
			var subs = events[event];
	
			for(var i = 0, j = subs.length; i<j; i++){
				
				subs[i].handler(event, data);
				
			}
			
		}
		
		function Unsubscribe(id){
			
			for(var event in events){
				if(events.hasOwnProperty(event)){
					for(var i = 0, j = events[event].length; i<j; i++){
						if(events[event][i].id === id){
							events[event].splice(i, 1);
							return id;
						}
					}
				}
			}
			
		}
	
	
	
	module.exports = {
	    
	    subscribe : Subscribe,
	    publish : Publish,
	    unsubscribe : Unsubscribe
	    
	};

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	var ResourceLoader = __webpack_require__(1),
	    Algorithms = __webpack_require__(5),
	    mainCanvas = document.getElementById('bgCanvas'),
	    PubSub = __webpack_require__(3),
	    centerX = mainCanvas.width / 2,
	    centerY = mainCanvas.height / 2;
	
	
	        inheritFrom(Display, Physics);
	        inheritFrom(Physics, Spacecraft);
	        inheritFrom(Display, Background);
	        //make custom classes inherit display class
	        inheritFrom(Physics, Missile);
	        inheritFrom(Display, Shield);
	        inheritFrom(Spacecraft, Ship);
	        inheritFrom(Display, Explosion);
	        inheritFrom(Spacecraft, Enemy);
	        inheritFrom(Physics, Rock);
	        inheritFrom(Spacecraft, Mothership);
	        inheritFrom(Physics, Perk);   
	    
	
	
	    //inheriter function
	    function inheritFrom(parent, child){
	        var copyOfParent = Object.create(parent.prototype);
	        copyOfParent.constructor = child;
	        child.prototype = copyOfParent;
	    }
	
	    //custom classes
		function Display(){
	       
			this.canvasWidth = 0;
			this.canvasHeight = 0;
			this.centerX = 0;
			this.centerY = 0;
			this.height = 0;
			this.width = 0;
			this.x = 0;
			this.y = 0;
			this.color = "#00FF00";
			this.alpha = 1;
	        this.alive = false;  
	        this.context = undefined;
	        this.type = "display";
	       
		}
	        //temp proto method....
	    Display.prototype.reset = function(){
				this.x = 0;
				this.y = 0;
				this.angle = 0;
				this.velX = 0;
				this.velY = 0;
				this.alive = false;
				this.colliding = false;
			};
	    
	    Display.prototype.setCanvas = function(canvas){
				this.context = canvas.getContext('2d');
				this.canvasWidth = canvas.width;
				this.canvasHeight = canvas.height;
			};
	    
	    Display.prototype.init = function(width, height){
				this.width = width || 20;
				this.height = height || 20;
				this.centerX = width/2;
				this.centerY = height/2;
				this.alive = false;
			};
	
	    function Physics(){
	        
	            Display.call(this);
	        
	        this.velX = 0;
	        this.velY = 0;
	        this.acelX = 0;
	        this.acelY = 0;
	        this.colliding = false;
	        this.speed = 0; 
	        this.thrust = 0;
	        this.angle = 0;
	    }
	    
	    Physics.prototype.spawn = function(x, y, angle, speed){
	        
	        this.x = x || centerX;
	        this.y = y || centerY;
	        this.colliding = false;
	        this.alive = true;
	        this.angle = angle || this.angle;
	        this.speed = speed || this.speed;
	        this.velX = Math.cos(this.angle)*this.speed;
	        this.velY = Math.sin(this.angle)*this.speed;
	        
	    };
	    
	    Physics.prototype.destroy = function(){
	        this.alive = false; 
	    };
	    
	    //spaceCraft function constructor 
	    function Spacecraft(){
	            
	           Physics.call(this);
	        
	        this.autoSpawn = false;
	        this.thrustAccel = 0.03;
	        this.alphaSpeed = 0.03;
	        this.shieldActive = false;
	        this.shieldDisabled = false;
			this.maxVelocity = 4;
	        this.missilesSpeed = 2.5;
			this.easeValue = 0.03;
			this.jumping = false;
	        
	    }
			
	    Spacecraft.prototype.init = function(width, height){
	        
	            Display.prototype.init.call(this, width, height);
	        
	        var shield = new Shield();
	            shield.setCanvas(mainCanvas);
	            shield.init(80,80);
			var missilePool = new Pool(10);
				missilePool.init('missile');
	            
	        var explosion = new Explosion(15);
	            explosion.setCanvas(mainCanvas);
	            
	            
	        this.explosion = explosion;
	        this.shield = shield;
	        this.missiles = missilePool;
	        
	    };    
		
	    Spacecraft.prototype.follow = function(object){
	        
				if(!object.alive || this.jumping){
					return;
				}	
				var dx, dy, distance, newVelX, newVelY, futureVel, direction;
				dx = object.x - this.x;
				dy = object.y - this.y;
				distance = Math.sqrt(dx*dx+dy*dy);
				direction = Math.atan2(dy, dx);
				this.angle = direction;
				
				if(distance>=140){
				newVelX = this.velX+Math.cos(this.angle)*this.thrustAccel;
				newVelY = this.velY+Math.sin(this.angle)*this.thrustAccel;	
				futureVel = Math.sqrt(newVelX*newVelX + newVelY*newVelY);	
						if(futureVel>1.5){
					newVelX = this.velX;
					newVelY = this.velY;
					}else{
					this.velX = newVelX;
					this.velY = newVelY;
					}
				}	
	    };
	    
	    Spacecraft.prototype.attack = function(object){
				if(Math.random() >= 0.005 || !this.alive || !object.alive){
					return;
				}
				this.shoot();
	    };
	    
	    Spacecraft.prototype.spawn = function(x, y, angle, speed){
	        
	            Physics.prototype.spawn.call(this, x, y, angle, speed);
	            this.missiles.hideItems();
	            //this.shield.reset();
				this.jumping = false;
	        
	    };
	    
	    Spacecraft.prototype.destroy = function(){
	        this.colliding = true;  
	        ResourceLoader.assets.explosionSound.play();
	    };
	
		Spacecraft.prototype.jump = function(){
			
			//if spacecraft is not jumping, have it face to the right and no Y velocity.
			if(!this.jumping){
				this.velY = this.angle = 0;
				this.velX = 1;
				this.jumping = true;
			}
			
		};
	
	    Spacecraft.prototype.draw = function(){
	        
	        //draws spacecraft launched missiles
	        for(var i=0; i<this.missiles.pool.length; i++){
	            var currentMissile = this.missiles.pool[i];   
	            if(currentMissile.alive){
	                currentMissile.draw();   
	            }
	        }
	        
	        if(this.colliding){	
	                //if spacecraft is colliding, create an explosion
	            this.explosion.create(this.x+this.centerX, this.y+this.centerY);
	            this.explosion.draw();
	                //once the explosion is not running, kill off spacecraft
	            if(!this.explosion.running){
	                this.alive = false;
	                this.colliding = false;
	                if(this.autoSpawn){
	                 this.spawn();   
	                }
	            }
	                //return while colliding
	            return;
	                    
	        }
	            //if shield is active draw it.
	        if(this.shield.active){
	                this.shield.x = this.x-this.shield.centerX+this.centerX;
	                this.shield.y = this.y-this.shield.centerY+this.centerY;
	                this.shield.draw();
	        }
			
			//if spacecraft is jumping, ease the spacecraft out.
			if(this.jumping && this.velX < 10){
				
				this.velX += this.velX*this.easeValue;
				
			}
			
			
	        
	    };
	    
	    Spacecraft.prototype.shoot = function(){
	        
	        //if instance is not alive, is colliding or not moving, it will NOT shoot
	        if(!this.alive || this.colliding || this.velX == 0){
	                return;
	        }
	
	        this.missiles.get(this.x+10, this.y+10, "missile", this.angle, this.missilesSpeed);
			
	    };
	    
	    //class for the rocks floating
	    function Rock(){
	        
	            Physics.call(this);
	        
	        this.size;
	        this.spriteAnimation = new SpriteAnimation();
	        this.spriteAnimation.setCanvas(mainCanvas);
	        this.explosion = new Explosion(7);
	        this.explosion.setCanvas(mainCanvas);
	        this.type = 'rock';
	    
	    }
	    
	    Rock.prototype.init = function(size){
	        
	          var spriteAnimationInfo,
	              largeRockSpeed = 0.5,
	              mediumRockSpeed = 1,
	              smallRockSpeed = 1.2,
	              randomAngle;
	        
	          this.sprite = ResourceLoader.assets.meteorSprite;
	            
	            size = size || "large";
	    
	            switch(size){
	                case "large":
	                    
	                    spriteAnimationInfo = {width:56,height:55, offsetX: 0, offsetY: 0, numCol:2, numRow:9,fps:60,speed:8,loop:false,from:0,to:17};
	                    this.spriteAnimation.init(spriteAnimationInfo);
	                    randomAngle = Math.random()*(Math.PI*2);
	                    Display.prototype.init.call(this, spriteAnimationInfo.width, spriteAnimationInfo.height);
	                    Physics.prototype.spawn.call(this, 0, 0, randomAngle, largeRockSpeed);
	                    this.alive = false;
	                    this.size = "large";
	                    this.type = "largeRock";
	                    
	                    break;
	                    
	                case "medium":
	                    
	                    spriteAnimationInfo = {width:44,height:44, numCol:3, numRow:6,fps:60,offsetX: 130, offsetY : 0, speed:12,loop:true,from:0,to:17};   
	                    this.spriteAnimation.init(spriteAnimationInfo);
	                    randomAngle = Math.random()*(Math.PI*2);
	                    Display.prototype.init.call(this, spriteAnimationInfo.width, spriteAnimationInfo.height);
	                    Physics.prototype.spawn.call(this, 0, 0, randomAngle, mediumRockSpeed);
	                    this.alive = false;
	                    this.size = "medium";
	                    this.type = "mediumRock";
	                    
	                    break;
	                    
	                case "small":
	                    
	                    spriteAnimationInfo = {width:33,height:33, numCol:3,offsetX: 290, offsetY: 0, numRow:6,fps:60,speed:15,loop:true,from:0,to:17};
	                    this.spriteAnimation.init(spriteAnimationInfo);
	                    randomAngle = Math.random()*(Math.PI*2);
	                    Display.prototype.init.call(this, spriteAnimationInfo.width, spriteAnimationInfo.height);
	                    Physics.prototype.spawn.call(this, 0, 0, randomAngle, smallRockSpeed);
	                    this.alive = false;
	                    this.size = "small";
	                    this.type = "smallRock";
	                    
	                    break;
	            }
	            
	    };
	    
	    Rock.prototype.draw = function(){
	            
				if(this.colliding){ 
	            //when object is colliding, creates and draws explosion
				this.explosion.create(this.x+this.centerX, this.y+this.centerY);
				this.explosion.draw();
	                this.destroy();
	
				     if(!this.explosion.running){
				     //once explosion is over, kills off object
	                    this.colliding = false;
	                    this.alive = false;
	                    }
	                // if the explosion is still running return to drawing the explosion
				     return;
				}
	            
	            this.x += this.velX;
	            this.y += this.velY;
	            
	            this.spriteAnimation.play(this.x, this.y, this.sprite);    
	            
	        };
	    
	    Rock.prototype.destroy = function(){
	        
	            if(this.colliding){
	                return;
	            }
	        
	            ResourceLoader.assets.meteorExplosionSound.play();
	            this.colliding = true;
	            
	            PubSub.publish('meteor_explosion', this);
	        
	    };    
	    
		function Background(){
	        
	            Display.call(this);
	        
	        this.velX = 0;
	        this.velY = 0;
			this.progressBarWidth = 400;
			this.progressBarHeight = 40;
		}
	    
	    Background.prototype.draw = function(){
	            this.x += this.velX;
				this.y += this.velY;
	            
	            this.context.drawImage(ResourceLoader.assets.backgroundSprite, 0,0,this.canvasWidth,this.canvasHeight,this.x-this.canvasWidth, this.y,this.canvasWidth,this.canvasHeight);	
	            this.context.drawImage(ResourceLoader.assets.backgroundSprite, 0,0,this.canvasWidth,this.canvasHeight,this.x,this.y,this.canvasWidth,this.canvasHeight);
				
				if(this.x>this.canvasWidth){
					this.x = 0;
				}	
	    };
	    
		function Ship(){
	        
	                Spacecraft.call(this);
	        
	            var shipSpriteInfo = {width:21,height:22, numCol:1, numRow:2,fps:60,speed:30,loop:false,from:0,to:0};
	        
	            this.thrust = false;
	            this.autoSpawn = true;
	            this.thrustAccel = 0.04;
	            this.missilesSpeed = 3.2;
	            this.spriteAnimation = new SpriteAnimation();
	            this.spriteAnimation.setCanvas(mainCanvas);
	            this.spriteAnimation.init(shipSpriteInfo); 
	            this.type = "humanShip";
	        
		}
	    
	    Ship.prototype.draw = function(){
	        
	           Spacecraft.prototype.draw.call(this);
	        
	        if(this.colliding){
	            return;   
	        }
	        
	                this.context.save();
	                this.alpha += this.alphaSpeed;
	                this.alpha = (this.alpha >= 1)? 1: this.alpha;
	                this.context.globalAlpha = this.alpha;
	                this.context.translate(this.x+10, this.y+10);	
	                this.context.rotate(this.angle);
	                this.x += this.velX;
	                this.y += this.velY;
	                if(this.thrust){
	                    this.spriteAnimation.startFrame = 1;
	                    this.spriteAnimation.finalFrame = 1;
	                    this.spriteAnimation.play(-this.centerX, -this.centerY, ResourceLoader.assets.playerSpriteSheet);
	                }else{
	                    //this.context.drawImage(shipSprite, 0, 0, this.width, this.height, -10,-10, this.width, this.height);
	                    this.spriteAnimation.startFrame = 0;
	                    this.spriteAnimation.finalFrame = 0;
	                    this.spriteAnimation.play(-this.centerX, -this.centerY, ResourceLoader.assets.playerSpriteSheet);
	                }
	                this.context.restore();
	    };
		
		Ship.prototype.shoot = function(){
			Spacecraft.prototype.shoot.call(this);
			ResourceLoader.assets.playerShootSound.play();
		};
	    
	    function Perk(){
	        
	            Physics.call(this);
	        
	        this.spriteAnimation = new SpriteAnimation(); 
	        this.spriteAnimation.setCanvas(mainCanvas);
	    
	        this.type = 'perk';    
	    }
	
	    Perk.prototype.draw = function(){
	        
	        if(!this.alive){
	            return;
	        }
	        
	        this.x += this.velX;
	        this.y += this.velY;
	        
	        this.spriteAnimation.play(this.x, this.y, ResourceLoader.assets.perkSprite);
	        
	    };
	
	    Perk.prototype.init = function(perk){
	            
	            var spriteInfo; 
	                
	            
	            switch(perk){
	                    
	                case "shield":
	                        spriteInfo = {width:18,height:19, numCol:1, numRow:2,fps:60,speed:1,loop:false,from:0,to:0};
	                        this.spriteAnimation.init(spriteInfo);
	                        Display.prototype.init.call(this, spriteInfo.width, spriteInfo.height);
	                        this.type = "shield";
	                    break;
	                    
	                case "life":
	                        spriteInfo = {width:18,height:19, numCol:1, numRow:2,fps:60,speed:1,loop:false,from:1,to:1};
	                        this.spriteAnimation.init(spriteInfo);
	                        Display.prototype.init.call(this, spriteInfo.width, spriteInfo.height);
	                        this.type = "life";
	                    break;
	            }
	    }; 
		
		Perk.prototype.destroy = function(){
			Physics.prototype.destroy.call(this);
			ResourceLoader.assets.perkSound.play();
		};        
	    //missle constructor
	    
		function Missile(){
	        
	            Physics.call(this);
	        
			this.speed = 3;
			this.life = 0;
			this.maxLife = 100;
	        this.type = "missile";
	
		}
	    
	    Missile.prototype.spawn = function(x, y, angle, speed){
	        Physics.prototype.spawn.call(this, x, y, angle, speed);  
	        this.life = 0;
	    };
	    
	    Missile.prototype.draw = function(){
	        
	        this.life++;
				if(this.life>=this.maxLife){
					this.life = 0;
					this.alive = false;
				}
				this.x += this.velX;
				this.y += this.velY;
				this.context.fillStyle = this.color;
				this.context.fillRect(this.x, this.y, this.width, this.height);
	    
	    };
	    
		function Enemy(){
	        
	            Spacecraft.call(this);
	        
			this.thrustAccel = 0.03;
	        this.type = "enemy";
	        
			
	        var spriteRandomIndex = Math.floor(Math.random()*4);
	        this.spriteAnimation = new SpriteAnimation();
	        this.spriteAnimation.setCanvas(mainCanvas);
	        var enemySpriteInfo = {width:23,height:21, numCol:1, numRow:4,fps:60,speed:30,loop:false,from:spriteRandomIndex,to:spriteRandomIndex};
	        this.spriteAnimation.init(enemySpriteInfo);
	    
		}
	    
	    Enemy.prototype.draw = function(){
	        
	                Spacecraft.prototype.draw.call(this);
	            
	            if(this.colliding || !this.alive){
	                return;   
	            }
	        
	                this.x += this.velX;
	                this.y += this.velY;
	                this.context.save();
	                this.context.translate(this.x+this.centerX, this.y+this.centerY);
	                this.context.rotate(this.angle);
	                this.spriteAnimation.play(-this.centerX, -this.centerX, ResourceLoader.assets.enemySpriteSheet);
	                this.context.restore();  
	                
	
	    };
	        
	    //mothership constructor
	    function Mothership(){
	        
	             Spacecraft.call(this);
	        
	        
	        this.hasReleasedShips = false;
	        this.spriteAnimation = new SpriteAnimation();
	        this.spriteAnimation.setCanvas(mainCanvas);
	        this.type = undefined;
	        this.missilesSpeed = 3;
	        this.alpha = 0;
	        this.alphaSpeed = 0.02;
	        this.numShips = 0;
	        this.type = "mothership";
	    
	    }
	    
	    Mothership.prototype.init = function(shipType){
	        
	            switch(shipType){
	                    
	                case "human":
	                    
	                 var spriteSheetInfo = {width:51,height:46, numCol:1, numRow:2,fps:60,speed:30,loop:false,from:0,to:0};
	                 var spriteIndex = Math.floor(Math.random()*spriteSheetInfo.to);
	                 spriteSheetInfo.from = spriteSheetInfo.to = spriteIndex;
	                 this.spriteAnimation.init(spriteSheetInfo);
	                 this.type = "human";
	                 this.width = spriteSheetInfo.width;
	                 this.height = spriteSheetInfo.height;
	                 this.centerX = this.width / 2;
	                 this.centerY = this.height / 2;
	                    Spacecraft.prototype.init.call(this, this.width, this.height);
	                    break;
	                    
	                case "alien":
	                    
	                var spriteSheetInfo = {width:51,height:46, numCol:4, numRow:2,fps:60,speed:30,loop:false,from:0,to:4};
	                var spriteIndex = Math.floor(Math.random()*spriteSheetInfo.to);
	                spriteSheetInfo.from = spriteSheetInfo.to = spriteIndex;
	                this.spriteAnimation.init(spriteSheetInfo);
	                this.type = "alien";
	                this.width = spriteSheetInfo.width;
	                this.height = spriteSheetInfo.height;
	                this.centerX = this.width / 2;
	                this.centerY = this.height / 2;
	                    Spacecraft.prototype.init.call(this, this.width, this.height);
	                    
	                    break;     
	            }
	            
	        };
	    
	    Mothership.prototype.setRelease = function(shipsPool, numShips, time){
	            
	            if(this.hasReleasedShips){
	                return;   
	            }
	            
	            //assigns number of ships to release
	            this.numShips = numShips;
	            this.shipsPool = shipsPool;
	            
	            //checks if time to release ships was passed in
	            time = (typeof time != "number")? 5000: time;
			
				var self = this;
			
				this.interval = window.setTimeout(function(){
					//release ships after the time has passed
					Mothership.prototype.releaseShips.call(self);
	                
				}, time);   
			
	        };
	    
	    Mothership.prototype.releaseShips = function(){
	       
	        console.log('ship release function has been called');
	            
	            this.hasReleasedShips = true;
	            this.shield.active = false;
	            
	
	            for(var i=0; i<this.numShips; i++){
	                    
	                var positionX = this.x + this.shipsPool.pool[i].width*i;
	                var positionY = this.y + this.shipsPool.pool[i].height*i;
	                this.shipsPool.get(positionX, positionY, 'enemy');
	                this.shipsPool.pool[i].shield.active = false;
	                        
	            } 
	                    
	            
	        };
	    
	    Mothership.prototype.destroy = function(){
			Spacecraft.prototype.destroy.call(this);
			window.clearTimeout(this.interval);
		};
	
	    Mothership.prototype.spawn = function(x, y, angle, speed){
	            
	            Spacecraft.prototype.spawn.call(this, x, y, angle, speed);
	            this.hasReleasedShips = false;
	            this.alpha = 0;
	            
	        };
	    
	    Mothership.prototype.draw = function(){
	            
	            Spacecraft.prototype.draw.call(this);
	        
	            if(this.colliding || !this.alive){
	                console.log('ships dead wont draw it');
	                return;
	                
	            }
	            this.x += this.velX;
	            this.y += this.velY;
	        
	        
	            this.context.save();
	            this.context.translate(this.x+this.centerX, this.y+this.centerY);
	            this.context.rotate(this.angle);
	            if(this.hasReleasedShips){
	                this.alpha -= this.alphaSpeed;   
	                this.alpha = (this.alpha <= 0)? 0: this.alpha; 
	                this.alive = (this.alpha <= 0)? false : true;
	            }else{
	            this.alpha += this.alphaSpeed;
	            this.alpha = (this.alpha >= 1)? 1: this.alpha;
	            }
	            this.context.globalAlpha = this.alpha;
	            this.spriteAnimation.play(-this.centerX, -this.centerY, ResourceLoader.assets.MothershipSpriteSheet);
	            this.context.restore();
	            
	            if(this.alpha <= 0){
	                this.alive = false;
	            } 
	        };
	    
	    // explosion constructor
		function Explosion(numParticles){
	        
	            Display.call(this);
	        
			this.running = false;
			this.particles = [];
			this.deadParticleCounter = 0;
			this.size = numParticles;
	        
			for(var i = 0; i<numParticles; i++){
				this.particles.push({x:0,y:0,alive:false,maxLife:0,velX:0,velY:0, width:2, height:2, life:0});
			}
				
		}
	    
	    Explosion.prototype.create = function(x, y){
	        if(this.running){
					return;
				}
				
				for(var i=0;i<this.size;i++){
					var currentParticle = this.particles[i];
					currentParticle.x = x;
					currentParticle.y = y;
					currentParticle.maxLife = Math.random()*45+15;
					currentParticle.velX = Math.random()*4-2.8;
					currentParticle.velY = Math.random()*4-2.8;
					currentParticle.alive = true;
					currentParticle.life = 0;
				}
				this.running = true;
				this.deadParticleCounter = 0;
	    };
	
	    Explosion.prototype.draw = function(){
	        
	        if(!this.running){
					return;
				}
				
				this.context.fillStyle = '#00FF00';
				for(var i=0; i<this.size; i++){
					var currentParticle = this.particles[i];
					if(currentParticle.alive){
					currentParticle.x += currentParticle.velX;
					currentParticle.y += currentParticle.velY;
					currentParticle.life++;
					this.context.fillRect(currentParticle.x, currentParticle.y, currentParticle.width, currentParticle.height);
	                        if(currentParticle.life >= currentParticle.maxLife){
	                        currentParticle.alive = false;
	                        currentParticle.life = 0;
	                        this.deadParticleCounter++;
	                    }
					}
					
				}
	//change the state from running to false by checking if there are any particles alive left
				if(this.deadParticleCounter>=this.size){
					this.running = false;
				}
	        
	    };
	    
	    //Shield constructor
		function Shield(){
	        
	            Display.call(this);
	        
			this.radius = 40;
			this.maxRadius = 45;
	        this.life = 100;
	        this.disabled = false;
	        this.color = '#0000FF';
	        this.type = 'shield';
	        var shieldState = false;
	    
	        Object.defineProperty(this, "active", {
	            get: function(){
	                
	                return shieldState;
	                
	            },
	            set: function(value){
	                
	                shieldState = (this.disabled)? false: value;
	                this.alive = shieldState;
	                
	            },
	            configurable: true,
	            enumerable: true
	        });
	        
	        
		}
	    
	    Shield.prototype.reduceLife = function(amount){
	        amount = (amount === undefined)? 50: amount;
	        this.life -= amount;
	    };
	    
	    Shield.prototype.draw = function(){
	        
	            if(!this.active){
	                console.log('shield is disabled');
	                return;
	            }
	            if(this.life <= 0){
	                this.life = 0;
	                this.disabled = true;
	                this.active = false;
	                    return;
	            }
				this.context.strokeStyle = this.color;
	            this.context.lineWidth = 1;
				this.context.beginPath(); 
				this.context.arc(this.x+this.centerX, this.y+this.centerY, this.radius, 0, Math.PI*2, true);
				this.context.closePath();
				this.context.stroke(); 
				this.radius += .25;
				this.radius = (this.radius>this.maxRadius)? 40: this.radius;
	        
	    };
	    
	    Shield.prototype.reset = function(){
	            this.life = 100;
	            this.disabled = false;
	    };
	    
	    //meteor pool
		function Pool(maxSize){
	        
			var pool = [];
	        
			this.pool = pool;
	        this.size = maxSize;
	        
		}
	    
	    Pool.prototype.init = function(type){
	            
	            switch(type){
	                case "missile":
	                    
	                  for(var i=0; i<this.size; i++){
						var missile = new Missile();
						missile.setCanvas(mainCanvas);
						missile.init(2,2);
						this.pool[i] = missile;
					}  
	                    break;
	                    
	                case "enemy":
	                   for(var j=0; j<this.size; j++){
	                    var randomX = Math.floor(Math.random()*mainCanvas.width);
	                    var randomY = Math.floor(Math.random()*mainCanvas.height);
	                    
	                    var enemy = new Enemy();
	                    enemy.setCanvas(mainCanvas);
	                    enemy.init(23, 21);
	                    enemy.x = randomX;
	                    enemy.y = randomY;
	
	                    this.pool[j] = enemy;
	                       
	                } 
	                    break;
	                    
	                case "perks":
	                    this.size = Math.floor(this.size / 2);
	
	                    for(var k=0; k<this.size; k++){
	                        var life = new Perk();
	                        life.setCanvas(mainCanvas);
	                        life.init("life");
	                        this.pool.push(life); 
	                    }
	
	                    for(var h=0; h<this.size; h++){
	                        var shield = new Perk();
	                        shield.setCanvas(mainCanvas);
	                        shield.init("shield");
	                        this.pool.push(shield);
	                    }
	                    
	                    this.size *= 2;
	                    
	                    break;
	                    
	                case "rocks":
	                    
	                    var numMediumRocks = this.size*2;
	                    var numSmallRocks = numMediumRocks*2;
	
	                        for(var l=0; l<this.size; l++){
	                            var meteor = new Rock();
	                            meteor.setCanvas(mainCanvas);
	                            meteor.init("large");
	                            meteor.type = "largeRock";
	                            this.pool.push(meteor);
	                        }
	                        for(var m=0; m<numMediumRocks; m++){
	                            var meteorMedium = new Rock();
	                            meteorMedium.setCanvas(mainCanvas);
	                            meteorMedium.init("medium");
	                            meteorMedium.type = "mediumRock";
	                            this.pool.push(meteorMedium);
	                        }
	                        for(var n=0; n<numSmallRocks; n++){
	                            var meteorSmall = new Rock();
	                            meteorSmall.setCanvas(mainCanvas);
	                            meteorSmall.init("small");
	                            meteorSmall.type = "smallRock";
	                            this.pool.push(meteorSmall);
	                        }
	                    
	                    this.size += (numMediumRocks+numSmallRocks);
	                    
	                    break;
	            }
	            
	    };
	    
	    Pool.prototype.get = function(x, y, type, angle, speed){
	        
	            type = type || "missile";
	        
	            /* code from before mixing both pools meteor and regular 
				if(!this.pool[size-1].alive){
					this.pool[size-1].spawn(x,y, angle, speed);
					this.pool.unshift(pool.pop());
				}
	            */
	            var i = 0;
	
	                while(i<this.size){
	                    if(this.pool[i].type === type && !this.pool[i].alive){
	                        this.pool[i].spawn(x, y, angle, speed);
	                        break;
	                    }
	                    i++;     
	                }
	        
	    };
	
	    Pool.prototype.isCollidingWith = function(args){
	            
	            var length = this.pool.length;
	            var argsLength = arguments.length;
	            
	            for(var i = 0; i<length; i++){
	                
	                var currentItem = this.pool[i];
	                
	                if(currentItem.alive){
	                
	                for(var h = 0; h<argsLength; h++){
	                    //each argument represents the objects being passed in to this method.
	                    var currentArgument = arguments[h];
						
						//if one of the arguments to check for collision is a pool of objects, iterate over each item.
						if(Array.isArray(currentArgument)){
							for(var j = 0, len = currentArgument.length; j < len; j++){
								var currentPoolItem = currentArgument[j];
								checkCollision(currentItem, currentPoolItem);
							}
						}else{
								checkCollision(currentItem, currentArgument);
						   }
	                }
	            }
	                
	        }
				//function in charge of testing for collision and executing what to do when there is a collision, it also makes a call to the recordCollision function which handles the recording of collisions for points and score.
				function checkCollision(item1, item2){
					
						if(Algorithms.hitTest(item1, item2)){
								if(item2 instanceof Shield){
									if(!(item1 instanceof Rock)){
											item1.destroy();
											item2.reduceLife(10);
											//recordCollision(item1.type);
	                                        PubSub.publish('collision', item1.type);
										}
									}else if(item1 instanceof Perk){
										item1.destroy();
										//recordCollision(item1.type);
	                                    PubSub.publish('collision', item1.type);
									}else{
										item2.destroy();
										item1.destroy();
										//recordCollision(item2.type);
	                                    PubSub.publish('collision', item2.type);
	                                    PubSub.publish('collision', item1.type);
										//recordCollision(item1.type);
									}
							}
	
				}
	    };
	    
	    Pool.prototype.hideItems  = function(){
	            var length = this.pool.length;
	            for(var i=0; i<length; i++){
	                this.pool[i].alive = false; 
	            }
	    };
	
	    function SpriteAnimation(){
			 
	        this.width;
	        this.height;
	        this.x;
	        this.y;
			this.offsetX = 0;
			this.offsetY = 0;
	        this.context;
	        this.canvasHeight;
	        this.canvasWidth;
	        this.speed;
	        this.numCol;
	        this.numRow;
	        this.currentFrame;
	        this.finalFrame;
	        this.startFrame;
	        this.totalFrames;
	        this.appFPS;
			 //spritesheet animations loops by default
	        this.loop = true;
			    //private members 
	     	this._frames = [];
	        this._frameIncrement;
	        this._frameIndex;
	
			 
		 }
		
	     SpriteAnimation.prototype.setCanvas = function(canvas){
	            this.context = canvas.getContext('2d');
	            this.canvasHeight = canvas.height;
	            this.canvasWidth = canvas.width;
	      };
		
	     SpriteAnimation.prototype.init = function(spriteObject){
	            
	            //sets up sprite properties from the spritesheet info object being passed in.
	            this.width = spriteObject.width || 32;
	            this.height = spriteObject.height || 32;
	            this.numCol = spriteObject.numCol || 1;
	            this.numRow = spriteObject.numRow || 1;
	            this.startFrame = spriteObject.from || 0;
	            this.finalFrame = spriteObject.to || 0;
	            this.speed = spriteObject.speed || 15;
			 	this.offsetX = spriteObject.offsetX || 0;
			 	this.offsetY = spriteObject.offsetY || 0;
	            this.totalFrames = spriteObject.numCol * spriteObject.numRow - 1;
	            this.loop = spriteObject.loop || true;
	            this.appFPS = spriteObject.fps;
	            
	            //creates the decimal of increment for each second
	            this._frameIncrement = this.speed/spriteObject.fps;
	            this._frameIndex = this.startFrame;        
	            
	            //creates a variable holding the length of the array holding the frames
	            var totalFramesLength = spriteObject.numCol * spriteObject.numRow;
	
	            for(var i = 0; i < totalFramesLength; i++){
	                var frame = {};
						frame.regX = this.offsetX;
						frame.regY = this.offsetY;
	            
	                frame.regX += (i % this.numCol)*this.width;
	                frame.regY += (i % this.numRow)*this.height;
	                
	                //pushes the objects with the regX and regY for each frame into a frame array.
	                this._frames.push(frame);
	                
	            }
	              
	        };
	        //use this method to locate or move the sprite sheet to a cordinate
	     SpriteAnimation.prototype.play = function(x, y, sprite){
	            this.x = x || 0;
	            this.y = y || 0;
	
	            //no animation will be playeed if the starting frame is equal to the final frame.
	            if(this.startFrame === this.finalFrame){
					
		//surrounds the sprite into a white block for debugging purposes, you can remove this in your final app
	                //this.context.strokeStyle = '#FFFFFF';
	                //this.context.strokeRect(this.x, this.y, this.width, this.height);
	               
	                this.currentFrame = this._frames[this.startFrame];
	                this.context.drawImage(sprite, this.currentFrame.regX, this.currentFrame.regY, this.width, this.height, this.x, this.y, this.width, this.height);
	                
	            }else{
	                //increments the frameIndex by a decimal, this will be floored because it is used to find an item in the frame array.
	                this._frameIndex += this._frameIncrement;
	                
	                if(this._frameIndex >= this.finalFrame + 1){
	                    this._frameIndex = (this.loop)? this.startFrame: this.finalFrame;
	                }
	                //floors the current index to a whole number so to find an object in the frame array
	                this.currentFrame = this._frames[Math.floor(this._frameIndex)];
	                //surrounds the sprite into a white block for debugging purposes, you can remove this in your final app
	                //this.context.strokeStyle = '#FFFFFF';
	                //this.context.strokeRect(this.x, this.y, this.width, this.height);
	                //draws the section of the image given the regX and regY as well as the width and height
	                this.context.drawImage(sprite, this.currentFrame.regX, this.currentFrame.regY, this.width, this.height, this.x, this.y, this.width, this.height); 
	            } 
	        };
	        //use this method to change the fps speed of your sprite sheet animation
	     SpriteAnimation.prototype.setSpeed = function(speed){
	            //reason why a method for this is needed is because there is  math to be done when speed is changed.
	          this.speed = speed || this.speed;
	            this._frameIncrement = this.speed / this.appFPS;
	            this._frameIndex = this.startFrame;   
	        }; 
		
	     SpriteAnimation.prototype.getFrame = function(frameIndex){
	            this._frameIndex = (frameIndex == undefined)? 0: frameIndex;
	            return this._frames[this._frameIndex];
	        };
	    
	module.exports = {
	    
	    Display : Display,
	    Phyiscs : Physics,
	    Spacecraft : Spacecraft,
	    Rock : Rock,
	    Background : Background,
	    Ship : Ship,
	    Perk : Perk,
	    Missile : Missile,
	    Enemy : Enemy,
	    Mothership : Mothership,
	    Explosion : Explosion,
	    Shield : Shield,
	    Pool : Pool,
	    SpriteAnimation : SpriteAnimation
	    
	};

/***/ },
/* 5 */
/***/ function(module, exports) {

	//checks if an object has left the canvas bouding box
	function checkBoundary(object){
	
			if(object.x >= object.canvasWidth){
				object.x = 0;
			}else if(object.x <= -object.width){
				object.x = object.canvasWidth-object.width;
			}else if(object.y >= object.canvasHeight+object.height){
				object.y = 0;
			}else if(object.y <= -object.height){
				object.y = object.canvasHeight-object.height;
			}	
		}
		
		//collision detection.
	function hitTest(object1, object2){
	   		var left1 = object1.x;
	   		var left2 = object2.x;
	   		var right1 = object1.x + object1.width;
	   		var right2 = object2.x + object2.width;
	   		var top1 = object1.y;
	   		var top2 = object2.y;
	   		var bottom1 = object1.y + object1.height;
	   		var bottom2 = object2.y + object2.height;
	
	   		if (bottom1 < top2) return(false);
	   		if (top1 > bottom2) return(false);
	   		if (right1 < left2) return(false);
	   		if (left1 > right2) return(false);
	        if (!object1.alive || object1.colliding || object2.colliding || !object2.alive) return(false);
	        
	        if (object1.type == "humanShip" && object1.velX == 0) return(false);
	        if (object2.type == "humanShip" && object2.velX == 0) return(false);
	        
	        if(object2.hasOwnProperty('shield')){
	            if(object2.shield.active){
	                return (false);
	            }
	        }
	        if(object1.hasOwnProperty('shield')){
	            if(object1.shield.active){
	                return (false);
	            }
	        }
	        
	
	        //otherwise return true 
	   		return(true);
	
		}
	
	
	module.exports = {
	    
	    checkBoundary : checkBoundary,
	    hitTest : hitTest
	    
	};

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	var PubSub = __webpack_require__(3),
	
		//state dictionary given property names for each state. 
	    state = {
	        loading: 0,
	        storyLine : 1,
		    titleScreen : 2,
	        gamePlay : 3,
	        levelTransition : 4,
	        beatGame : 5,
	        gameOver : 6,
	        credits : 7,
	        howToPlay : 8,
	        onPause : 9,
	        shipJump : 10,
	        setUpLevel: 11,
	
	        current : -1 
	    };
	
	function init(){
	    
	    if(this.hasInitialized) return this;
	     
	    this.hasInitialized = true;
	    this.pages = document.getElementsByClassName('appPage');
	    this.interface = document.getElementById('interfaceWrapper');
	    this.counters = document.getElementsByClassName('counter');
	    this.subId = PubSub.subscribe('statechange', handleStateChange.bind(this));
	    //Adds mousedown event listener to the div containing all the app pages
		this.interface.addEventListener('mousedown', handleClick);
	    
	    return this;
	    
	}
	
	function handleClick(event){
	    
	    var button = event.target,
	        from = button.getAttribute('data-from'),
	        to = button.getAttribute('data-to');
	    
		//if the element that triggered event has data-to and from attributes, trigger event.
	    if(from && to){
	         PubSub.publish('statechange', {from: state[from], to: state[to]});   
	    }
	    
	}
	
	function updateCounters(counter, value){
	    
		//if the counter exists update its value.
		if(this.counters[counter]){
	
			 this.counters[counter].innerHTML = value;
			
		}
	   
	    
	    return this;
	    
	}
	
	function show(pageName){
		
	    //if the page exists show it. 
	    if(this.pages[pageName]){
	        
	        this.pages[pageName].setAttribute('style', 'display: block;');
	        
	    }
	    
	    return this;
	    
	}
	
	function hide(pageName){
	    
		//if the page is defined, hide it. 
	    if(this.pages[pageName]){
	        
	        this.pages[pageName].setAttribute('style', 'display: none;');
	        
	    }
	    
	    return this;
	    
	}
	
	function hideAll(){
	    
	    var self = this;
		
	 	//delegates the forEach array method to iterate and hide each page.
	    [].forEach.call(this.pages, function(curretPage, index){
	       
			//calls the module hide method with the current context.
	        hide.call(self, index);
	        
	    });
	    
	    return self;
	    
	}
	
	
	function handleStateChange(event, data){
	    
		//hides away current state page and shows new state page.
	    hide.call(this, data.from);
	    show.call(this, data.to);
	    
	}
	
	module.exports = {
	    
	    init : init,
	    show : show,
	    hide : hide,
	    hideAll : hideAll,
	    hasInitialized : false,
	    updateCounter : updateCounters
	    
	    
	};

/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	var ResourceLoader = __webpack_require__(1),
	    keyboardControl = __webpack_require__(8),
	    Constructors = __webpack_require__(4),
	    PubSub = __webpack_require__(3),
	    UIController = __webpack_require__(6),
	    Algorithms = __webpack_require__(5),
	    mainCanvas = document.getElementById('bgCanvas'),
	    mainContext = mainCanvas.getContext('2d')
	    mouse = {x: 200, y:200},
	    centerX = mainCanvas.width / 2,
	    centerY = mainCanvas.height / 2,
	    FRAME_RATE = 1000/60,
	    
	    state = {
	        INIT : -1,
	        LOADING: 0,
	        STORY_LINE : 1,
		    TITLE_SCREEN : 2,
	        GAME_PLAY : 3,
	        LEVEL_TRANSITION : 4,
	        BEAT_GAME : 5,
	        GAME_OVER : 6,
	        CREDITS : 7,
	        HOW_TO_PLAY : 8,
	        PAUSED : 9,
	        SHIP_JUMP : 10,
	        SET_UP_LEVEL: 11,
	
	        CURRENT : -1 
	    },
	    
	    stateHandlers = {},
	    
	    loopOn = false;  
	
	    var totalEnemies = 8,
	        totalRocks = 10,
	        levelRocks = 5,
	        levelEnemies = 8,
	        levelPerks = 4,
	        enemiesKilled = 0
	        currentScore = 0,
	        shipLives = 4,
	        rocksDestroyed = 0,
	        currentLevel = 0,
	        lastLevel = 14;
	
		//TEMP: player instance and enemies
	    var playerShip,
		    alienMothership,
	        humanMothership,
		    background;
	
	     //pools holding enemies and rocks
	    var enemyShipsPool,
	        humanShipsPool,
	        perksPool,
	        meteorPool;   
	
	function init(){
	        
	        var self = this;
	    
	        attachStateHandlers();
	    
	        playerShip = new Constructors.Ship();
		    alienMothership = new Constructors.Mothership();
	        humanMothership = new Constructors.Mothership();
		    background = new Constructors.Background();
	
	     //pools holding enemies and rocks
	        enemyShipsPool = new Constructors.Pool(totalEnemies);
	        humanShipsPool = new Constructors.Pool(10);
	        perksPool = new Constructors.Pool(10);
	        meteorPool = new Constructors.Pool(totalRocks);   
	
	        background.setCanvas(mainCanvas);
			background.init(1000, 480);
			background.velX = 1;
	        
	        perksPool.init("perks");
	        meteorPool.init("rocks");
	        enemyShipsPool.init('enemy');
	        
	        alienMothership.setCanvas(mainCanvas);
	        alienMothership.init('alien');
	
	        playerShip.setCanvas(mainCanvas);
	        playerShip.init(23, 23);
	        playerShip.spawn(centerX, centerY);
	        
	        window.addEventListener('mousemove', onMouseMove, false);
	        
	        //add game control for desktop based on keyboard events
	        keyboardControl.init(playerShip);
	    
	        
	        //sign up for subscriptions
	        var subID1 = PubSub.subscribe('statechange', handleStateChange.bind(self));
	        var subID2 = PubSub.subscribe('meteor_explosion', handleMeteorExplosion.bind(self));
	        var subID3 = PubSub.subscribe('collision', recordCollision.bind(self));
	    
		window.alienMothership = alienMothership;
		window.playerShip = playerShip;
	    
	}
	
	
	function onMouseMove(e){
	    
	    
	    
	    
	}
	
	
	//function in charged of setting up the enemies and rocks in the new level given the current level
	function handleSetUpLevel(){
	    
	        
	        
	        console.log('Set Up Level function CALLED');
	        
	        //sets up random location for rocks and mothership
	            var randomX, randomY;
	        
	        //increases level by 1
	        currentLevel += 1;
	        
	        //checks if game is over
	        if(currentLevel > lastLevel){
	            userBeatGame = true;
	            PubSub.publish('statechange', {from: state.CURRENT, to: state.BEAT_GAME});
	            return;
	        }
	           
	        if(currentLevel == lastLevel){
	            ResourceLoader.assets.lastLevelSound.play();
	        }else{
	            //begins normal soundtrack 
			   ResourceLoader.assets.soundTrack.play();
	        }
			
	        //resets enemy killed and rocks destroyed counter and ship lives
	        enemiesKilled = 0;
	        rocksDestroyed = 0;
	    
	        if(currentLevel == 1){
	            shipLives = 4;
	        }
	        //sets up number of rocks and enemies that will be displayed
	        levelEnemies = currentLevel+1;
	        levelRocks = currentLevel+2;
	        
	        //checks to see if the level rocks and enemies exceed total in pool.
	        levelEnemies = (levelEnemies>=totalEnemies)? totalEnemies : levelEnemies;
	        levelRocks = (levelRocks>=totalRocks)? totalRocks : levelRocks;
	        
	        //centers ship and hide all of its missiles
	        playerShip.spawn(centerX, centerY);
	        
	        //kill off any alive rocks and enemies
	        perksPool.hideItems();
	        enemyShipsPool.hideItems();
	        meteorPool.hideItems();
	        
	        //inits the rocks
	        for(var i=0; i<levelRocks; i++){
	            randomX = Math.floor(Math.random()*(mainCanvas.width-50)),
	            randomY = Math.floor(Math.random()*(mainCanvas.height-50));
	            meteorPool.get(randomX, randomY, "largeRock");
	            meteorPool.get(randomX, randomY, "smallRock");
	        }
	        
	        for(var h=0; h<levelPerks; h++){
	            randomX = Math.floor(Math.random()*(mainCanvas.width-50)),
	            randomY = Math.floor(Math.random()*(mainCanvas.height-50));
	            perksPool.get(randomX, randomY, "life");
	            perksPool.get(randomY, randomX, "shield");
	        }
	    
	        //alienMothership.init("alien");
	        alienMothership.spawn(randomX, randomY);
	        alienMothership.shield.active = true;
	        alienMothership.setRelease(enemyShipsPool, levelEnemies, 8000);
	        
	        //updateCounter('level');
	        //updateCounter('life');
	        //updateCounter('score');
	    
	        UIController.updateCounter('level', currentLevel);
	        UIController.updateCounter('lives', shipLives);
	        UIController.updateCounter('score', currentScore);
	        
	        PubSub.publish('statechange', {from: state.SET_UP_LEVEL, to: state.GAME_PLAY});
	    
	}
	
	function attachStateHandlers(){
	    
	    stateHandlers[state.LOADING] = handleLoading;
	    stateHandlers[state.STORY_LINE] = handleStoryLine;
	    stateHandlers[state.TITLE_SCREEN] = handleTitleScreen;
	    stateHandlers[state.SET_UP_LEVEL] = handleSetUpLevel;
	    stateHandlers[state.GAME_PLAY] = handleGamePlay;
	    stateHandlers[state.SHIP_JUMP] = handleShipJump;
	    stateHandlers[state.LEVEL_TRANSITION] = handleLevelTransition;
	    stateHandlers[state.BEAT_GAME] = handleBeatGame;
	    stateHandlers[state.GAME_OVER] = handleGameOver;
	    stateHandlers[state.CREDITS] = handleCredits;
	    stateHandlers[state.HOW_TO_PLAY] = handleHowToPlay;
	    stateHandlers[state.PAUSED] = handlePause;
	        
	}
	
	function handleLoading(){
	    //do nothing   
	}
	
	function handleStoryLine(){
	
	    if(!loopOn){
	     
	        loopOn = true;
	        gameLoop();
	        
	    }
	    
	    background.draw();
	    
	}
	
	function handleTitleScreen(){
	    
	    if(!loopOn){
	        
	        loopOn = true;
	        gameLoop();
	        
	    }
	    
	    background.draw();
	    mainContext.drawImage(ResourceLoader.assets.earthSprite, (mainCanvas.width/2-(ResourceLoader.assets.earthSprite.width/2)), 0);
	        
	        for(var i=0; i<7; i++){
	            var currentEnemy = enemyShipsPool.pool[i];
	            currentEnemy.draw();
	            currentEnemy.follow(mouse);
	            Algorithms.checkBoundary(currentEnemy);
	        }
	    
	}
	
	function handleGamePlay(){
	    
	    if(!loopOn){
	        
	        ResourceLoader.assets.soundTrack.play();
	        loopOn = true;
	        gameLoop();
	           
	    }
	    
	     background.draw();
	
	        if(alienMothership.alive){
	            alienMothership.draw();
	            Algorithms.checkBoundary(alienMothership);
	            alienMothership.follow(playerShip);
	            alienMothership.attack(playerShip);
	            alienMothership.missiles.isCollidingWith(playerShip, playerShip.shield);
	            playerShip.missiles.isCollidingWith(alienMothership, alienMothership.shield);
	        }
	
	            for(var m=0; m<perksPool.pool.length; m++){
	                    var currentPerk = perksPool.pool[m];
	                    if(currentPerk.alive){
	                        currentPerk.draw(); 
	                        
	                        if(Algorithms.hitTest(currentPerk, playerShip)){
	                            console.log('DETECTION CONFIRMED!!');
	                            console.log(currentPerk);
	                            console.log(playerShip);
	                            currentPerk.destroy();
	                            PubSub.publish('collision', currentPerk.type);
	                        }
	                    }
	                }
	        
	        for(var i = 0; i<meteorPool.pool.length; i++){
	           
	            var currentMeteor = meteorPool.pool[i];
	            
	            if(currentMeteor.alive){
	                currentMeteor.draw();
	                Algorithms.checkBoundary(currentMeteor);
	                playerShip.missiles.isCollidingWith(currentMeteor);
	            }
	        }
	        
	        meteorPool.isCollidingWith(playerShip, playerShip.shield);
	        
	        for(var h = 0; h<enemyShipsPool.pool.length; h++){
	            
	            var currentEnemy = enemyShipsPool.pool[h];
	            
	            if(currentEnemy.alive){
	                
	                currentEnemy.draw();
	                Algorithms.checkBoundary(currentEnemy);
	                currentEnemy.follow(playerShip);
	                currentEnemy.attack(playerShip);
	                currentEnemy.missiles.isCollidingWith(playerShip, playerShip.shield, meteorPool.pool);
	                playerShip.missiles.isCollidingWith(currentEnemy, currentEnemy.shield);
	                
	                if(Algorithms.hitTest(currentEnemy, playerShip)){
	                    
	                    currentEnemy.destroy();
	                    playerShip.destroy();
	                    PubSub.publish('collision', currentEnemy.type);
	                    PubSub.publish('collision', playerShip.type);
	                    
	                }
	                
	            }
	            
	        }
	    
	        //check frames
			
	        if(playerShip.alive){
				keyboardControl.update();
	            Algorithms.checkBoundary(playerShip);
	            playerShip.draw();
	        }
	        
	        
	        if(shipLives <= 0 && !playerShip.colliding && state.CURRENT == state.GAME_PLAY){
	            
	                    if(currentLevel == lastLevel){
							ResourceLoader.assets.lastLevelSound.stop();
						}else{
							ResourceLoader.assets.soundTrack.stop(); 
						}
	                
	                PubSub.publish('statechange', {from: state.GAME_PLAY, to: state.GAME_OVER});
	            
	                currentLevel = 0;
	            
	        }else if(levelEnemies <= 0 && !playerShip.colliding && playerShip.alive && state.CURRENT == state.GAME_PLAY){
	            
	                    if(currentLevel == lastLevel){
							ResourceLoader.assets.lastLevelSound.stop();
						}else{
							ResourceLoader.assets.soundTrack.stop(); 
						}
	            
	            PubSub.publish('statechange', {from: state.GAME_PLAY, to: state.SHIP_JUMP});
	
	        }
	    
	}
	
	function handleLevelTransition(){
	    
	    if(loopOn){
	     
	        loopOn = false;
	        gameLoop();
	
	    }
	
	    
	    UIController.updateCounter('reportScore', currentScore);
	    UIController.updateCounter('reportCarnage', enemiesKilled);   
	    UIController.updateCounter('reportAsteroids', rocksDestroyed);
	
	    
	}
	
	function handleMeteorExplosion(event, meteor){
	    
	    
	            switch(meteor.size){
	                case "large":
	                meteorPool.get(meteor.x, meteor.y, "mediumRock");
	                meteorPool.get(meteor.x, meteor.y, "mediumRock");
	                    break;
	                case "medium":
	                meteorPool.get(meteor.x, meteor.y, "smallRock");
	                meteorPool.get(meteor.x, meteor.y, "smallRock");
	                    break;
	                case "small":
	                    //no rocks
	                    break;     
	            } 
	    
	}
	
	function handleShipJump(){
	    
	    if(!loopOn){
	        
	        loopOn = true;
	        gameLoop();
	        
	    }
	    
	    
	    //draw background
	        background.draw();
	        
	        //drawRemaining rocks
	        for(var k=0; k<meteorPool.pool.length; k++){
	            var currentRock = meteorPool.pool[k];
	            
	            //if rock alive draw it
	            if(currentRock.alive){
	                Algorithms.checkBoundary(currentRock);
	                currentRock.draw();
	            }
	        }
	        
	        enemyShipsPool.pool.forEach(function(enemy){
	            if(enemy.alive){
	                enemy.draw();
	            }
	        });
	        
			playerShip.jump();
	        playerShip.draw();
	        
	        
	        if(playerShip.x >= 1020-playerShip.width){ 
	            
	            PubSub.publish('statechange', {from: state.SHIP_JUMP, to: state.LEVEL_TRANSITION});
	            
	        }
	    
	}
	
	function handlePause(){
	 
	    ResourceLoader.assets.soundTrack.pause();
	    ResourceLoader.assets.lastLevelSound.pause();
	    loopOn = false;
	    
	}
	
	function handleBeatGame(){
	    
	        if(loopOn){
	            
	            loopOn = false;
	            
	        }
			
	        //outputs the final score to the winner gamer :)
	        //ResourceLoader.finalLevelSound.stop();       
	        //beatGameScore.innerHTML = "Your Score: "+currentScore;
	    
	        UIController.updateCounter('beatGameScore', currentScore);
	        userBeatGame = false;
	                
	        ResourceLoader.assets.victorySound.play();
	        
	        //resets that score
	        currentScore = 0;
	        currentLevel = 0;
	       
	}
	
	function handleGameOver(){
	    
	        if(loopOn){
	         
	            loopOn = false;
	            
	        }
	        
	        //checks to see which sound to stop playing given the level the user was before dying
			ResourceLoader.assets.gameOverSound.play();
	        
	        //resets the score and level
	        currentLevel = 0;
	        currentScore = 0;
	    
	}
	
	function recordCollision(event, objectType){
	    
	        switch(objectType){
	            case "largeRock":
	                currentScore += 20;
	                UIController.updateCounter('score', currentScore);
	                rocksDestroyed++;
	                break;
	                
	            case "mediumRock":
	                currentScore += 10;
	                UIController.updateCounter('score', currentScore);
	                rocksDestroyed++;
	                break;
	                
	            case "smallRock":
	                currentScore += 5;
	                UIController.updateCounter('score', currentScore);
	                rocksDestroyed++;
	                break;
	                
	            case "humanShip":
	                shipLives--;
	                currentScore -= 50;
	                UIController.updateCounter('score', currentScore);
	                UIController.updateCounter('lives', shipLives);
	                break;
	                
	            case "enemy":
	                currentScore += 50;
	                UIController.updateCounter('score', currentScore);
	                levelEnemies--;
	                enemiesKilled++;
	                break;
	                
	            case "life":
	                shipLives++;
	                UIController.updateCounter('lives', shipLives);
	                break;
	                
	            case "shield":
	                playerShip.shield.reset();
	                break;
	            case "cash":
	                break;
	        }
	        
	}
	
	function handleCredits(){
	    
		if(loopOn){
			loopOn = false;
		}
	    
	    
	}
	
	function handleHowToPlay(){
	    
		if(loopOn){
			loopOn = false;
		}
	    
	    
	}
	
	function handleStateChange(event, data){
	    
	    state.CURRENT = data.to;
	    
	    runState(data.to);
	    
	    
	}
	
	function runState(state){
	    
	     stateHandlers[state]();
	    
	}
	    
	function gameLoop(){
	    
	    if(loopOn){
	     
			requestAnimFrame(gameLoop, FRAME_RATE);
				
			runState(state.CURRENT);
			
			console.log('game loop running');
			
			
			}
	}
	
	module.exports = {
	    
	    init : init
	    
	};

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	
	var PubSub = __webpack_require__(3);
	
	var keyboardControl = function(){
		
		//control keys
		const UP_ARROW = 38,
			LEFT_ARROW = 37,
			RIGHT_ARROW = 39,
			DOWN_ARROW = 40,
			X_KEY = 88,
			SPACE_BAR = 32,
			LETTER_P = 80,
	          
	        state = {
	            INIT : -1,
	            LOADING: 0,
	            STORY_LINE : 1,
	            TITLE_SCREEN : 2,
	            GAME_PLAY : 3,
	            LEVEL_TRANSITION : 4,
	            BEAT_GAME : 5,
	            GAME_OVER : 6,
	            CREDITS : 7,
	            HOW_TO_PLAY : 8,
	            PAUSED : 9,
	            SHIP_JUMP : 10,
	            SET_UP_LEVEL: 11,
	
	            CURRENT : -1 
	    };
		
		//array of active and deactive keys
		var keyPressList = [],
			objects = [],
			initialized = false,
			inGamePlay = false;
		
		function init(objectsToControl){
			
			//pushes the elements to be manipulated by the keyword keys
			if(!objects.length){
				for(element in arguments){
					objects.push(arguments[element]);
				}
			}
		
			document.addEventListener('keyup', onKeyUp, false);
			document.addEventListener('keydown', onKeyDown, false);
			initialized = true;
			console.log('Keyword Control Module Initialized');
	        PubSub.subscribe('statechange', handleStateChange);
			
		}
		
		function handleStateChange(event, data){
			state.CURRENT = data.to;
		}
		
		function onKeyUp(e){
	        
			if(!initialized) return(console.log('Keyword Module has not been initialized...'));
			e.preventDefault();
			keyPressList[e.keyCode] = false;
	        
	        if(keyPressList[LETTER_P] == false && state.CURRENT === state.PAUSED){
					keyPressList[LETTER_P] = true;
	                PubSub.publish('statechange', {from: state.PAUSED, to: state.GAME_PLAY});
					console.log('Letter P has been pressed');
	
				}
	        
		}
		
		function onKeyDown(e){
			if(!initialized) return(console.log('Keyword Module has not been initialized...'));
			e.preventDefault();
			keyPressList[e.keyCode] = true; 
		}
		
		function runKeys(){
	        
			var length = objects.length;
			
			for(var i = 0; i<length; i++){
				
				var object = objects[i];
				
				if(keyPressList[LEFT_ARROW]){
					object.angle -= 5*Math.PI/180;
				}else if(keyPressList[RIGHT_ARROW]){
					object.angle += 5*Math.PI/180;
				}
				if(keyPressList[UP_ARROW]){
					object.thrust = true;
					var faceX = Math.cos(object.angle);
					var faceY = Math.sin(object.angle);
					var newVelX = object.velX+faceX*object.thrustAccel;
					var newVelY = object.velY+faceY*object.thrustAccel;
	
					var futureVelocity = Math.sqrt((newVelX*newVelX)+(newVelY*newVelY));
	
					if(futureVelocity > object.maxVelocity){
						newVelX = object.velX;
						newVelY = object.velY;
					}
	
					object.velX = newVelX;
					object.velY = newVelY;	
	
				}else{
					object.thrust = false;
				}
				if(keyPressList[SPACE_BAR] == false){                
					keyPressList[SPACE_BAR] = true;
					if(!object.shield.active){
					object.shoot();
					}				
				}
				if(keyPressList[X_KEY]){
					object.shield.active = true;
	
				}else if(keyPressList[X_KEY] == false){
					object.shield.active = false;
				}
				if(keyPressList[LETTER_P] == false){
					keyPressList[LETTER_P] = true;
	                PubSub.publish('statechange', {from: state.GAME_PLAY, to: state.PAUSED});
					console.log('Letter P has been pressed');
	
				}
				
			}
			
		}
		
		function end(){
			document.removeEventListener('keyup', onKeyUp, false);
			document.removeEventListener('keydown', onKeyDown, false);
			initialized = false;
			console.log('Keyword Module Terminated');
		}
		
		return{
			init : init,
			update : runKeys,
			end : end
		}
		
	}();
	
	module.exports = keyboardControl;

/***/ }
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgMzlmZDEwY2I4NDZjZDJlMDBmODQiLCJ3ZWJwYWNrOi8vLy4vanMvbWFpbi5qcyIsIndlYnBhY2s6Ly8vLi9qcy9SZXNvdXJjZUxvYWRlci5qcyIsIndlYnBhY2s6Ly8vLi9+L2hvd2xlci9kaXN0L2hvd2xlci5qcyIsIndlYnBhY2s6Ly8vLi9qcy9QdWJTdWIuanMiLCJ3ZWJwYWNrOi8vLy4vanMvQ29uc3RydWN0b3JzLmpzIiwid2VicGFjazovLy8uL2pzL0FsZ29yaXRobXMuanMiLCJ3ZWJwYWNrOi8vLy4vanMvVUlDb250cm9sbGVyLmpzIiwid2VicGFjazovLy8uL2pzL0dhbWUuanMiLCJ3ZWJwYWNrOi8vLy4vanMva2V5Ym9hcmRDb250cm9sLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1QkFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7O0FDdENBOztBQUVBOzs7QUFHQTs7QUFFQTs7O0FBR0Esc0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVMsSTs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQSx1REFBc0Q7O0FBRXREO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFD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QTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBaUIsY0FBYztBQUMvQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWMsWUFBWTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBaUIsY0FBYztBQUMvQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFjLFNBQVM7QUFDdkIsZUFBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQSxlQUFjLFNBQVM7QUFDdkIsZUFBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFjLE1BQU07QUFDcEIsY0FBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7Ozs7Ozs7Ozs7OztBQy9xRkQsaUJBQWdCO0FBQ2hCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEtBQUk7O0FBRUo7O0FBRUE7O0FBRUE7Ozs7QUFJQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsa0NBQWlDLEtBQUs7O0FBRXRDOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSw2Q0FBNEMsS0FBSztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7OztBQUlBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxHOzs7Ozs7QUN6RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0M7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSw0QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBLE87O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDhEO0FBQ0EsNkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsSztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLCtCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxxQkFBb0IsNkJBQTZCO0FBQ2pELHdEO0FBQ0E7QUFDQSx1QztBQUNBO0FBQ0E7O0FBRUEsNEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOzs7O0FBSUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLDRDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSw0Q0FBMkMsMEc7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsNENBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsdUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsb0U7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsTzs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx1TDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsbUNBQWtDOztBQUVsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RDtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0Esb0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsc0Q7QUFDQTs7QUFFQSw0QjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLDRCOzs7QUFHQTs7QUFFQTtBQUNBLHVDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFD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TTtBQUNOLCtDO0FBQ0E7O0FBRUEsNENBQTJDLDJDQUEyQzs7QUFFdEY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQSxnRTtBQUNBOzs7QUFHQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCO0FBQ0EsYzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0EscUJBQW9CLDBCQUEwQjtBQUM5Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7OztBQUdBLG1EOztBQUVBLDRDQUEyQyxrREFBa0Q7O0FBRTdGOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLGlEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOzs7QUFHQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEc7Ozs7Ozs7QUM1a0JBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0RBQStDLHdDQUF3QztBQUN2Rjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQztBQUNBOztBQUVBOztBQUVBOztBQUVBLGlCQUFnQixVQUFVOztBQUUxQjs7QUFFQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQjs7QUFFQSxLQUFJO0FBQ0o7QUFDQTtBQUNBLHlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBK0Msd0NBQXdDO0FBQ3ZGOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEVBQUM7O0FBRUQsa0MiLCJmaWxlIjoiLi9zY3JpcHRzLm1pbi5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKVxuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuXG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRleHBvcnRzOiB7fSxcbiBcdFx0XHRpZDogbW9kdWxlSWQsXG4gXHRcdFx0bG9hZGVkOiBmYWxzZVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sb2FkZWQgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogd2VicGFjay9ib290c3RyYXAgMzlmZDEwY2I4NDZjZDJlMDBmODRcbiAqKi8iLCJ3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIG9uV2luZG93TG9hZCwgZmFsc2UpO1xyXG5cclxuZnVuY3Rpb24gb25XaW5kb3dMb2FkKCl7XHJcbiAgICBcclxuICAgIFxyXG4gICAgY2FudmFzQXBwKCk7XHJcbiAgICBcclxufVxyXG5cclxuXHJcbmZ1bmN0aW9uIGNhbnZhc0FwcCgpe1x0XHJcblx0XHJcblx0XHR2YXIgUmVzb3VyY2VMb2FkZXIgPSByZXF1aXJlKCcuL1Jlc291cmNlTG9hZGVyLmpzJyksXHJcbiAgICAgICAgICAgIFB1YlN1YiA9IHJlcXVpcmUoJy4vUHViU3ViLmpzJyksXHJcbiAgICAgICAgICAgIENvbnNjdHJ1Y3RvcnMgPSByZXF1aXJlKCcuL0NvbnN0cnVjdG9ycycpLFxyXG4gICAgICAgICAgICBVSUNvbnRyb2xsZXIgPSByZXF1aXJlKCcuL1VJQ29udHJvbGxlcicpLFxyXG4gICAgICAgICAgICBHYW1lID0gcmVxdWlyZSgnLi9HYW1lJyk7XHJcbiAgICBcclxuXHRcdFx0Ly9zZXRzIHVwIGdhbWUgZW5naW5lXHJcblx0XHR3aW5kb3cucmVxdWVzdEFuaW1GcmFtZSA9IChmdW5jdGlvbigpe1xyXG5cdHJldHVybiAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSAgIHx8XHJcblx0XHRcdHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcclxuXHRcdFx0d2luZG93Lm1velJlcXVlc3RBbmltYXRpb25GcmFtZSAgICB8fFxyXG5cdFx0XHR3aW5kb3cub1JlcXVlc3RBbmltYXRpb25GcmFtZSAgICAgIHx8XHJcblx0XHRcdHdpbmRvdy5tc1JlcXVlc3RBbmltYXRpb25GcmFtZSAgICAgfHxcclxuXHRcdFx0ZnVuY3Rpb24oLyogZnVuY3Rpb24gKi8gY2FsbGJhY2ssIC8qIERPTUVsZW1lbnQgKi8gZWxlbWVudCl7XHJcblx0XHRcdFx0d2luZG93LnNldFRpbWVvdXQoY2FsbGJhY2ssIEZSQU1FX1JBVEUpO1xyXG5cdFx0XHR9O1xyXG4gICAgICAgIH0pKCk7IFxyXG4gICAgXHJcbiAgICB2YXIgc3RhdGUgPSB7XHJcbiAgICAgICAgICAgIElOSVQgOiAtMSxcclxuICAgICAgICAgICAgTE9BRElORzogMCxcclxuICAgICAgICAgICAgU1RPUllfTElORSA6IDEsXHJcbiAgICAgICAgICAgIFRJVExFX1NDUkVFTiA6IDIsXHJcbiAgICAgICAgICAgIEdBTUVfUExBWSA6IDMsXHJcbiAgICAgICAgICAgIExFVkVMX1RSQU5TSVRJT04gOiA0LFxyXG4gICAgICAgICAgICBCRUFUX0dBTUUgOiA1LFxyXG4gICAgICAgICAgICBHQU1FX09WRVIgOiA2LFxyXG4gICAgICAgICAgICBDUkVESVRTIDogNyxcclxuICAgICAgICAgICAgSE9XX1RPX1BMQVkgOiA4LFxyXG4gICAgICAgICAgICBQQVVTRUQgOiA5LFxyXG4gICAgICAgICAgICBTSElQX0pVTVAgOiAxMCxcclxuICAgICAgICAgICAgU0VUX1VQX0xFVkVMOiAxMSxcclxuXHJcbiAgICAgICAgICAgIENVUlJFTlQgOiAtMSBcclxuICAgIH07XHJcbiAgICBcclxuICAgIFxyXG4gICAgd2luZG93LlJlc291cmNlTG9hZGVyID0gUmVzb3VyY2VMb2FkZXI7XHJcblx0Ly9hZGRpbmcgdGhlIHN0YXRlIG9iamVjdCB0byB0aGUga2V5Ym9hcmRDb250cm9sIHN0YXRlIHByb3BlcnR5XHJcbiAgICB2YXIgcHJlbG9hZEltYWdlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3ByZWxvYWQnKTtcclxuICAgIFxyXG4gICAgcHJlbG9hZEltYWdlLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCAnZGlzcGxheTogbm9uZTsnKTtcclxuXHRcclxuXHQvL2ZyYW1lLCBhc3NldHMgY291bnRlciBhbmQgYXVkaW8gc3VwcG9ydFxyXG5cdHZhciBmcmFtZVJhdGUgPSBuZXcgRnJhbWVSYXRlQ291bnRlcigpO1xyXG5cclxuXHRcclxuICAgIHZhciBsb2FkQmFyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2xvYWRCYXInKTtcclxuICAgIFxyXG5cdC8vc2V0IHVwIGxvYWRlclxyXG5cdHZhciBsb2FkZXJPcHRpb25zID0ge1xyXG5cdFx0XHRhc3NldHMgOiB7XHJcblx0XHRcdFx0aW1ncyA6IHtcclxuICAgICAgICAgICAgICAgICAgICBlYXJ0aFNwcml0ZSA6IFwiYXNzZXRzL3Nwcml0ZXMvZWFydGgucG5nXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgcGxheWVyU3ByaXRlU2hlZXQgOiBcImFzc2V0cy9zcHJpdGVzL3BsYXllclNoaXAucG5nXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgZW5lbXlTcHJpdGVTaGVldCA6IFwiYXNzZXRzL3Nwcml0ZXMvZW5lbXlTaGlwcy5wbmdcIixcclxuICAgICAgICAgICAgICAgICAgICBNb3RoZXJzaGlwU3ByaXRlU2hlZXQgOiBcImFzc2V0cy9zcHJpdGVzL21vdGhlcnNoaXBzLnBuZ1wiLFxyXG4gICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmRTcHJpdGUgOiBcImFzc2V0cy9zcHJpdGVzL2JhY2tncm91bmQucG5nXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgbWV0ZW9yU3ByaXRlIDogXCJhc3NldHMvc3ByaXRlcy9tZXRlb3JTcHJpdGUucG5nXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgcGVya1Nwcml0ZSA6IFwiYXNzZXRzL3Nwcml0ZXMvcGVya3MucG5nXCJcclxuXHRcdFx0XHR9LFxyXG4gICAgICAgICAgICAgICAgc291bmRzIDoge1xyXG4gICAgICAgICAgICAgICAgICAgIHNvdW5kVHJhY2sgOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNyYzogWydhc3NldHMvc291bmRzL3NvdW5kdHJhY2subXAzJywnYXNzZXRzL3NvdW5kcy9zb3VuZHRyYWNrLndhdiddLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2b2x1bWU6IDAuNSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbG9vcDogZmFsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICBsYXN0TGV2ZWxTb3VuZCA6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgIHNyYzogWydhc3NldHMvc291bmRzL2ZpbmFsTGV2ZWxTb3VuZC5tcDMnLCdhc3NldHMvc291bmRzL2ZpbmFsTGV2ZWxTb3VuZC53YXYnXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgIHZvbHVtZTogMSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICBtZXRlb3JFeHBsb3Npb25Tb3VuZCA6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3JjOiBbJ2Fzc2V0cy9zb3VuZHMvbWV0ZW9yRXhwbG9zaW9uLm1wMycsJ2Fzc2V0cy9zb3VuZHMvbWV0ZW9yRXhwbG9zaW9uLndhdiddLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2b2x1bWU6IDEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgcGxheWVyU2hvb3RTb3VuZCA6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3JjOiBbJ2Fzc2V0cy9zb3VuZHMvc2hvb3QubXAzJywnYXNzZXRzL3NvdW5kcy9zaG9vdC53YXYnXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdm9sdW1lOiAwLjMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgZXhwbG9zaW9uU291bmQgOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNyYzogWydhc3NldHMvc291bmRzL2V4cGxvc2lvbi5tcDMnLCdhc3NldHMvc291bmRzL2V4cGxvc2lvbi53YXYnXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdm9sdW1lOiAwLjIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgcGVya1NvdW5kIDoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzcmM6IFsnYXNzZXRzL3NvdW5kcy9wZXJrLm1wMycsJ2Fzc2V0cy9zb3VuZHMvcGVyay53YXYnXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdm9sdW1lOiAxLjAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgdmljdG9yeVNvdW5kIDoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzcmM6IFsnYXNzZXRzL3NvdW5kcy92aWN0b3J5Lm1wMycsJ2Fzc2V0cy9zb3VuZHMvdmljdG9yeS53YXYnXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdm9sdW1lOiAxLjAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgZ2FtZU92ZXJTb3VuZCA6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3JjOiBbJ2Fzc2V0cy9zb3VuZHMvZ2FtZW92ZXIubXAzJywnYXNzZXRzL3NvdW5kcy9nYW1lb3Zlci53YXYnXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdm9sdW1lOiAxLjAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHRcdFx0fSxcclxuICAgICAgICAgICAgdXNlSG93bCA6IHRydWUsXHJcbiAgICAgICAgXHJcblx0XHRcdG9ubG9hZCA6IGZ1bmN0aW9uKGl0ZW0pe1xyXG5cdFx0XHRcdGxvYWRCYXIuc2V0QXR0cmlidXRlKCdzdHlsZScsICd3aWR0aDogJytSZXNvdXJjZUxvYWRlci5sb2FkZWQqMTAwKyclOycpO1xyXG5cdFx0XHR9LFxyXG4gICAgICAgIFxyXG5cdFx0XHRmaW5hbCA6IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgICAgICBHYW1lLmluaXQoKTtcclxuXHRcdFx0XHRQdWJTdWIucHVibGlzaCgnc3RhdGVjaGFuZ2UnLCB7ZnJvbTpzdGF0ZS5MT0FESU5HLCB0bzpzdGF0ZS5TVE9SWV9MSU5FfSk7XHJcblx0XHRcdH1cclxuXHRcdH07XHJcbiAgICBcclxuICAgIFVJQ29udHJvbGxlci5pbml0KCk7XHJcbiAgICBSZXNvdXJjZUxvYWRlci5pbml0KGxvYWRlck9wdGlvbnMpO1xyXG4gICAgUmVzb3VyY2VMb2FkZXIuZG93bmxvYWRBbGwoKTtcclxuICAgIFxyXG4gICAgXHJcbiAgIFxyXG4gICAgXHJcbiAgICBcclxuICAgIFxyXG4gICAgLy9QdWJTdWIucHVibGlzaCgnc3RhdGVjaGFuZ2UnLCB7ZnJvbTogc3RhdGUuTE9BRElORywgdG86IHN0YXRlLlNUT1JZX0xJTkV9KTtcclxuICAgIFxyXG5cdFxyXG5cdC8vY291bnRlcnNcclxuXHR2YXIgc2NvcmVDb3VudGVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3Njb3JlQ291bnRlcicpO1xyXG5cdHZhciBsZXZlbENvdW50ZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbGV2ZWxDb3VudGVyJyk7XHJcblx0dmFyIGxpdmVzQ291bnRlciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdsaXZlc0NvdW50ZXInKTtcclxuXHR2YXIgZnJhbWVSYXRlQ291bnRlciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdmcmFtZVJhdGUnKTtcclxuICAgIHZhciByZXBvcnRFbmVtaWVzS2lsbGVkID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3JlcG9ydENhcm5hZ2UnKTtcclxuICAgIHZhciByZXBvcnRSb2Nrc0Rlc3Ryb3llZCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdlcG9ydEFzdGVyb2lkcycpO1xyXG4gICAgdmFyIHJlcG9ydFNjb3JlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3JlcG9ydFNjb3JlJyk7XHJcbiAgICB2YXIgYmVhdEdhbWVTY29yZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdiZWF0R2FtZVNjb3JlJyk7XHJcblx0XHJcblxyXG5cdFxyXG5cclxuICAgICAgICBcclxuICAgIC8vZ2FtZSBzY29yZSB0cmFja2VyXHJcbiAgICBcclxuICAgIGZ1bmN0aW9uIHJlY29yZENvbGxpc2lvbihvYmplY3RUeXBlKXtcclxuICAgICAgICBzd2l0Y2gob2JqZWN0VHlwZSl7XHJcbiAgICAgICAgICAgIGNhc2UgXCJsYXJnZVJvY2tcIjpcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRTY29yZSArPSAyMDtcclxuICAgICAgICAgICAgICAgIHVwZGF0ZUNvdW50ZXIoJ3Njb3JlJyk7XHJcbiAgICAgICAgICAgICAgICByb2Nrc0Rlc3Ryb3llZCsrO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgY2FzZSBcIm1lZGl1bVJvY2tcIjpcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRTY29yZSArPSAxMDtcclxuICAgICAgICAgICAgICAgIHVwZGF0ZUNvdW50ZXIoJ3Njb3JlJyk7XHJcbiAgICAgICAgICAgICAgICByb2Nrc0Rlc3Ryb3llZCsrO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgY2FzZSBcInNtYWxsUm9ja1wiOlxyXG4gICAgICAgICAgICAgICAgY3VycmVudFNjb3JlICs9IDU7XHJcbiAgICAgICAgICAgICAgICB1cGRhdGVDb3VudGVyKCdzY29yZScpO1xyXG4gICAgICAgICAgICAgICAgcm9ja3NEZXN0cm95ZWQrKztcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGNhc2UgXCJodW1hblNoaXBcIjpcclxuICAgICAgICAgICAgICAgIHNoaXBMaXZlcy0tO1xyXG4gICAgICAgICAgICAgICAgY3VycmVudFNjb3JlIC09IDUwO1xyXG4gICAgICAgICAgICAgICAgdXBkYXRlQ291bnRlcignc2NvcmUnKTtcclxuICAgICAgICAgICAgICAgIHVwZGF0ZUNvdW50ZXIoJ2xpZmUnKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGNhc2UgXCJlbmVteVwiOlxyXG4gICAgICAgICAgICAgICAgY3VycmVudFNjb3JlICs9IDUwO1xyXG4gICAgICAgICAgICAgICAgdXBkYXRlQ291bnRlcignc2NvcmUnKTtcclxuICAgICAgICAgICAgICAgIGxldmVsRW5lbWllcy0tO1xyXG4gICAgICAgICAgICAgICAgZW5lbWllc0tpbGxlZCsrO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgY2FzZSBcImxpZmVcIjpcclxuICAgICAgICAgICAgICAgIHNoaXBMaXZlcysrO1xyXG4gICAgICAgICAgICAgICAgdXBkYXRlQ291bnRlcignbGlmZScpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgY2FzZSBcInNoaWVsZFwiOlxyXG4gICAgICAgICAgICAgICAgcGxheWVyU2hpcC5zaGllbGQucmVzZXQoKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwiY2FzaFwiOlxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgfVxyXG4gICAgXHJcblx0Ly9oYW5kbGVzIHRoZSBtb3VzZW1vdmUgaW50ZXJhY3Rpb24gYXQgdGl0bGUgc2NyZWVuLlxyXG5cdGZ1bmN0aW9uIG9uTW91c2VNb3ZlKGV2ZW50KXtcclxuICAgICAgICBcclxuXHRcdGlmKHN0YXRlLkNVUlJFTlQgIT0gc3RhdGUuVElUTEVfU0NSRUVOKXtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuXHRcdGlmICggZXZlbnQubGF5ZXJYIHx8ICBldmVudC5sYXllclggPT0gMCkgeyAvLyBGaXJlZm94XHJcbiAgIFx0XHRcdG1vdXNlLnggPSBldmVudC5sYXllclggO1xyXG4gICAgXHRcdG1vdXNlLnkgPSBldmVudC5sYXllclk7XHJcbiAgXHRcdH0gZWxzZSBpZiAoZXZlbnQub2Zmc2V0WCB8fCBldmVudC5vZmZzZXRYID09IDApIHsgLy8gT3BlcmFcclxuICAgIFx0XHRtb3VzZS54ID0gZXZlbnQub2Zmc2V0WDtcclxuICAgIFx0XHRtb3VzZS55ID0gZXZlbnQub2Zmc2V0WTtcclxuICBcdFx0fVxyXG5cdFx0XHJcblx0fVxyXG5cdFxyXG5cdC8vQ2hlY2tzIGZvciBkZXZpY2Ugb3JpZW50YXRpb25cclxuXHRmdW5jdGlvbiBvbk9yaWVudGF0aW9uQ2hhbmdlKGUpe1xyXG5cclxuXHRcdGlmKHdpbmRvdy5pbm5lckhlaWdodD49IHdpbmRvdy5pbm5lcldpZHRoKXtcclxuXHRcdFx0dXNlckFnZW50LnBvcnRyYWl0ID0gdHJ1ZTtcclxuXHRcdFx0b3JpZW50YXRpb25NZXNzYWdlSG9sZGVyLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCAnZGlzcGxheTogYmxvY2s7Jyk7XHJcblx0XHRcdGNhbnZhc0hvbGRlci5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgJ2Rpc3BsYXk6bm9uZTsnKTtcclxuICAgICAgICAgICAgaW50ZXJmYWNlV3JhcHBlci5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgJ2Rpc3BsYXk6IG5vbmU7Jyk7XHJcblx0XHR9ZWxzZSBpZih3aW5kb3cuaW5uZXJIZWlnaHQ8PXdpbmRvdy5pbm5lcldpZHRoKXtcclxuXHRcdFx0b3JpZW50YXRpb25NZXNzYWdlSG9sZGVyLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCAnJyk7XHJcblx0XHRcdGNhbnZhc0hvbGRlci5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgJycpO1xyXG4gICAgICAgICAgICBpbnRlcmZhY2VXcmFwcGVyLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCAnJyk7XHJcblx0XHRcdHVzZXJBZ2VudC5wb3J0cmFpdCA9IGZhbHNlO1xyXG5cdFx0fVxyXG5cdFx0XHJcblx0fVxyXG5cdFxyXG5cdC8vcmVtb3ZlcyB0aGUgZGVmYXVsdCBiZWhhdmlvciBvZiBwaW5jaGluZyB6b29tIG9uIE1vYmlsZVxyXG5cdGZ1bmN0aW9uIG9uVG91Y2hNb3ZlKGUpe1xyXG5cdFx0XHJcblx0XHRlLnByZXZlbnREZWZhdWx0KCk7XHJcblx0fVxyXG5cclxuXHQvL0ZyYW1SYXRlIENsYXNzXHJcblx0XHJcblx0ZnVuY3Rpb24gRnJhbWVSYXRlQ291bnRlcigpIHtcclxuXHJcbiAgICAgICAgdGhpcy5sYXN0RnJhbWVDb3VudCA9IDA7XHJcbiAgICAgICAgdmFyIGRhdGVUZW1wID0gbmV3IERhdGUoKTtcclxuICAgICAgICB0aGlzLmZyYW1lTGFzdCA9IGRhdGVUZW1wLmdldFRpbWUoKTtcclxuICAgICAgICBkZWxldGUgZGF0ZVRlbXA7XHJcbiAgICAgICAgdGhpcy5mcmFtZUN0ciA9IDA7XHJcbiAgICB9XHJcblxyXG4gICAgRnJhbWVSYXRlQ291bnRlci5wcm90b3R5cGUuY291bnRGcmFtZXM9ZnVuY3Rpb24oKSB7XHJcbiAgICAgICB2YXIgZGF0ZVRlbXAgPSBuZXcgRGF0ZSgpO1xyXG4gICAgICAgdGhpcy5mcmFtZUN0cisrO1xyXG5cclxuICAgICAgIGlmIChkYXRlVGVtcC5nZXRUaW1lKCkgPj10aGlzLmZyYW1lTGFzdCsxMDAwKSB7XHJcbiAgICAgICAgICAvL0NvbnNvbGVMb2cubG9nKFwiZnJhbWUgZXZlbnRcIik7XHJcbiAgICAgICAgICB0aGlzLmxhc3RGcmFtZUNvdW50ID0gdGhpcy5mcmFtZUN0cjtcclxuICAgICAgICAgIHRoaXMuZnJhbWVMYXN0ID0gZGF0ZVRlbXAuZ2V0VGltZSgpO1xyXG4gICAgICAgICAgdGhpcy5mcmFtZUN0ciA9IDA7XHJcbiAgICAgICB9XHJcblxyXG4gICAgICAgZGVsZXRlIGRhdGVUZW1wO1xyXG4gICAgfVxyXG5cclxufVxyXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vanMvbWFpbi5qc1xuICoqIG1vZHVsZSBpZCA9IDBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBIb3dsID0gcmVxdWlyZSgnaG93bGVyJykuSG93bDtcclxudmFyIFB1YlN1YiA9IHJlcXVpcmUoJy4vUHViU3ViJyk7XHJcblxyXG5cclxudmFyIFJlc291cmNlTG9hZGVyID0gKGZ1bmN0aW9uKCl7XHJcblx0XHJcblx0dmFyIHRvdGFsQXNzZXRzID0gMCxcclxuXHRcdGxvYWRlZEFzc2V0cyA9IDAsXHJcblx0XHRhc3NldHNEb3dubG9hZGVkID0gZmFsc2UsXHJcblx0XHRVc2VyT3B0aW9ucyxcclxuXHRcdHBlcmNlbnRhZ2VMb2FkZWQsXHJcblx0XHRhdWRpb1N1cHBvcnQsXHJcblx0XHRhc3NldHMgPSB7fTtcclxuXHRcclxuXHRcdC8vZGVmYXVsdCBvcHRpb25zIGlmIG5vIG9wdGlvbiBhcmd1bWVudCBpcyBwYXNzZWQgYnkgdXNlci5cclxuXHRcdHZhciBkZWZhdWx0T3B0aW9ucyA9IHtcclxuXHRcdFx0XHRcdCAgb25sb2FkOiBmdW5jdGlvbigpeyBcclxuXHRcdFx0XHRcdFx0Y29uc29sZS5sb2coJ05vIGNhbGxiYWNrIHdhcyBwYXNzZWQgaW4uLicpO1xyXG5cdFx0XHRcdFx0XHR9LFxyXG5cdFx0XHRcdFx0ICBmaW5hbCA6IGZ1bmN0aW9uKCl7XHJcblx0XHRcdFx0XHRcdCAgY29uc29sZS5sb2coJ05vIGZpbmFsIGZ1bmN0aW9uIHRvIGNhbGwgd2FzIHBhc3NlZCBpbi4uJyk7XHJcblx0XHRcdFx0XHQgIH0sXHJcblx0XHRcdFx0XHQgYXNzZXRzIDogW11cclxuXHRcdFx0XHRcdCB9O1xyXG5cdFxyXG5cdC8qIEV4YW1wbGUgb2Ygb3B0aW9uczpcclxuXHRcclxuXHR7XHJcblx0XHRhc3NldHMgOiB7XHJcblx0XHRcclxuXHRcdFx0aW1ncyA6IHtcclxuXHRcdFx0XHQvL2ltZyBuYW1lcyB3aXRoIFVSTHNcclxuXHRcdFx0XHRiZ19ibGFjayA6IFwiYXNzZXRzL2ltZy9iYWNrZ3JvdW5kLnBuZyxcclxuXHRcdFx0XHRtZXRlb3JTcHJpdGUgOiBcImFzc2V0cy9pbWcvbWV0ZW9yLnBuZyxcclxuXHRcdFx0XHRlbmVtaWVzU3ByaXRlIDogXCJhc3NldHMvaW1nL2VuZW1pZXMucG5nLFxyXG5cdFx0XHRcdGVuZW15U2hpcFNwcml0ZXM6IFwiYXNzZXRzL2ltZy9lbmVteVNoaXBzLnBuZ1xyXG5cdFx0XHR9LFxyXG5cdFx0XHRzb3VuZHMgOiB7XHJcblx0XHRcdFx0Ly9zb3VuZHMgbmFtZSB3aXRoIFVSTHNcclxuXHRcdFx0XHRzb3VuZHRyYWNrIDogW1wiYXNzZXRzL3NvdW5kcy9wbGF5ZXIubXAzXCIsIFwiYXNzZXRzL3NvdW5kcy9wbGF5ZXIud2F2XCJdLFxyXG5cdFx0XHRcdGVuZFNvdW5kIDogW1wiYXNzZXRzL3NvdW5kcy9nYW1lb3Zlci5tcDNcIiwgXCJhc3NldHMvc291bmRzL2dhbWVvdmVyLndhdlwiXVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcbiAgICAgICAgdXNlSG93bCA6IGZhbHNlLFxyXG5cdFx0XHQvL2Z1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIG9uIGV2ZXJ5IGl0ZW0gbG9hZGVkXHJcblx0XHRvbmxvYWQgOiB1cGRhdGVMb2FkZXJEaXNwbGF5ZXIsXHJcblx0XHRcdC8vZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgb25jZSBhbGwgaGF2ZSBsb2FkZWRcclxuXHRcdGZpbmFsIDogZmluYWxGdW5jdGlvblRvQ2FsbFxyXG5cdH1cclxuXHJcblx0Ki9cclxuXHRcdFxyXG5cdGZ1bmN0aW9uIGluaXQob3B0aW9ucyl7XHJcblx0XHRVc2VyT3B0aW9ucyA9IG9wdGlvbnMgfHwgZGVmYXVsdE9wdGlvbnM7XHJcblx0fVxyXG5cdFxyXG5cdGZ1bmN0aW9uIGRvd25sb2FkKCl7XHJcblx0XHRcclxuXHRcdC8vcmV0dXJuIGlmIGFsbCBhc3NldHMgaGF2ZSBhbHJlYWR5IGxvYWRlZCBhbmQgaW5kZXhlZC5cclxuXHRcdGlmKGFzc2V0c0Rvd25sb2FkZWQpIHJldHVybjtcclxuICAgICAgICBcclxuICAgICAgICBQdWJTdWIucHVibGlzaCgnc3RhdGVjaGFuZ2UnLCB7ZnJvbTogc3RhdGUuSU5JVCwgdG86IHN0YXRlLkxPQURJTkd9KTtcclxuXHRcdFxyXG5cdFx0Ly9zZXRzIHRvIHRydWUgc28gdGhpcyBtZXRob2QgKGRvd25sb2FkQWxsKCkpIGlzIGNhbGxlZCBvbmx5IG9uY2VkLlxyXG5cdFx0YXNzZXRzRG93bmxvYWRlZCA9IHRydWU7XHJcblx0XHQvL2NyZWF0ZXMgdGhlIHNvdW5kIGFuZCBpbWFnZSBlbGVtZW50cyBmb3IgZWFjaCBhc3NldCBpbiB0aGUgb3B0aW9ucyBhcmd1bWVudC5cclxuXHRcdGZvcih2YXIgaXRlbSBpbiBVc2VyT3B0aW9ucy5hc3NldHMuaW1ncyl7XHJcblx0XHRcdGFzc2V0c1tpdGVtXSA9IG5ldyBJbWFnZSgpO1xyXG5cdFx0XHRhc3NldHNbaXRlbV0uc3JjID0gVXNlck9wdGlvbnMuYXNzZXRzLmltZ3NbaXRlbV07XHJcblx0XHRcdGFzc2V0c1tpdGVtXS5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgb25Mb2FkLCBmYWxzZSk7XHJcblx0XHRcdHRvdGFsQXNzZXRzKys7XHJcblx0XHR9XHJcblx0XHQvL2FycmF5cyBhcmUgcGFzc2VkIGZvciBlYWNoIHNvdW5kIGFzc2V0IGNvbnRhaW5pbmcgdGhlIHNvdXJjZSB0byB0aGUgc291bmQuXHJcbiAgICAgICAgaWYoIVVzZXJPcHRpb25zLnVzZUhvd2wpe1xyXG4gICAgICAgICAgICBmb3IodmFyIGl0ZW0gaW4gVXNlck9wdGlvbnMuYXNzZXRzLnNvdW5kcyl7XHJcbiAgICAgICAgICAgICAgICBmb3IodmFyIGk9MCwgaj1Vc2VyT3B0aW9ucy5hc3NldHMuc291bmRzW2l0ZW1dLmxlbmd0aDsgaTxqOyBpKyspe1xyXG4gICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRTb3VuZCA9IFVzZXJPcHRpb25zLmFzc2V0cy5zb3VuZHNbaXRlbV1baV07XHJcbiAgICAgICAgICAgICAgICAgICAgLy9hbmFseXplcyB0aGUgZXh0ZW5zaW9uIGFuZCBwaWNrcyB0aGUgZmlyc3Qgb25lIHRoYXQgaXMgc3VwcG9ydGVkIGJ5IHRoZSBicm93c2VyLlxyXG4gICAgICAgICAgICAgICAgICAgIGlmKGlzQXVkaW9TdXBwb3J0KGN1cnJlbnRTb3VuZC5zbGljZSgtMykpKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXRzW2l0ZW1dID0gbmV3IEF1ZGlvKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzc2V0c1tpdGVtXS5zcmMgPSBVc2VyT3B0aW9ucy5hc3NldHMuc291bmRzW2l0ZW1dW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhc3NldHNbaXRlbV0uYWRkRXZlbnRMaXN0ZW5lcignY2FucGxheXRocm91Z2gnLCBvbkxvYWQsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdG90YWxBc3NldHMrKztcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICAvL2NyZWF0ZXMgaG93bCBpbnN0YW5jZSBhbmQgcGFzc2VzIGluIGhvd2wgb3B0aW9ucyBnaXZlbiBieSB0aGUgdXNlci5cclxuICAgICAgICAgICAgZm9yKHZhciBpdGVtIGluIFVzZXJPcHRpb25zLmFzc2V0cy5zb3VuZHMpe1xyXG4gICAgICAgICAgICAgICAgdmFyIGhvd2xPcHRpb25zID0gVXNlck9wdGlvbnMuYXNzZXRzLnNvdW5kc1tpdGVtXTtcclxuICAgICAgICAgICAgICAgIGhvd2xPcHRpb25zLm9ubG9hZCA9IG9uTG9hZDtcclxuICAgICAgICAgICAgICAgIGFzc2V0c1tpdGVtXSA9IG5ldyBIb3dsKGhvd2xPcHRpb25zKTsgXHJcbiAgICAgICAgICAgICAgICB0b3RhbEFzc2V0cysrO1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblx0XHRcclxuXHR9XHJcblx0XHJcblx0ZnVuY3Rpb24gb25Mb2FkKGl0ZW0pe1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vaW5jcmVtZW50cyBsb2FkIGNvdW50IGFuZCByZW1vdmUgbGlzdGVuZXJzLlxyXG5cdFx0bG9hZGVkQXNzZXRzKys7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIGl0ZW1Mb2FkZWQ7XHJcblxyXG4gICAgICAgIGlmKGl0ZW0pe1xyXG4gICAgICAgICAgICBpZihpdGVtLnRhcmdldC50YWdOYW1lID09PSBcIkFVRElPXCIpe1xyXG4gICAgICAgICAgICAgICAgaXRlbUxvYWRlZCA9IGl0ZW0udGFyZ2V0O1xyXG4gICAgICAgICAgICAgICAgaXRlbS50YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2FucGxheXRocm91Z2gnLCBvbkxvYWQsIGZhbHNlKTtcclxuICAgICAgICAgICAgfWVsc2UgaWYgKGl0ZW0udGFyZ2V0LnRhZ05hbWUgPT09IFwiSU1HXCIpe1xyXG4gICAgICAgICAgICAgICAgaXRlbUxvYWRlZCA9IGl0ZW0udGFyZ2V0O1xyXG4gICAgICAgICAgICAgICAgaXRlbS50YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbG9hZCcsIG9uTG9hZCwgZmFsc2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgIGl0ZW1Mb2FkZWQgPSB7bmFtZTogXCJIb3dsIHNvdW5kXCIsIHNyYzogXCJIb3dsIHNvdW5kIGNoZWNrIHNvdW5kXCJ9OyAgIFxyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuXHRcdC8vY2FsY3VsYXRlcyB0aGUgZGVjaW1hbCB2YWx1ZSBmcm9tIHJhdGlvXHJcblx0XHRwZXJjZW50YWdlTG9hZGVkID0gTWF0aC5mbG9vcigobG9hZGVkQXNzZXRzIC8gdG90YWxBc3NldHMpKjEwMCkvMTAwO1xyXG5cdFx0XHJcblx0XHQvL2NhbGwgdGhlIGFwcHJvcHJpYXRlIGNhbGxiYWNrIGZ1bmN0aW9uIGdpdmVuIHRoZSBhbW1vdW50IG9mIGFzc2V0cyBsb2FkZWQuXHJcblx0XHRpZihVc2VyT3B0aW9ucy5vbmxvYWQpe1xyXG5cdFx0XHRVc2VyT3B0aW9ucy5vbmxvYWQoaXRlbUxvYWRlZCk7XHJcblx0XHR9XHJcblx0XHRpZihsb2FkZWRBc3NldHMgPj0gdG90YWxBc3NldHMgJiYgVXNlck9wdGlvbnMuZmluYWwpe1xyXG5cdFx0XHRVc2VyT3B0aW9ucy5maW5hbChpdGVtTG9hZGVkKTtcclxuXHRcdH1cclxuXHRcdFxyXG5cdH1cclxuXHRcclxuXHQvL2dldHMgdGhlIGFwcHJvcHJpYXRlIHN1cHBvcnRlZCBhdWRpbyBmb3JtYXQuXHJcblx0ZnVuY3Rpb24gaXNBdWRpb1N1cHBvcnQoZXh0ZW5zaW9uKXtcclxuXHRcdFxyXG5cdFx0dmFyIGF1ZGlvID0gbmV3IEF1ZGlvKCk7XHJcblx0XHR2YXIgc3VwcG9ydFZhbHVlID0gYXVkaW8uY2FuUGxheVR5cGUoXCJhdWRpby9cIitleHRlbnNpb24pO1xyXG5cdFx0aWYoIHN1cHBvcnRWYWx1ZSA9PT0gXCJtYXliZVwiIHx8IHN1cHBvcnRWYWx1ZSA9PT0gXCJwcm9iYWJseVwiICl7XHJcblx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0fWVsc2V7XHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdH1cclxuXHR9XHJcblx0XHJcblx0cmV0dXJuIHtcclxuXHRcdGluaXQgOiBpbml0LFxyXG5cdFx0YXNzZXRzIDogYXNzZXRzLFxyXG5cdFx0Z2V0IGxvYWRlZCgpe1xyXG5cdFx0XHRyZXR1cm4gcGVyY2VudGFnZUxvYWRlZDtcclxuXHRcdH0sXHJcbiAgICBcdGRvd25sb2FkQWxsIDogZG93bmxvYWRcclxuXHR9XHJcblx0XHJcbn0pKCk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJlc291cmNlTG9hZGVyO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9qcy9SZXNvdXJjZUxvYWRlci5qc1xuICoqIG1vZHVsZSBpZCA9IDFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qIVxuICogIGhvd2xlci5qcyB2Mi4wLjBcbiAqICBob3dsZXJqcy5jb21cbiAqXG4gKiAgKGMpIDIwMTMtMjAxNiwgSmFtZXMgU2ltcHNvbiBvZiBHb2xkRmlyZSBTdHVkaW9zXG4gKiAgZ29sZGZpcmVzdHVkaW9zLmNvbVxuICpcbiAqICBNSVQgTGljZW5zZVxuICovXG5cbihmdW5jdGlvbigpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgLyoqIEdsb2JhbCBNZXRob2RzICoqL1xuICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgdGhlIGdsb2JhbCBjb250cm9sbGVyLiBBbGwgY29udGFpbmVkIG1ldGhvZHMgYW5kIHByb3BlcnRpZXMgYXBwbHlcbiAgICogdG8gYWxsIHNvdW5kcyB0aGF0IGFyZSBjdXJyZW50bHkgcGxheWluZyBvciB3aWxsIGJlIGluIHRoZSBmdXR1cmUuXG4gICAqL1xuICB2YXIgSG93bGVyR2xvYmFsID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5pbml0KCk7XG4gIH07XG4gIEhvd2xlckdsb2JhbC5wcm90b3R5cGUgPSB7XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSB0aGUgZ2xvYmFsIEhvd2xlciBvYmplY3QuXG4gICAgICogQHJldHVybiB7SG93bGVyfVxuICAgICAqL1xuICAgIGluaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzIHx8IEhvd2xlcjtcblxuICAgICAgLy8gSW50ZXJuYWwgcHJvcGVydGllcy5cbiAgICAgIHNlbGYuX2NvZGVjcyA9IHt9O1xuICAgICAgc2VsZi5faG93bHMgPSBbXTtcbiAgICAgIHNlbGYuX211dGVkID0gZmFsc2U7XG4gICAgICBzZWxmLl92b2x1bWUgPSAxO1xuICAgICAgc2VsZi5fY2FuUGxheUV2ZW50ID0gJ2NhbnBsYXl0aHJvdWdoJztcbiAgICAgIHNlbGYuX25hdmlnYXRvciA9ICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cubmF2aWdhdG9yKSA/IHdpbmRvdy5uYXZpZ2F0b3IgOiBudWxsO1xuXG4gICAgICAvLyBQdWJsaWMgcHJvcGVydGllcy5cbiAgICAgIHNlbGYubWFzdGVyR2FpbiA9IG51bGw7XG4gICAgICBzZWxmLm5vQXVkaW8gPSBmYWxzZTtcbiAgICAgIHNlbGYudXNpbmdXZWJBdWRpbyA9IHRydWU7XG4gICAgICBzZWxmLmF1dG9TdXNwZW5kID0gdHJ1ZTtcbiAgICAgIHNlbGYuY3R4ID0gbnVsbDtcblxuICAgICAgLy8gU2V0IHRvIGZhbHNlIHRvIGRpc2FibGUgdGhlIGF1dG8gaU9TIGVuYWJsZXIuXG4gICAgICBzZWxmLm1vYmlsZUF1dG9FbmFibGUgPSB0cnVlO1xuXG4gICAgICAvLyBTZXR1cCB0aGUgdmFyaW91cyBzdGF0ZSB2YWx1ZXMgZm9yIGdsb2JhbCB0cmFja2luZy5cbiAgICAgIHNlbGYuX3NldHVwKCk7XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQvc2V0IHRoZSBnbG9iYWwgdm9sdW1lIGZvciBhbGwgc291bmRzLlxuICAgICAqIEBwYXJhbSAge0Zsb2F0fSB2b2wgVm9sdW1lIGZyb20gMC4wIHRvIDEuMC5cbiAgICAgKiBAcmV0dXJuIHtIb3dsZXIvRmxvYXR9ICAgICBSZXR1cm5zIHNlbGYgb3IgY3VycmVudCB2b2x1bWUuXG4gICAgICovXG4gICAgdm9sdW1lOiBmdW5jdGlvbih2b2wpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcyB8fCBIb3dsZXI7XG4gICAgICB2b2wgPSBwYXJzZUZsb2F0KHZvbCk7XG5cbiAgICAgIC8vIElmIHdlIGRvbid0IGhhdmUgYW4gQXVkaW9Db250ZXh0IGNyZWF0ZWQgeWV0LCBydW4gdGhlIHNldHVwLlxuICAgICAgaWYgKCFzZWxmLmN0eCkge1xuICAgICAgICBzZXR1cEF1ZGlvQ29udGV4dCgpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIHZvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgdm9sID49IDAgJiYgdm9sIDw9IDEpIHtcbiAgICAgICAgc2VsZi5fdm9sdW1lID0gdm9sO1xuXG4gICAgICAgIC8vIERvbid0IHVwZGF0ZSBhbnkgb2YgdGhlIG5vZGVzIGlmIHdlIGFyZSBtdXRlZC5cbiAgICAgICAgaWYgKHNlbGYuX211dGVkKSB7XG4gICAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBXaGVuIHVzaW5nIFdlYiBBdWRpbywgd2UganVzdCBuZWVkIHRvIGFkanVzdCB0aGUgbWFzdGVyIGdhaW4uXG4gICAgICAgIGlmIChzZWxmLnVzaW5nV2ViQXVkaW8pIHtcbiAgICAgICAgICBzZWxmLm1hc3RlckdhaW4uZ2Fpbi52YWx1ZSA9IHZvbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIExvb3AgdGhyb3VnaCBhbmQgY2hhbmdlIHZvbHVtZSBmb3IgYWxsIEhUTUw1IGF1ZGlvIG5vZGVzLlxuICAgICAgICBmb3IgKHZhciBpPTA7IGk8c2VsZi5faG93bHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAoIXNlbGYuX2hvd2xzW2ldLl93ZWJBdWRpbykge1xuICAgICAgICAgICAgLy8gR2V0IGFsbCBvZiB0aGUgc291bmRzIGluIHRoaXMgSG93bCBncm91cC5cbiAgICAgICAgICAgIHZhciBpZHMgPSBzZWxmLl9ob3dsc1tpXS5fZ2V0U291bmRJZHMoKTtcblxuICAgICAgICAgICAgLy8gTG9vcCB0aHJvdWdoIGFsbCBzb3VuZHMgYW5kIGNoYW5nZSB0aGUgdm9sdW1lcy5cbiAgICAgICAgICAgIGZvciAodmFyIGo9MDsgajxpZHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgdmFyIHNvdW5kID0gc2VsZi5faG93bHNbaV0uX3NvdW5kQnlJZChpZHNbal0pO1xuXG4gICAgICAgICAgICAgIGlmIChzb3VuZCAmJiBzb3VuZC5fbm9kZSkge1xuICAgICAgICAgICAgICAgIHNvdW5kLl9ub2RlLnZvbHVtZSA9IHNvdW5kLl92b2x1bWUgKiB2b2w7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGYuX3ZvbHVtZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSGFuZGxlIG11dGluZyBhbmQgdW5tdXRpbmcgZ2xvYmFsbHkuXG4gICAgICogQHBhcmFtICB7Qm9vbGVhbn0gbXV0ZWQgSXMgbXV0ZWQgb3Igbm90LlxuICAgICAqL1xuICAgIG11dGU6IGZ1bmN0aW9uKG11dGVkKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXMgfHwgSG93bGVyO1xuXG4gICAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGFuIEF1ZGlvQ29udGV4dCBjcmVhdGVkIHlldCwgcnVuIHRoZSBzZXR1cC5cbiAgICAgIGlmICghc2VsZi5jdHgpIHtcbiAgICAgICAgc2V0dXBBdWRpb0NvbnRleHQoKTtcbiAgICAgIH1cblxuICAgICAgc2VsZi5fbXV0ZWQgPSBtdXRlZDtcblxuICAgICAgLy8gV2l0aCBXZWIgQXVkaW8sIHdlIGp1c3QgbmVlZCB0byBtdXRlIHRoZSBtYXN0ZXIgZ2Fpbi5cbiAgICAgIGlmIChzZWxmLnVzaW5nV2ViQXVkaW8pIHtcbiAgICAgICAgc2VsZi5tYXN0ZXJHYWluLmdhaW4udmFsdWUgPSBtdXRlZCA/IDAgOiBzZWxmLl92b2x1bWU7XG4gICAgICB9XG5cbiAgICAgIC8vIExvb3AgdGhyb3VnaCBhbmQgbXV0ZSBhbGwgSFRNTDUgQXVkaW8gbm9kZXMuXG4gICAgICBmb3IgKHZhciBpPTA7IGk8c2VsZi5faG93bHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKCFzZWxmLl9ob3dsc1tpXS5fd2ViQXVkaW8pIHtcbiAgICAgICAgICAvLyBHZXQgYWxsIG9mIHRoZSBzb3VuZHMgaW4gdGhpcyBIb3dsIGdyb3VwLlxuICAgICAgICAgIHZhciBpZHMgPSBzZWxmLl9ob3dsc1tpXS5fZ2V0U291bmRJZHMoKTtcblxuICAgICAgICAgIC8vIExvb3AgdGhyb3VnaCBhbGwgc291bmRzIGFuZCBtYXJrIHRoZSBhdWRpbyBub2RlIGFzIG11dGVkLlxuICAgICAgICAgIGZvciAodmFyIGo9MDsgajxpZHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIHZhciBzb3VuZCA9IHNlbGYuX2hvd2xzW2ldLl9zb3VuZEJ5SWQoaWRzW2pdKTtcblxuICAgICAgICAgICAgaWYgKHNvdW5kICYmIHNvdW5kLl9ub2RlKSB7XG4gICAgICAgICAgICAgIHNvdW5kLl9ub2RlLm11dGVkID0gKG11dGVkKSA/IHRydWUgOiBzb3VuZC5fbXV0ZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVbmxvYWQgYW5kIGRlc3Ryb3kgYWxsIGN1cnJlbnRseSBsb2FkZWQgSG93bCBvYmplY3RzLlxuICAgICAqIEByZXR1cm4ge0hvd2xlcn1cbiAgICAgKi9cbiAgICB1bmxvYWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzIHx8IEhvd2xlcjtcblxuICAgICAgZm9yICh2YXIgaT1zZWxmLl9ob3dscy5sZW5ndGgtMTsgaT49MDsgaS0tKSB7XG4gICAgICAgIHNlbGYuX2hvd2xzW2ldLnVubG9hZCgpO1xuICAgICAgfVxuXG4gICAgICAvLyBDcmVhdGUgYSBuZXcgQXVkaW9Db250ZXh0IHRvIG1ha2Ugc3VyZSBpdCBpcyBmdWxseSByZXNldC5cbiAgICAgIGlmIChzZWxmLnVzaW5nV2ViQXVkaW8gJiYgdHlwZW9mIHNlbGYuY3R4LmNsb3NlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBzZWxmLmN0eC5jbG9zZSgpO1xuICAgICAgICBzZWxmLmN0eCA9IG51bGw7XG4gICAgICAgIHNldHVwQXVkaW9Db250ZXh0KCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBmb3IgY29kZWMgc3VwcG9ydCBvZiBzcGVjaWZpYyBleHRlbnNpb24uXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBleHQgQXVkaW8gZmlsZSBleHRlbnRpb24uXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBjb2RlY3M6IGZ1bmN0aW9uKGV4dCkge1xuICAgICAgcmV0dXJuICh0aGlzIHx8IEhvd2xlcikuX2NvZGVjc1tleHRdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXR1cCB2YXJpb3VzIHN0YXRlIHZhbHVlcyBmb3IgZ2xvYmFsIHRyYWNraW5nLlxuICAgICAqIEByZXR1cm4ge0hvd2xlcn1cbiAgICAgKi9cbiAgICBfc2V0dXA6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzIHx8IEhvd2xlcjtcblxuICAgICAgLy8gS2VlcHMgdHJhY2sgb2YgdGhlIHN1c3BlbmQvcmVzdW1lIHN0YXRlIG9mIHRoZSBBdWRpb0NvbnRleHQuXG4gICAgICBzZWxmLnN0YXRlID0gc2VsZi5jdHggPyBzZWxmLmN0eC5zdGF0ZSB8fCAncnVubmluZycgOiAncnVubmluZyc7XG5cbiAgICAgIC8vIEF1dG9tYXRpY2FsbHkgYmVnaW4gdGhlIDMwLXNlY29uZCBzdXNwZW5kIHByb2Nlc3NcbiAgICAgIHNlbGYuX2F1dG9TdXNwZW5kKCk7XG5cbiAgICAgIC8vIENoZWNrIGZvciBzdXBwb3J0ZWQgY29kZWNzLlxuICAgICAgaWYgKCFzZWxmLm5vQXVkaW8pIHtcbiAgICAgICAgc2VsZi5fc2V0dXBDb2RlY3MoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrIGZvciBicm93c2VyIHN1cHBvcnQgZm9yIHZhcmlvdXMgY29kZWNzIGFuZCBjYWNoZSB0aGUgcmVzdWx0cy5cbiAgICAgKiBAcmV0dXJuIHtIb3dsZXJ9XG4gICAgICovXG4gICAgX3NldHVwQ29kZWNzOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcyB8fCBIb3dsZXI7XG4gICAgICB2YXIgYXVkaW9UZXN0ID0gKHR5cGVvZiBBdWRpbyAhPT0gJ3VuZGVmaW5lZCcpID8gbmV3IEF1ZGlvKCkgOiBudWxsO1xuXG4gICAgICBpZiAoIWF1ZGlvVGVzdCB8fCB0eXBlb2YgYXVkaW9UZXN0LmNhblBsYXlUeXBlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgfVxuXG4gICAgICB2YXIgbXBlZ1Rlc3QgPSBhdWRpb1Rlc3QuY2FuUGxheVR5cGUoJ2F1ZGlvL21wZWc7JykucmVwbGFjZSgvXm5vJC8sICcnKTtcblxuICAgICAgLy8gT3BlcmEgdmVyc2lvbiA8MzMgaGFzIG1peGVkIE1QMyBzdXBwb3J0LCBzbyB3ZSBuZWVkIHRvIGNoZWNrIGZvciBhbmQgYmxvY2sgaXQuXG4gICAgICB2YXIgY2hlY2tPcGVyYSA9IHNlbGYuX25hdmlnYXRvciAmJiBzZWxmLl9uYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9PUFJcXC8oWzAtNl0uKS9nKTtcbiAgICAgIHZhciBpc09sZE9wZXJhID0gKGNoZWNrT3BlcmEgJiYgcGFyc2VJbnQoY2hlY2tPcGVyYVswXS5zcGxpdCgnLycpWzFdLCAxMCkgPCAzMyk7XG5cbiAgICAgIHNlbGYuX2NvZGVjcyA9IHtcbiAgICAgICAgbXAzOiAhISghaXNPbGRPcGVyYSAmJiAobXBlZ1Rlc3QgfHwgYXVkaW9UZXN0LmNhblBsYXlUeXBlKCdhdWRpby9tcDM7JykucmVwbGFjZSgvXm5vJC8sICcnKSkpLFxuICAgICAgICBtcGVnOiAhIW1wZWdUZXN0LFxuICAgICAgICBvcHVzOiAhIWF1ZGlvVGVzdC5jYW5QbGF5VHlwZSgnYXVkaW8vb2dnOyBjb2RlY3M9XCJvcHVzXCInKS5yZXBsYWNlKC9ebm8kLywgJycpLFxuICAgICAgICBvZ2c6ICEhYXVkaW9UZXN0LmNhblBsYXlUeXBlKCdhdWRpby9vZ2c7IGNvZGVjcz1cInZvcmJpc1wiJykucmVwbGFjZSgvXm5vJC8sICcnKSxcbiAgICAgICAgb2dhOiAhIWF1ZGlvVGVzdC5jYW5QbGF5VHlwZSgnYXVkaW8vb2dnOyBjb2RlY3M9XCJ2b3JiaXNcIicpLnJlcGxhY2UoL15ubyQvLCAnJyksXG4gICAgICAgIHdhdjogISFhdWRpb1Rlc3QuY2FuUGxheVR5cGUoJ2F1ZGlvL3dhdjsgY29kZWNzPVwiMVwiJykucmVwbGFjZSgvXm5vJC8sICcnKSxcbiAgICAgICAgYWFjOiAhIWF1ZGlvVGVzdC5jYW5QbGF5VHlwZSgnYXVkaW8vYWFjOycpLnJlcGxhY2UoL15ubyQvLCAnJyksXG4gICAgICAgIGNhZjogISFhdWRpb1Rlc3QuY2FuUGxheVR5cGUoJ2F1ZGlvL3gtY2FmOycpLnJlcGxhY2UoL15ubyQvLCAnJyksXG4gICAgICAgIG00YTogISEoYXVkaW9UZXN0LmNhblBsYXlUeXBlKCdhdWRpby94LW00YTsnKSB8fCBhdWRpb1Rlc3QuY2FuUGxheVR5cGUoJ2F1ZGlvL200YTsnKSB8fCBhdWRpb1Rlc3QuY2FuUGxheVR5cGUoJ2F1ZGlvL2FhYzsnKSkucmVwbGFjZSgvXm5vJC8sICcnKSxcbiAgICAgICAgbXA0OiAhIShhdWRpb1Rlc3QuY2FuUGxheVR5cGUoJ2F1ZGlvL3gtbXA0OycpIHx8IGF1ZGlvVGVzdC5jYW5QbGF5VHlwZSgnYXVkaW8vbXA0OycpIHx8IGF1ZGlvVGVzdC5jYW5QbGF5VHlwZSgnYXVkaW8vYWFjOycpKS5yZXBsYWNlKC9ebm8kLywgJycpLFxuICAgICAgICB3ZWJhOiAhIWF1ZGlvVGVzdC5jYW5QbGF5VHlwZSgnYXVkaW8vd2VibTsgY29kZWNzPVwidm9yYmlzXCInKS5yZXBsYWNlKC9ebm8kLywgJycpLFxuICAgICAgICB3ZWJtOiAhIWF1ZGlvVGVzdC5jYW5QbGF5VHlwZSgnYXVkaW8vd2VibTsgY29kZWNzPVwidm9yYmlzXCInKS5yZXBsYWNlKC9ebm8kLywgJycpLFxuICAgICAgICBkb2xieTogISFhdWRpb1Rlc3QuY2FuUGxheVR5cGUoJ2F1ZGlvL21wNDsgY29kZWNzPVwiZWMtM1wiJykucmVwbGFjZSgvXm5vJC8sICcnKVxuICAgICAgfTtcblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1vYmlsZSBicm93c2VycyB3aWxsIG9ubHkgYWxsb3cgYXVkaW8gdG8gYmUgcGxheWVkIGFmdGVyIGEgdXNlciBpbnRlcmFjdGlvbi5cbiAgICAgKiBBdHRlbXB0IHRvIGF1dG9tYXRpY2FsbHkgdW5sb2NrIGF1ZGlvIG9uIHRoZSBmaXJzdCB1c2VyIGludGVyYWN0aW9uLlxuICAgICAqIENvbmNlcHQgZnJvbTogaHR0cDovL3BhdWxiYWthdXMuY29tL3R1dG9yaWFscy9odG1sNS93ZWItYXVkaW8tb24taW9zL1xuICAgICAqIEByZXR1cm4ge0hvd2xlcn1cbiAgICAgKi9cbiAgICBfZW5hYmxlTW9iaWxlQXVkaW86IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzIHx8IEhvd2xlcjtcblxuICAgICAgLy8gT25seSBydW4gdGhpcyBvbiBtb2JpbGUgZGV2aWNlcyBpZiBhdWRpbyBpc24ndCBhbHJlYWR5IGVhbmJsZWQuXG4gICAgICB2YXIgaXNNb2JpbGUgPSAvaVBob25lfGlQYWR8aVBvZHxBbmRyb2lkfEJsYWNrQmVycnl8QkIxMHxTaWxrfE1vYmkvaS50ZXN0KHNlbGYuX25hdmlnYXRvciAmJiBzZWxmLl9uYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgICAgIHZhciBpc1RvdWNoID0gISEoKCdvbnRvdWNoZW5kJyBpbiB3aW5kb3cpIHx8IChzZWxmLl9uYXZpZ2F0b3IgJiYgc2VsZi5fbmF2aWdhdG9yLm1heFRvdWNoUG9pbnRzID4gMCkgfHwgKHNlbGYuX25hdmlnYXRvciAmJiBzZWxmLl9uYXZpZ2F0b3IubXNNYXhUb3VjaFBvaW50cyA+IDApKTtcbiAgICAgIGlmIChzZWxmLl9tb2JpbGVFbmFibGVkIHx8ICFzZWxmLmN0eCB8fCAoIWlzTW9iaWxlICYmICFpc1RvdWNoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHNlbGYuX21vYmlsZUVuYWJsZWQgPSBmYWxzZTtcblxuICAgICAgLy8gU29tZSBtb2JpbGUgZGV2aWNlcy9wbGF0Zm9ybXMgaGF2ZSBkaXN0b3J0aW9uIGlzc3VlcyB3aGVuIG9wZW5pbmcvY2xvc2luZyB0YWJzIGFuZC9vciB3ZWIgdmlld3MuXG4gICAgICAvLyBCdWdzIGluIHRoZSBicm93c2VyIChlc3BlY2lhbGx5IE1vYmlsZSBTYWZhcmkpIGNhbiBjYXVzZSB0aGUgc2FtcGxlUmF0ZSB0byBjaGFuZ2UgZnJvbSA0NDEwMCB0byA0ODAwMC5cbiAgICAgIC8vIEJ5IGNhbGxpbmcgSG93bGVyLnVubG9hZCgpLCB3ZSBjcmVhdGUgYSBuZXcgQXVkaW9Db250ZXh0IHdpdGggdGhlIGNvcnJlY3Qgc2FtcGxlUmF0ZS5cbiAgICAgIGlmICghc2VsZi5fbW9iaWxlVW5sb2FkZWQgJiYgc2VsZi5jdHguc2FtcGxlUmF0ZSAhPT0gNDQxMDApIHtcbiAgICAgICAgc2VsZi5fbW9iaWxlVW5sb2FkZWQgPSB0cnVlO1xuICAgICAgICBzZWxmLnVubG9hZCgpO1xuICAgICAgfVxuXG4gICAgICAvLyBTY3JhdGNoIGJ1ZmZlciBmb3IgZW5hYmxpbmcgaU9TIHRvIGRpc3Bvc2Ugb2Ygd2ViIGF1ZGlvIGJ1ZmZlcnMgY29ycmVjdGx5LCBhcyBwZXI6XG4gICAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzI0MTE5Njg0XG4gICAgICBzZWxmLl9zY3JhdGNoQnVmZmVyID0gc2VsZi5jdHguY3JlYXRlQnVmZmVyKDEsIDEsIDIyMDUwKTtcblxuICAgICAgLy8gQ2FsbCB0aGlzIG1ldGhvZCBvbiB0b3VjaCBzdGFydCB0byBjcmVhdGUgYW5kIHBsYXkgYSBidWZmZXIsXG4gICAgICAvLyB0aGVuIGNoZWNrIGlmIHRoZSBhdWRpbyBhY3R1YWxseSBwbGF5ZWQgdG8gZGV0ZXJtaW5lIGlmXG4gICAgICAvLyBhdWRpbyBoYXMgbm93IGJlZW4gdW5sb2NrZWQgb24gaU9TLCBBbmRyb2lkLCBldGMuXG4gICAgICB2YXIgdW5sb2NrID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIENyZWF0ZSBhbiBlbXB0eSBidWZmZXIuXG4gICAgICAgIHZhciBzb3VyY2UgPSBzZWxmLmN0eC5jcmVhdGVCdWZmZXJTb3VyY2UoKTtcbiAgICAgICAgc291cmNlLmJ1ZmZlciA9IHNlbGYuX3NjcmF0Y2hCdWZmZXI7XG4gICAgICAgIHNvdXJjZS5jb25uZWN0KHNlbGYuY3R4LmRlc3RpbmF0aW9uKTtcblxuICAgICAgICAvLyBQbGF5IHRoZSBlbXB0eSBidWZmZXIuXG4gICAgICAgIGlmICh0eXBlb2Ygc291cmNlLnN0YXJ0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHNvdXJjZS5ub3RlT24oMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc291cmNlLnN0YXJ0KDApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2V0dXAgYSB0aW1lb3V0IHRvIGNoZWNrIHRoYXQgd2UgYXJlIHVubG9ja2VkIG9uIHRoZSBuZXh0IGV2ZW50IGxvb3AuXG4gICAgICAgIHNvdXJjZS5vbmVuZGVkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgc291cmNlLmRpc2Nvbm5lY3QoMCk7XG5cbiAgICAgICAgICAvLyBVcGRhdGUgdGhlIHVubG9ja2VkIHN0YXRlIGFuZCBwcmV2ZW50IHRoaXMgY2hlY2sgZnJvbSBoYXBwZW5pbmcgYWdhaW4uXG4gICAgICAgICAgc2VsZi5fbW9iaWxlRW5hYmxlZCA9IHRydWU7XG4gICAgICAgICAgc2VsZi5tb2JpbGVBdXRvRW5hYmxlID0gZmFsc2U7XG5cbiAgICAgICAgICAvLyBSZW1vdmUgdGhlIHRvdWNoIHN0YXJ0IGxpc3RlbmVyLlxuICAgICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdW5sb2NrLCB0cnVlKTtcbiAgICAgICAgfTtcbiAgICAgIH07XG5cbiAgICAgIC8vIFNldHVwIGEgdG91Y2ggc3RhcnQgbGlzdGVuZXIgdG8gYXR0ZW1wdCBhbiB1bmxvY2sgaW4uXG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHVubG9jaywgdHJ1ZSk7XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBdXRvbWF0aWNhbGx5IHN1c3BlbmQgdGhlIFdlYiBBdWRpbyBBdWRpb0NvbnRleHQgYWZ0ZXIgbm8gc291bmQgaGFzIHBsYXllZCBmb3IgMzAgc2Vjb25kcy5cbiAgICAgKiBUaGlzIHNhdmVzIHByb2Nlc3NpbmcvZW5lcmd5IGFuZCBmaXhlcyB2YXJpb3VzIGJyb3dzZXItc3BlY2lmaWMgYnVncyB3aXRoIGF1ZGlvIGdldHRpbmcgc3R1Y2suXG4gICAgICogQHJldHVybiB7SG93bGVyfVxuICAgICAqL1xuICAgIF9hdXRvU3VzcGVuZDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgIGlmICghc2VsZi5hdXRvU3VzcGVuZCB8fCAhc2VsZi5jdHggfHwgdHlwZW9mIHNlbGYuY3R4LnN1c3BlbmQgPT09ICd1bmRlZmluZWQnIHx8ICFIb3dsZXIudXNpbmdXZWJBdWRpbykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIENoZWNrIGlmIGFueSBzb3VuZHMgYXJlIHBsYXlpbmcuXG4gICAgICBmb3IgKHZhciBpPTA7IGk8c2VsZi5faG93bHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHNlbGYuX2hvd2xzW2ldLl93ZWJBdWRpbykge1xuICAgICAgICAgIGZvciAodmFyIGo9MDsgajxzZWxmLl9ob3dsc1tpXS5fc291bmRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBpZiAoIXNlbGYuX2hvd2xzW2ldLl9zb3VuZHNbal0uX3BhdXNlZCkge1xuICAgICAgICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHNlbGYuX3N1c3BlbmRUaW1lcikge1xuICAgICAgICBjbGVhclRpbWVvdXQoc2VsZi5fc3VzcGVuZFRpbWVyKTtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgbm8gc291bmQgaGFzIHBsYXllZCBhZnRlciAzMCBzZWNvbmRzLCBzdXNwZW5kIHRoZSBjb250ZXh0LlxuICAgICAgc2VsZi5fc3VzcGVuZFRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCFzZWxmLmF1dG9TdXNwZW5kKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgc2VsZi5fc3VzcGVuZFRpbWVyID0gbnVsbDtcbiAgICAgICAgc2VsZi5zdGF0ZSA9ICdzdXNwZW5kaW5nJztcbiAgICAgICAgc2VsZi5jdHguc3VzcGVuZCgpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgc2VsZi5zdGF0ZSA9ICdzdXNwZW5kZWQnO1xuXG4gICAgICAgICAgaWYgKHNlbGYuX3Jlc3VtZUFmdGVyU3VzcGVuZCkge1xuICAgICAgICAgICAgZGVsZXRlIHNlbGYuX3Jlc3VtZUFmdGVyU3VzcGVuZDtcbiAgICAgICAgICAgIHNlbGYuX2F1dG9SZXN1bWUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSwgMzAwMDApO1xuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQXV0b21hdGljYWxseSByZXN1bWUgdGhlIFdlYiBBdWRpbyBBdWRpb0NvbnRleHQgd2hlbiBhIG5ldyBzb3VuZCBpcyBwbGF5ZWQuXG4gICAgICogQHJldHVybiB7SG93bGVyfVxuICAgICAqL1xuICAgIF9hdXRvUmVzdW1lOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgaWYgKCFzZWxmLmN0eCB8fCB0eXBlb2Ygc2VsZi5jdHgucmVzdW1lID09PSAndW5kZWZpbmVkJyB8fCAhSG93bGVyLnVzaW5nV2ViQXVkaW8pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2VsZi5zdGF0ZSA9PT0gJ3J1bm5pbmcnICYmIHNlbGYuX3N1c3BlbmRUaW1lcikge1xuICAgICAgICBjbGVhclRpbWVvdXQoc2VsZi5fc3VzcGVuZFRpbWVyKTtcbiAgICAgICAgc2VsZi5fc3VzcGVuZFRpbWVyID0gbnVsbDtcbiAgICAgIH0gZWxzZSBpZiAoc2VsZi5zdGF0ZSA9PT0gJ3N1c3BlbmRlZCcpIHtcbiAgICAgICAgc2VsZi5zdGF0ZSA9ICdyZXN1bWluZyc7XG4gICAgICAgIHNlbGYuY3R4LnJlc3VtZSgpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgc2VsZi5zdGF0ZSA9ICdydW5uaW5nJztcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHNlbGYuX3N1c3BlbmRUaW1lcikge1xuICAgICAgICAgIGNsZWFyVGltZW91dChzZWxmLl9zdXNwZW5kVGltZXIpO1xuICAgICAgICAgIHNlbGYuX3N1c3BlbmRUaW1lciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoc2VsZi5zdGF0ZSA9PT0gJ3N1c3BlbmRpbmcnKSB7XG4gICAgICAgIHNlbGYuX3Jlc3VtZUFmdGVyU3VzcGVuZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cbiAgfTtcblxuICAvLyBTZXR1cCB0aGUgZ2xvYmFsIGF1ZGlvIGNvbnRyb2xsZXIuXG4gIHZhciBIb3dsZXIgPSBuZXcgSG93bGVyR2xvYmFsKCk7XG5cbiAgLyoqIEdyb3VwIE1ldGhvZHMgKiovXG4gIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBhdWRpbyBncm91cCBjb250cm9sbGVyLlxuICAgKiBAcGFyYW0ge09iamVjdH0gbyBQYXNzZWQgaW4gcHJvcGVydGllcyBmb3IgdGhpcyBncm91cC5cbiAgICovXG4gIHZhciBIb3dsID0gZnVuY3Rpb24obykge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIC8vIFRocm93IGFuIGVycm9yIGlmIG5vIHNvdXJjZSBpcyBwcm92aWRlZC5cbiAgICBpZiAoIW8uc3JjIHx8IG8uc3JjLmxlbmd0aCA9PT0gMCkge1xuICAgICAgY29uc29sZS5lcnJvcignQW4gYXJyYXkgb2Ygc291cmNlIGZpbGVzIG11c3QgYmUgcGFzc2VkIHdpdGggYW55IG5ldyBIb3dsLicpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHNlbGYuaW5pdChvKTtcbiAgfTtcbiAgSG93bC5wcm90b3R5cGUgPSB7XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSBhIG5ldyBIb3dsIGdyb3VwIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IG8gUGFzc2VkIGluIHByb3BlcnRpZXMgZm9yIHRoaXMgZ3JvdXAuXG4gICAgICogQHJldHVybiB7SG93bH1cbiAgICAgKi9cbiAgICBpbml0OiBmdW5jdGlvbihvKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgIC8vIElmIHdlIGRvbid0IGhhdmUgYW4gQXVkaW9Db250ZXh0IGNyZWF0ZWQgeWV0LCBydW4gdGhlIHNldHVwLlxuICAgICAgaWYgKCFIb3dsZXIuY3R4KSB7XG4gICAgICAgIHNldHVwQXVkaW9Db250ZXh0KCk7XG4gICAgICB9XG5cbiAgICAgIC8vIFNldHVwIHVzZXItZGVmaW5lZCBkZWZhdWx0IHByb3BlcnRpZXMuXG4gICAgICBzZWxmLl9hdXRvcGxheSA9IG8uYXV0b3BsYXkgfHwgZmFsc2U7XG4gICAgICBzZWxmLl9mb3JtYXQgPSAodHlwZW9mIG8uZm9ybWF0ICE9PSAnc3RyaW5nJykgPyBvLmZvcm1hdCA6IFtvLmZvcm1hdF07XG4gICAgICBzZWxmLl9odG1sNSA9IG8uaHRtbDUgfHwgZmFsc2U7XG4gICAgICBzZWxmLl9tdXRlZCA9IG8ubXV0ZSB8fCBmYWxzZTtcbiAgICAgIHNlbGYuX2xvb3AgPSBvLmxvb3AgfHwgZmFsc2U7XG4gICAgICBzZWxmLl9wb29sID0gby5wb29sIHx8IDU7XG4gICAgICBzZWxmLl9wcmVsb2FkID0gKHR5cGVvZiBvLnByZWxvYWQgPT09ICdib29sZWFuJykgPyBvLnByZWxvYWQgOiB0cnVlO1xuICAgICAgc2VsZi5fcmF0ZSA9IG8ucmF0ZSB8fCAxO1xuICAgICAgc2VsZi5fc3ByaXRlID0gby5zcHJpdGUgfHwge307XG4gICAgICBzZWxmLl9zcmMgPSAodHlwZW9mIG8uc3JjICE9PSAnc3RyaW5nJykgPyBvLnNyYyA6IFtvLnNyY107XG4gICAgICBzZWxmLl92b2x1bWUgPSBvLnZvbHVtZSAhPT0gdW5kZWZpbmVkID8gby52b2x1bWUgOiAxO1xuXG4gICAgICAvLyBTZXR1cCBhbGwgb3RoZXIgZGVmYXVsdCBwcm9wZXJ0aWVzLlxuICAgICAgc2VsZi5fZHVyYXRpb24gPSAwO1xuICAgICAgc2VsZi5fc3RhdGUgPSAndW5sb2FkZWQnO1xuICAgICAgc2VsZi5fc291bmRzID0gW107XG4gICAgICBzZWxmLl9lbmRUaW1lcnMgPSB7fTtcbiAgICAgIHNlbGYuX3F1ZXVlID0gW107XG5cbiAgICAgIC8vIFNldHVwIGV2ZW50IGxpc3RlbmVycy5cbiAgICAgIHNlbGYuX29uZW5kID0gby5vbmVuZCA/IFt7Zm46IG8ub25lbmR9XSA6IFtdO1xuICAgICAgc2VsZi5fb25mYWRlID0gby5vbmZhZGUgPyBbe2ZuOiBvLm9uZmFkZX1dIDogW107XG4gICAgICBzZWxmLl9vbmxvYWQgPSBvLm9ubG9hZCA/IFt7Zm46IG8ub25sb2FkfV0gOiBbXTtcbiAgICAgIHNlbGYuX29ubG9hZGVycm9yID0gby5vbmxvYWRlcnJvciA/IFt7Zm46IG8ub25sb2FkZXJyb3J9XSA6IFtdO1xuICAgICAgc2VsZi5fb25wYXVzZSA9IG8ub25wYXVzZSA/IFt7Zm46IG8ub25wYXVzZX1dIDogW107XG4gICAgICBzZWxmLl9vbnBsYXkgPSBvLm9ucGxheSA/IFt7Zm46IG8ub25wbGF5fV0gOiBbXTtcbiAgICAgIHNlbGYuX29uc3RvcCA9IG8ub25zdG9wID8gW3tmbjogby5vbnN0b3B9XSA6IFtdO1xuICAgICAgc2VsZi5fb25tdXRlID0gby5vbm11dGUgPyBbe2ZuOiBvLm9ubXV0ZX1dIDogW107XG4gICAgICBzZWxmLl9vbnZvbHVtZSA9IG8ub252b2x1bWUgPyBbe2ZuOiBvLm9udm9sdW1lfV0gOiBbXTtcbiAgICAgIHNlbGYuX29ucmF0ZSA9IG8ub25yYXRlID8gW3tmbjogby5vbnJhdGV9XSA6IFtdO1xuICAgICAgc2VsZi5fb25zZWVrID0gby5vbnNlZWsgPyBbe2ZuOiBvLm9uc2Vla31dIDogW107XG5cbiAgICAgIC8vIFdlYiBBdWRpbyBvciBIVE1MNSBBdWRpbz9cbiAgICAgIHNlbGYuX3dlYkF1ZGlvID0gSG93bGVyLnVzaW5nV2ViQXVkaW8gJiYgIXNlbGYuX2h0bWw1O1xuXG4gICAgICAvLyBBdXRvbWF0aWNhbGx5IHRyeSB0byBlbmFibGUgYXVkaW8gb24gaU9TLlxuICAgICAgaWYgKHR5cGVvZiBIb3dsZXIuY3R4ICE9PSAndW5kZWZpbmVkJyAmJiBIb3dsZXIuY3R4ICYmIEhvd2xlci5tb2JpbGVBdXRvRW5hYmxlKSB7XG4gICAgICAgIEhvd2xlci5fZW5hYmxlTW9iaWxlQXVkaW8oKTtcbiAgICAgIH1cblxuICAgICAgLy8gS2VlcCB0cmFjayBvZiB0aGlzIEhvd2wgZ3JvdXAgaW4gdGhlIGdsb2JhbCBjb250cm9sbGVyLlxuICAgICAgSG93bGVyLl9ob3dscy5wdXNoKHNlbGYpO1xuXG4gICAgICAvLyBMb2FkIHRoZSBzb3VyY2UgZmlsZSB1bmxlc3Mgb3RoZXJ3aXNlIHNwZWNpZmllZC5cbiAgICAgIGlmIChzZWxmLl9wcmVsb2FkKSB7XG4gICAgICAgIHNlbGYubG9hZCgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTG9hZCB0aGUgYXVkaW8gZmlsZS5cbiAgICAgKiBAcmV0dXJuIHtIb3dsZXJ9XG4gICAgICovXG4gICAgbG9hZDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgdXJsID0gbnVsbDtcblxuICAgICAgLy8gSWYgbm8gYXVkaW8gaXMgYXZhaWxhYmxlLCBxdWl0IGltbWVkaWF0ZWx5LlxuICAgICAgaWYgKEhvd2xlci5ub0F1ZGlvKSB7XG4gICAgICAgIHNlbGYuX2VtaXQoJ2xvYWRlcnJvcicsIG51bGwsICdObyBhdWRpbyBzdXBwb3J0LicpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIE1ha2Ugc3VyZSBvdXIgc291cmNlIGlzIGluIGFuIGFycmF5LlxuICAgICAgaWYgKHR5cGVvZiBzZWxmLl9zcmMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHNlbGYuX3NyYyA9IFtzZWxmLl9zcmNdO1xuICAgICAgfVxuXG4gICAgICAvLyBMb29wIHRocm91Z2ggdGhlIHNvdXJjZXMgYW5kIHBpY2sgdGhlIGZpcnN0IG9uZSB0aGF0IGlzIGNvbXBhdGlibGUuXG4gICAgICBmb3IgKHZhciBpPTA7IGk8c2VsZi5fc3JjLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBleHQsIHN0cjtcblxuICAgICAgICBpZiAoc2VsZi5fZm9ybWF0ICYmIHNlbGYuX2Zvcm1hdFtpXSkge1xuICAgICAgICAgIC8vIElmIGFuIGV4dGVuc2lvbiB3YXMgc3BlY2lmaWVkLCB1c2UgdGhhdCBpbnN0ZWFkLlxuICAgICAgICAgIGV4dCA9IHNlbGYuX2Zvcm1hdFtpXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIHNvdXJjZSBpcyBhIHN0cmluZy5cbiAgICAgICAgICBzdHIgPSBzZWxmLl9zcmNbaV07XG4gICAgICAgICAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBzZWxmLl9lbWl0KCdsb2FkZXJyb3InLCBudWxsLCAnTm9uLXN0cmluZyBmb3VuZCBpbiBzZWxlY3RlZCBhdWRpbyBzb3VyY2VzIC0gaWdub3JpbmcuJyk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBFeHRyYWN0IHRoZSBmaWxlIGV4dGVuc2lvbiBmcm9tIHRoZSBVUkwgb3IgYmFzZTY0IGRhdGEgVVJJLlxuICAgICAgICAgIGV4dCA9IC9eZGF0YTphdWRpb1xcLyhbXjssXSspOy9pLmV4ZWMoc3RyKTtcbiAgICAgICAgICBpZiAoIWV4dCkge1xuICAgICAgICAgICAgZXh0ID0gL1xcLihbXi5dKykkLy5leGVjKHN0ci5zcGxpdCgnPycsIDEpWzBdKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoZXh0KSB7XG4gICAgICAgICAgICBleHQgPSBleHRbMV0udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDaGVjayBpZiB0aGlzIGV4dGVuc2lvbiBpcyBhdmFpbGFibGUuXG4gICAgICAgIGlmIChIb3dsZXIuY29kZWNzKGV4dCkpIHtcbiAgICAgICAgICB1cmwgPSBzZWxmLl9zcmNbaV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCF1cmwpIHtcbiAgICAgICAgc2VsZi5fZW1pdCgnbG9hZGVycm9yJywgbnVsbCwgJ05vIGNvZGVjIHN1cHBvcnQgZm9yIHNlbGVjdGVkIGF1ZGlvIHNvdXJjZXMuJyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgc2VsZi5fc3JjID0gdXJsO1xuICAgICAgc2VsZi5fc3RhdGUgPSAnbG9hZGluZyc7XG5cbiAgICAgIC8vIElmIHRoZSBob3N0aW5nIHBhZ2UgaXMgSFRUUFMgYW5kIHRoZSBzb3VyY2UgaXNuJ3QsXG4gICAgICAvLyBkcm9wIGRvd24gdG8gSFRNTDUgQXVkaW8gdG8gYXZvaWQgTWl4ZWQgQ29udGVudCBlcnJvcnMuXG4gICAgICBpZiAod2luZG93LmxvY2F0aW9uLnByb3RvY29sID09PSAnaHR0cHM6JyAmJiB1cmwuc2xpY2UoMCwgNSkgPT09ICdodHRwOicpIHtcbiAgICAgICAgc2VsZi5faHRtbDUgPSB0cnVlO1xuICAgICAgICBzZWxmLl93ZWJBdWRpbyA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICAvLyBDcmVhdGUgYSBuZXcgc291bmQgb2JqZWN0IGFuZCBhZGQgaXQgdG8gdGhlIHBvb2wuXG4gICAgICBuZXcgU291bmQoc2VsZik7XG5cbiAgICAgIC8vIExvYWQgYW5kIGRlY29kZSB0aGUgYXVkaW8gZGF0YSBmb3IgcGxheWJhY2suXG4gICAgICBpZiAoc2VsZi5fd2ViQXVkaW8pIHtcbiAgICAgICAgbG9hZEJ1ZmZlcihzZWxmKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFBsYXkgYSBzb3VuZCBvciByZXN1bWUgcHJldmlvdXMgcGxheWJhY2suXG4gICAgICogQHBhcmFtICB7U3RyaW5nL051bWJlcn0gc3ByaXRlICAgU3ByaXRlIG5hbWUgZm9yIHNwcml0ZSBwbGF5YmFjayBvciBzb3VuZCBpZCB0byBjb250aW51ZSBwcmV2aW91cy5cbiAgICAgKiBAcGFyYW0gIHtCb29sZWFufSBpbnRlcm5hbCBJbnRlcm5hbCBVc2U6IHRydWUgcHJldmVudHMgZXZlbnQgZmlyaW5nLlxuICAgICAqIEByZXR1cm4ge051bWJlcn0gICAgICAgICAgU291bmQgSUQuXG4gICAgICovXG4gICAgcGxheTogZnVuY3Rpb24oc3ByaXRlLCBpbnRlcm5hbCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIGlkID0gbnVsbDtcblxuICAgICAgLy8gRGV0ZXJtaW5lIGlmIGEgc3ByaXRlLCBzb3VuZCBpZCBvciBub3RoaW5nIHdhcyBwYXNzZWRcbiAgICAgIGlmICh0eXBlb2Ygc3ByaXRlID09PSAnbnVtYmVyJykge1xuICAgICAgICBpZCA9IHNwcml0ZTtcbiAgICAgICAgc3ByaXRlID0gbnVsbDtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHNwcml0ZSA9PT0gJ3N0cmluZycgJiYgc2VsZi5fc3RhdGUgPT09ICdsb2FkZWQnICYmICFzZWxmLl9zcHJpdGVbc3ByaXRlXSkge1xuICAgICAgICAvLyBJZiB0aGUgcGFzc2VkIHNwcml0ZSBkb2Vzbid0IGV4aXN0LCBkbyBub3RoaW5nLlxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHNwcml0ZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgLy8gVXNlIHRoZSBkZWZhdWx0IHNvdW5kIHNwcml0ZSAocGxheXMgdGhlIGZ1bGwgYXVkaW8gbGVuZ3RoKS5cbiAgICAgICAgc3ByaXRlID0gJ19fZGVmYXVsdCc7XG5cbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlcmUgaXMgYSBzaW5nbGUgcGF1c2VkIHNvdW5kIHRoYXQgaXNuJ3QgZW5kZWQuXG4gICAgICAgIC8vIElmIHRoZXJlIGlzLCBwbGF5IHRoYXQgc291bmQuIElmIG5vdCwgY29udGludWUgYXMgdXN1YWwuXG4gICAgICAgIHZhciBudW0gPSAwO1xuICAgICAgICBmb3IgKHZhciBpPTA7IGk8c2VsZi5fc291bmRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKHNlbGYuX3NvdW5kc1tpXS5fcGF1c2VkICYmICFzZWxmLl9zb3VuZHNbaV0uX2VuZGVkKSB7XG4gICAgICAgICAgICBudW0rKztcbiAgICAgICAgICAgIGlkID0gc2VsZi5fc291bmRzW2ldLl9pZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobnVtID09PSAxKSB7XG4gICAgICAgICAgc3ByaXRlID0gbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gR2V0IHRoZSBzZWxlY3RlZCBub2RlLCBvciBnZXQgb25lIGZyb20gdGhlIHBvb2wuXG4gICAgICB2YXIgc291bmQgPSBpZCA/IHNlbGYuX3NvdW5kQnlJZChpZCkgOiBzZWxmLl9pbmFjdGl2ZVNvdW5kKCk7XG5cbiAgICAgIC8vIElmIHRoZSBzb3VuZCBkb2Vzbid0IGV4aXN0LCBkbyBub3RoaW5nLlxuICAgICAgaWYgKCFzb3VuZCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgLy8gU2VsZWN0IHRoZSBzcHJpdGUgZGVmaW5pdGlvbi5cbiAgICAgIGlmIChpZCAmJiAhc3ByaXRlKSB7XG4gICAgICAgIHNwcml0ZSA9IHNvdW5kLl9zcHJpdGUgfHwgJ19fZGVmYXVsdCc7XG4gICAgICB9XG5cbiAgICAgIC8vIElmIHdlIGhhdmUgbm8gc3ByaXRlIGFuZCB0aGUgc291bmQgaGFzbid0IGxvYWRlZCwgd2UgbXVzdCB3YWl0XG4gICAgICAvLyBmb3IgdGhlIHNvdW5kIHRvIGxvYWQgdG8gZ2V0IG91ciBhdWRpbydzIGR1cmF0aW9uLlxuICAgICAgaWYgKHNlbGYuX3N0YXRlICE9PSAnbG9hZGVkJyAmJiAhc2VsZi5fc3ByaXRlW3Nwcml0ZV0pIHtcbiAgICAgICAgc2VsZi5fcXVldWUucHVzaCh7XG4gICAgICAgICAgZXZlbnQ6ICdwbGF5JyxcbiAgICAgICAgICBhY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc2VsZi5wbGF5KHNlbGYuX3NvdW5kQnlJZChzb3VuZC5faWQpID8gc291bmQuX2lkIDogdW5kZWZpbmVkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBzb3VuZC5faWQ7XG4gICAgICB9XG5cbiAgICAgIC8vIERvbid0IHBsYXkgdGhlIHNvdW5kIGlmIGFuIGlkIHdhcyBwYXNzZWQgYW5kIGl0IGlzIGFscmVhZHkgcGxheWluZy5cbiAgICAgIGlmIChpZCAmJiAhc291bmQuX3BhdXNlZCkge1xuICAgICAgICAvLyBUcmlnZ2VyIHRoZSBwbGF5IGV2ZW50LCBpbiBvcmRlciB0byBrZWVwIGl0ZXJhdGluZyB0aHJvdWdoIHF1ZXVlLlxuICAgICAgICBpZiAoIWludGVybmFsKSB7XG4gICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHNlbGYuX2VtaXQoJ3BsYXknLCBzb3VuZC5faWQpO1xuICAgICAgICAgIH0sIDApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNvdW5kLl9pZDtcbiAgICAgIH1cblxuICAgICAgLy8gTWFrZSBzdXJlIHRoZSBBdWRpb0NvbnRleHQgaXNuJ3Qgc3VzcGVuZGVkLCBhbmQgcmVzdW1lIGl0IGlmIGl0IGlzLlxuICAgICAgaWYgKHNlbGYuX3dlYkF1ZGlvKSB7XG4gICAgICAgIEhvd2xlci5fYXV0b1Jlc3VtZSgpO1xuICAgICAgfVxuXG4gICAgICAvLyBEZXRlcm1pbmUgaG93IGxvbmcgdG8gcGxheSBmb3IgYW5kIHdoZXJlIHRvIHN0YXJ0IHBsYXlpbmcuXG4gICAgICB2YXIgc2VlayA9IHNvdW5kLl9zZWVrID4gMCA/IHNvdW5kLl9zZWVrIDogc2VsZi5fc3ByaXRlW3Nwcml0ZV1bMF0gLyAxMDAwO1xuICAgICAgdmFyIGR1cmF0aW9uID0gKChzZWxmLl9zcHJpdGVbc3ByaXRlXVswXSArIHNlbGYuX3Nwcml0ZVtzcHJpdGVdWzFdKSAvIDEwMDApIC0gc2VlaztcbiAgICAgIHZhciB0aW1lb3V0ID0gKGR1cmF0aW9uICogMTAwMCkgLyBNYXRoLmFicyhzb3VuZC5fcmF0ZSk7XG5cbiAgICAgIC8vIFVwZGF0ZSB0aGUgcGFyYW1ldGVycyBvZiB0aGUgc291bmRcbiAgICAgIHNvdW5kLl9wYXVzZWQgPSBmYWxzZTtcbiAgICAgIHNvdW5kLl9lbmRlZCA9IGZhbHNlO1xuICAgICAgc291bmQuX3Nwcml0ZSA9IHNwcml0ZTtcbiAgICAgIHNvdW5kLl9zZWVrID0gc2VlaztcbiAgICAgIHNvdW5kLl9zdGFydCA9IHNlbGYuX3Nwcml0ZVtzcHJpdGVdWzBdIC8gMTAwMDtcbiAgICAgIHNvdW5kLl9zdG9wID0gKHNlbGYuX3Nwcml0ZVtzcHJpdGVdWzBdICsgc2VsZi5fc3ByaXRlW3Nwcml0ZV1bMV0pIC8gMTAwMDtcbiAgICAgIHNvdW5kLl9sb29wID0gISEoc291bmQuX2xvb3AgfHwgc2VsZi5fc3ByaXRlW3Nwcml0ZV1bMl0pO1xuXG4gICAgICAvLyBCZWdpbiB0aGUgYWN0dWFsIHBsYXliYWNrLlxuICAgICAgdmFyIG5vZGUgPSBzb3VuZC5fbm9kZTtcbiAgICAgIGlmIChzZWxmLl93ZWJBdWRpbykge1xuICAgICAgICAvLyBGaXJlIHRoaXMgd2hlbiB0aGUgc291bmQgaXMgcmVhZHkgdG8gcGxheSB0byBiZWdpbiBXZWIgQXVkaW8gcGxheWJhY2suXG4gICAgICAgIHZhciBwbGF5V2ViQXVkaW8gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICBzZWxmLl9yZWZyZXNoQnVmZmVyKHNvdW5kKTtcblxuICAgICAgICAgIC8vIFNldHVwIHRoZSBwbGF5YmFjayBwYXJhbXMuXG4gICAgICAgICAgdmFyIHZvbCA9IChzb3VuZC5fbXV0ZWQgfHwgc2VsZi5fbXV0ZWQpID8gMCA6IHNvdW5kLl92b2x1bWU7XG4gICAgICAgICAgbm9kZS5nYWluLnNldFZhbHVlQXRUaW1lKHZvbCwgSG93bGVyLmN0eC5jdXJyZW50VGltZSk7XG4gICAgICAgICAgc291bmQuX3BsYXlTdGFydCA9IEhvd2xlci5jdHguY3VycmVudFRpbWU7XG5cbiAgICAgICAgICAvLyBQbGF5IHRoZSBzb3VuZCB1c2luZyB0aGUgc3VwcG9ydGVkIG1ldGhvZC5cbiAgICAgICAgICBpZiAodHlwZW9mIG5vZGUuYnVmZmVyU291cmNlLnN0YXJ0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgc291bmQuX2xvb3AgPyBub2RlLmJ1ZmZlclNvdXJjZS5ub3RlR3JhaW5PbigwLCBzZWVrLCA4NjQwMCkgOiBub2RlLmJ1ZmZlclNvdXJjZS5ub3RlR3JhaW5PbigwLCBzZWVrLCBkdXJhdGlvbik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNvdW5kLl9sb29wID8gbm9kZS5idWZmZXJTb3VyY2Uuc3RhcnQoMCwgc2VlaywgODY0MDApIDogbm9kZS5idWZmZXJTb3VyY2Uuc3RhcnQoMCwgc2VlaywgZHVyYXRpb24pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFN0YXJ0IGEgbmV3IHRpbWVyIGlmIG5vbmUgaXMgcHJlc2VudC5cbiAgICAgICAgICBpZiAodGltZW91dCAhPT0gSW5maW5pdHkpIHtcbiAgICAgICAgICAgIHNlbGYuX2VuZFRpbWVyc1tzb3VuZC5faWRdID0gc2V0VGltZW91dChzZWxmLl9lbmRlZC5iaW5kKHNlbGYsIHNvdW5kKSwgdGltZW91dCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFpbnRlcm5hbCkge1xuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgc2VsZi5fZW1pdCgncGxheScsIHNvdW5kLl9pZCk7XG4gICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHNlbGYuX3N0YXRlID09PSAnbG9hZGVkJykge1xuICAgICAgICAgIHBsYXlXZWJBdWRpbygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFdhaXQgZm9yIHRoZSBhdWRpbyB0byBsb2FkIGFuZCB0aGVuIGJlZ2luIHBsYXliYWNrLlxuICAgICAgICAgIHNlbGYub25jZSgnbG9hZCcsIHBsYXlXZWJBdWRpbywgc291bmQuX2lkKTtcblxuICAgICAgICAgIC8vIENhbmNlbCB0aGUgZW5kIHRpbWVyLlxuICAgICAgICAgIHNlbGYuX2NsZWFyVGltZXIoc291bmQuX2lkKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRmlyZSB0aGlzIHdoZW4gdGhlIHNvdW5kIGlzIHJlYWR5IHRvIHBsYXkgdG8gYmVnaW4gSFRNTDUgQXVkaW8gcGxheWJhY2suXG4gICAgICAgIHZhciBwbGF5SHRtbDUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICBub2RlLmN1cnJlbnRUaW1lID0gc2VlaztcbiAgICAgICAgICBub2RlLm11dGVkID0gc291bmQuX211dGVkIHx8IHNlbGYuX211dGVkIHx8IEhvd2xlci5fbXV0ZWQgfHwgbm9kZS5tdXRlZDtcbiAgICAgICAgICBub2RlLnZvbHVtZSA9IHNvdW5kLl92b2x1bWUgKiBIb3dsZXIudm9sdW1lKCk7XG4gICAgICAgICAgbm9kZS5wbGF5YmFja1JhdGUgPSBzb3VuZC5fcmF0ZTtcblxuICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBub2RlLnBsYXkoKTtcblxuICAgICAgICAgICAgLy8gU2V0dXAgdGhlIG5ldyBlbmQgdGltZXIuXG4gICAgICAgICAgICBpZiAodGltZW91dCAhPT0gSW5maW5pdHkpIHtcbiAgICAgICAgICAgICAgc2VsZi5fZW5kVGltZXJzW3NvdW5kLl9pZF0gPSBzZXRUaW1lb3V0KHNlbGYuX2VuZGVkLmJpbmQoc2VsZiwgc291bmQpLCB0aW1lb3V0KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFpbnRlcm5hbCkge1xuICAgICAgICAgICAgICBzZWxmLl9lbWl0KCdwbGF5Jywgc291bmQuX2lkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCAwKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBQbGF5IGltbWVkaWF0ZWx5IGlmIHJlYWR5LCBvciB3YWl0IGZvciB0aGUgJ2NhbnBsYXl0aHJvdWdoJ2UgdmVudC5cbiAgICAgICAgdmFyIGxvYWRlZE5vUmVhZHlTdGF0ZSA9IChzZWxmLl9zdGF0ZSA9PT0gJ2xvYWRlZCcgJiYgKHdpbmRvdyAmJiB3aW5kb3cuZWplY3RhIHx8ICFub2RlLnJlYWR5U3RhdGUgJiYgSG93bGVyLl9uYXZpZ2F0b3IuaXNDb2Nvb25KUykpO1xuICAgICAgICBpZiAobm9kZS5yZWFkeVN0YXRlID09PSA0IHx8IGxvYWRlZE5vUmVhZHlTdGF0ZSkge1xuICAgICAgICAgIHBsYXlIdG1sNSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBsaXN0ZW5lciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gQmVnaW4gcGxheWJhY2suXG4gICAgICAgICAgICBwbGF5SHRtbDUoKTtcblxuICAgICAgICAgICAgLy8gQ2xlYXIgdGhpcyBsaXN0ZW5lci5cbiAgICAgICAgICAgIG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihIb3dsZXIuX2NhblBsYXlFdmVudCwgbGlzdGVuZXIsIGZhbHNlKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihIb3dsZXIuX2NhblBsYXlFdmVudCwgbGlzdGVuZXIsIGZhbHNlKTtcblxuICAgICAgICAgIC8vIENhbmNlbCB0aGUgZW5kIHRpbWVyLlxuICAgICAgICAgIHNlbGYuX2NsZWFyVGltZXIoc291bmQuX2lkKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gc291bmQuX2lkO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQYXVzZSBwbGF5YmFjayBhbmQgc2F2ZSBjdXJyZW50IHBvc2l0aW9uLlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gaWQgVGhlIHNvdW5kIElEIChlbXB0eSB0byBwYXVzZSBhbGwgaW4gZ3JvdXApLlxuICAgICAqIEByZXR1cm4ge0hvd2x9XG4gICAgICovXG4gICAgcGF1c2U6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgIC8vIElmIHRoZSBzb3VuZCBoYXNuJ3QgbG9hZGVkLCBhZGQgaXQgdG8gdGhlIGxvYWQgcXVldWUgdG8gcGF1c2Ugd2hlbiBjYXBhYmxlLlxuICAgICAgaWYgKHNlbGYuX3N0YXRlICE9PSAnbG9hZGVkJykge1xuICAgICAgICBzZWxmLl9xdWV1ZS5wdXNoKHtcbiAgICAgICAgICBldmVudDogJ3BhdXNlJyxcbiAgICAgICAgICBhY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc2VsZi5wYXVzZShpZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgbm8gaWQgaXMgcGFzc2VkLCBnZXQgYWxsIElEJ3MgdG8gYmUgcGF1c2VkLlxuICAgICAgdmFyIGlkcyA9IHNlbGYuX2dldFNvdW5kSWRzKGlkKTtcblxuICAgICAgZm9yICh2YXIgaT0wOyBpPGlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAvLyBDbGVhciB0aGUgZW5kIHRpbWVyLlxuICAgICAgICBzZWxmLl9jbGVhclRpbWVyKGlkc1tpXSk7XG5cbiAgICAgICAgLy8gR2V0IHRoZSBzb3VuZC5cbiAgICAgICAgdmFyIHNvdW5kID0gc2VsZi5fc291bmRCeUlkKGlkc1tpXSk7XG5cbiAgICAgICAgaWYgKHNvdW5kICYmICFzb3VuZC5fcGF1c2VkKSB7XG4gICAgICAgICAgLy8gUmVzZXQgdGhlIHNlZWsgcG9zaXRpb24uXG4gICAgICAgICAgc291bmQuX3NlZWsgPSBzZWxmLnNlZWsoaWRzW2ldKTtcbiAgICAgICAgICBzb3VuZC5fcmF0ZVNlZWsgPSAwO1xuICAgICAgICAgIHNvdW5kLl9wYXVzZWQgPSB0cnVlO1xuXG4gICAgICAgICAgLy8gU3RvcCBjdXJyZW50bHkgcnVubmluZyBmYWRlcy5cbiAgICAgICAgICBzZWxmLl9zdG9wRmFkZShpZHNbaV0pO1xuXG4gICAgICAgICAgaWYgKHNvdW5kLl9ub2RlKSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5fd2ViQXVkaW8pIHtcbiAgICAgICAgICAgICAgLy8gbWFrZSBzdXJlIHRoZSBzb3VuZCBoYXMgYmVlbiBjcmVhdGVkXG4gICAgICAgICAgICAgIGlmICghc291bmQuX25vZGUuYnVmZmVyU291cmNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAodHlwZW9mIHNvdW5kLl9ub2RlLmJ1ZmZlclNvdXJjZS5zdG9wID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHNvdW5kLl9ub2RlLmJ1ZmZlclNvdXJjZS5ub3RlT2ZmKDApO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNvdW5kLl9ub2RlLmJ1ZmZlclNvdXJjZS5zdG9wKDApO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy8gQ2xlYW4gdXAgdGhlIGJ1ZmZlciBzb3VyY2UuXG4gICAgICAgICAgICAgIHNlbGYuX2NsZWFuQnVmZmVyKHNvdW5kLl9ub2RlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIWlzTmFOKHNvdW5kLl9ub2RlLmR1cmF0aW9uKSB8fCBzb3VuZC5fbm9kZS5kdXJhdGlvbiA9PT0gSW5maW5pdHkpIHtcbiAgICAgICAgICAgICAgc291bmQuX25vZGUucGF1c2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBGaXJlIHRoZSBwYXVzZSBldmVudCwgdW5sZXNzIGB0cnVlYCBpcyBwYXNzZWQgYXMgdGhlIDJuZCBhcmd1bWVudC5cbiAgICAgICAgICBpZiAoIWFyZ3VtZW50c1sxXSkge1xuICAgICAgICAgICAgc2VsZi5fZW1pdCgncGF1c2UnLCBzb3VuZC5faWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU3RvcCBwbGF5YmFjayBhbmQgcmVzZXQgdG8gc3RhcnQuXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBpZCBUaGUgc291bmQgSUQgKGVtcHR5IHRvIHN0b3AgYWxsIGluIGdyb3VwKS5cbiAgICAgKiBAcGFyYW0gIHtCb29sZWFufSBpbnRlcm5hbCBJbnRlcm5hbCBVc2U6IHRydWUgcHJldmVudHMgZXZlbnQgZmlyaW5nLlxuICAgICAqIEByZXR1cm4ge0hvd2x9XG4gICAgICovXG4gICAgc3RvcDogZnVuY3Rpb24oaWQsIGludGVybmFsKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgIC8vIElmIHRoZSBzb3VuZCBoYXNuJ3QgbG9hZGVkLCBhZGQgaXQgdG8gdGhlIGxvYWQgcXVldWUgdG8gc3RvcCB3aGVuIGNhcGFibGUuXG4gICAgICBpZiAoc2VsZi5fc3RhdGUgIT09ICdsb2FkZWQnKSB7XG4gICAgICAgIHNlbGYuX3F1ZXVlLnB1c2goe1xuICAgICAgICAgIGV2ZW50OiAnc3RvcCcsXG4gICAgICAgICAgYWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHNlbGYuc3RvcChpZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgbm8gaWQgaXMgcGFzc2VkLCBnZXQgYWxsIElEJ3MgdG8gYmUgc3RvcHBlZC5cbiAgICAgIHZhciBpZHMgPSBzZWxmLl9nZXRTb3VuZElkcyhpZCk7XG5cbiAgICAgIGZvciAodmFyIGk9MDsgaTxpZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gQ2xlYXIgdGhlIGVuZCB0aW1lci5cbiAgICAgICAgc2VsZi5fY2xlYXJUaW1lcihpZHNbaV0pO1xuXG4gICAgICAgIC8vIEdldCB0aGUgc291bmQuXG4gICAgICAgIHZhciBzb3VuZCA9IHNlbGYuX3NvdW5kQnlJZChpZHNbaV0pO1xuXG4gICAgICAgIGlmIChzb3VuZCAmJiAhc291bmQuX3BhdXNlZCkge1xuICAgICAgICAgIC8vIFJlc2V0IHRoZSBzZWVrIHBvc2l0aW9uLlxuICAgICAgICAgIHNvdW5kLl9zZWVrID0gc291bmQuX3N0YXJ0IHx8IDA7XG4gICAgICAgICAgc291bmQuX3JhdGVTZWVrID0gMDtcbiAgICAgICAgICBzb3VuZC5fcGF1c2VkID0gdHJ1ZTtcbiAgICAgICAgICBzb3VuZC5fZW5kZWQgPSB0cnVlO1xuXG4gICAgICAgICAgLy8gU3RvcCBjdXJyZW50bHkgcnVubmluZyBmYWRlcy5cbiAgICAgICAgICBzZWxmLl9zdG9wRmFkZShpZHNbaV0pO1xuXG4gICAgICAgICAgaWYgKHNvdW5kLl9ub2RlKSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5fd2ViQXVkaW8pIHtcbiAgICAgICAgICAgICAgLy8gbWFrZSBzdXJlIHRoZSBzb3VuZCBoYXMgYmVlbiBjcmVhdGVkXG4gICAgICAgICAgICAgIGlmICghc291bmQuX25vZGUuYnVmZmVyU291cmNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAodHlwZW9mIHNvdW5kLl9ub2RlLmJ1ZmZlclNvdXJjZS5zdG9wID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHNvdW5kLl9ub2RlLmJ1ZmZlclNvdXJjZS5ub3RlT2ZmKDApO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNvdW5kLl9ub2RlLmJ1ZmZlclNvdXJjZS5zdG9wKDApO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy8gQ2xlYW4gdXAgdGhlIGJ1ZmZlciBzb3VyY2UuXG4gICAgICAgICAgICAgIHNlbGYuX2NsZWFuQnVmZmVyKHNvdW5kLl9ub2RlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIWlzTmFOKHNvdW5kLl9ub2RlLmR1cmF0aW9uKSB8fCBzb3VuZC5fbm9kZS5kdXJhdGlvbiA9PT0gSW5maW5pdHkpIHtcbiAgICAgICAgICAgICAgc291bmQuX25vZGUuY3VycmVudFRpbWUgPSBzb3VuZC5fc3RhcnQgfHwgMDtcbiAgICAgICAgICAgICAgc291bmQuX25vZGUucGF1c2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc291bmQgJiYgIWludGVybmFsKSB7XG4gICAgICAgICAgc2VsZi5fZW1pdCgnc3RvcCcsIHNvdW5kLl9pZCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE11dGUvdW5tdXRlIGEgc2luZ2xlIHNvdW5kIG9yIGFsbCBzb3VuZHMgaW4gdGhpcyBIb3dsIGdyb3VwLlxuICAgICAqIEBwYXJhbSAge0Jvb2xlYW59IG11dGVkIFNldCB0byB0cnVlIHRvIG11dGUgYW5kIGZhbHNlIHRvIHVubXV0ZS5cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGlkICAgIFRoZSBzb3VuZCBJRCB0byB1cGRhdGUgKG9taXQgdG8gbXV0ZS91bm11dGUgYWxsKS5cbiAgICAgKiBAcmV0dXJuIHtIb3dsfVxuICAgICAqL1xuICAgIG11dGU6IGZ1bmN0aW9uKG11dGVkLCBpZCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAvLyBJZiB0aGUgc291bmQgaGFzbid0IGxvYWRlZCwgYWRkIGl0IHRvIHRoZSBsb2FkIHF1ZXVlIHRvIG11dGUgd2hlbiBjYXBhYmxlLlxuICAgICAgaWYgKHNlbGYuX3N0YXRlICE9PSAnbG9hZGVkJykge1xuICAgICAgICBzZWxmLl9xdWV1ZS5wdXNoKHtcbiAgICAgICAgICBldmVudDogJ211dGUnLFxuICAgICAgICAgIGFjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBzZWxmLm11dGUobXV0ZWQsIGlkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiBhcHBseWluZyBtdXRlL3VubXV0ZSB0byBhbGwgc291bmRzLCB1cGRhdGUgdGhlIGdyb3VwJ3MgdmFsdWUuXG4gICAgICBpZiAodHlwZW9mIGlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBpZiAodHlwZW9mIG11dGVkID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICBzZWxmLl9tdXRlZCA9IG11dGVkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBzZWxmLl9tdXRlZDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBJZiBubyBpZCBpcyBwYXNzZWQsIGdldCBhbGwgSUQncyB0byBiZSBtdXRlZC5cbiAgICAgIHZhciBpZHMgPSBzZWxmLl9nZXRTb3VuZElkcyhpZCk7XG5cbiAgICAgIGZvciAodmFyIGk9MDsgaTxpZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gR2V0IHRoZSBzb3VuZC5cbiAgICAgICAgdmFyIHNvdW5kID0gc2VsZi5fc291bmRCeUlkKGlkc1tpXSk7XG5cbiAgICAgICAgaWYgKHNvdW5kKSB7XG4gICAgICAgICAgc291bmQuX211dGVkID0gbXV0ZWQ7XG5cbiAgICAgICAgICBpZiAoc2VsZi5fd2ViQXVkaW8gJiYgc291bmQuX25vZGUpIHtcbiAgICAgICAgICAgIHNvdW5kLl9ub2RlLmdhaW4uc2V0VmFsdWVBdFRpbWUobXV0ZWQgPyAwIDogc291bmQuX3ZvbHVtZSwgSG93bGVyLmN0eC5jdXJyZW50VGltZSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChzb3VuZC5fbm9kZSkge1xuICAgICAgICAgICAgc291bmQuX25vZGUubXV0ZWQgPSBIb3dsZXIuX211dGVkID8gdHJ1ZSA6IG11dGVkO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHNlbGYuX2VtaXQoJ211dGUnLCBzb3VuZC5faWQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQvc2V0IHRoZSB2b2x1bWUgb2YgdGhpcyBzb3VuZCBvciBvZiB0aGUgSG93bCBncm91cC4gVGhpcyBtZXRob2QgY2FuIG9wdGlvbmFsbHkgdGFrZSAwLCAxIG9yIDIgYXJndW1lbnRzLlxuICAgICAqICAgdm9sdW1lKCkgLT4gUmV0dXJucyB0aGUgZ3JvdXAncyB2b2x1bWUgdmFsdWUuXG4gICAgICogICB2b2x1bWUoaWQpIC0+IFJldHVybnMgdGhlIHNvdW5kIGlkJ3MgY3VycmVudCB2b2x1bWUuXG4gICAgICogICB2b2x1bWUodm9sKSAtPiBTZXRzIHRoZSB2b2x1bWUgb2YgYWxsIHNvdW5kcyBpbiB0aGlzIEhvd2wgZ3JvdXAuXG4gICAgICogICB2b2x1bWUodm9sLCBpZCkgLT4gU2V0cyB0aGUgdm9sdW1lIG9mIHBhc3NlZCBzb3VuZCBpZC5cbiAgICAgKiBAcmV0dXJuIHtIb3dsL051bWJlcn0gUmV0dXJucyBzZWxmIG9yIGN1cnJlbnQgdm9sdW1lLlxuICAgICAqL1xuICAgIHZvbHVtZTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgIHZhciB2b2wsIGlkO1xuXG4gICAgICAvLyBEZXRlcm1pbmUgdGhlIHZhbHVlcyBiYXNlZCBvbiBhcmd1bWVudHMuXG4gICAgICBpZiAoYXJncy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgLy8gUmV0dXJuIHRoZSB2YWx1ZSBvZiB0aGUgZ3JvdXBzJyB2b2x1bWUuXG4gICAgICAgIHJldHVybiBzZWxmLl92b2x1bWU7XG4gICAgICB9IGVsc2UgaWYgKGFyZ3MubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIC8vIEZpcnN0IGNoZWNrIGlmIHRoaXMgaXMgYW4gSUQsIGFuZCBpZiBub3QsIGFzc3VtZSBpdCBpcyBhIG5ldyB2b2x1bWUuXG4gICAgICAgIHZhciBpZHMgPSBzZWxmLl9nZXRTb3VuZElkcygpO1xuICAgICAgICB2YXIgaW5kZXggPSBpZHMuaW5kZXhPZihhcmdzWzBdKTtcbiAgICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgICBpZCA9IHBhcnNlSW50KGFyZ3NbMF0sIDEwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2b2wgPSBwYXJzZUZsb2F0KGFyZ3NbMF0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGFyZ3MubGVuZ3RoID49IDIpIHtcbiAgICAgICAgdm9sID0gcGFyc2VGbG9hdChhcmdzWzBdKTtcbiAgICAgICAgaWQgPSBwYXJzZUludChhcmdzWzFdLCAxMCk7XG4gICAgICB9XG5cbiAgICAgIC8vIFVwZGF0ZSB0aGUgdm9sdW1lIG9yIHJldHVybiB0aGUgY3VycmVudCB2b2x1bWUuXG4gICAgICB2YXIgc291bmQ7XG4gICAgICBpZiAodHlwZW9mIHZvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgdm9sID49IDAgJiYgdm9sIDw9IDEpIHtcbiAgICAgICAgLy8gSWYgdGhlIHNvdW5kIGhhc24ndCBsb2FkZWQsIGFkZCBpdCB0byB0aGUgbG9hZCBxdWV1ZSB0byBjaGFuZ2Ugdm9sdW1lIHdoZW4gY2FwYWJsZS5cbiAgICAgICAgaWYgKHNlbGYuX3N0YXRlICE9PSAnbG9hZGVkJykge1xuICAgICAgICAgIHNlbGYuX3F1ZXVlLnB1c2goe1xuICAgICAgICAgICAgZXZlbnQ6ICd2b2x1bWUnLFxuICAgICAgICAgICAgYWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgc2VsZi52b2x1bWUuYXBwbHkoc2VsZiwgYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNldCB0aGUgZ3JvdXAgdm9sdW1lLlxuICAgICAgICBpZiAodHlwZW9mIGlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHNlbGYuX3ZvbHVtZSA9IHZvbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVwZGF0ZSBvbmUgb3IgYWxsIHZvbHVtZXMuXG4gICAgICAgIGlkID0gc2VsZi5fZ2V0U291bmRJZHMoaWQpO1xuICAgICAgICBmb3IgKHZhciBpPTA7IGk8aWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAvLyBHZXQgdGhlIHNvdW5kLlxuICAgICAgICAgIHNvdW5kID0gc2VsZi5fc291bmRCeUlkKGlkW2ldKTtcblxuICAgICAgICAgIGlmIChzb3VuZCkge1xuICAgICAgICAgICAgc291bmQuX3ZvbHVtZSA9IHZvbDtcblxuICAgICAgICAgICAgLy8gU3RvcCBjdXJyZW50bHkgcnVubmluZyBmYWRlcy5cbiAgICAgICAgICAgIGlmICghYXJnc1syXSkge1xuICAgICAgICAgICAgICBzZWxmLl9zdG9wRmFkZShpZFtpXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzZWxmLl93ZWJBdWRpbyAmJiBzb3VuZC5fbm9kZSAmJiAhc291bmQuX211dGVkKSB7XG4gICAgICAgICAgICAgIHNvdW5kLl9ub2RlLmdhaW4uc2V0VmFsdWVBdFRpbWUodm9sLCBIb3dsZXIuY3R4LmN1cnJlbnRUaW1lKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc291bmQuX25vZGUgJiYgIXNvdW5kLl9tdXRlZCkge1xuICAgICAgICAgICAgICBzb3VuZC5fbm9kZS52b2x1bWUgPSB2b2wgKiBIb3dsZXIudm9sdW1lKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNlbGYuX2VtaXQoJ3ZvbHVtZScsIHNvdW5kLl9pZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzb3VuZCA9IGlkID8gc2VsZi5fc291bmRCeUlkKGlkKSA6IHNlbGYuX3NvdW5kc1swXTtcbiAgICAgICAgcmV0dXJuIHNvdW5kID8gc291bmQuX3ZvbHVtZSA6IDA7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGYWRlIGEgY3VycmVudGx5IHBsYXlpbmcgc291bmQgYmV0d2VlbiB0d28gdm9sdW1lcyAoaWYgbm8gaWQgaXMgcGFzc3NlZCwgYWxsIHNvdW5kcyB3aWxsIGZhZGUpLlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gZnJvbSBUaGUgdmFsdWUgdG8gZmFkZSBmcm9tICgwLjAgdG8gMS4wKS5cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHRvICAgVGhlIHZvbHVtZSB0byBmYWRlIHRvICgwLjAgdG8gMS4wKS5cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGxlbiAgVGltZSBpbiBtaWxsaXNlY29uZHMgdG8gZmFkZS5cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGlkICAgVGhlIHNvdW5kIGlkIChvbWl0IHRvIGZhZGUgYWxsIHNvdW5kcykuXG4gICAgICogQHJldHVybiB7SG93bH1cbiAgICAgKi9cbiAgICBmYWRlOiBmdW5jdGlvbihmcm9tLCB0bywgbGVuLCBpZCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIGRpZmYgPSBNYXRoLmFicyhmcm9tIC0gdG8pO1xuICAgICAgdmFyIGRpciA9IGZyb20gPiB0byA/ICdvdXQnIDogJ2luJztcbiAgICAgIHZhciBzdGVwcyA9IGRpZmYgLyAwLjAxO1xuICAgICAgdmFyIHN0ZXBMZW4gPSBsZW4gLyBzdGVwcztcblxuICAgICAgLy8gSWYgdGhlIHNvdW5kIGhhc24ndCBsb2FkZWQsIGFkZCBpdCB0byB0aGUgbG9hZCBxdWV1ZSB0byBmYWRlIHdoZW4gY2FwYWJsZS5cbiAgICAgIGlmIChzZWxmLl9zdGF0ZSAhPT0gJ2xvYWRlZCcpIHtcbiAgICAgICAgc2VsZi5fcXVldWUucHVzaCh7XG4gICAgICAgICAgZXZlbnQ6ICdmYWRlJyxcbiAgICAgICAgICBhY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc2VsZi5mYWRlKGZyb20sIHRvLCBsZW4sIGlkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgfVxuXG4gICAgICAvLyBTZXQgdGhlIHZvbHVtZSB0byB0aGUgc3RhcnQgcG9zaXRpb24uXG4gICAgICBzZWxmLnZvbHVtZShmcm9tLCBpZCk7XG5cbiAgICAgIC8vIEZhZGUgdGhlIHZvbHVtZSBvZiBvbmUgb3IgYWxsIHNvdW5kcy5cbiAgICAgIHZhciBpZHMgPSBzZWxmLl9nZXRTb3VuZElkcyhpZCk7XG4gICAgICBmb3IgKHZhciBpPTA7IGk8aWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIEdldCB0aGUgc291bmQuXG4gICAgICAgIHZhciBzb3VuZCA9IHNlbGYuX3NvdW5kQnlJZChpZHNbaV0pO1xuXG4gICAgICAgIC8vIENyZWF0ZSBhIGxpbmVhciBmYWRlIG9yIGZhbGwgYmFjayB0byB0aW1lb3V0cyB3aXRoIEhUTUw1IEF1ZGlvLlxuICAgICAgICBpZiAoc291bmQpIHtcbiAgICAgICAgICAvLyBTdG9wIHRoZSBwcmV2aW91cyBmYWRlIGlmIG5vIHNwcml0ZSBpcyBiZWluZyB1c2VkIChvdGhlcndpc2UsIHZvbHVtZSBoYW5kbGVzIHRoaXMpLlxuICAgICAgICAgIGlmICghaWQpIHtcbiAgICAgICAgICAgIHNlbGYuX3N0b3BGYWRlKGlkc1tpXSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gSWYgd2UgYXJlIHVzaW5nIFdlYiBBdWRpbywgbGV0IHRoZSBuYXRpdmUgbWV0aG9kcyBkbyB0aGUgYWN0dWFsIGZhZGUuXG4gICAgICAgICAgaWYgKHNlbGYuX3dlYkF1ZGlvICYmICFzb3VuZC5fbXV0ZWQpIHtcbiAgICAgICAgICAgIHZhciBjdXJyZW50VGltZSA9IEhvd2xlci5jdHguY3VycmVudFRpbWU7XG4gICAgICAgICAgICB2YXIgZW5kID0gY3VycmVudFRpbWUgKyAobGVuIC8gMTAwMCk7XG4gICAgICAgICAgICBzb3VuZC5fdm9sdW1lID0gZnJvbTtcbiAgICAgICAgICAgIHNvdW5kLl9ub2RlLmdhaW4uc2V0VmFsdWVBdFRpbWUoZnJvbSwgY3VycmVudFRpbWUpO1xuICAgICAgICAgICAgc291bmQuX25vZGUuZ2Fpbi5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZSh0bywgZW5kKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgdm9sID0gZnJvbTtcbiAgICAgICAgICBzb3VuZC5faW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChmdW5jdGlvbihzb3VuZElkLCBzb3VuZCkge1xuICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSB2b2x1bWUgYW1vdW50LlxuICAgICAgICAgICAgdm9sICs9IChkaXIgPT09ICdpbicgPyAwLjAxIDogLTAuMDEpO1xuXG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIHZvbHVtZSBpcyBpbiB0aGUgcmlnaHQgYm91bmRzLlxuICAgICAgICAgICAgdm9sID0gTWF0aC5tYXgoMCwgdm9sKTtcbiAgICAgICAgICAgIHZvbCA9IE1hdGgubWluKDEsIHZvbCk7XG5cbiAgICAgICAgICAgIC8vIFJvdW5kIHRvIHdpdGhpbiAyIGRlY2ltYWwgcG9pbnRzLlxuICAgICAgICAgICAgdm9sID0gTWF0aC5yb3VuZCh2b2wgKiAxMDApIC8gMTAwO1xuXG4gICAgICAgICAgICAvLyBDaGFuZ2UgdGhlIHZvbHVtZS5cbiAgICAgICAgICAgIGlmIChzZWxmLl93ZWJBdWRpbykge1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIGlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHNlbGYuX3ZvbHVtZSA9IHZvbDtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHNvdW5kLl92b2x1bWUgPSB2b2w7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzZWxmLnZvbHVtZSh2b2wsIHNvdW5kSWQsIHRydWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBXaGVuIHRoZSBmYWRlIGlzIGNvbXBsZXRlLCBzdG9wIGl0IGFuZCBmaXJlIGV2ZW50LlxuICAgICAgICAgICAgaWYgKHZvbCA9PT0gdG8pIHtcbiAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChzb3VuZC5faW50ZXJ2YWwpO1xuICAgICAgICAgICAgICBzb3VuZC5faW50ZXJ2YWwgPSBudWxsO1xuICAgICAgICAgICAgICBzZWxmLnZvbHVtZSh2b2wsIHNvdW5kSWQpO1xuICAgICAgICAgICAgICBzZWxmLl9lbWl0KCdmYWRlJywgc291bmRJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfS5iaW5kKHNlbGYsIGlkc1tpXSwgc291bmQpLCBzdGVwTGVuKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwgbWV0aG9kIHRoYXQgc3RvcHMgdGhlIGN1cnJlbnRseSBwbGF5aW5nIGZhZGUgd2hlblxuICAgICAqIGEgbmV3IGZhZGUgc3RhcnRzLCB2b2x1bWUgaXMgY2hhbmdlZCBvciB0aGUgc291bmQgaXMgc3RvcHBlZC5cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGlkIFRoZSBzb3VuZCBpZC5cbiAgICAgKiBAcmV0dXJuIHtIb3dsfVxuICAgICAqL1xuICAgIF9zdG9wRmFkZTogZnVuY3Rpb24oaWQpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBzb3VuZCA9IHNlbGYuX3NvdW5kQnlJZChpZCk7XG5cbiAgICAgIGlmIChzb3VuZCAmJiBzb3VuZC5faW50ZXJ2YWwpIHtcbiAgICAgICAgaWYgKHNlbGYuX3dlYkF1ZGlvKSB7XG4gICAgICAgICAgc291bmQuX25vZGUuZ2Fpbi5jYW5jZWxTY2hlZHVsZWRWYWx1ZXMoSG93bGVyLmN0eC5jdXJyZW50VGltZSk7XG4gICAgICAgIH1cblxuICAgICAgICBjbGVhckludGVydmFsKHNvdW5kLl9pbnRlcnZhbCk7XG4gICAgICAgIHNvdW5kLl9pbnRlcnZhbCA9IG51bGw7XG4gICAgICAgIHNlbGYuX2VtaXQoJ2ZhZGUnLCBpZCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQvc2V0IHRoZSBsb29wIHBhcmFtZXRlciBvbiBhIHNvdW5kLiBUaGlzIG1ldGhvZCBjYW4gb3B0aW9uYWxseSB0YWtlIDAsIDEgb3IgMiBhcmd1bWVudHMuXG4gICAgICogICBsb29wKCkgLT4gUmV0dXJucyB0aGUgZ3JvdXAncyBsb29wIHZhbHVlLlxuICAgICAqICAgbG9vcChpZCkgLT4gUmV0dXJucyB0aGUgc291bmQgaWQncyBsb29wIHZhbHVlLlxuICAgICAqICAgbG9vcChsb29wKSAtPiBTZXRzIHRoZSBsb29wIHZhbHVlIGZvciBhbGwgc291bmRzIGluIHRoaXMgSG93bCBncm91cC5cbiAgICAgKiAgIGxvb3AobG9vcCwgaWQpIC0+IFNldHMgdGhlIGxvb3AgdmFsdWUgb2YgcGFzc2VkIHNvdW5kIGlkLlxuICAgICAqIEByZXR1cm4ge0hvd2wvQm9vbGVhbn0gUmV0dXJucyBzZWxmIG9yIGN1cnJlbnQgbG9vcCB2YWx1ZS5cbiAgICAgKi9cbiAgICBsb29wOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgdmFyIGxvb3AsIGlkLCBzb3VuZDtcblxuICAgICAgLy8gRGV0ZXJtaW5lIHRoZSB2YWx1ZXMgZm9yIGxvb3AgYW5kIGlkLlxuICAgICAgaWYgKGFyZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIC8vIFJldHVybiB0aGUgZ3JvdSdzIGxvb3AgdmFsdWUuXG4gICAgICAgIHJldHVybiBzZWxmLl9sb29wO1xuICAgICAgfSBlbHNlIGlmIChhcmdzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBpZiAodHlwZW9mIGFyZ3NbMF0gPT09ICdib29sZWFuJykge1xuICAgICAgICAgIGxvb3AgPSBhcmdzWzBdO1xuICAgICAgICAgIHNlbGYuX2xvb3AgPSBsb29wO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFJldHVybiB0aGlzIHNvdW5kJ3MgbG9vcCB2YWx1ZS5cbiAgICAgICAgICBzb3VuZCA9IHNlbGYuX3NvdW5kQnlJZChwYXJzZUludChhcmdzWzBdLCAxMCkpO1xuICAgICAgICAgIHJldHVybiBzb3VuZCA/IHNvdW5kLl9sb29wIDogZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoYXJncy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgbG9vcCA9IGFyZ3NbMF07XG4gICAgICAgIGlkID0gcGFyc2VJbnQoYXJnc1sxXSwgMTApO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiBubyBpZCBpcyBwYXNzZWQsIGdldCBhbGwgSUQncyB0byBiZSBsb29wZWQuXG4gICAgICB2YXIgaWRzID0gc2VsZi5fZ2V0U291bmRJZHMoaWQpO1xuICAgICAgZm9yICh2YXIgaT0wOyBpPGlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBzb3VuZCA9IHNlbGYuX3NvdW5kQnlJZChpZHNbaV0pO1xuXG4gICAgICAgIGlmIChzb3VuZCkge1xuICAgICAgICAgIHNvdW5kLl9sb29wID0gbG9vcDtcbiAgICAgICAgICBpZiAoc2VsZi5fd2ViQXVkaW8gJiYgc291bmQuX25vZGUgJiYgc291bmQuX25vZGUuYnVmZmVyU291cmNlKSB7XG4gICAgICAgICAgICBzb3VuZC5fbm9kZS5idWZmZXJTb3VyY2UubG9vcCA9IGxvb3A7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQvc2V0IHRoZSBwbGF5YmFjayByYXRlIG9mIGEgc291bmQuIFRoaXMgbWV0aG9kIGNhbiBvcHRpb25hbGx5IHRha2UgMCwgMSBvciAyIGFyZ3VtZW50cy5cbiAgICAgKiAgIHJhdGUoKSAtPiBSZXR1cm5zIHRoZSBmaXJzdCBzb3VuZCBub2RlJ3MgY3VycmVudCBwbGF5YmFjayByYXRlLlxuICAgICAqICAgcmF0ZShpZCkgLT4gUmV0dXJucyB0aGUgc291bmQgaWQncyBjdXJyZW50IHBsYXliYWNrIHJhdGUuXG4gICAgICogICByYXRlKHJhdGUpIC0+IFNldHMgdGhlIHBsYXliYWNrIHJhdGUgb2YgYWxsIHNvdW5kcyBpbiB0aGlzIEhvd2wgZ3JvdXAuXG4gICAgICogICByYXRlKHJhdGUsIGlkKSAtPiBTZXRzIHRoZSBwbGF5YmFjayByYXRlIG9mIHBhc3NlZCBzb3VuZCBpZC5cbiAgICAgKiBAcmV0dXJuIHtIb3dsL051bWJlcn0gUmV0dXJucyBzZWxmIG9yIHRoZSBjdXJyZW50IHBsYXliYWNrIHJhdGUuXG4gICAgICovXG4gICAgcmF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgIHZhciByYXRlLCBpZDtcblxuICAgICAgLy8gRGV0ZXJtaW5lIHRoZSB2YWx1ZXMgYmFzZWQgb24gYXJndW1lbnRzLlxuICAgICAgaWYgKGFyZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIC8vIFdlIHdpbGwgc2ltcGx5IHJldHVybiB0aGUgY3VycmVudCByYXRlIG9mIHRoZSBmaXJzdCBub2RlLlxuICAgICAgICBpZCA9IHNlbGYuX3NvdW5kc1swXS5faWQ7XG4gICAgICB9IGVsc2UgaWYgKGFyZ3MubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIC8vIEZpcnN0IGNoZWNrIGlmIHRoaXMgaXMgYW4gSUQsIGFuZCBpZiBub3QsIGFzc3VtZSBpdCBpcyBhIG5ldyByYXRlIHZhbHVlLlxuICAgICAgICB2YXIgaWRzID0gc2VsZi5fZ2V0U291bmRJZHMoKTtcbiAgICAgICAgdmFyIGluZGV4ID0gaWRzLmluZGV4T2YoYXJnc1swXSk7XG4gICAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgICAgaWQgPSBwYXJzZUludChhcmdzWzBdLCAxMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmF0ZSA9IHBhcnNlRmxvYXQoYXJnc1swXSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoYXJncy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgcmF0ZSA9IHBhcnNlRmxvYXQoYXJnc1swXSk7XG4gICAgICAgIGlkID0gcGFyc2VJbnQoYXJnc1sxXSwgMTApO1xuICAgICAgfVxuXG4gICAgICAvLyBVcGRhdGUgdGhlIHBsYXliYWNrIHJhdGUgb3IgcmV0dXJuIHRoZSBjdXJyZW50IHZhbHVlLlxuICAgICAgdmFyIHNvdW5kO1xuICAgICAgaWYgKHR5cGVvZiByYXRlID09PSAnbnVtYmVyJykge1xuICAgICAgICAvLyBJZiB0aGUgc291bmQgaGFzbid0IGxvYWRlZCwgYWRkIGl0IHRvIHRoZSBsb2FkIHF1ZXVlIHRvIGNoYW5nZSBwbGF5YmFjayByYXRlIHdoZW4gY2FwYWJsZS5cbiAgICAgICAgaWYgKHNlbGYuX3N0YXRlICE9PSAnbG9hZGVkJykge1xuICAgICAgICAgIHNlbGYuX3F1ZXVlLnB1c2goe1xuICAgICAgICAgICAgZXZlbnQ6ICdyYXRlJyxcbiAgICAgICAgICAgIGFjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHNlbGYucmF0ZS5hcHBseShzZWxmLCBhcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2V0IHRoZSBncm91cCByYXRlLlxuICAgICAgICBpZiAodHlwZW9mIGlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHNlbGYuX3JhdGUgPSByYXRlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVXBkYXRlIG9uZSBvciBhbGwgdm9sdW1lcy5cbiAgICAgICAgaWQgPSBzZWxmLl9nZXRTb3VuZElkcyhpZCk7XG4gICAgICAgIGZvciAodmFyIGk9MDsgaTxpZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIC8vIEdldCB0aGUgc291bmQuXG4gICAgICAgICAgc291bmQgPSBzZWxmLl9zb3VuZEJ5SWQoaWRbaV0pO1xuXG4gICAgICAgICAgaWYgKHNvdW5kKSB7XG4gICAgICAgICAgICAvLyBLZWVwIHRyYWNrIG9mIG91ciBwb3NpdGlvbiB3aGVuIHRoZSByYXRlIGNoYW5nZWQgYW5kIHVwZGF0ZSB0aGUgcGxheWJhY2tcbiAgICAgICAgICAgIC8vIHN0YXJ0IHBvc2l0aW9uIHNvIHdlIGNhbiBwcm9wZXJseSBhZGp1c3QgdGhlIHNlZWsgcG9zaXRpb24gZm9yIHRpbWUgZWxhcHNlZC5cbiAgICAgICAgICAgIHNvdW5kLl9yYXRlU2VlayA9IHNlbGYuc2VlayhpZFtpXSk7XG4gICAgICAgICAgICBzb3VuZC5fcGxheVN0YXJ0ID0gc2VsZi5fd2ViQXVkaW8gPyBIb3dsZXIuY3R4LmN1cnJlbnRUaW1lIDogc291bmQuX3BsYXlTdGFydDtcbiAgICAgICAgICAgIHNvdW5kLl9yYXRlID0gcmF0ZTtcblxuICAgICAgICAgICAgLy8gQ2hhbmdlIHRoZSBwbGF5YmFjayByYXRlLlxuICAgICAgICAgICAgaWYgKHNlbGYuX3dlYkF1ZGlvICYmIHNvdW5kLl9ub2RlICYmIHNvdW5kLl9ub2RlLmJ1ZmZlclNvdXJjZSkge1xuICAgICAgICAgICAgICBzb3VuZC5fbm9kZS5idWZmZXJTb3VyY2UucGxheWJhY2tSYXRlLnZhbHVlID0gcmF0ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc291bmQuX25vZGUpIHtcbiAgICAgICAgICAgICAgc291bmQuX25vZGUucGxheWJhY2tSYXRlID0gcmF0ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gUmVzZXQgdGhlIHRpbWVycy5cbiAgICAgICAgICAgIHZhciBzZWVrID0gc2VsZi5zZWVrKGlkW2ldKTtcbiAgICAgICAgICAgIHZhciBkdXJhdGlvbiA9ICgoc2VsZi5fc3ByaXRlW3NvdW5kLl9zcHJpdGVdWzBdICsgc2VsZi5fc3ByaXRlW3NvdW5kLl9zcHJpdGVdWzFdKSAvIDEwMDApIC0gc2VlaztcbiAgICAgICAgICAgIHZhciB0aW1lb3V0ID0gKGR1cmF0aW9uICogMTAwMCkgLyBNYXRoLmFicyhzb3VuZC5fcmF0ZSk7XG5cbiAgICAgICAgICAgIC8vIFN0YXJ0IGEgbmV3IGVuZCB0aW1lciBpZiBzb3VuZCBpcyBhbHJlYWR5IHBsYXlpbmcuXG4gICAgICAgICAgICBpZiAoc2VsZi5fZW5kVGltZXJzW2lkW2ldXSB8fCAhc291bmQuX3BhdXNlZCkge1xuICAgICAgICAgICAgICBzZWxmLl9jbGVhclRpbWVyKGlkW2ldKTtcbiAgICAgICAgICAgICAgc2VsZi5fZW5kVGltZXJzW2lkW2ldXSA9IHNldFRpbWVvdXQoc2VsZi5fZW5kZWQuYmluZChzZWxmLCBzb3VuZCksIHRpbWVvdXQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzZWxmLl9lbWl0KCdyYXRlJywgc291bmQuX2lkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNvdW5kID0gc2VsZi5fc291bmRCeUlkKGlkKTtcbiAgICAgICAgcmV0dXJuIHNvdW5kID8gc291bmQuX3JhdGUgOiBzZWxmLl9yYXRlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0L3NldCB0aGUgc2VlayBwb3NpdGlvbiBvZiBhIHNvdW5kLiBUaGlzIG1ldGhvZCBjYW4gb3B0aW9uYWxseSB0YWtlIDAsIDEgb3IgMiBhcmd1bWVudHMuXG4gICAgICogICBzZWVrKCkgLT4gUmV0dXJucyB0aGUgZmlyc3Qgc291bmQgbm9kZSdzIGN1cnJlbnQgc2VlayBwb3NpdGlvbi5cbiAgICAgKiAgIHNlZWsoaWQpIC0+IFJldHVybnMgdGhlIHNvdW5kIGlkJ3MgY3VycmVudCBzZWVrIHBvc2l0aW9uLlxuICAgICAqICAgc2VlayhzZWVrKSAtPiBTZXRzIHRoZSBzZWVrIHBvc2l0aW9uIG9mIHRoZSBmaXJzdCBzb3VuZCBub2RlLlxuICAgICAqICAgc2VlayhzZWVrLCBpZCkgLT4gU2V0cyB0aGUgc2VlayBwb3NpdGlvbiBvZiBwYXNzZWQgc291bmQgaWQuXG4gICAgICogQHJldHVybiB7SG93bC9OdW1iZXJ9IFJldHVybnMgc2VsZiBvciB0aGUgY3VycmVudCBzZWVrIHBvc2l0aW9uLlxuICAgICAqL1xuICAgIHNlZWs6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICB2YXIgc2VlaywgaWQ7XG5cbiAgICAgIC8vIERldGVybWluZSB0aGUgdmFsdWVzIGJhc2VkIG9uIGFyZ3VtZW50cy5cbiAgICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAvLyBXZSB3aWxsIHNpbXBseSByZXR1cm4gdGhlIGN1cnJlbnQgcG9zaXRpb24gb2YgdGhlIGZpcnN0IG5vZGUuXG4gICAgICAgIGlkID0gc2VsZi5fc291bmRzWzBdLl9pZDtcbiAgICAgIH0gZWxzZSBpZiAoYXJncy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgLy8gRmlyc3QgY2hlY2sgaWYgdGhpcyBpcyBhbiBJRCwgYW5kIGlmIG5vdCwgYXNzdW1lIGl0IGlzIGEgbmV3IHNlZWsgcG9zaXRpb24uXG4gICAgICAgIHZhciBpZHMgPSBzZWxmLl9nZXRTb3VuZElkcygpO1xuICAgICAgICB2YXIgaW5kZXggPSBpZHMuaW5kZXhPZihhcmdzWzBdKTtcbiAgICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgICBpZCA9IHBhcnNlSW50KGFyZ3NbMF0sIDEwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZCA9IHNlbGYuX3NvdW5kc1swXS5faWQ7XG4gICAgICAgICAgc2VlayA9IHBhcnNlRmxvYXQoYXJnc1swXSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoYXJncy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgc2VlayA9IHBhcnNlRmxvYXQoYXJnc1swXSk7XG4gICAgICAgIGlkID0gcGFyc2VJbnQoYXJnc1sxXSwgMTApO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiB0aGVyZSBpcyBubyBJRCwgYmFpbCBvdXQuXG4gICAgICBpZiAodHlwZW9mIGlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgdGhlIHNvdW5kIGhhc24ndCBsb2FkZWQsIGFkZCBpdCB0byB0aGUgbG9hZCBxdWV1ZSB0byBzZWVrIHdoZW4gY2FwYWJsZS5cbiAgICAgIGlmIChzZWxmLl9zdGF0ZSAhPT0gJ2xvYWRlZCcpIHtcbiAgICAgICAgc2VsZi5fcXVldWUucHVzaCh7XG4gICAgICAgICAgZXZlbnQ6ICdzZWVrJyxcbiAgICAgICAgICBhY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc2VsZi5zZWVrLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICB9XG5cbiAgICAgIC8vIEdldCB0aGUgc291bmQuXG4gICAgICB2YXIgc291bmQgPSBzZWxmLl9zb3VuZEJ5SWQoaWQpO1xuXG4gICAgICBpZiAoc291bmQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZWVrID09PSAnbnVtYmVyJyAmJiBzZWVrID49IDApIHtcbiAgICAgICAgICAvLyBQYXVzZSB0aGUgc291bmQgYW5kIHVwZGF0ZSBwb3NpdGlvbiBmb3IgcmVzdGFydGluZyBwbGF5YmFjay5cbiAgICAgICAgICB2YXIgcGxheWluZyA9IHNlbGYucGxheWluZyhpZCk7XG4gICAgICAgICAgaWYgKHBsYXlpbmcpIHtcbiAgICAgICAgICAgIHNlbGYucGF1c2UoaWQsIHRydWUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIE1vdmUgdGhlIHBvc2l0aW9uIG9mIHRoZSB0cmFjayBhbmQgY2FuY2VsIHRpbWVyLlxuICAgICAgICAgIHNvdW5kLl9zZWVrID0gc2VlaztcbiAgICAgICAgICBzb3VuZC5fZW5kZWQgPSBmYWxzZTtcbiAgICAgICAgICBzZWxmLl9jbGVhclRpbWVyKGlkKTtcblxuICAgICAgICAgIC8vIFJlc3RhcnQgdGhlIHBsYXliYWNrIGlmIHRoZSBzb3VuZCB3YXMgcGxheWluZy5cbiAgICAgICAgICBpZiAocGxheWluZykge1xuICAgICAgICAgICAgc2VsZi5wbGF5KGlkLCB0cnVlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBVcGRhdGUgdGhlIHNlZWsgcG9zaXRpb24gZm9yIEhUTUw1IEF1ZGlvLlxuICAgICAgICAgIGlmICghc2VsZi5fd2ViQXVkaW8gJiYgc291bmQuX25vZGUpIHtcbiAgICAgICAgICAgIHNvdW5kLl9ub2RlLmN1cnJlbnRUaW1lID0gc2VlaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzZWxmLl9lbWl0KCdzZWVrJywgaWQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChzZWxmLl93ZWJBdWRpbykge1xuICAgICAgICAgICAgdmFyIHJlYWxUaW1lID0gc2VsZi5wbGF5aW5nKGlkKSA/IEhvd2xlci5jdHguY3VycmVudFRpbWUgLSBzb3VuZC5fcGxheVN0YXJ0IDogMDtcbiAgICAgICAgICAgIHZhciByYXRlU2VlayA9IHNvdW5kLl9yYXRlU2VlayA/IHNvdW5kLl9yYXRlU2VlayAtIHNvdW5kLl9zZWVrIDogMDtcbiAgICAgICAgICAgIHJldHVybiBzb3VuZC5fc2VlayArIChyYXRlU2VlayArIHJlYWxUaW1lICogTWF0aC5hYnMoc291bmQuX3JhdGUpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHNvdW5kLl9ub2RlLmN1cnJlbnRUaW1lO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgYSBzcGVjaWZpYyBzb3VuZCBpcyBjdXJyZW50bHkgcGxheWluZyBvciBub3QgKGlmIGlkIGlzIHByb3ZpZGVkKSwgb3IgY2hlY2sgaWYgYXQgbGVhc3Qgb25lIG9mIHRoZSBzb3VuZHMgaW4gdGhlIGdyb3VwIGlzIHBsYXlpbmcgb3Igbm90LlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gIGlkIFRoZSBzb3VuZCBpZCB0byBjaGVjay4gSWYgbm9uZSBpcyBwYXNzZWQsIHRoZSB3aG9sZSBzb3VuZCBncm91cCBpcyBjaGVja2VkLlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IFRydWUgaWYgcGxheWluZyBhbmQgZmFsc2UgaWYgbm90LlxuICAgICAqL1xuICAgIHBsYXlpbmc6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgIC8vIENoZWNrIHRoZSBwYXNzZWQgc291bmQgSUQgKGlmIGFueSkuXG4gICAgICBpZiAodHlwZW9mIGlkID09PSAnbnVtYmVyJykge1xuICAgICAgICB2YXIgc291bmQgPSBzZWxmLl9zb3VuZEJ5SWQoaWQpO1xuICAgICAgICByZXR1cm4gc291bmQgPyAhc291bmQuX3BhdXNlZCA6IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICAvLyBPdGhlcndpc2UsIGxvb3AgdGhyb3VnaCBhbGwgc291bmRzIGFuZCBjaGVjayBpZiBhbnkgYXJlIHBsYXlpbmcuXG4gICAgICBmb3IgKHZhciBpPTA7IGk8c2VsZi5fc291bmRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICghc2VsZi5fc291bmRzW2ldLl9wYXVzZWQpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgZHVyYXRpb24gb2YgdGhpcyBzb3VuZC4gUGFzc2luZyBhIHNvdW5kIGlkIHdpbGwgcmV0dXJuIHRoZSBzcHJpdGUgZHVyYXRpb24uXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBpZCBUaGUgc291bmQgaWQgdG8gY2hlY2suIElmIG5vbmUgaXMgcGFzc2VkLCByZXR1cm4gZnVsbCBzb3VyY2UgZHVyYXRpb24uXG4gICAgICogQHJldHVybiB7TnVtYmVyfSBBdWRpbyBkdXJhdGlvbiBpbiBzZWNvbmRzLlxuICAgICAqL1xuICAgIGR1cmF0aW9uOiBmdW5jdGlvbihpZCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIGR1cmF0aW9uID0gc2VsZi5fZHVyYXRpb247XG5cbiAgICAgIC8vIElmIHdlIHBhc3MgYW4gSUQsIGdldCB0aGUgc291bmQgYW5kIHJldHVybiB0aGUgc3ByaXRlIGxlbmd0aC5cbiAgICAgIHZhciBzb3VuZCA9IHNlbGYuX3NvdW5kQnlJZChpZCk7XG4gICAgICBpZiAoc291bmQpIHtcbiAgICAgICAgZHVyYXRpb24gPSBzZWxmLl9zcHJpdGVbc291bmQuX3Nwcml0ZV1bMV0gLyAxMDAwO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZHVyYXRpb247XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGN1cnJlbnQgbG9hZGVkIHN0YXRlIG9mIHRoaXMgSG93bC5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9ICd1bmxvYWRlZCcsICdsb2FkaW5nJywgJ2xvYWRlZCdcbiAgICAgKi9cbiAgICBzdGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc3RhdGU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFVubG9hZCBhbmQgZGVzdHJveSB0aGUgY3VycmVudCBIb3dsIG9iamVjdC5cbiAgICAgKiBUaGlzIHdpbGwgaW1tZWRpYXRlbHkgc3RvcCBhbGwgc291bmQgaW5zdGFuY2VzIGF0dGFjaGVkIHRvIHRoaXMgZ3JvdXAuXG4gICAgICovXG4gICAgdW5sb2FkOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgLy8gU3RvcCBwbGF5aW5nIGFueSBhY3RpdmUgc291bmRzLlxuICAgICAgdmFyIHNvdW5kcyA9IHNlbGYuX3NvdW5kcztcbiAgICAgIGZvciAodmFyIGk9MDsgaTxzb3VuZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gU3RvcCB0aGUgc291bmQgaWYgaXQgaXMgY3VycmVudGx5IHBsYXlpbmcuXG4gICAgICAgIGlmICghc291bmRzW2ldLl9wYXVzZWQpIHtcbiAgICAgICAgICBzZWxmLnN0b3Aoc291bmRzW2ldLl9pZCk7XG4gICAgICAgICAgc2VsZi5fZW1pdCgnZW5kJywgc291bmRzW2ldLl9pZCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZW1vdmUgdGhlIHNvdXJjZSBvciBkaXNjb25uZWN0LlxuICAgICAgICBpZiAoIXNlbGYuX3dlYkF1ZGlvKSB7XG4gICAgICAgICAgLy8gU2V0IHRoZSBzb3VyY2UgdG8gMC1zZWNvbmQgc2lsZW5jZSB0byBzdG9wIGFueSBkb3dubG9hZGluZy5cbiAgICAgICAgICBzb3VuZHNbaV0uX25vZGUuc3JjID0gJ2RhdGE6YXVkaW8vd2F2O2Jhc2U2NCxVa2xHUmlRQUFBQlhRVlpGWm0xMElCQUFBQUFCQUFFQVJLd0FBSWhZQVFBQ0FCQUFaR0YwWVFBQUFBQT0nO1xuXG4gICAgICAgICAgLy8gUmVtb3ZlIGFueSBldmVudCBsaXN0ZW5lcnMuXG4gICAgICAgICAgc291bmRzW2ldLl9ub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgc291bmRzW2ldLl9lcnJvckZuLCBmYWxzZSk7XG4gICAgICAgICAgc291bmRzW2ldLl9ub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoSG93bGVyLl9jYW5QbGF5RXZlbnQsIHNvdW5kc1tpXS5fbG9hZEZuLCBmYWxzZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBFbXB0eSBvdXQgYWxsIG9mIHRoZSBub2Rlcy5cbiAgICAgICAgZGVsZXRlIHNvdW5kc1tpXS5fbm9kZTtcblxuICAgICAgICAvLyBNYWtlIHN1cmUgYWxsIHRpbWVycyBhcmUgY2xlYXJlZCBvdXQuXG4gICAgICAgIHNlbGYuX2NsZWFyVGltZXIoc291bmRzW2ldLl9pZCk7XG5cbiAgICAgICAgLy8gUmVtb3ZlIHRoZSByZWZlcmVuY2VzIGluIHRoZSBnbG9iYWwgSG93bGVyIG9iamVjdC5cbiAgICAgICAgdmFyIGluZGV4ID0gSG93bGVyLl9ob3dscy5pbmRleE9mKHNlbGYpO1xuICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICAgIEhvd2xlci5faG93bHMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBEZWxldGUgdGhpcyBzb3VuZCBmcm9tIHRoZSBjYWNoZSAoaWYgbm8gb3RoZXIgSG93bCBpcyB1c2luZyBpdCkuXG4gICAgICB2YXIgcmVtQ2FjaGUgPSB0cnVlO1xuICAgICAgZm9yIChpPTA7IGk8SG93bGVyLl9ob3dscy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoSG93bGVyLl9ob3dsc1tpXS5fc3JjID09PSBzZWxmLl9zcmMpIHtcbiAgICAgICAgICByZW1DYWNoZSA9IGZhbHNlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChjYWNoZSAmJiByZW1DYWNoZSkge1xuICAgICAgICBkZWxldGUgY2FjaGVbc2VsZi5fc3JjXTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2xlYXIgb3V0IGBzZWxmYC5cbiAgICAgIHNlbGYuX3N0YXRlID0gJ3VubG9hZGVkJztcbiAgICAgIHNlbGYuX3NvdW5kcyA9IFtdO1xuICAgICAgc2VsZiA9IG51bGw7XG5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBMaXN0ZW4gdG8gYSBjdXN0b20gZXZlbnQuXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSAgIGV2ZW50IEV2ZW50IG5hbWUuXG4gICAgICogQHBhcmFtICB7RnVuY3Rpb259IGZuICAgIExpc3RlbmVyIHRvIGNhbGwuXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSAgIGlkICAgIChvcHRpb25hbCkgT25seSBsaXN0ZW4gdG8gZXZlbnRzIGZvciB0aGlzIHNvdW5kLlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gICBvbmNlICAoSU5URVJOQUwpIE1hcmtzIGV2ZW50IHRvIGZpcmUgb25seSBvbmNlLlxuICAgICAqIEByZXR1cm4ge0hvd2x9XG4gICAgICovXG4gICAgb246IGZ1bmN0aW9uKGV2ZW50LCBmbiwgaWQsIG9uY2UpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBldmVudHMgPSBzZWxmWydfb24nICsgZXZlbnRdO1xuXG4gICAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGV2ZW50cy5wdXNoKG9uY2UgPyB7aWQ6IGlkLCBmbjogZm4sIG9uY2U6IG9uY2V9IDoge2lkOiBpZCwgZm46IGZufSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYSBjdXN0b20gZXZlbnQuIENhbGwgd2l0aG91dCBwYXJhbWV0ZXJzIHRvIHJlbW92ZSBhbGwgZXZlbnRzLlxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gICBldmVudCBFdmVudCBuYW1lLlxuICAgICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBmbiAgICBMaXN0ZW5lciB0byByZW1vdmUuIExlYXZlIGVtcHR5IHRvIHJlbW92ZSBhbGwuXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSAgIGlkICAgIChvcHRpb25hbCkgT25seSByZW1vdmUgZXZlbnRzIGZvciB0aGlzIHNvdW5kLlxuICAgICAqIEByZXR1cm4ge0hvd2x9XG4gICAgICovXG4gICAgb2ZmOiBmdW5jdGlvbihldmVudCwgZm4sIGlkKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgZXZlbnRzID0gc2VsZlsnX29uJyArIGV2ZW50XTtcbiAgICAgIHZhciBpID0gMDtcblxuICAgICAgaWYgKGZuKSB7XG4gICAgICAgIC8vIExvb3AgdGhyb3VnaCBldmVudCBzdG9yZSBhbmQgcmVtb3ZlIHRoZSBwYXNzZWQgZnVuY3Rpb24uXG4gICAgICAgIGZvciAoaT0wOyBpPGV2ZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChmbiA9PT0gZXZlbnRzW2ldLmZuICYmIGlkID09PSBldmVudHNbaV0uaWQpIHtcbiAgICAgICAgICAgIGV2ZW50cy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZXZlbnQpIHtcbiAgICAgICAgLy8gQ2xlYXIgb3V0IGFsbCBldmVudHMgb2YgdGhpcyB0eXBlLlxuICAgICAgICBzZWxmWydfb24nICsgZXZlbnRdID0gW107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBDbGVhciBvdXQgYWxsIGV2ZW50cyBvZiBldmVyeSB0eXBlLlxuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHNlbGYpO1xuICAgICAgICBmb3IgKGk9MDsgaTxrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKChrZXlzW2ldLmluZGV4T2YoJ19vbicpID09PSAwKSAmJiBBcnJheS5pc0FycmF5KHNlbGZba2V5c1tpXV0pKSB7XG4gICAgICAgICAgICBzZWxmW2tleXNbaV1dID0gW107XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBMaXN0ZW4gdG8gYSBjdXN0b20gZXZlbnQgYW5kIHJlbW92ZSBpdCBvbmNlIGZpcmVkLlxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gICBldmVudCBFdmVudCBuYW1lLlxuICAgICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBmbiAgICBMaXN0ZW5lciB0byBjYWxsLlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gICBpZCAgICAob3B0aW9uYWwpIE9ubHkgbGlzdGVuIHRvIGV2ZW50cyBmb3IgdGhpcyBzb3VuZC5cbiAgICAgKiBAcmV0dXJuIHtIb3dsfVxuICAgICAqL1xuICAgIG9uY2U6IGZ1bmN0aW9uKGV2ZW50LCBmbiwgaWQpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgLy8gU2V0dXAgdGhlIGV2ZW50IGxpc3RlbmVyLlxuICAgICAgc2VsZi5vbihldmVudCwgZm4sIGlkLCAxKTtcblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEVtaXQgYWxsIGV2ZW50cyBvZiBhIHNwZWNpZmljIHR5cGUgYW5kIHBhc3MgdGhlIHNvdW5kIGlkLlxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gZXZlbnQgRXZlbnQgbmFtZS5cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGlkICAgIFNvdW5kIElELlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gbXNnICAgTWVzc2FnZSB0byBnbyB3aXRoIGV2ZW50LlxuICAgICAqIEByZXR1cm4ge0hvd2x9XG4gICAgICovXG4gICAgX2VtaXQ6IGZ1bmN0aW9uKGV2ZW50LCBpZCwgbXNnKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgZXZlbnRzID0gc2VsZlsnX29uJyArIGV2ZW50XTtcblxuICAgICAgLy8gTG9vcCB0aHJvdWdoIGV2ZW50IHN0b3JlIGFuZCBmaXJlIGFsbCBmdW5jdGlvbnMuXG4gICAgICBmb3IgKHZhciBpPWV2ZW50cy5sZW5ndGgtMTsgaT49MDsgaS0tKSB7XG4gICAgICAgIGlmICghZXZlbnRzW2ldLmlkIHx8IGV2ZW50c1tpXS5pZCA9PT0gaWQgfHwgZXZlbnQgPT09ICdsb2FkJykge1xuICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oZm4pIHtcbiAgICAgICAgICAgIGZuLmNhbGwodGhpcywgaWQsIG1zZyk7XG4gICAgICAgICAgfS5iaW5kKHNlbGYsIGV2ZW50c1tpXS5mbiksIDApO1xuXG4gICAgICAgICAgLy8gSWYgdGhpcyBldmVudCB3YXMgc2V0dXAgd2l0aCBgb25jZWAsIHJlbW92ZSBpdC5cbiAgICAgICAgICBpZiAoZXZlbnRzW2ldLm9uY2UpIHtcbiAgICAgICAgICAgIHNlbGYub2ZmKGV2ZW50LCBldmVudHNbaV0uZm4sIGV2ZW50c1tpXS5pZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBRdWV1ZSBvZiBhY3Rpb25zIGluaXRpYXRlZCBiZWZvcmUgdGhlIHNvdW5kIGhhcyBsb2FkZWQuXG4gICAgICogVGhlc2Ugd2lsbCBiZSBjYWxsZWQgaW4gc2VxdWVuY2UsIHdpdGggdGhlIG5leHQgb25seSBmaXJpbmdcbiAgICAgKiBhZnRlciB0aGUgcHJldmlvdXMgaGFzIGZpbmlzaGVkIGV4ZWN1dGluZyAoZXZlbiBpZiBhc3luYyBsaWtlIHBsYXkpLlxuICAgICAqIEByZXR1cm4ge0hvd2x9XG4gICAgICovXG4gICAgX2xvYWRRdWV1ZTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgIGlmIChzZWxmLl9xdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgIHZhciB0YXNrID0gc2VsZi5fcXVldWVbMF07XG5cbiAgICAgICAgLy8gZG9uJ3QgbW92ZSBvbnRvIHRoZSBuZXh0IHRhc2sgdW50aWwgdGhpcyBvbmUgaXMgZG9uZVxuICAgICAgICBzZWxmLm9uY2UodGFzay5ldmVudCwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgc2VsZi5fcXVldWUuc2hpZnQoKTtcbiAgICAgICAgICBzZWxmLl9sb2FkUXVldWUoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGFzay5hY3Rpb24oKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpcmVkIHdoZW4gcGxheWJhY2sgZW5kcyBhdCB0aGUgZW5kIG9mIHRoZSBkdXJhdGlvbi5cbiAgICAgKiBAcGFyYW0gIHtTb3VuZH0gc291bmQgVGhlIHNvdW5kIG9iamVjdCB0byB3b3JrIHdpdGguXG4gICAgICogQHJldHVybiB7SG93bH1cbiAgICAgKi9cbiAgICBfZW5kZWQ6IGZ1bmN0aW9uKHNvdW5kKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgc3ByaXRlID0gc291bmQuX3Nwcml0ZTtcblxuICAgICAgLy8gU2hvdWxkIHRoaXMgc291bmQgbG9vcD9cbiAgICAgIHZhciBsb29wID0gISEoc291bmQuX2xvb3AgfHwgc2VsZi5fc3ByaXRlW3Nwcml0ZV1bMl0pO1xuXG4gICAgICAvLyBGaXJlIHRoZSBlbmRlZCBldmVudC5cbiAgICAgIHNlbGYuX2VtaXQoJ2VuZCcsIHNvdW5kLl9pZCk7XG5cbiAgICAgIC8vIFJlc3RhcnQgdGhlIHBsYXliYWNrIGZvciBIVE1MNSBBdWRpbyBsb29wLlxuICAgICAgaWYgKCFzZWxmLl93ZWJBdWRpbyAmJiBsb29wKSB7XG4gICAgICAgIHNlbGYuc3RvcChzb3VuZC5faWQsIHRydWUpLnBsYXkoc291bmQuX2lkKTtcbiAgICAgIH1cblxuICAgICAgLy8gUmVzdGFydCB0aGlzIHRpbWVyIGlmIG9uIGEgV2ViIEF1ZGlvIGxvb3AuXG4gICAgICBpZiAoc2VsZi5fd2ViQXVkaW8gJiYgbG9vcCkge1xuICAgICAgICBzZWxmLl9lbWl0KCdwbGF5Jywgc291bmQuX2lkKTtcbiAgICAgICAgc291bmQuX3NlZWsgPSBzb3VuZC5fc3RhcnQgfHwgMDtcbiAgICAgICAgc291bmQuX3JhdGVTZWVrID0gMDtcbiAgICAgICAgc291bmQuX3BsYXlTdGFydCA9IEhvd2xlci5jdHguY3VycmVudFRpbWU7XG5cbiAgICAgICAgdmFyIHRpbWVvdXQgPSAoKHNvdW5kLl9zdG9wIC0gc291bmQuX3N0YXJ0KSAqIDEwMDApIC8gTWF0aC5hYnMoc291bmQuX3JhdGUpO1xuICAgICAgICBzZWxmLl9lbmRUaW1lcnNbc291bmQuX2lkXSA9IHNldFRpbWVvdXQoc2VsZi5fZW5kZWQuYmluZChzZWxmLCBzb3VuZCksIHRpbWVvdXQpO1xuICAgICAgfVxuXG4gICAgICAvLyBNYXJrIHRoZSBub2RlIGFzIHBhdXNlZC5cbiAgICAgIGlmIChzZWxmLl93ZWJBdWRpbyAmJiAhbG9vcCkge1xuICAgICAgICBzb3VuZC5fcGF1c2VkID0gdHJ1ZTtcbiAgICAgICAgc291bmQuX2VuZGVkID0gdHJ1ZTtcbiAgICAgICAgc291bmQuX3NlZWsgPSBzb3VuZC5fc3RhcnQgfHwgMDtcbiAgICAgICAgc291bmQuX3JhdGVTZWVrID0gMDtcbiAgICAgICAgc2VsZi5fY2xlYXJUaW1lcihzb3VuZC5faWQpO1xuXG4gICAgICAgIC8vIENsZWFuIHVwIHRoZSBidWZmZXIgc291cmNlLlxuICAgICAgICBzZWxmLl9jbGVhbkJ1ZmZlcihzb3VuZC5fbm9kZSk7XG5cbiAgICAgICAgLy8gQXR0ZW1wdCB0byBhdXRvLXN1c3BlbmQgQXVkaW9Db250ZXh0IGlmIG5vIHNvdW5kcyBhcmUgc3RpbGwgcGxheWluZy5cbiAgICAgICAgSG93bGVyLl9hdXRvU3VzcGVuZCgpO1xuICAgICAgfVxuXG4gICAgICAvLyBXaGVuIHVzaW5nIGEgc3ByaXRlLCBlbmQgdGhlIHRyYWNrLlxuICAgICAgaWYgKCFzZWxmLl93ZWJBdWRpbyAmJiAhbG9vcCkge1xuICAgICAgICBzZWxmLnN0b3Aoc291bmQuX2lkKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENsZWFyIHRoZSBlbmQgdGltZXIgZm9yIGEgc291bmQgcGxheWJhY2suXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBpZCBUaGUgc291bmQgSUQuXG4gICAgICogQHJldHVybiB7SG93bH1cbiAgICAgKi9cbiAgICBfY2xlYXJUaW1lcjogZnVuY3Rpb24oaWQpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgaWYgKHNlbGYuX2VuZFRpbWVyc1tpZF0pIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHNlbGYuX2VuZFRpbWVyc1tpZF0pO1xuICAgICAgICBkZWxldGUgc2VsZi5fZW5kVGltZXJzW2lkXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgc291bmQgaWRlbnRpZmllZCBieSB0aGlzIElELCBvciByZXR1cm4gbnVsbC5cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGlkIFNvdW5kIElEXG4gICAgICogQHJldHVybiB7T2JqZWN0fSAgICBTb3VuZCBvYmplY3Qgb3IgbnVsbC5cbiAgICAgKi9cbiAgICBfc291bmRCeUlkOiBmdW5jdGlvbihpZCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAvLyBMb29wIHRocm91Z2ggYWxsIHNvdW5kcyBhbmQgZmluZCB0aGUgb25lIHdpdGggdGhpcyBJRC5cbiAgICAgIGZvciAodmFyIGk9MDsgaTxzZWxmLl9zb3VuZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGlkID09PSBzZWxmLl9zb3VuZHNbaV0uX2lkKSB7XG4gICAgICAgICAgcmV0dXJuIHNlbGYuX3NvdW5kc1tpXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGFuIGluYWN0aXZlIHNvdW5kIGZyb20gdGhlIHBvb2wgb3IgY3JlYXRlIGEgbmV3IG9uZS5cbiAgICAgKiBAcmV0dXJuIHtTb3VuZH0gU291bmQgcGxheWJhY2sgb2JqZWN0LlxuICAgICAqL1xuICAgIF9pbmFjdGl2ZVNvdW5kOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgc2VsZi5fZHJhaW4oKTtcblxuICAgICAgLy8gRmluZCB0aGUgZmlyc3QgaW5hY3RpdmUgbm9kZSB0byByZWN5Y2xlLlxuICAgICAgZm9yICh2YXIgaT0wOyBpPHNlbGYuX3NvdW5kcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoc2VsZi5fc291bmRzW2ldLl9lbmRlZCkge1xuICAgICAgICAgIHJldHVybiBzZWxmLl9zb3VuZHNbaV0ucmVzZXQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBJZiBubyBpbmFjdGl2ZSBub2RlIHdhcyBmb3VuZCwgY3JlYXRlIGEgbmV3IG9uZS5cbiAgICAgIHJldHVybiBuZXcgU291bmQoc2VsZik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERyYWluIGV4Y2VzcyBpbmFjdGl2ZSBzb3VuZHMgZnJvbSB0aGUgcG9vbC5cbiAgICAgKi9cbiAgICBfZHJhaW46IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIGxpbWl0ID0gc2VsZi5fcG9vbDtcbiAgICAgIHZhciBjbnQgPSAwO1xuICAgICAgdmFyIGkgPSAwO1xuXG4gICAgICAvLyBJZiB0aGVyZSBhcmUgbGVzcyBzb3VuZHMgdGhhbiB0aGUgbWF4IHBvb2wgc2l6ZSwgd2UgYXJlIGRvbmUuXG4gICAgICBpZiAoc2VsZi5fc291bmRzLmxlbmd0aCA8IGxpbWl0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gQ291bnQgdGhlIG51bWJlciBvZiBpbmFjdGl2ZSBzb3VuZHMuXG4gICAgICBmb3IgKGk9MDsgaTxzZWxmLl9zb3VuZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHNlbGYuX3NvdW5kc1tpXS5fZW5kZWQpIHtcbiAgICAgICAgICBjbnQrKztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBSZW1vdmUgZXhjZXNzIGluYWN0aXZlIHNvdW5kcywgZ29pbmcgaW4gcmV2ZXJzZSBvcmRlci5cbiAgICAgIGZvciAoaT1zZWxmLl9zb3VuZHMubGVuZ3RoIC0gMTsgaT49MDsgaS0tKSB7XG4gICAgICAgIGlmIChjbnQgPD0gbGltaXQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2VsZi5fc291bmRzW2ldLl9lbmRlZCkge1xuICAgICAgICAgIC8vIERpc2Nvbm5lY3QgdGhlIGF1ZGlvIHNvdXJjZSB3aGVuIHVzaW5nIFdlYiBBdWRpby5cbiAgICAgICAgICBpZiAoc2VsZi5fd2ViQXVkaW8gJiYgc2VsZi5fc291bmRzW2ldLl9ub2RlKSB7XG4gICAgICAgICAgICBzZWxmLl9zb3VuZHNbaV0uX25vZGUuZGlzY29ubmVjdCgwKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBSZW1vdmUgc291bmRzIHVudGlsIHdlIGhhdmUgdGhlIHBvb2wgc2l6ZS5cbiAgICAgICAgICBzZWxmLl9zb3VuZHMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgIGNudC0tO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBhbGwgSUQncyBmcm9tIHRoZSBzb3VuZHMgcG9vbC5cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGlkIE9ubHkgcmV0dXJuIG9uZSBJRCBpZiBvbmUgaXMgcGFzc2VkLlxuICAgICAqIEByZXR1cm4ge0FycmF5fSAgICBBcnJheSBvZiBJRHMuXG4gICAgICovXG4gICAgX2dldFNvdW5kSWRzOiBmdW5jdGlvbihpZCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICBpZiAodHlwZW9mIGlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB2YXIgaWRzID0gW107XG4gICAgICAgIGZvciAodmFyIGk9MDsgaTxzZWxmLl9zb3VuZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZHMucHVzaChzZWxmLl9zb3VuZHNbaV0uX2lkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpZHM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gW2lkXTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTG9hZCB0aGUgc291bmQgYmFjayBpbnRvIHRoZSBidWZmZXIgc291cmNlLlxuICAgICAqIEBwYXJhbSAge1NvdW5kfSBzb3VuZCBUaGUgc291bmQgb2JqZWN0IHRvIHdvcmsgd2l0aC5cbiAgICAgKiBAcmV0dXJuIHtIb3dsfVxuICAgICAqL1xuICAgIF9yZWZyZXNoQnVmZmVyOiBmdW5jdGlvbihzb3VuZCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAvLyBTZXR1cCB0aGUgYnVmZmVyIHNvdXJjZSBmb3IgcGxheWJhY2suXG4gICAgICBzb3VuZC5fbm9kZS5idWZmZXJTb3VyY2UgPSBIb3dsZXIuY3R4LmNyZWF0ZUJ1ZmZlclNvdXJjZSgpO1xuICAgICAgc291bmQuX25vZGUuYnVmZmVyU291cmNlLmJ1ZmZlciA9IGNhY2hlW3NlbGYuX3NyY107XG5cbiAgICAgIC8vIENvbm5lY3QgdG8gdGhlIGNvcnJlY3Qgbm9kZS5cbiAgICAgIGlmIChzb3VuZC5fcGFubmVyKSB7XG4gICAgICAgIHNvdW5kLl9ub2RlLmJ1ZmZlclNvdXJjZS5jb25uZWN0KHNvdW5kLl9wYW5uZXIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc291bmQuX25vZGUuYnVmZmVyU291cmNlLmNvbm5lY3Qoc291bmQuX25vZGUpO1xuICAgICAgfVxuXG4gICAgICAvLyBTZXR1cCBsb29waW5nIGFuZCBwbGF5YmFjayByYXRlLlxuICAgICAgc291bmQuX25vZGUuYnVmZmVyU291cmNlLmxvb3AgPSBzb3VuZC5fbG9vcDtcbiAgICAgIGlmIChzb3VuZC5fbG9vcCkge1xuICAgICAgICBzb3VuZC5fbm9kZS5idWZmZXJTb3VyY2UubG9vcFN0YXJ0ID0gc291bmQuX3N0YXJ0IHx8IDA7XG4gICAgICAgIHNvdW5kLl9ub2RlLmJ1ZmZlclNvdXJjZS5sb29wRW5kID0gc291bmQuX3N0b3A7XG4gICAgICB9XG4gICAgICBzb3VuZC5fbm9kZS5idWZmZXJTb3VyY2UucGxheWJhY2tSYXRlLnZhbHVlID0gc291bmQuX3JhdGU7XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQcmV2ZW50IG1lbW9yeSBsZWFrcyBieSBjbGVhbmluZyB1cCB0aGUgYnVmZmVyIHNvdXJjZSBhZnRlciBwbGF5YmFjay5cbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IG5vZGUgU291bmQncyBhdWRpbyBub2RlIGNvbnRhaW5pbmcgdGhlIGJ1ZmZlciBzb3VyY2UuXG4gICAgICogQHJldHVybiB7SG93bH1cbiAgICAgKi9cbiAgICBfY2xlYW5CdWZmZXI6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgaWYgKHNlbGYuX3NjcmF0Y2hCdWZmZXIpIHtcbiAgICAgICAgbm9kZS5idWZmZXJTb3VyY2Uub25lbmRlZCA9IG51bGw7XG4gICAgICAgIG5vZGUuYnVmZmVyU291cmNlLmRpc2Nvbm5lY3QoMCk7XG4gICAgICAgIHRyeSB7IG5vZGUuYnVmZmVyU291cmNlLmJ1ZmZlciA9IHNlbGYuX3NjcmF0Y2hCdWZmZXI7IH0gY2F0Y2goZSkge31cbiAgICAgIH1cbiAgICAgIG5vZGUuYnVmZmVyU291cmNlID0gbnVsbDtcblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuICB9O1xuXG4gIC8qKiBTaW5nbGUgU291bmQgTWV0aG9kcyAqKi9cbiAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAvKipcbiAgICogU2V0dXAgdGhlIHNvdW5kIG9iamVjdCwgd2hpY2ggZWFjaCBub2RlIGF0dGFjaGVkIHRvIGEgSG93bCBncm91cCBpcyBjb250YWluZWQgaW4uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBob3dsIFRoZSBIb3dsIHBhcmVudCBncm91cC5cbiAgICovXG4gIHZhciBTb3VuZCA9IGZ1bmN0aW9uKGhvd2wpIHtcbiAgICB0aGlzLl9wYXJlbnQgPSBob3dsO1xuICAgIHRoaXMuaW5pdCgpO1xuICB9O1xuICBTb3VuZC5wcm90b3R5cGUgPSB7XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSBhIG5ldyBTb3VuZCBvYmplY3QuXG4gICAgICogQHJldHVybiB7U291bmR9XG4gICAgICovXG4gICAgaW5pdDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgcGFyZW50ID0gc2VsZi5fcGFyZW50O1xuXG4gICAgICAvLyBTZXR1cCB0aGUgZGVmYXVsdCBwYXJhbWV0ZXJzLlxuICAgICAgc2VsZi5fbXV0ZWQgPSBwYXJlbnQuX211dGVkO1xuICAgICAgc2VsZi5fbG9vcCA9IHBhcmVudC5fbG9vcDtcbiAgICAgIHNlbGYuX3ZvbHVtZSA9IHBhcmVudC5fdm9sdW1lO1xuICAgICAgc2VsZi5fbXV0ZWQgPSBwYXJlbnQuX211dGVkO1xuICAgICAgc2VsZi5fcmF0ZSA9IHBhcmVudC5fcmF0ZTtcbiAgICAgIHNlbGYuX3NlZWsgPSAwO1xuICAgICAgc2VsZi5fcGF1c2VkID0gdHJ1ZTtcbiAgICAgIHNlbGYuX2VuZGVkID0gdHJ1ZTtcbiAgICAgIHNlbGYuX3Nwcml0ZSA9ICdfX2RlZmF1bHQnO1xuXG4gICAgICAvLyBHZW5lcmF0ZSBhIHVuaXF1ZSBJRCBmb3IgdGhpcyBzb3VuZC5cbiAgICAgIHNlbGYuX2lkID0gTWF0aC5yb3VuZChEYXRlLm5vdygpICogTWF0aC5yYW5kb20oKSk7XG5cbiAgICAgIC8vIEFkZCBpdHNlbGYgdG8gdGhlIHBhcmVudCdzIHBvb2wuXG4gICAgICBwYXJlbnQuX3NvdW5kcy5wdXNoKHNlbGYpO1xuXG4gICAgICAvLyBDcmVhdGUgdGhlIG5ldyBub2RlLlxuICAgICAgc2VsZi5jcmVhdGUoKTtcblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhbmQgc2V0dXAgYSBuZXcgc291bmQgb2JqZWN0LCB3aGV0aGVyIEhUTUw1IEF1ZGlvIG9yIFdlYiBBdWRpby5cbiAgICAgKiBAcmV0dXJuIHtTb3VuZH1cbiAgICAgKi9cbiAgICBjcmVhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIHBhcmVudCA9IHNlbGYuX3BhcmVudDtcbiAgICAgIHZhciB2b2x1bWUgPSAoSG93bGVyLl9tdXRlZCB8fCBzZWxmLl9tdXRlZCB8fCBzZWxmLl9wYXJlbnQuX211dGVkKSA/IDAgOiBzZWxmLl92b2x1bWU7XG5cbiAgICAgIGlmIChwYXJlbnQuX3dlYkF1ZGlvKSB7XG4gICAgICAgIC8vIENyZWF0ZSB0aGUgZ2FpbiBub2RlIGZvciBjb250cm9sbGluZyB2b2x1bWUgKHRoZSBzb3VyY2Ugd2lsbCBjb25uZWN0IHRvIHRoaXMpLlxuICAgICAgICBzZWxmLl9ub2RlID0gKHR5cGVvZiBIb3dsZXIuY3R4LmNyZWF0ZUdhaW4gPT09ICd1bmRlZmluZWQnKSA/IEhvd2xlci5jdHguY3JlYXRlR2Fpbk5vZGUoKSA6IEhvd2xlci5jdHguY3JlYXRlR2FpbigpO1xuICAgICAgICBzZWxmLl9ub2RlLmdhaW4uc2V0VmFsdWVBdFRpbWUodm9sdW1lLCBIb3dsZXIuY3R4LmN1cnJlbnRUaW1lKTtcbiAgICAgICAgc2VsZi5fbm9kZS5wYXVzZWQgPSB0cnVlO1xuICAgICAgICBzZWxmLl9ub2RlLmNvbm5lY3QoSG93bGVyLm1hc3RlckdhaW4pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VsZi5fbm9kZSA9IG5ldyBBdWRpbygpO1xuXG4gICAgICAgIC8vIExpc3RlbiBmb3IgZXJyb3JzIChodHRwOi8vZGV2LnczLm9yZy9odG1sNS9zcGVjLWF1dGhvci12aWV3L3NwZWMuaHRtbCNtZWRpYWVycm9yKS5cbiAgICAgICAgc2VsZi5fZXJyb3JGbiA9IHNlbGYuX2Vycm9yTGlzdGVuZXIuYmluZChzZWxmKTtcbiAgICAgICAgc2VsZi5fbm9kZS5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIHNlbGYuX2Vycm9yRm4sIGZhbHNlKTtcblxuICAgICAgICAvLyBMaXN0ZW4gZm9yICdjYW5wbGF5dGhyb3VnaCcgZXZlbnQgdG8gbGV0IHVzIGtub3cgdGhlIHNvdW5kIGlzIHJlYWR5LlxuICAgICAgICBzZWxmLl9sb2FkRm4gPSBzZWxmLl9sb2FkTGlzdGVuZXIuYmluZChzZWxmKTtcbiAgICAgICAgc2VsZi5fbm9kZS5hZGRFdmVudExpc3RlbmVyKEhvd2xlci5fY2FuUGxheUV2ZW50LCBzZWxmLl9sb2FkRm4sIGZhbHNlKTtcblxuICAgICAgICAvLyBTZXR1cCB0aGUgbmV3IGF1ZGlvIG5vZGUuXG4gICAgICAgIHNlbGYuX25vZGUuc3JjID0gcGFyZW50Ll9zcmM7XG4gICAgICAgIHNlbGYuX25vZGUucHJlbG9hZCA9ICdhdXRvJztcbiAgICAgICAgc2VsZi5fbm9kZS52b2x1bWUgPSB2b2x1bWUgKiBIb3dsZXIudm9sdW1lKCk7XG5cbiAgICAgICAgLy8gQmVnaW4gbG9hZGluZyB0aGUgc291cmNlLlxuICAgICAgICBzZWxmLl9ub2RlLmxvYWQoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlc2V0IHRoZSBwYXJhbWV0ZXJzIG9mIHRoaXMgc291bmQgdG8gdGhlIG9yaWdpbmFsIHN0YXRlIChmb3IgcmVjeWNsZSkuXG4gICAgICogQHJldHVybiB7U291bmR9XG4gICAgICovXG4gICAgcmVzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIHBhcmVudCA9IHNlbGYuX3BhcmVudDtcblxuICAgICAgLy8gUmVzZXQgYWxsIG9mIHRoZSBwYXJhbWV0ZXJzIG9mIHRoaXMgc291bmQuXG4gICAgICBzZWxmLl9tdXRlZCA9IHBhcmVudC5fbXV0ZWQ7XG4gICAgICBzZWxmLl9sb29wID0gcGFyZW50Ll9sb29wO1xuICAgICAgc2VsZi5fdm9sdW1lID0gcGFyZW50Ll92b2x1bWU7XG4gICAgICBzZWxmLl9tdXRlZCA9IHBhcmVudC5fbXV0ZWQ7XG4gICAgICBzZWxmLl9yYXRlID0gcGFyZW50Ll9yYXRlO1xuICAgICAgc2VsZi5fc2VlayA9IDA7XG4gICAgICBzZWxmLl9yYXRlU2VlayA9IDA7XG4gICAgICBzZWxmLl9wYXVzZWQgPSB0cnVlO1xuICAgICAgc2VsZi5fZW5kZWQgPSB0cnVlO1xuICAgICAgc2VsZi5fc3ByaXRlID0gJ19fZGVmYXVsdCc7XG5cbiAgICAgIC8vIEdlbmVyYXRlIGEgbmV3IElEIHNvIHRoYXQgaXQgaXNuJ3QgY29uZnVzZWQgd2l0aCB0aGUgcHJldmlvdXMgc291bmQuXG4gICAgICBzZWxmLl9pZCA9IE1hdGgucm91bmQoRGF0ZS5ub3coKSAqIE1hdGgucmFuZG9tKCkpO1xuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSFRNTDUgQXVkaW8gZXJyb3IgbGlzdGVuZXIgY2FsbGJhY2suXG4gICAgICovXG4gICAgX2Vycm9yTGlzdGVuZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICBpZiAoc2VsZi5fbm9kZS5lcnJvciAmJiBzZWxmLl9ub2RlLmVycm9yLmNvZGUgPT09IDQpIHtcbiAgICAgICAgSG93bGVyLm5vQXVkaW8gPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBGaXJlIGFuIGVycm9yIGV2ZW50IGFuZCBwYXNzIGJhY2sgdGhlIGNvZGUuXG4gICAgICBzZWxmLl9wYXJlbnQuX2VtaXQoJ2xvYWRlcnJvcicsIHNlbGYuX2lkLCBzZWxmLl9ub2RlLmVycm9yID8gc2VsZi5fbm9kZS5lcnJvci5jb2RlIDogMCk7XG5cbiAgICAgIC8vIENsZWFyIHRoZSBldmVudCBsaXN0ZW5lci5cbiAgICAgIHNlbGYuX25vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXJyb3InLCBzZWxmLl9lcnJvckxpc3RlbmVyLCBmYWxzZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEhUTUw1IEF1ZGlvIGNhbnBsYXl0aHJvdWdoIGxpc3RlbmVyIGNhbGxiYWNrLlxuICAgICAqL1xuICAgIF9sb2FkTGlzdGVuZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIHBhcmVudCA9IHNlbGYuX3BhcmVudDtcblxuICAgICAgLy8gUm91bmQgdXAgdGhlIGR1cmF0aW9uIHRvIGFjY291bnQgZm9yIHRoZSBsb3dlciBwcmVjaXNpb24gaW4gSFRNTDUgQXVkaW8uXG4gICAgICBwYXJlbnQuX2R1cmF0aW9uID0gTWF0aC5jZWlsKHNlbGYuX25vZGUuZHVyYXRpb24gKiAxMCkgLyAxMDtcblxuICAgICAgLy8gU2V0dXAgYSBzcHJpdGUgaWYgbm9uZSBpcyBkZWZpbmVkLlxuICAgICAgaWYgKE9iamVjdC5rZXlzKHBhcmVudC5fc3ByaXRlKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcGFyZW50Ll9zcHJpdGUgPSB7X19kZWZhdWx0OiBbMCwgcGFyZW50Ll9kdXJhdGlvbiAqIDEwMDBdfTtcbiAgICAgIH1cblxuICAgICAgaWYgKHBhcmVudC5fc3RhdGUgIT09ICdsb2FkZWQnKSB7XG4gICAgICAgIHBhcmVudC5fc3RhdGUgPSAnbG9hZGVkJztcbiAgICAgICAgcGFyZW50Ll9lbWl0KCdsb2FkJyk7XG4gICAgICAgIHBhcmVudC5fbG9hZFF1ZXVlKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwYXJlbnQuX2F1dG9wbGF5KSB7XG4gICAgICAgIHBhcmVudC5wbGF5KCk7XG4gICAgICB9XG5cbiAgICAgIC8vIENsZWFyIHRoZSBldmVudCBsaXN0ZW5lci5cbiAgICAgIHNlbGYuX25vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihIb3dsZXIuX2NhblBsYXlFdmVudCwgc2VsZi5fbG9hZEZuLCBmYWxzZSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKiBIZWxwZXIgTWV0aG9kcyAqKi9cbiAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICB2YXIgY2FjaGUgPSB7fTtcblxuICAvKipcbiAgICogQnVmZmVyIGEgc291bmQgZnJvbSBVUkwsIERhdGEgVVJJIG9yIGNhY2hlIGFuZCBkZWNvZGUgdG8gYXVkaW8gc291cmNlIChXZWIgQXVkaW8gQVBJKS5cbiAgICogQHBhcmFtICB7SG93bH0gc2VsZlxuICAgKi9cbiAgdmFyIGxvYWRCdWZmZXIgPSBmdW5jdGlvbihzZWxmKSB7XG4gICAgdmFyIHVybCA9IHNlbGYuX3NyYztcblxuICAgIC8vIENoZWNrIGlmIHRoZSBidWZmZXIgaGFzIGFscmVhZHkgYmVlbiBjYWNoZWQgYW5kIHVzZSBpdCBpbnN0ZWFkLlxuICAgIGlmIChjYWNoZVt1cmxdKSB7XG4gICAgICAvLyBTZXQgdGhlIGR1cmF0aW9uIGZyb20gdGhlIGNhY2hlLlxuICAgICAgc2VsZi5fZHVyYXRpb24gPSBjYWNoZVt1cmxdLmR1cmF0aW9uO1xuXG4gICAgICAvLyBMb2FkIHRoZSBzb3VuZCBpbnRvIHRoaXMgSG93bC5cbiAgICAgIGxvYWRTb3VuZChzZWxmKTtcblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICgvXmRhdGE6W147XSs7YmFzZTY0LC8udGVzdCh1cmwpKSB7XG4gICAgICAvLyBEZWNvZGUgdGhlIGJhc2U2NCBkYXRhIFVSSSB3aXRob3V0IFhIUiwgc2luY2Ugc29tZSBicm93c2VycyBkb24ndCBzdXBwb3J0IGl0LlxuICAgICAgdmFyIGRhdGEgPSBhdG9iKHVybC5zcGxpdCgnLCcpWzFdKTtcbiAgICAgIHZhciBkYXRhVmlldyA9IG5ldyBVaW50OEFycmF5KGRhdGEubGVuZ3RoKTtcbiAgICAgIGZvciAodmFyIGk9MDsgaTxkYXRhLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGRhdGFWaWV3W2ldID0gZGF0YS5jaGFyQ29kZUF0KGkpO1xuICAgICAgfVxuXG4gICAgICBkZWNvZGVBdWRpb0RhdGEoZGF0YVZpZXcuYnVmZmVyLCBzZWxmKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTG9hZCB0aGUgYnVmZmVyIGZyb20gdGhlIFVSTC5cbiAgICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgIHhoci5vcGVuKCdHRVQnLCB1cmwsIHRydWUpO1xuICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9ICdhcnJheWJ1ZmZlcic7XG4gICAgICB4aHIub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBnZXQgYSBzdWNjZXNzZnVsIHJlc3BvbnNlIGJhY2suXG4gICAgICAgIHZhciBjb2RlID0gKHhoci5zdGF0dXMgKyAnJylbMF07XG4gICAgICAgIGlmIChjb2RlICE9PSAnMCcgJiYgY29kZSAhPT0gJzInICYmIGNvZGUgIT09ICczJykge1xuICAgICAgICAgIHNlbGYuX2VtaXQoJ2xvYWRlcnJvcicsIG51bGwsICdGYWlsZWQgbG9hZGluZyBhdWRpbyBmaWxlIHdpdGggc3RhdHVzOiAnICsgeGhyLnN0YXR1cyArICcuJyk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVjb2RlQXVkaW9EYXRhKHhoci5yZXNwb25zZSwgc2VsZik7XG4gICAgICB9O1xuICAgICAgeGhyLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgYW4gZXJyb3IsIHN3aXRjaCB0byBIVE1MNSBBdWRpby5cbiAgICAgICAgaWYgKHNlbGYuX3dlYkF1ZGlvKSB7XG4gICAgICAgICAgc2VsZi5faHRtbDUgPSB0cnVlO1xuICAgICAgICAgIHNlbGYuX3dlYkF1ZGlvID0gZmFsc2U7XG4gICAgICAgICAgc2VsZi5fc291bmRzID0gW107XG4gICAgICAgICAgZGVsZXRlIGNhY2hlW3VybF07XG4gICAgICAgICAgc2VsZi5sb2FkKCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBzYWZlWGhyU2VuZCh4aHIpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogU2VuZCB0aGUgWEhSIHJlcXVlc3Qgd3JhcHBlZCBpbiBhIHRyeS9jYXRjaC5cbiAgICogQHBhcmFtICB7T2JqZWN0fSB4aHIgWEhSIHRvIHNlbmQuXG4gICAqL1xuICB2YXIgc2FmZVhoclNlbmQgPSBmdW5jdGlvbih4aHIpIHtcbiAgICB0cnkge1xuICAgICAgeGhyLnNlbmQoKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB4aHIub25lcnJvcigpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogRGVjb2RlIGF1ZGlvIGRhdGEgZnJvbSBhbiBhcnJheSBidWZmZXIuXG4gICAqIEBwYXJhbSAge0FycmF5QnVmZmVyfSBhcnJheWJ1ZmZlciBUaGUgYXVkaW8gZGF0YS5cbiAgICogQHBhcmFtICB7SG93bH0gICAgICAgIHNlbGZcbiAgICovXG4gIHZhciBkZWNvZGVBdWRpb0RhdGEgPSBmdW5jdGlvbihhcnJheWJ1ZmZlciwgc2VsZikge1xuICAgIC8vIERlY29kZSB0aGUgYnVmZmVyIGludG8gYW4gYXVkaW8gc291cmNlLlxuICAgIEhvd2xlci5jdHguZGVjb2RlQXVkaW9EYXRhKGFycmF5YnVmZmVyLCBmdW5jdGlvbihidWZmZXIpIHtcbiAgICAgIGlmIChidWZmZXIgJiYgc2VsZi5fc291bmRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY2FjaGVbc2VsZi5fc3JjXSA9IGJ1ZmZlcjtcbiAgICAgICAgbG9hZFNvdW5kKHNlbGYsIGJ1ZmZlcik7XG4gICAgICB9XG4gICAgfSwgZnVuY3Rpb24oKSB7XG4gICAgICBzZWxmLl9lbWl0KCdsb2FkZXJyb3InLCBudWxsLCAnRGVjb2RpbmcgYXVkaW8gZGF0YSBmYWlsZWQuJyk7XG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNvdW5kIGlzIG5vdyBsb2FkZWQsIHNvIGZpbmlzaCBzZXR0aW5nIGV2ZXJ5dGhpbmcgdXAgYW5kIGZpcmUgdGhlIGxvYWRlZCBldmVudC5cbiAgICogQHBhcmFtICB7SG93bH0gc2VsZlxuICAgKiBAcGFyYW0gIHtPYmplY3R9IGJ1ZmZlciBUaGUgZGVjb2RlZCBidWZmZXIgc291bmQgc291cmNlLlxuICAgKi9cbiAgdmFyIGxvYWRTb3VuZCA9IGZ1bmN0aW9uKHNlbGYsIGJ1ZmZlcikge1xuICAgIC8vIFNldCB0aGUgZHVyYXRpb24uXG4gICAgaWYgKGJ1ZmZlciAmJiAhc2VsZi5fZHVyYXRpb24pIHtcbiAgICAgIHNlbGYuX2R1cmF0aW9uID0gYnVmZmVyLmR1cmF0aW9uO1xuICAgIH1cblxuICAgIC8vIFNldHVwIGEgc3ByaXRlIGlmIG5vbmUgaXMgZGVmaW5lZC5cbiAgICBpZiAoT2JqZWN0LmtleXMoc2VsZi5fc3ByaXRlKS5sZW5ndGggPT09IDApIHtcbiAgICAgIHNlbGYuX3Nwcml0ZSA9IHtfX2RlZmF1bHQ6IFswLCBzZWxmLl9kdXJhdGlvbiAqIDEwMDBdfTtcbiAgICB9XG5cbiAgICAvLyBGaXJlIHRoZSBsb2FkZWQgZXZlbnQuXG4gICAgaWYgKHNlbGYuX3N0YXRlICE9PSAnbG9hZGVkJykge1xuICAgICAgc2VsZi5fc3RhdGUgPSAnbG9hZGVkJztcbiAgICAgIHNlbGYuX2VtaXQoJ2xvYWQnKTtcbiAgICAgIHNlbGYuX2xvYWRRdWV1ZSgpO1xuICAgIH1cblxuICAgIC8vIEJlZ2luIHBsYXliYWNrIGlmIHNwZWNpZmllZC5cbiAgICBpZiAoc2VsZi5fYXV0b3BsYXkpIHtcbiAgICAgIHNlbGYucGxheSgpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogU2V0dXAgdGhlIGF1ZGlvIGNvbnRleHQgd2hlbiBhdmFpbGFibGUsIG9yIHN3aXRjaCB0byBIVE1MNSBBdWRpbyBtb2RlLlxuICAgKi9cbiAgdmFyIHNldHVwQXVkaW9Db250ZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgSG93bGVyLm5vQXVkaW8gPSBmYWxzZTtcblxuICAgIC8vIENoZWNrIGlmIHdlIGFyZSB1c2luZyBXZWIgQXVkaW8gYW5kIHNldHVwIHRoZSBBdWRpb0NvbnRleHQgaWYgd2UgYXJlLlxuICAgIHRyeSB7XG4gICAgICBpZiAodHlwZW9mIEF1ZGlvQ29udGV4dCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgSG93bGVyLmN0eCA9IG5ldyBBdWRpb0NvbnRleHQoKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHdlYmtpdEF1ZGlvQ29udGV4dCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgSG93bGVyLmN0eCA9IG5ldyB3ZWJraXRBdWRpb0NvbnRleHQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIEhvd2xlci51c2luZ1dlYkF1ZGlvID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSBjYXRjaChlKSB7XG4gICAgICBIb3dsZXIudXNpbmdXZWJBdWRpbyA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmICghSG93bGVyLnVzaW5nV2ViQXVkaW8pIHtcbiAgICAgIC8vIE5vIGF1ZGlvIGlzIGF2YWlsYWJsZSBvbiB0aGlzIHN5c3RlbSBpZiBub0F1ZGlvIGlzIHNldCB0byB0cnVlLlxuICAgICAgaWYgKHR5cGVvZiBBdWRpbyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB2YXIgdGVzdCA9IG5ldyBBdWRpbygpO1xuXG4gICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGNhbnBsYXl0aHJvdWdoIGV2ZW50IGlzIGF2YWlsYWJsZS5cbiAgICAgICAgICBpZiAodHlwZW9mIHRlc3Qub25jYW5wbGF5dGhyb3VnaCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIEhvd2xlci5fY2FuUGxheUV2ZW50ID0gJ2NhbnBsYXknO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgICAgSG93bGVyLm5vQXVkaW8gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBIb3dsZXIubm9BdWRpbyA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVGVzdCB0byBtYWtlIHN1cmUgYXVkaW8gaXNuJ3QgZGlzYWJsZWQgaW4gSW50ZXJuZXQgRXhwbG9yZXJcbiAgICB0cnkge1xuICAgICAgdmFyIHRlc3QgPSBuZXcgQXVkaW8oKTtcbiAgICAgIGlmICh0ZXN0Lm11dGVkKSB7XG4gICAgICAgIEhvd2xlci5ub0F1ZGlvID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7fVxuXG4gICAgLy8gQ2hlY2sgaWYgYSB3ZWJ2aWV3IGlzIGJlaW5nIHVzZWQgb24gaU9TOCBvciBlYXJsaWVyIChyYXRoZXIgdGhhbiB0aGUgYnJvd3NlcikuXG4gICAgLy8gSWYgaXQgaXMsIGRpc2FibGUgV2ViIEF1ZGlvIGFzIGl0IGNhdXNlcyBjcmFzaGluZy5cbiAgICB2YXIgaU9TID0gKC9pUChob25lfG9kfGFkKS8udGVzdChIb3dsZXIuX25hdmlnYXRvciAmJiBIb3dsZXIuX25hdmlnYXRvci5wbGF0Zm9ybSkpO1xuICAgIHZhciBhcHBWZXJzaW9uID0gSG93bGVyLl9uYXZpZ2F0b3IgJiYgSG93bGVyLl9uYXZpZ2F0b3IuYXBwVmVyc2lvbi5tYXRjaCgvT1MgKFxcZCspXyhcXGQrKV8/KFxcZCspPy8pO1xuICAgIHZhciB2ZXJzaW9uID0gYXBwVmVyc2lvbiA/IHBhcnNlSW50KGFwcFZlcnNpb25bMV0sIDEwKSA6IG51bGw7XG4gICAgaWYgKGlPUyAmJiB2ZXJzaW9uICYmIHZlcnNpb24gPCA5KSB7XG4gICAgICB2YXIgc2FmYXJpID0gL3NhZmFyaS8udGVzdChIb3dsZXIuX25hdmlnYXRvciAmJiBIb3dsZXIuX25hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKSk7XG4gICAgICBpZiAoSG93bGVyLl9uYXZpZ2F0b3IgJiYgSG93bGVyLl9uYXZpZ2F0b3Iuc3RhbmRhbG9uZSAmJiAhc2FmYXJpIHx8IEhvd2xlci5fbmF2aWdhdG9yICYmICFIb3dsZXIuX25hdmlnYXRvci5zdGFuZGFsb25lICYmICFzYWZhcmkpIHtcbiAgICAgICAgSG93bGVyLnVzaW5nV2ViQXVkaW8gPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDcmVhdGUgYW5kIGV4cG9zZSB0aGUgbWFzdGVyIEdhaW5Ob2RlIHdoZW4gdXNpbmcgV2ViIEF1ZGlvICh1c2VmdWwgZm9yIHBsdWdpbnMgb3IgYWR2YW5jZWQgdXNhZ2UpLlxuICAgIGlmIChIb3dsZXIudXNpbmdXZWJBdWRpbykge1xuICAgICAgSG93bGVyLm1hc3RlckdhaW4gPSAodHlwZW9mIEhvd2xlci5jdHguY3JlYXRlR2FpbiA9PT0gJ3VuZGVmaW5lZCcpID8gSG93bGVyLmN0eC5jcmVhdGVHYWluTm9kZSgpIDogSG93bGVyLmN0eC5jcmVhdGVHYWluKCk7XG4gICAgICBIb3dsZXIubWFzdGVyR2Fpbi5nYWluLnZhbHVlID0gMTtcbiAgICAgIEhvd2xlci5tYXN0ZXJHYWluLmNvbm5lY3QoSG93bGVyLmN0eC5kZXN0aW5hdGlvbik7XG4gICAgfVxuXG4gICAgLy8gUmUtcnVuIHRoZSBzZXR1cCBvbiBIb3dsZXIuXG4gICAgSG93bGVyLl9zZXR1cCgpO1xuICB9O1xuXG4gIC8vIEFkZCBzdXBwb3J0IGZvciBBTUQgKEFzeW5jaHJvbm91cyBNb2R1bGUgRGVmaW5pdGlvbikgbGlicmFyaWVzIHN1Y2ggYXMgcmVxdWlyZS5qcy5cbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgIGRlZmluZShbXSwgZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBIb3dsZXI6IEhvd2xlcixcbiAgICAgICAgSG93bDogSG93bFxuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuXG4gIC8vIEFkZCBzdXBwb3J0IGZvciBDb21tb25KUyBsaWJyYXJpZXMgc3VjaCBhcyBicm93c2VyaWZ5LlxuICBpZiAodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgZXhwb3J0cy5Ib3dsZXIgPSBIb3dsZXI7XG4gICAgZXhwb3J0cy5Ib3dsID0gSG93bDtcbiAgfVxuXG4gIC8vIERlZmluZSBnbG9iYWxseSBpbiBjYXNlIEFNRCBpcyBub3QgYXZhaWxhYmxlIG9yIHVudXNlZC5cbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgd2luZG93Lkhvd2xlckdsb2JhbCA9IEhvd2xlckdsb2JhbDtcbiAgICB3aW5kb3cuSG93bGVyID0gSG93bGVyO1xuICAgIHdpbmRvdy5Ib3dsID0gSG93bDtcbiAgICB3aW5kb3cuU291bmQgPSBTb3VuZDtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykgeyAvLyBBZGQgdG8gZ2xvYmFsIGluIE5vZGUuanMgKGZvciB0ZXN0aW5nLCBldGMpLlxuICAgIGdsb2JhbC5Ib3dsZXJHbG9iYWwgPSBIb3dsZXJHbG9iYWw7XG4gICAgZ2xvYmFsLkhvd2xlciA9IEhvd2xlcjtcbiAgICBnbG9iYWwuSG93bCA9IEhvd2w7XG4gICAgZ2xvYmFsLlNvdW5kID0gU291bmQ7XG4gIH1cbn0pKCk7XG5cblxuLyohXG4gKiAgU3BhdGlhbCBQbHVnaW4gLSBBZGRzIHN1cHBvcnQgZm9yIHN0ZXJlbyBhbmQgM0QgYXVkaW8gd2hlcmUgV2ViIEF1ZGlvIGlzIHN1cHBvcnRlZC5cbiAqICBcbiAqICBob3dsZXIuanMgdjIuMC4wXG4gKiAgaG93bGVyanMuY29tXG4gKlxuICogIChjKSAyMDEzLTIwMTYsIEphbWVzIFNpbXBzb24gb2YgR29sZEZpcmUgU3R1ZGlvc1xuICogIGdvbGRmaXJlc3R1ZGlvcy5jb21cbiAqXG4gKiAgTUlUIExpY2Vuc2VcbiAqL1xuXG4oZnVuY3Rpb24oKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vIFNldHVwIGRlZmF1bHQgcHJvcGVydGllcy5cbiAgSG93bGVyR2xvYmFsLnByb3RvdHlwZS5fcG9zID0gWzAsIDAsIDBdO1xuICBIb3dsZXJHbG9iYWwucHJvdG90eXBlLl9vcmllbnRhdGlvbiA9IFswLCAwLCAtMSwgMCwgMSwgMF07XG4gIFxuICAvKiogR2xvYmFsIE1ldGhvZHMgKiovXG4gIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgLyoqXG4gICAqIEhlbHBlciBtZXRob2QgdG8gdXBkYXRlIHRoZSBzdGVyZW8gcGFubmluZyBwb3NpdGlvbiBvZiBhbGwgY3VycmVudCBIb3dscy5cbiAgICogRnV0dXJlIEhvd2xzIHdpbGwgbm90IHVzZSB0aGlzIHZhbHVlIHVubGVzcyBleHBsaWNpdGVseSBzZXQuXG4gICAqIEBwYXJhbSAge051bWJlcn0gcGFuIEEgdmFsdWUgb2YgLTEuMCBpcyBhbGwgdGhlIHdheSBsZWZ0IGFuZCAxLjAgaXMgYWxsIHRoZSB3YXkgcmlnaHQuXG4gICAqIEByZXR1cm4ge0hvd2xlci9OdW1iZXJ9ICAgICBTZWxmIG9yIGN1cnJlbnQgc3RlcmVvIHBhbm5pbmcgdmFsdWUuXG4gICAqL1xuICBIb3dsZXJHbG9iYWwucHJvdG90eXBlLnN0ZXJlbyA9IGZ1bmN0aW9uKHBhbikge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIC8vIFN0b3AgcmlnaHQgaGVyZSBpZiBub3QgdXNpbmcgV2ViIEF1ZGlvLlxuICAgIGlmICghc2VsZi5jdHggfHwgIXNlbGYuY3R4Lmxpc3RlbmVyKSB7XG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG5cbiAgICAvLyBMb29wIHRocm91Z2ggYWxsIEhvd2xzIGFuZCB1cGRhdGUgdGhlaXIgc3RlcmVvIHBhbm5pbmcuXG4gICAgZm9yICh2YXIgaT1zZWxmLl9ob3dscy5sZW5ndGgtMTsgaT49MDsgaS0tKSB7XG4gICAgICBzZWxmLl9ob3dsc1tpXS5zdGVyZW8ocGFuKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2VsZjtcbiAgfTtcblxuICAvKipcbiAgICogR2V0L3NldCB0aGUgcG9zaXRpb24gb2YgdGhlIGxpc3RlbmVyIGluIDNEIGNhcnRlc2lhbiBzcGFjZS4gU291bmRzIHVzaW5nXG4gICAqIDNEIHBvc2l0aW9uIHdpbGwgYmUgcmVsYXRpdmUgdG8gdGhlIGxpc3RlbmVyJ3MgcG9zaXRpb24uXG4gICAqIEBwYXJhbSAge051bWJlcn0geCBUaGUgeC1wb3NpdGlvbiBvZiB0aGUgbGlzdGVuZXIuXG4gICAqIEBwYXJhbSAge051bWJlcn0geSBUaGUgeS1wb3NpdGlvbiBvZiB0aGUgbGlzdGVuZXIuXG4gICAqIEBwYXJhbSAge051bWJlcn0geiBUaGUgei1wb3NpdGlvbiBvZiB0aGUgbGlzdGVuZXIuXG4gICAqIEByZXR1cm4ge0hvd2xlci9BcnJheX0gICBTZWxmIG9yIGN1cnJlbnQgbGlzdGVuZXIgcG9zaXRpb24uXG4gICAqL1xuICBIb3dsZXJHbG9iYWwucHJvdG90eXBlLnBvcyA9IGZ1bmN0aW9uKHgsIHksIHopIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAvLyBTdG9wIHJpZ2h0IGhlcmUgaWYgbm90IHVzaW5nIFdlYiBBdWRpby5cbiAgICBpZiAoIXNlbGYuY3R4IHx8ICFzZWxmLmN0eC5saXN0ZW5lcikge1xuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuXG4gICAgLy8gU2V0IHRoZSBkZWZhdWx0cyBmb3Igb3B0aW9uYWwgJ3knICYgJ3onLlxuICAgIHkgPSAodHlwZW9mIHkgIT09ICdudW1iZXInKSA/IHNlbGYuX3Bvc1sxXSA6IHk7XG4gICAgeiA9ICh0eXBlb2YgeiAhPT0gJ251bWJlcicpID8gc2VsZi5fcG9zWzJdIDogejtcblxuICAgIGlmICh0eXBlb2YgeCA9PT0gJ251bWJlcicpIHtcbiAgICAgIHNlbGYuX3BvcyA9IFt4LCB5LCB6XTtcbiAgICAgIHNlbGYuY3R4Lmxpc3RlbmVyLnNldFBvc2l0aW9uKHNlbGYuX3Bvc1swXSwgc2VsZi5fcG9zWzFdLCBzZWxmLl9wb3NbMl0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gc2VsZi5fcG9zO1xuICAgIH1cblxuICAgIHJldHVybiBzZWxmO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQvc2V0IHRoZSBkaXJlY3Rpb24gdGhlIGxpc3RlbmVyIGlzIHBvaW50aW5nIGluIHRoZSAzRCBjYXJ0ZXNpYW4gc3BhY2UuXG4gICAqIEEgZnJvbnQgYW5kIHVwIHZlY3RvciBtdXN0IGJlIHByb3ZpZGVkLiBUaGUgZnJvbnQgaXMgdGhlIGRpcmVjdGlvbiB0aGVcbiAgICogZmFjZSBvZiB0aGUgbGlzdGVuZXIgaXMgcG9pbnRpbmcsIGFuZCB1cCBpcyB0aGUgZGlyZWN0aW9uIHRoZSB0b3Agb2YgdGhlXG4gICAqIGxpc3RlbmVyIGlzIHBvaW50aW5nLiBUaHVzLCB0aGVzZSB2YWx1ZXMgYXJlIGV4cGVjdGVkIHRvIGJlIGF0IHJpZ2h0IGFuZ2xlc1xuICAgKiBmcm9tIGVhY2ggb3RoZXIuXG4gICAqIEBwYXJhbSAge051bWJlcn0geCAgIFRoZSB4LW9yaWVudGF0aW9uIG9mIHRoZSBsaXN0ZW5lci5cbiAgICogQHBhcmFtICB7TnVtYmVyfSB5ICAgVGhlIHktb3JpZW50YXRpb24gb2YgdGhlIGxpc3RlbmVyLlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHogICBUaGUgei1vcmllbnRhdGlvbiBvZiB0aGUgbGlzdGVuZXIuXG4gICAqIEBwYXJhbSAge051bWJlcn0geFVwIFRoZSB4LW9yaWVudGF0aW9uIG9mIHRoZSB0b3Agb2YgdGhlIGxpc3RlbmVyLlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHlVcCBUaGUgeS1vcmllbnRhdGlvbiBvZiB0aGUgdG9wIG9mIHRoZSBsaXN0ZW5lci5cbiAgICogQHBhcmFtICB7TnVtYmVyfSB6VXAgVGhlIHotb3JpZW50YXRpb24gb2YgdGhlIHRvcCBvZiB0aGUgbGlzdGVuZXIuXG4gICAqIEByZXR1cm4ge0hvd2xlci9BcnJheX0gICAgIFJldHVybnMgc2VsZiBvciB0aGUgY3VycmVudCBvcmllbnRhdGlvbiB2ZWN0b3JzLlxuICAgKi9cbiAgSG93bGVyR2xvYmFsLnByb3RvdHlwZS5vcmllbnRhdGlvbiA9IGZ1bmN0aW9uKHgsIHksIHosIHhVcCwgeVVwLCB6VXApIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAvLyBTdG9wIHJpZ2h0IGhlcmUgaWYgbm90IHVzaW5nIFdlYiBBdWRpby5cbiAgICBpZiAoIXNlbGYuY3R4IHx8ICFzZWxmLmN0eC5saXN0ZW5lcikge1xuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuXG4gICAgLy8gU2V0IHRoZSBkZWZhdWx0cyBmb3Igb3B0aW9uYWwgJ3knICYgJ3onLlxuICAgIHZhciBvciA9IHNlbGYuX29yaWVudGF0aW9uO1xuICAgIHkgPSAodHlwZW9mIHkgIT09ICdudW1iZXInKSA/IG9yWzFdIDogeTtcbiAgICB6ID0gKHR5cGVvZiB6ICE9PSAnbnVtYmVyJykgPyBvclsyXSA6IHo7XG4gICAgeFVwID0gKHR5cGVvZiB4VXAgIT09ICdudW1iZXInKSA/IG9yWzNdIDogeFVwO1xuICAgIHlVcCA9ICh0eXBlb2YgeVVwICE9PSAnbnVtYmVyJykgPyBvcls0XSA6IHlVcDtcbiAgICB6VXAgPSAodHlwZW9mIHpVcCAhPT0gJ251bWJlcicpID8gb3JbNV0gOiB6VXA7XG5cbiAgICBpZiAodHlwZW9mIHggPT09ICdudW1iZXInKSB7XG4gICAgICBzZWxmLl9vcmllbnRhdGlvbiA9IFt4LCB5LCB6LCB4VXAsIHlVcCwgelVwXTtcbiAgICAgIHNlbGYuY3R4Lmxpc3RlbmVyLnNldE9yaWVudGF0aW9uKHgsIHksIHosIHhVcCwgeVVwLCB6VXApO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gb3I7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNlbGY7XG4gIH07XG5cbiAgLyoqIEdyb3VwIE1ldGhvZHMgKiovXG4gIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgLyoqXG4gICAqIEFkZCBuZXcgcHJvcGVydGllcyB0byB0aGUgY29yZSBpbml0LlxuICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gX3N1cGVyIENvcmUgaW5pdCBtZXRob2QuXG4gICAqIEByZXR1cm4ge0hvd2x9XG4gICAqL1xuICBIb3dsLnByb3RvdHlwZS5pbml0ID0gKGZ1bmN0aW9uKF9zdXBlcikge1xuICAgIHJldHVybiBmdW5jdGlvbihvKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgIC8vIFNldHVwIHVzZXItZGVmaW5lZCBkZWZhdWx0IHByb3BlcnRpZXMuXG4gICAgICBzZWxmLl9vcmllbnRhdGlvbiA9IG8ub3JpZW50YXRpb24gfHwgWzEsIDAsIDBdO1xuICAgICAgc2VsZi5fc3RlcmVvID0gby5zdGVyZW8gfHwgbnVsbDtcbiAgICAgIHNlbGYuX3BvcyA9IG8ucG9zIHx8IG51bGw7XG4gICAgICBzZWxmLl9wYW5uZXJBdHRyID0ge1xuICAgICAgICBjb25lSW5uZXJBbmdsZTogdHlwZW9mIG8uY29uZUlubmVyQW5nbGUgIT09ICd1bmRlZmluZWQnID8gby5jb25lSW5uZXJBbmdsZSA6IDM2MCxcbiAgICAgICAgY29uZU91dGVyQW5nbGU6IHR5cGVvZiBvLmNvbmVPdXRlckFuZ2xlICE9PSAndW5kZWZpbmVkJyA/IG8uY29uZU91dGVyQW5nbGUgOiAzNjAsXG4gICAgICAgIGNvbmVPdXRlckdhaW46IHR5cGVvZiBvLmNvbmVPdXRlckdhaW4gIT09ICd1bmRlZmluZWQnID8gby5jb25lT3V0ZXJHYWluIDogMCxcbiAgICAgICAgZGlzdGFuY2VNb2RlbDogdHlwZW9mIG8uZGlzdGFuY2VNb2RlbCAhPT0gJ3VuZGVmaW5lZCcgPyBvLmRpc3RhbmNlTW9kZWwgOiAnaW52ZXJzZScsXG4gICAgICAgIG1heERpc3RhbmNlOiB0eXBlb2Ygby5tYXhEaXN0YW5jZSAhPT0gJ3VuZGVmaW5lZCcgPyBvLm1heERpc3RhbmNlIDogMTAwMDAsXG4gICAgICAgIHBhbm5pbmdNb2RlbDogdHlwZW9mIG8ucGFubmluZ01vZGVsICE9PSAndW5kZWZpbmVkJyA/IG8ucGFubmluZ01vZGVsIDogJ0hSVEYnLFxuICAgICAgICByZWZEaXN0YW5jZTogdHlwZW9mIG8ucmVmRGlzdGFuY2UgIT09ICd1bmRlZmluZWQnID8gby5yZWZEaXN0YW5jZSA6IDEsXG4gICAgICAgIHJvbGxvZmZGYWN0b3I6IHR5cGVvZiBvLnJvbGxvZmZGYWN0b3IgIT09ICd1bmRlZmluZWQnID8gby5yb2xsb2ZmRmFjdG9yIDogMVxuICAgICAgfTtcblxuICAgICAgLy8gU2V0dXAgZXZlbnQgbGlzdGVuZXJzLlxuICAgICAgc2VsZi5fb25zdGVyZW8gPSBvLm9uc3RlcmVvID8gW3tmbjogby5vbnN0ZXJlb31dIDogW107XG4gICAgICBzZWxmLl9vbnBvcyA9IG8ub25wb3MgPyBbe2ZuOiBvLm9ucG9zfV0gOiBbXTtcbiAgICAgIHNlbGYuX29ub3JpZW50YXRpb24gPSBvLm9ub3JpZW50YXRpb24gPyBbe2ZuOiBvLm9ub3JpZW50YXRpb259XSA6IFtdO1xuXG4gICAgICAvLyBDb21wbGV0ZSBpbml0aWxpemF0aW9uIHdpdGggaG93bGVyLmpzIGNvcmUncyBpbml0IGZ1bmN0aW9uLlxuICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIG8pO1xuICAgIH07XG4gIH0pKEhvd2wucHJvdG90eXBlLmluaXQpO1xuXG4gIC8qKlxuICAgKiBHZXQvc2V0IHRoZSBzdGVyZW8gcGFubmluZyBvZiB0aGUgYXVkaW8gc291cmNlIGZvciB0aGlzIHNvdW5kIG9yIGFsbCBpbiB0aGUgZ3JvdXAuXG4gICAqIEBwYXJhbSAge051bWJlcn0gcGFuICBBIHZhbHVlIG9mIC0xLjAgaXMgYWxsIHRoZSB3YXkgbGVmdCBhbmQgMS4wIGlzIGFsbCB0aGUgd2F5IHJpZ2h0LlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGlkIChvcHRpb25hbCkgVGhlIHNvdW5kIElELiBJZiBub25lIGlzIHBhc3NlZCwgYWxsIGluIGdyb3VwIHdpbGwgYmUgdXBkYXRlZC5cbiAgICogQHJldHVybiB7SG93bC9OdW1iZXJ9ICAgIFJldHVybnMgc2VsZiBvciB0aGUgY3VycmVudCBzdGVyZW8gcGFubmluZyB2YWx1ZS5cbiAgICovXG4gIEhvd2wucHJvdG90eXBlLnN0ZXJlbyA9IGZ1bmN0aW9uKHBhbiwgaWQpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAvLyBTdG9wIHJpZ2h0IGhlcmUgaWYgbm90IHVzaW5nIFdlYiBBdWRpby5cbiAgICBpZiAoIXNlbGYuX3dlYkF1ZGlvKSB7XG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgc291bmQgaGFzbid0IGxvYWRlZCwgYWRkIGl0IHRvIHRoZSBsb2FkIHF1ZXVlIHRvIGNoYW5nZSBzdGVyZW8gcGFuIHdoZW4gY2FwYWJsZS5cbiAgICBpZiAoc2VsZi5fc3RhdGUgIT09ICdsb2FkZWQnKSB7XG4gICAgICBzZWxmLl9xdWV1ZS5wdXNoKHtcbiAgICAgICAgZXZlbnQ6ICdzdGVyZW8nLFxuICAgICAgICBhY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHNlbGYuc3RlcmVvKHBhbiwgaWQpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgZm9yIFBhbm5lclN0ZXJlb05vZGUgc3VwcG9ydCBhbmQgZmFsbGJhY2sgdG8gUGFubmVyTm9kZSBpZiBpdCBkb2Vzbid0IGV4aXN0LlxuICAgIHZhciBwYW5uZXJUeXBlID0gKHR5cGVvZiBIb3dsZXIuY3R4LmNyZWF0ZVN0ZXJlb1Bhbm5lciA9PT0gJ3VuZGVmaW5lZCcpID8gJ3NwYXRpYWwnIDogJ3N0ZXJlbyc7XG5cbiAgICAvLyBTZXR1cCB0aGUgZ3JvdXAncyBzdGVyZW8gcGFubmluZyBpZiBubyBJRCBpcyBwYXNzZWQuXG4gICAgaWYgKHR5cGVvZiBpZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIC8vIFJldHVybiB0aGUgZ3JvdXAncyBzdGVyZW8gcGFubmluZyBpZiBubyBwYXJhbWV0ZXJzIGFyZSBwYXNzZWQuXG4gICAgICBpZiAodHlwZW9mIHBhbiA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgc2VsZi5fc3RlcmVvID0gcGFuO1xuICAgICAgICBzZWxmLl9wb3MgPSBbcGFuLCAwLCAwXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBzZWxmLl9zdGVyZW87XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ2hhbmdlIHRoZSBzdHJlbyBwYW5uaW5nIG9mIG9uZSBvciBhbGwgc291bmRzIGluIGdyb3VwLlxuICAgIHZhciBpZHMgPSBzZWxmLl9nZXRTb3VuZElkcyhpZCk7XG4gICAgZm9yICh2YXIgaT0wOyBpPGlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgLy8gR2V0IHRoZSBzb3VuZC5cbiAgICAgIHZhciBzb3VuZCA9IHNlbGYuX3NvdW5kQnlJZChpZHNbaV0pO1xuXG4gICAgICBpZiAoc291bmQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBwYW4gPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgc291bmQuX3N0ZXJlbyA9IHBhbjtcbiAgICAgICAgICBzb3VuZC5fcG9zID0gW3BhbiwgMCwgMF07XG5cbiAgICAgICAgICBpZiAoc291bmQuX25vZGUpIHtcbiAgICAgICAgICAgIC8vIElmIHdlIGFyZSBmYWxsaW5nIGJhY2ssIG1ha2Ugc3VyZSB0aGUgcGFubmluZ01vZGVsIGlzIGVxdWFscG93ZXIuXG4gICAgICAgICAgICBzb3VuZC5fcGFubmVyQXR0ci5wYW5uaW5nTW9kZWwgPSAnZXF1YWxwb3dlcic7XG5cbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZXJlIGlzIGEgcGFubmVyIHNldHVwIGFuZCBjcmVhdGUgYSBuZXcgb25lIGlmIG5vdC5cbiAgICAgICAgICAgIGlmICghc291bmQuX3Bhbm5lciB8fCAhc291bmQuX3Bhbm5lci5wYW4pIHtcbiAgICAgICAgICAgICAgc2V0dXBQYW5uZXIoc291bmQsIHBhbm5lclR5cGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocGFubmVyVHlwZSA9PT0gJ3NwYXRpYWwnKSB7XG4gICAgICAgICAgICAgIHNvdW5kLl9wYW5uZXIuc2V0UG9zaXRpb24ocGFuLCAwLCAwKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHNvdW5kLl9wYW5uZXIucGFuLnZhbHVlID0gcGFuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHNlbGYuX2VtaXQoJ3N0ZXJlbycsIHNvdW5kLl9pZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHNvdW5kLl9zdGVyZW87XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc2VsZjtcbiAgfTtcblxuICAvKipcbiAgICogR2V0L3NldCB0aGUgM0Qgc3BhdGlhbCBwb3NpdGlvbiBvZiB0aGUgYXVkaW8gc291cmNlIGZvciB0aGlzIHNvdW5kIG9yXG4gICAqIGFsbCBpbiB0aGUgZ3JvdXAuIFRoZSBtb3N0IGNvbW1vbiB1c2FnZSBpcyB0byBzZXQgdGhlICd4JyBwb3NpdGlvbiBmb3JcbiAgICogbGVmdC9yaWdodCBwYW5uaW5nLiBTZXR0aW5nIGFueSB2YWx1ZSBoaWdoZXIgdGhhbiAxLjAgd2lsbCBiZWdpbiB0b1xuICAgKiBkZWNyZWFzZSB0aGUgdm9sdW1lIG9mIHRoZSBzb3VuZCBhcyBpdCBtb3ZlcyBmdXJ0aGVyIGF3YXkuXG4gICAqIEBwYXJhbSAge051bWJlcn0geCAgVGhlIHgtcG9zaXRpb24gb2YgdGhlIGF1ZGlvIGZyb20gLTEwMDAuMCB0byAxMDAwLjAuXG4gICAqIEBwYXJhbSAge051bWJlcn0geSAgVGhlIHktcG9zaXRpb24gb2YgdGhlIGF1ZGlvIGZyb20gLTEwMDAuMCB0byAxMDAwLjAuXG4gICAqIEBwYXJhbSAge051bWJlcn0geiAgVGhlIHotcG9zaXRpb24gb2YgdGhlIGF1ZGlvIGZyb20gLTEwMDAuMCB0byAxMDAwLjAuXG4gICAqIEBwYXJhbSAge051bWJlcn0gaWQgKG9wdGlvbmFsKSBUaGUgc291bmQgSUQuIElmIG5vbmUgaXMgcGFzc2VkLCBhbGwgaW4gZ3JvdXAgd2lsbCBiZSB1cGRhdGVkLlxuICAgKiBAcmV0dXJuIHtIb3dsL0FycmF5fSAgICBSZXR1cm5zIHNlbGYgb3IgdGhlIGN1cnJlbnQgM0Qgc3BhdGlhbCBwb3NpdGlvbjogW3gsIHksIHpdLlxuICAgKi9cbiAgSG93bC5wcm90b3R5cGUucG9zID0gZnVuY3Rpb24oeCwgeSwgeiwgaWQpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAvLyBTdG9wIHJpZ2h0IGhlcmUgaWYgbm90IHVzaW5nIFdlYiBBdWRpby5cbiAgICBpZiAoIXNlbGYuX3dlYkF1ZGlvKSB7XG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgc291bmQgaGFzbid0IGxvYWRlZCwgYWRkIGl0IHRvIHRoZSBsb2FkIHF1ZXVlIHRvIGNoYW5nZSBwb3NpdGlvbiB3aGVuIGNhcGFibGUuXG4gICAgaWYgKHNlbGYuX3N0YXRlICE9PSAnbG9hZGVkJykge1xuICAgICAgc2VsZi5fcXVldWUucHVzaCh7XG4gICAgICAgIGV2ZW50OiAncG9zJyxcbiAgICAgICAgYWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBzZWxmLnBvcyh4LCB5LCB6LCBpZCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG5cbiAgICAvLyBTZXQgdGhlIGRlZmF1bHRzIGZvciBvcHRpb25hbCAneScgJiAneicuXG4gICAgeSA9ICh0eXBlb2YgeSAhPT0gJ251bWJlcicpID8gMCA6IHk7XG4gICAgeiA9ICh0eXBlb2YgeiAhPT0gJ251bWJlcicpID8gLTAuNSA6IHo7XG5cbiAgICAvLyBTZXR1cCB0aGUgZ3JvdXAncyBzcGF0aWFsIHBvc2l0aW9uIGlmIG5vIElEIGlzIHBhc3NlZC5cbiAgICBpZiAodHlwZW9mIGlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgLy8gUmV0dXJuIHRoZSBncm91cCdzIHNwYXRpYWwgcG9zaXRpb24gaWYgbm8gcGFyYW1ldGVycyBhcmUgcGFzc2VkLlxuICAgICAgaWYgKHR5cGVvZiB4ID09PSAnbnVtYmVyJykge1xuICAgICAgICBzZWxmLl9wb3MgPSBbeCwgeSwgel07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gc2VsZi5fcG9zO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIENoYW5nZSB0aGUgc3BhdGlhbCBwb3NpdGlvbiBvZiBvbmUgb3IgYWxsIHNvdW5kcyBpbiBncm91cC5cbiAgICB2YXIgaWRzID0gc2VsZi5fZ2V0U291bmRJZHMoaWQpO1xuICAgIGZvciAodmFyIGk9MDsgaTxpZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIC8vIEdldCB0aGUgc291bmQuXG4gICAgICB2YXIgc291bmQgPSBzZWxmLl9zb3VuZEJ5SWQoaWRzW2ldKTtcblxuICAgICAgaWYgKHNvdW5kKSB7XG4gICAgICAgIGlmICh0eXBlb2YgeCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICBzb3VuZC5fcG9zID0gW3gsIHksIHpdO1xuXG4gICAgICAgICAgaWYgKHNvdW5kLl9ub2RlKSB7XG4gICAgICAgICAgICAvLyBDaGVjayBpZiB0aGVyZSBpcyBhIHBhbm5lciBzZXR1cCBhbmQgY3JlYXRlIGEgbmV3IG9uZSBpZiBub3QuXG4gICAgICAgICAgICBpZiAoIXNvdW5kLl9wYW5uZXIgfHwgc291bmQuX3Bhbm5lci5wYW4pIHtcbiAgICAgICAgICAgICAgc2V0dXBQYW5uZXIoc291bmQsICdzcGF0aWFsJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNvdW5kLl9wYW5uZXIuc2V0UG9zaXRpb24oeCwgeSwgeik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc2VsZi5fZW1pdCgncG9zJywgc291bmQuX2lkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gc291bmQuX3BvcztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzZWxmO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQvc2V0IHRoZSBkaXJlY3Rpb24gdGhlIGF1ZGlvIHNvdXJjZSBpcyBwb2ludGluZyBpbiB0aGUgM0QgY2FydGVzaWFuIGNvb3JkaW5hdGVcbiAgICogc3BhY2UuIERlcGVuZGluZyBvbiBob3cgZGlyZWN0aW9uIHRoZSBzb3VuZCBpcywgYmFzZWQgb24gdGhlIGBjb25lYCBhdHRyaWJ1dGVzLFxuICAgKiBhIHNvdW5kIHBvaW50aW5nIGF3YXkgZnJvbSB0aGUgbGlzdGVuZXIgY2FuIGJlIHF1aWV0IG9yIHNpbGVudC5cbiAgICogQHBhcmFtICB7TnVtYmVyfSB4ICBUaGUgeC1vcmllbnRhdGlvbiBvZiB0aGUgc291cmNlLlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHkgIFRoZSB5LW9yaWVudGF0aW9uIG9mIHRoZSBzb3VyY2UuXG4gICAqIEBwYXJhbSAge051bWJlcn0geiAgVGhlIHotb3JpZW50YXRpb24gb2YgdGhlIHNvdXJjZS5cbiAgICogQHBhcmFtICB7TnVtYmVyfSBpZCAob3B0aW9uYWwpIFRoZSBzb3VuZCBJRC4gSWYgbm9uZSBpcyBwYXNzZWQsIGFsbCBpbiBncm91cCB3aWxsIGJlIHVwZGF0ZWQuXG4gICAqIEByZXR1cm4ge0hvd2wvQXJyYXl9ICAgIFJldHVybnMgc2VsZiBvciB0aGUgY3VycmVudCAzRCBzcGF0aWFsIG9yaWVudGF0aW9uOiBbeCwgeSwgel0uXG4gICAqL1xuICBIb3dsLnByb3RvdHlwZS5vcmllbnRhdGlvbiA9IGZ1bmN0aW9uKHgsIHksIHosIGlkKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgLy8gU3RvcCByaWdodCBoZXJlIGlmIG5vdCB1c2luZyBXZWIgQXVkaW8uXG4gICAgaWYgKCFzZWxmLl93ZWJBdWRpbykge1xuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIHNvdW5kIGhhc24ndCBsb2FkZWQsIGFkZCBpdCB0byB0aGUgbG9hZCBxdWV1ZSB0byBjaGFuZ2Ugb3JpZW50YXRpb24gd2hlbiBjYXBhYmxlLlxuICAgIGlmIChzZWxmLl9zdGF0ZSAhPT0gJ2xvYWRlZCcpIHtcbiAgICAgIHNlbGYuX3F1ZXVlLnB1c2goe1xuICAgICAgICBldmVudDogJ29yaWVudGF0aW9uJyxcbiAgICAgICAgYWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBzZWxmLm9yaWVudGF0aW9uKHgsIHksIHosIGlkKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cblxuICAgIC8vIFNldCB0aGUgZGVmYXVsdHMgZm9yIG9wdGlvbmFsICd5JyAmICd6Jy5cbiAgICB5ID0gKHR5cGVvZiB5ICE9PSAnbnVtYmVyJykgPyBzZWxmLl9vcmllbnRhdGlvblsxXSA6IHk7XG4gICAgeiA9ICh0eXBlb2YgeiAhPT0gJ251bWJlcicpID8gc2VsZi5fb3JpZW50YXRpb25bMl0gOiB6O1xuXG4gICAgLy8gU2V0dXAgdGhlIGdyb3VwJ3Mgc3BhdGlhbCBvcmllbnRhdGlvbiBpZiBubyBJRCBpcyBwYXNzZWQuXG4gICAgaWYgKHR5cGVvZiBpZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIC8vIFJldHVybiB0aGUgZ3JvdXAncyBzcGF0aWFsIG9yaWVudGF0aW9uIGlmIG5vIHBhcmFtZXRlcnMgYXJlIHBhc3NlZC5cbiAgICAgIGlmICh0eXBlb2YgeCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgc2VsZi5fb3JpZW50YXRpb24gPSBbeCwgeSwgel07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gc2VsZi5fb3JpZW50YXRpb247XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ2hhbmdlIHRoZSBzcGF0aWFsIG9yaWVudGF0aW9uIG9mIG9uZSBvciBhbGwgc291bmRzIGluIGdyb3VwLlxuICAgIHZhciBpZHMgPSBzZWxmLl9nZXRTb3VuZElkcyhpZCk7XG4gICAgZm9yICh2YXIgaT0wOyBpPGlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgLy8gR2V0IHRoZSBzb3VuZC5cbiAgICAgIHZhciBzb3VuZCA9IHNlbGYuX3NvdW5kQnlJZChpZHNbaV0pO1xuXG4gICAgICBpZiAoc291bmQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB4ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIHNvdW5kLl9vcmllbnRhdGlvbiA9IFt4LCB5LCB6XTtcblxuICAgICAgICAgIGlmIChzb3VuZC5fbm9kZSkge1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlcmUgaXMgYSBwYW5uZXIgc2V0dXAgYW5kIGNyZWF0ZSBhIG5ldyBvbmUgaWYgbm90LlxuICAgICAgICAgICAgaWYgKCFzb3VuZC5fcGFubmVyKSB7XG4gICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBoYXZlIGEgcG9zaXRpb24gdG8gc2V0dXAgdGhlIG5vZGUgd2l0aC5cbiAgICAgICAgICAgICAgaWYgKCFzb3VuZC5fcG9zKSB7XG4gICAgICAgICAgICAgICAgc291bmQuX3BvcyA9IHNlbGYuX3BvcyB8fCBbMCwgMCwgLTAuNV07XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBzZXR1cFBhbm5lcihzb3VuZCwgJ3NwYXRpYWwnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc291bmQuX3Bhbm5lci5zZXRPcmllbnRhdGlvbih4LCB5LCB6KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzZWxmLl9lbWl0KCdvcmllbnRhdGlvbicsIHNvdW5kLl9pZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHNvdW5kLl9vcmllbnRhdGlvbjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzZWxmO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQvc2V0IHRoZSBwYW5uZXIgbm9kZSdzIGF0dHJpYnV0ZXMgZm9yIGEgc291bmQgb3IgZ3JvdXAgb2Ygc291bmRzLlxuICAgKiBUaGlzIG1ldGhvZCBjYW4gb3B0aW9uYWxsIHRha2UgMCwgMSBvciAyIGFyZ3VtZW50cy5cbiAgICogICBwYW5uZXJBdHRyKCkgLT4gUmV0dXJucyB0aGUgZ3JvdXAncyB2YWx1ZXMuXG4gICAqICAgcGFubmVyQXR0cihpZCkgLT4gUmV0dXJucyB0aGUgc291bmQgaWQncyB2YWx1ZXMuXG4gICAqICAgcGFubmVyQXR0cihvKSAtPiBTZXQncyB0aGUgdmFsdWVzIG9mIGFsbCBzb3VuZHMgaW4gdGhpcyBIb3dsIGdyb3VwLlxuICAgKiAgIHBhbm5lckF0dHIobywgaWQpIC0+IFNldCdzIHRoZSB2YWx1ZXMgb2YgcGFzc2VkIHNvdW5kIGlkLlxuICAgKlxuICAgKiAgIEF0dHJpYnV0ZXM6XG4gICAqICAgICBjb25lSW5uZXJBbmdsZSAtICgzNjAgYnkgZGVmYXVsdCkgVGhlcmUgd2lsbCBiZSBubyB2b2x1bWUgcmVkdWN0aW9uIGluc2lkZSB0aGlzIGFuZ2xlLlxuICAgKiAgICAgY29uZU91dGVyQW5nbGUgLSAoMzYwIGJ5IGRlZmF1bHQpIFRoZSB2b2x1bWUgd2lsbCBiZSByZWR1Y2VkIHRvIGEgY29uc3RhbnQgdmFsdWUgb2ZcbiAgICogICAgICAgICAgICAgICAgICAgICAgYGNvbmVPdXRlckdhaW5gIG91dHNpZGUgdGhpcyBhbmdsZS5cbiAgICogICAgIGNvbmVPdXRlckdhaW4gLSAoMCBieSBkZWZhdWx0KSBUaGUgYW1vdW50IG9mIHZvbHVtZSByZWR1Y3Rpb24gb3V0c2lkZSBvZiBgY29uZU91dGVyQW5nbGVgLlxuICAgKiAgICAgZGlzdGFuY2VNb2RlbCAtICgnaW52ZXJzZScgYnkgZGVmYXVsdCkgRGV0ZXJtaW5lcyBhbGdvcml0aG0gdG8gdXNlIHRvIHJlZHVjZSB2b2x1bWUgYXMgYXVkaW8gbW92ZXNcbiAgICogICAgICAgICAgICAgICAgICAgICAgYXdheSBmcm9tIGxpc3RlbmVyLiBDYW4gYmUgYGxpbmVhcmAsIGBpbnZlcnNlYCBvciBgZXhwb25lbnRpYWxgLlxuICAgKiAgICAgbWF4RGlzdGFuY2UgLSAoMTAwMDAgYnkgZGVmYXVsdCkgVm9sdW1lIHdvbid0IHJlZHVjZSBiZXR3ZWVuIHNvdXJjZS9saXN0ZW5lciBiZXlvbmQgdGhpcyBkaXN0YW5jZS5cbiAgICogICAgIHBhbm5pbmdNb2RlbCAtICgnSFJURicgYnkgZGVmYXVsdCkgRGV0ZXJtaW5lcyB3aGljaCBzcGF0aWFsaXphdGlvbiBhbGdvcml0aG0gaXMgdXNlZCB0byBwb3NpdGlvbiBhdWRpby5cbiAgICogICAgICAgICAgICAgICAgICAgICBDYW4gYmUgYEhSVEZgIG9yIGBlcXVhbHBvd2VyYC5cbiAgICogICAgIHJlZkRpc3RhbmNlIC0gKDEgYnkgZGVmYXVsdCkgQSByZWZlcmVuY2UgZGlzdGFuY2UgZm9yIHJlZHVjaW5nIHZvbHVtZSBhcyB0aGUgc291cmNlXG4gICAqICAgICAgICAgICAgICAgICAgICBtb3ZlcyBhd2F5IGZyb20gdGhlIGxpc3RlbmVyLlxuICAgKiAgICAgcm9sbG9mZkZhY3RvciAtICgxIGJ5IGRlZmF1bHQpIEhvdyBxdWlja2x5IHRoZSB2b2x1bWUgcmVkdWNlcyBhcyBzb3VyY2UgbW92ZXMgZnJvbSBsaXN0ZW5lci5cbiAgICogXG4gICAqIEByZXR1cm4ge0hvd2wvT2JqZWN0fSBSZXR1cm5zIHNlbGYgb3IgY3VycmVudCBwYW5uZXIgYXR0cmlidXRlcy5cbiAgICovXG4gIEhvd2wucHJvdG90eXBlLnBhbm5lckF0dHIgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgdmFyIG8sIGlkLCBzb3VuZDtcblxuICAgIC8vIFN0b3AgcmlnaHQgaGVyZSBpZiBub3QgdXNpbmcgV2ViIEF1ZGlvLlxuICAgIGlmICghc2VsZi5fd2ViQXVkaW8pIHtcbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cblxuICAgIC8vIERldGVybWluZSB0aGUgdmFsdWVzIGJhc2VkIG9uIGFyZ3VtZW50cy5cbiAgICBpZiAoYXJncy5sZW5ndGggPT09IDApIHtcbiAgICAgIC8vIFJldHVybiB0aGUgZ3JvdXAncyBwYW5uZXIgYXR0cmlidXRlIHZhbHVlcy5cbiAgICAgIHJldHVybiBzZWxmLl9wYW5uZXJBdHRyO1xuICAgIH0gZWxzZSBpZiAoYXJncy5sZW5ndGggPT09IDEpIHtcbiAgICAgIGlmICh0eXBlb2YgYXJnc1swXSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgbyA9IGFyZ3NbMF07XG5cbiAgICAgICAgLy8gU2V0IHRoZSBncm91J3MgcGFubmVyIGF0dHJpYnV0ZSB2YWx1ZXMuXG4gICAgICAgIGlmICh0eXBlb2YgaWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgc2VsZi5fcGFubmVyQXR0ciA9IHtcbiAgICAgICAgICAgIGNvbmVJbm5lckFuZ2xlOiB0eXBlb2Ygby5jb25lSW5uZXJBbmdsZSAhPT0gJ3VuZGVmaW5lZCcgPyBvLmNvbmVJbm5lckFuZ2xlIDogc2VsZi5fY29uZUlubmVyQW5nbGUsXG4gICAgICAgICAgICBjb25lT3V0ZXJBbmdsZTogdHlwZW9mIG8uY29uZU91dGVyQW5nbGUgIT09ICd1bmRlZmluZWQnID8gby5jb25lT3V0ZXJBbmdsZSA6IHNlbGYuX2NvbmVPdXRlckFuZ2xlLFxuICAgICAgICAgICAgY29uZU91dGVyR2FpbjogdHlwZW9mIG8uY29uZU91dGVyR2FpbiAhPT0gJ3VuZGVmaW5lZCcgPyBvLmNvbmVPdXRlckdhaW4gOiBzZWxmLl9jb25lT3V0ZXJHYWluLFxuICAgICAgICAgICAgZGlzdGFuY2VNb2RlbDogdHlwZW9mIG8uZGlzdGFuY2VNb2RlbCAhPT0gJ3VuZGVmaW5lZCcgPyBvLmRpc3RhbmNlTW9kZWwgOiBzZWxmLl9kaXN0YW5jZU1vZGVsLFxuICAgICAgICAgICAgbWF4RGlzdGFuY2U6IHR5cGVvZiBvLm1heERpc3RhbmNlICE9PSAndW5kZWZpbmVkJyA/IG8ubWF4RGlzdGFuY2UgOiBzZWxmLl9tYXhEaXN0YW5jZSxcbiAgICAgICAgICAgIHBhbm5pbmdNb2RlbDogdHlwZW9mIG8ucGFubmluZ01vZGVsICE9PSAndW5kZWZpbmVkJyA/IG8ucGFubmluZ01vZGVsIDogc2VsZi5fcGFubmluZ01vZGVsLFxuICAgICAgICAgICAgcmVmRGlzdGFuY2U6IHR5cGVvZiBvLnJlZkRpc3RhbmNlICE9PSAndW5kZWZpbmVkJyA/IG8ucmVmRGlzdGFuY2UgOiBzZWxmLl9yZWZEaXN0YW5jZSxcbiAgICAgICAgICAgIHJvbGxvZmZGYWN0b3I6IHR5cGVvZiBvLnJvbGxvZmZGYWN0b3IgIT09ICd1bmRlZmluZWQnID8gby5yb2xsb2ZmRmFjdG9yIDogc2VsZi5fcm9sbG9mZkZhY3RvclxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFJldHVybiB0aGlzIHNvdW5kJ3MgcGFubmVyIGF0dHJpYnV0ZSB2YWx1ZXMuXG4gICAgICAgIHNvdW5kID0gc2VsZi5fc291bmRCeUlkKHBhcnNlSW50KGFyZ3NbMF0sIDEwKSk7XG4gICAgICAgIHJldHVybiBzb3VuZCA/IHNvdW5kLl9wYW5uZXJBdHRyIDogc2VsZi5fcGFubmVyQXR0cjtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGFyZ3MubGVuZ3RoID09PSAyKSB7XG4gICAgICBvID0gYXJnc1swXTtcbiAgICAgIGlkID0gcGFyc2VJbnQoYXJnc1sxXSwgMTApO1xuICAgIH1cblxuICAgIC8vIFVwZGF0ZSB0aGUgdmFsdWVzIG9mIHRoZSBzcGVjaWZpZWQgc291bmRzLlxuICAgIHZhciBpZHMgPSBzZWxmLl9nZXRTb3VuZElkcyhpZCk7XG4gICAgZm9yICh2YXIgaT0wOyBpPGlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgc291bmQgPSBzZWxmLl9zb3VuZEJ5SWQoaWRzW2ldKTtcblxuICAgICAgaWYgKHNvdW5kKSB7XG4gICAgICAgIC8vIE1lcmdlIHRoZSBuZXcgdmFsdWVzIGludG8gdGhlIHNvdW5kLlxuICAgICAgICB2YXIgcGEgPSBzb3VuZC5fcGFubmVyQXR0cjtcbiAgICAgICAgcGEgPSB7XG4gICAgICAgICAgY29uZUlubmVyQW5nbGU6IHR5cGVvZiBvLmNvbmVJbm5lckFuZ2xlICE9PSAndW5kZWZpbmVkJyA/IG8uY29uZUlubmVyQW5nbGUgOiBwYS5jb25lSW5uZXJBbmdsZSxcbiAgICAgICAgICBjb25lT3V0ZXJBbmdsZTogdHlwZW9mIG8uY29uZU91dGVyQW5nbGUgIT09ICd1bmRlZmluZWQnID8gby5jb25lT3V0ZXJBbmdsZSA6IHBhLmNvbmVPdXRlckFuZ2xlLFxuICAgICAgICAgIGNvbmVPdXRlckdhaW46IHR5cGVvZiBvLmNvbmVPdXRlckdhaW4gIT09ICd1bmRlZmluZWQnID8gby5jb25lT3V0ZXJHYWluIDogcGEuY29uZU91dGVyR2FpbixcbiAgICAgICAgICBkaXN0YW5jZU1vZGVsOiB0eXBlb2Ygby5kaXN0YW5jZU1vZGVsICE9PSAndW5kZWZpbmVkJyA/IG8uZGlzdGFuY2VNb2RlbCA6IHBhLmRpc3RhbmNlTW9kZWwsXG4gICAgICAgICAgbWF4RGlzdGFuY2U6IHR5cGVvZiBvLm1heERpc3RhbmNlICE9PSAndW5kZWZpbmVkJyA/IG8ubWF4RGlzdGFuY2UgOiBwYS5tYXhEaXN0YW5jZSxcbiAgICAgICAgICBwYW5uaW5nTW9kZWw6IHR5cGVvZiBvLnBhbm5pbmdNb2RlbCAhPT0gJ3VuZGVmaW5lZCcgPyBvLnBhbm5pbmdNb2RlbCA6IHBhLnBhbm5pbmdNb2RlbCxcbiAgICAgICAgICByZWZEaXN0YW5jZTogdHlwZW9mIG8ucmVmRGlzdGFuY2UgIT09ICd1bmRlZmluZWQnID8gby5yZWZEaXN0YW5jZSA6IHBhLnJlZkRpc3RhbmNlLFxuICAgICAgICAgIHJvbGxvZmZGYWN0b3I6IHR5cGVvZiBvLnJvbGxvZmZGYWN0b3IgIT09ICd1bmRlZmluZWQnID8gby5yb2xsb2ZmRmFjdG9yIDogcGEucm9sbG9mZkZhY3RvclxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgcGFubmVyIHZhbHVlcyBvciBjcmVhdGUgYSBuZXcgcGFubmVyIGlmIG5vbmUgZXhpc3RzLlxuICAgICAgICB2YXIgcGFubmVyID0gc291bmQuX3Bhbm5lcjtcbiAgICAgICAgaWYgKHBhbm5lcikge1xuICAgICAgICAgIHBhbm5lci5jb25lSW5uZXJBbmdsZSA9IHBhLmNvbmVJbm5lckFuZ2xlO1xuICAgICAgICAgIHBhbm5lci5jb25lT3V0ZXJBbmdsZSA9IHBhLmNvbmVPdXRlckFuZ2xlO1xuICAgICAgICAgIHBhbm5lci5jb25lT3V0ZXJHYWluID0gcGEuY29uZU91dGVyR2FpbjtcbiAgICAgICAgICBwYW5uZXIuZGlzdGFuY2VNb2RlbCA9IHBhLmRpc3RhbmNlTW9kZWw7XG4gICAgICAgICAgcGFubmVyLm1heERpc3RhbmNlID0gcGEubWF4RGlzdGFuY2U7XG4gICAgICAgICAgcGFubmVyLnBhbm5pbmdNb2RlbCA9IHBhLnBhbm5pbmdNb2RlbDtcbiAgICAgICAgICBwYW5uZXIucmVmRGlzdGFuY2UgPSBwYS5yZWZEaXN0YW5jZTtcbiAgICAgICAgICBwYW5uZXIucm9sbG9mZkZhY3RvciA9IHBhLnJvbGxvZmZGYWN0b3I7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gTWFrZSBzdXJlIHdlIGhhdmUgYSBwb3NpdGlvbiB0byBzZXR1cCB0aGUgbm9kZSB3aXRoLlxuICAgICAgICAgIGlmICghc291bmQuX3Bvcykge1xuICAgICAgICAgICAgc291bmQuX3BvcyA9IHNlbGYuX3BvcyB8fCBbMCwgMCwgLTAuNV07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IHBhbm5lciBub2RlLlxuICAgICAgICAgIHNldHVwUGFubmVyKHNvdW5kLCAnc3BhdGlhbCcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHNlbGY7XG4gIH07XG5cbiAgLyoqIFNpbmdsZSBTb3VuZCBNZXRob2RzICoqL1xuICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gIC8qKlxuICAgKiBBZGQgbmV3IHByb3BlcnRpZXMgdG8gdGhlIGNvcmUgU291bmQgaW5pdC5cbiAgICogQHBhcmFtICB7RnVuY3Rpb259IF9zdXBlciBDb3JlIFNvdW5kIGluaXQgbWV0aG9kLlxuICAgKiBAcmV0dXJuIHtTb3VuZH1cbiAgICovXG4gIFNvdW5kLnByb3RvdHlwZS5pbml0ID0gKGZ1bmN0aW9uKF9zdXBlcikge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBwYXJlbnQgPSBzZWxmLl9wYXJlbnQ7XG5cbiAgICAgIC8vIFNldHVwIHVzZXItZGVmaW5lZCBkZWZhdWx0IHByb3BlcnRpZXMuXG4gICAgICBzZWxmLl9vcmllbnRhdGlvbiA9IHBhcmVudC5fb3JpZW50YXRpb247XG4gICAgICBzZWxmLl9zdGVyZW8gPSBwYXJlbnQuX3N0ZXJlbztcbiAgICAgIHNlbGYuX3BvcyA9IHBhcmVudC5fcG9zO1xuICAgICAgc2VsZi5fcGFubmVyQXR0ciA9IHBhcmVudC5fcGFubmVyQXR0cjtcblxuICAgICAgLy8gQ29tcGxldGUgaW5pdGlsaXphdGlvbiB3aXRoIGhvd2xlci5qcyBjb3JlIFNvdW5kJ3MgaW5pdCBmdW5jdGlvbi5cbiAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuXG4gICAgICAvLyBJZiBhIHN0ZXJlbyBvciBwb3NpdGlvbiB3YXMgc3BlY2lmaWVkLCBzZXQgaXQgdXAuXG4gICAgICBpZiAoc2VsZi5fc3RlcmVvKSB7XG4gICAgICAgIHBhcmVudC5zdGVyZW8oc2VsZi5fc3RlcmVvKTtcbiAgICAgIH0gZWxzZSBpZiAoc2VsZi5fcG9zKSB7XG4gICAgICAgIHBhcmVudC5wb3Moc2VsZi5fcG9zWzBdLCBzZWxmLl9wb3NbMV0sIHNlbGYuX3Bvc1syXSwgc2VsZi5faWQpO1xuICAgICAgfVxuICAgIH07XG4gIH0pKFNvdW5kLnByb3RvdHlwZS5pbml0KTtcblxuICAvKipcbiAgICogT3ZlcnJpZGUgdGhlIFNvdW5kLnJlc2V0IG1ldGhvZCB0byBjbGVhbiB1cCBwcm9wZXJ0aWVzIGZyb20gdGhlIHNwYXRpYWwgcGx1Z2luLlxuICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gX3N1cGVyIFNvdW5kIHJlc2V0IG1ldGhvZC5cbiAgICogQHJldHVybiB7U291bmR9XG4gICAqL1xuICBTb3VuZC5wcm90b3R5cGUucmVzZXQgPSAoZnVuY3Rpb24oX3N1cGVyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIHBhcmVudCA9IHNlbGYuX3BhcmVudDtcblxuICAgICAgLy8gUmVzZXQgYWxsIHNwYXRpYWwgcGx1Z2luIHByb3BlcnRpZXMgb24gdGhpcyBzb3VuZC5cbiAgICAgIHNlbGYuX29yaWVudGF0aW9uID0gcGFyZW50Ll9vcmllbnRhdGlvbjtcbiAgICAgIHNlbGYuX3BvcyA9IHBhcmVudC5fcG9zO1xuICAgICAgc2VsZi5fcGFubmVyQXR0ciA9IHBhcmVudC5fcGFubmVyQXR0cjtcblxuICAgICAgLy8gQ29tcGxldGUgcmVzZXR0aW5nIG9mIHRoZSBzb3VuZC5cbiAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICB9O1xuICB9KShTb3VuZC5wcm90b3R5cGUucmVzZXQpO1xuXG4gIC8qKiBIZWxwZXIgTWV0aG9kcyAqKi9cbiAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IHBhbm5lciBub2RlIGFuZCBzYXZlIGl0IG9uIHRoZSBzb3VuZC5cbiAgICogQHBhcmFtICB7U291bmR9IHNvdW5kIFNwZWNpZmljIHNvdW5kIHRvIHNldHVwIHBhbm5pbmcgb24uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFR5cGUgb2YgcGFubmVyIHRvIGNyZWF0ZTogJ3N0ZXJlbycgb3IgJ3NwYXRpYWwnLlxuICAgKi9cbiAgdmFyIHNldHVwUGFubmVyID0gZnVuY3Rpb24oc291bmQsIHR5cGUpIHtcbiAgICB0eXBlID0gdHlwZSB8fCAnc3BhdGlhbCc7XG5cbiAgICAvLyBDcmVhdGUgdGhlIG5ldyBwYW5uZXIgbm9kZS5cbiAgICBpZiAodHlwZSA9PT0gJ3NwYXRpYWwnKSB7XG4gICAgICBzb3VuZC5fcGFubmVyID0gSG93bGVyLmN0eC5jcmVhdGVQYW5uZXIoKTtcbiAgICAgIHNvdW5kLl9wYW5uZXIuY29uZUlubmVyQW5nbGUgPSBzb3VuZC5fcGFubmVyQXR0ci5jb25lSW5uZXJBbmdsZTtcbiAgICAgIHNvdW5kLl9wYW5uZXIuY29uZU91dGVyQW5nbGUgPSBzb3VuZC5fcGFubmVyQXR0ci5jb25lT3V0ZXJBbmdsZTtcbiAgICAgIHNvdW5kLl9wYW5uZXIuY29uZU91dGVyR2FpbiA9IHNvdW5kLl9wYW5uZXJBdHRyLmNvbmVPdXRlckdhaW47XG4gICAgICBzb3VuZC5fcGFubmVyLmRpc3RhbmNlTW9kZWwgPSBzb3VuZC5fcGFubmVyQXR0ci5kaXN0YW5jZU1vZGVsO1xuICAgICAgc291bmQuX3Bhbm5lci5tYXhEaXN0YW5jZSA9IHNvdW5kLl9wYW5uZXJBdHRyLm1heERpc3RhbmNlO1xuICAgICAgc291bmQuX3Bhbm5lci5wYW5uaW5nTW9kZWwgPSBzb3VuZC5fcGFubmVyQXR0ci5wYW5uaW5nTW9kZWw7XG4gICAgICBzb3VuZC5fcGFubmVyLnJlZkRpc3RhbmNlID0gc291bmQuX3Bhbm5lckF0dHIucmVmRGlzdGFuY2U7XG4gICAgICBzb3VuZC5fcGFubmVyLnJvbGxvZmZGYWN0b3IgPSBzb3VuZC5fcGFubmVyQXR0ci5yb2xsb2ZmRmFjdG9yO1xuICAgICAgc291bmQuX3Bhbm5lci5zZXRQb3NpdGlvbihzb3VuZC5fcG9zWzBdLCBzb3VuZC5fcG9zWzFdLCBzb3VuZC5fcG9zWzJdKTtcbiAgICAgIHNvdW5kLl9wYW5uZXIuc2V0T3JpZW50YXRpb24oc291bmQuX29yaWVudGF0aW9uWzBdLCBzb3VuZC5fb3JpZW50YXRpb25bMV0sIHNvdW5kLl9vcmllbnRhdGlvblsyXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNvdW5kLl9wYW5uZXIgPSBIb3dsZXIuY3R4LmNyZWF0ZVN0ZXJlb1Bhbm5lcigpO1xuICAgICAgc291bmQuX3Bhbm5lci5wYW4udmFsdWUgPSBzb3VuZC5fc3RlcmVvO1xuICAgIH1cblxuICAgIHNvdW5kLl9wYW5uZXIuY29ubmVjdChzb3VuZC5fbm9kZSk7XG5cbiAgICAvLyBVcGRhdGUgdGhlIGNvbm5lY3Rpb25zLlxuICAgIGlmICghc291bmQuX3BhdXNlZCkge1xuICAgICAgc291bmQuX3BhcmVudC5wYXVzZShzb3VuZC5faWQsIHRydWUpLnBsYXkoc291bmQuX2lkKTtcbiAgICB9XG4gIH07XG59KSgpO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vaG93bGVyL2Rpc3QvaG93bGVyLmpzXG4gKiogbW9kdWxlIGlkID0gMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXHJcblxyXG5cclxuXHRcclxuXHR2YXIgZXZlbnRzID0ge30sXHJcblx0XHRpZFJlZ2lzdHJ5ID0gOTEwMDtcclxuXHRcclxuXHRcclxuXHRmdW5jdGlvbiBTdWJzY3JpYmUoZXZlbnQsIGZ1bmMpe1xyXG5cdFx0aWYoIWV2ZW50cy5oYXNPd25Qcm9wZXJ0eShldmVudCkpe1xyXG5cdFx0XHRldmVudHNbZXZlbnRdID0gW107XHJcblx0XHR9XHJcblx0XHRcclxuXHRcdHZhciBldmVudElEID0gKytpZFJlZ2lzdHJ5O1xyXG5cdFx0XHJcblx0XHRldmVudHNbZXZlbnRdLnB1c2goe1xyXG5cdFx0XHRcclxuXHRcdFx0aWQgOiBldmVudElELFxyXG5cdFx0XHRoYW5kbGVyIDogZnVuY1xyXG5cdFx0XHRcdFx0XHQgICBcclxuXHRcdFx0fSk7XHJcblx0XHRcclxuXHRcdHJldHVybiBldmVudElEO1xyXG5cclxuXHR9XHJcblx0XHJcblx0ZnVuY3Rpb24gUHVibGlzaCgpe1xyXG4gICAgICAgIFxyXG4gICAgICAgIFxyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciBldmVudCA9IGFyZ3VtZW50c1swXSxcclxuICAgICAgICAgICAgZGF0YSA9IGFyZ3VtZW50c1sxXSxcclxuICAgICAgICAgICAgcmVhbE9uZSA9IGFyZ3VtZW50c1syXTtcclxuXHRcdFxyXG4gICAgICAgIFxyXG4gICAgICAgIFxyXG5cdFx0XHRpZighZXZlbnRzLmhhc093blByb3BlcnR5KGV2ZW50KSl7XHJcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0XHR9XHJcblx0XHRcdFxyXG5cdFx0dmFyIHN1YnMgPSBldmVudHNbZXZlbnRdO1xyXG5cclxuXHRcdGZvcih2YXIgaSA9IDAsIGogPSBzdWJzLmxlbmd0aDsgaTxqOyBpKyspe1xyXG5cdFx0XHRcclxuXHRcdFx0c3Vic1tpXS5oYW5kbGVyKGV2ZW50LCBkYXRhKTtcclxuXHRcdFx0XHJcblx0XHR9XHJcblx0XHRcclxuXHR9XHJcblx0XHJcblx0ZnVuY3Rpb24gVW5zdWJzY3JpYmUoaWQpe1xyXG5cdFx0XHJcblx0XHRmb3IodmFyIGV2ZW50IGluIGV2ZW50cyl7XHJcblx0XHRcdGlmKGV2ZW50cy5oYXNPd25Qcm9wZXJ0eShldmVudCkpe1xyXG5cdFx0XHRcdGZvcih2YXIgaSA9IDAsIGogPSBldmVudHNbZXZlbnRdLmxlbmd0aDsgaTxqOyBpKyspe1xyXG5cdFx0XHRcdFx0aWYoZXZlbnRzW2V2ZW50XVtpXS5pZCA9PT0gaWQpe1xyXG5cdFx0XHRcdFx0XHRldmVudHNbZXZlbnRdLnNwbGljZShpLCAxKTtcclxuXHRcdFx0XHRcdFx0cmV0dXJuIGlkO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0XHJcblx0fVxyXG5cclxuXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgIFxyXG4gICAgc3Vic2NyaWJlIDogU3Vic2NyaWJlLFxyXG4gICAgcHVibGlzaCA6IFB1Ymxpc2gsXHJcbiAgICB1bnN1YnNjcmliZSA6IFVuc3Vic2NyaWJlXHJcbiAgICBcclxufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vanMvUHViU3ViLmpzXG4gKiogbW9kdWxlIGlkID0gM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIFJlc291cmNlTG9hZGVyID0gcmVxdWlyZSgnLi9SZXNvdXJjZUxvYWRlcicpLFxyXG4gICAgQWxnb3JpdGhtcyA9IHJlcXVpcmUoJy4vQWxnb3JpdGhtcycpLFxyXG4gICAgbWFpbkNhbnZhcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdiZ0NhbnZhcycpLFxyXG4gICAgUHViU3ViID0gcmVxdWlyZSgnLi9QdWJTdWInKSxcclxuICAgIGNlbnRlclggPSBtYWluQ2FudmFzLndpZHRoIC8gMixcclxuICAgIGNlbnRlclkgPSBtYWluQ2FudmFzLmhlaWdodCAvIDI7XHJcblxyXG5cclxuICAgICAgICBpbmhlcml0RnJvbShEaXNwbGF5LCBQaHlzaWNzKTtcclxuICAgICAgICBpbmhlcml0RnJvbShQaHlzaWNzLCBTcGFjZWNyYWZ0KTtcclxuICAgICAgICBpbmhlcml0RnJvbShEaXNwbGF5LCBCYWNrZ3JvdW5kKTtcclxuICAgICAgICAvL21ha2UgY3VzdG9tIGNsYXNzZXMgaW5oZXJpdCBkaXNwbGF5IGNsYXNzXHJcbiAgICAgICAgaW5oZXJpdEZyb20oUGh5c2ljcywgTWlzc2lsZSk7XHJcbiAgICAgICAgaW5oZXJpdEZyb20oRGlzcGxheSwgU2hpZWxkKTtcclxuICAgICAgICBpbmhlcml0RnJvbShTcGFjZWNyYWZ0LCBTaGlwKTtcclxuICAgICAgICBpbmhlcml0RnJvbShEaXNwbGF5LCBFeHBsb3Npb24pO1xyXG4gICAgICAgIGluaGVyaXRGcm9tKFNwYWNlY3JhZnQsIEVuZW15KTtcclxuICAgICAgICBpbmhlcml0RnJvbShQaHlzaWNzLCBSb2NrKTtcclxuICAgICAgICBpbmhlcml0RnJvbShTcGFjZWNyYWZ0LCBNb3RoZXJzaGlwKTtcclxuICAgICAgICBpbmhlcml0RnJvbShQaHlzaWNzLCBQZXJrKTsgICBcclxuICAgIFxyXG5cclxuXHJcbiAgICAvL2luaGVyaXRlciBmdW5jdGlvblxyXG4gICAgZnVuY3Rpb24gaW5oZXJpdEZyb20ocGFyZW50LCBjaGlsZCl7XHJcbiAgICAgICAgdmFyIGNvcHlPZlBhcmVudCA9IE9iamVjdC5jcmVhdGUocGFyZW50LnByb3RvdHlwZSk7XHJcbiAgICAgICAgY29weU9mUGFyZW50LmNvbnN0cnVjdG9yID0gY2hpbGQ7XHJcbiAgICAgICAgY2hpbGQucHJvdG90eXBlID0gY29weU9mUGFyZW50O1xyXG4gICAgfVxyXG5cclxuICAgIC8vY3VzdG9tIGNsYXNzZXNcclxuXHRmdW5jdGlvbiBEaXNwbGF5KCl7XHJcbiAgICAgICBcclxuXHRcdHRoaXMuY2FudmFzV2lkdGggPSAwO1xyXG5cdFx0dGhpcy5jYW52YXNIZWlnaHQgPSAwO1xyXG5cdFx0dGhpcy5jZW50ZXJYID0gMDtcclxuXHRcdHRoaXMuY2VudGVyWSA9IDA7XHJcblx0XHR0aGlzLmhlaWdodCA9IDA7XHJcblx0XHR0aGlzLndpZHRoID0gMDtcclxuXHRcdHRoaXMueCA9IDA7XHJcblx0XHR0aGlzLnkgPSAwO1xyXG5cdFx0dGhpcy5jb2xvciA9IFwiIzAwRkYwMFwiO1xyXG5cdFx0dGhpcy5hbHBoYSA9IDE7XHJcbiAgICAgICAgdGhpcy5hbGl2ZSA9IGZhbHNlOyAgXHJcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMudHlwZSA9IFwiZGlzcGxheVwiO1xyXG4gICAgICAgXHJcblx0fVxyXG4gICAgICAgIC8vdGVtcCBwcm90byBtZXRob2QuLi4uXHJcbiAgICBEaXNwbGF5LnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uKCl7XHJcblx0XHRcdHRoaXMueCA9IDA7XHJcblx0XHRcdHRoaXMueSA9IDA7XHJcblx0XHRcdHRoaXMuYW5nbGUgPSAwO1xyXG5cdFx0XHR0aGlzLnZlbFggPSAwO1xyXG5cdFx0XHR0aGlzLnZlbFkgPSAwO1xyXG5cdFx0XHR0aGlzLmFsaXZlID0gZmFsc2U7XHJcblx0XHRcdHRoaXMuY29sbGlkaW5nID0gZmFsc2U7XHJcblx0XHR9O1xyXG4gICAgXHJcbiAgICBEaXNwbGF5LnByb3RvdHlwZS5zZXRDYW52YXMgPSBmdW5jdGlvbihjYW52YXMpe1xyXG5cdFx0XHR0aGlzLmNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcclxuXHRcdFx0dGhpcy5jYW52YXNXaWR0aCA9IGNhbnZhcy53aWR0aDtcclxuXHRcdFx0dGhpcy5jYW52YXNIZWlnaHQgPSBjYW52YXMuaGVpZ2h0O1xyXG5cdFx0fTtcclxuICAgIFxyXG4gICAgRGlzcGxheS5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQpe1xyXG5cdFx0XHR0aGlzLndpZHRoID0gd2lkdGggfHwgMjA7XHJcblx0XHRcdHRoaXMuaGVpZ2h0ID0gaGVpZ2h0IHx8IDIwO1xyXG5cdFx0XHR0aGlzLmNlbnRlclggPSB3aWR0aC8yO1xyXG5cdFx0XHR0aGlzLmNlbnRlclkgPSBoZWlnaHQvMjtcclxuXHRcdFx0dGhpcy5hbGl2ZSA9IGZhbHNlO1xyXG5cdFx0fTtcclxuXHJcbiAgICBmdW5jdGlvbiBQaHlzaWNzKCl7XHJcbiAgICAgICAgXHJcbiAgICAgICAgICAgIERpc3BsYXkuY2FsbCh0aGlzKTtcclxuICAgICAgICBcclxuICAgICAgICB0aGlzLnZlbFggPSAwO1xyXG4gICAgICAgIHRoaXMudmVsWSA9IDA7XHJcbiAgICAgICAgdGhpcy5hY2VsWCA9IDA7XHJcbiAgICAgICAgdGhpcy5hY2VsWSA9IDA7XHJcbiAgICAgICAgdGhpcy5jb2xsaWRpbmcgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnNwZWVkID0gMDsgXHJcbiAgICAgICAgdGhpcy50aHJ1c3QgPSAwO1xyXG4gICAgICAgIHRoaXMuYW5nbGUgPSAwO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBQaHlzaWNzLnByb3RvdHlwZS5zcGF3biA9IGZ1bmN0aW9uKHgsIHksIGFuZ2xlLCBzcGVlZCl7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdGhpcy54ID0geCB8fCBjZW50ZXJYO1xyXG4gICAgICAgIHRoaXMueSA9IHkgfHwgY2VudGVyWTtcclxuICAgICAgICB0aGlzLmNvbGxpZGluZyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuYWxpdmUgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuYW5nbGUgPSBhbmdsZSB8fCB0aGlzLmFuZ2xlO1xyXG4gICAgICAgIHRoaXMuc3BlZWQgPSBzcGVlZCB8fCB0aGlzLnNwZWVkO1xyXG4gICAgICAgIHRoaXMudmVsWCA9IE1hdGguY29zKHRoaXMuYW5nbGUpKnRoaXMuc3BlZWQ7XHJcbiAgICAgICAgdGhpcy52ZWxZID0gTWF0aC5zaW4odGhpcy5hbmdsZSkqdGhpcy5zcGVlZDtcclxuICAgICAgICBcclxuICAgIH07XHJcbiAgICBcclxuICAgIFBoeXNpY3MucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpe1xyXG4gICAgICAgIHRoaXMuYWxpdmUgPSBmYWxzZTsgXHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICAvL3NwYWNlQ3JhZnQgZnVuY3Rpb24gY29uc3RydWN0b3IgXHJcbiAgICBmdW5jdGlvbiBTcGFjZWNyYWZ0KCl7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgIFBoeXNpY3MuY2FsbCh0aGlzKTtcclxuICAgICAgICBcclxuICAgICAgICB0aGlzLmF1dG9TcGF3biA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMudGhydXN0QWNjZWwgPSAwLjAzO1xyXG4gICAgICAgIHRoaXMuYWxwaGFTcGVlZCA9IDAuMDM7XHJcbiAgICAgICAgdGhpcy5zaGllbGRBY3RpdmUgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnNoaWVsZERpc2FibGVkID0gZmFsc2U7XHJcblx0XHR0aGlzLm1heFZlbG9jaXR5ID0gNDtcclxuICAgICAgICB0aGlzLm1pc3NpbGVzU3BlZWQgPSAyLjU7XHJcblx0XHR0aGlzLmVhc2VWYWx1ZSA9IDAuMDM7XHJcblx0XHR0aGlzLmp1bXBpbmcgPSBmYWxzZTtcclxuICAgICAgICBcclxuICAgIH1cclxuXHRcdFxyXG4gICAgU3BhY2VjcmFmdC5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQpe1xyXG4gICAgICAgIFxyXG4gICAgICAgICAgICBEaXNwbGF5LnByb3RvdHlwZS5pbml0LmNhbGwodGhpcywgd2lkdGgsIGhlaWdodCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIHNoaWVsZCA9IG5ldyBTaGllbGQoKTtcclxuICAgICAgICAgICAgc2hpZWxkLnNldENhbnZhcyhtYWluQ2FudmFzKTtcclxuICAgICAgICAgICAgc2hpZWxkLmluaXQoODAsODApO1xyXG5cdFx0dmFyIG1pc3NpbGVQb29sID0gbmV3IFBvb2woMTApO1xyXG5cdFx0XHRtaXNzaWxlUG9vbC5pbml0KCdtaXNzaWxlJyk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgIHZhciBleHBsb3Npb24gPSBuZXcgRXhwbG9zaW9uKDE1KTtcclxuICAgICAgICAgICAgZXhwbG9zaW9uLnNldENhbnZhcyhtYWluQ2FudmFzKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgIHRoaXMuZXhwbG9zaW9uID0gZXhwbG9zaW9uO1xyXG4gICAgICAgIHRoaXMuc2hpZWxkID0gc2hpZWxkO1xyXG4gICAgICAgIHRoaXMubWlzc2lsZXMgPSBtaXNzaWxlUG9vbDtcclxuICAgICAgICBcclxuICAgIH07ICAgIFxyXG5cdFxyXG4gICAgU3BhY2VjcmFmdC5wcm90b3R5cGUuZm9sbG93ID0gZnVuY3Rpb24ob2JqZWN0KXtcclxuICAgICAgICBcclxuXHRcdFx0aWYoIW9iamVjdC5hbGl2ZSB8fCB0aGlzLmp1bXBpbmcpe1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fVx0XHJcblx0XHRcdHZhciBkeCwgZHksIGRpc3RhbmNlLCBuZXdWZWxYLCBuZXdWZWxZLCBmdXR1cmVWZWwsIGRpcmVjdGlvbjtcclxuXHRcdFx0ZHggPSBvYmplY3QueCAtIHRoaXMueDtcclxuXHRcdFx0ZHkgPSBvYmplY3QueSAtIHRoaXMueTtcclxuXHRcdFx0ZGlzdGFuY2UgPSBNYXRoLnNxcnQoZHgqZHgrZHkqZHkpO1xyXG5cdFx0XHRkaXJlY3Rpb24gPSBNYXRoLmF0YW4yKGR5LCBkeCk7XHJcblx0XHRcdHRoaXMuYW5nbGUgPSBkaXJlY3Rpb247XHJcblx0XHRcdFxyXG5cdFx0XHRpZihkaXN0YW5jZT49MTQwKXtcclxuXHRcdFx0bmV3VmVsWCA9IHRoaXMudmVsWCtNYXRoLmNvcyh0aGlzLmFuZ2xlKSp0aGlzLnRocnVzdEFjY2VsO1xyXG5cdFx0XHRuZXdWZWxZID0gdGhpcy52ZWxZK01hdGguc2luKHRoaXMuYW5nbGUpKnRoaXMudGhydXN0QWNjZWw7XHRcclxuXHRcdFx0ZnV0dXJlVmVsID0gTWF0aC5zcXJ0KG5ld1ZlbFgqbmV3VmVsWCArIG5ld1ZlbFkqbmV3VmVsWSk7XHRcclxuXHRcdFx0XHRcdGlmKGZ1dHVyZVZlbD4xLjUpe1xyXG5cdFx0XHRcdG5ld1ZlbFggPSB0aGlzLnZlbFg7XHJcblx0XHRcdFx0bmV3VmVsWSA9IHRoaXMudmVsWTtcclxuXHRcdFx0XHR9ZWxzZXtcclxuXHRcdFx0XHR0aGlzLnZlbFggPSBuZXdWZWxYO1xyXG5cdFx0XHRcdHRoaXMudmVsWSA9IG5ld1ZlbFk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHRcclxuICAgIH07XHJcbiAgICBcclxuICAgIFNwYWNlY3JhZnQucHJvdG90eXBlLmF0dGFjayA9IGZ1bmN0aW9uKG9iamVjdCl7XHJcblx0XHRcdGlmKE1hdGgucmFuZG9tKCkgPj0gMC4wMDUgfHwgIXRoaXMuYWxpdmUgfHwgIW9iamVjdC5hbGl2ZSl7XHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR9XHJcblx0XHRcdHRoaXMuc2hvb3QoKTtcclxuICAgIH07XHJcbiAgICBcclxuICAgIFNwYWNlY3JhZnQucHJvdG90eXBlLnNwYXduID0gZnVuY3Rpb24oeCwgeSwgYW5nbGUsIHNwZWVkKXtcclxuICAgICAgICBcclxuICAgICAgICAgICAgUGh5c2ljcy5wcm90b3R5cGUuc3Bhd24uY2FsbCh0aGlzLCB4LCB5LCBhbmdsZSwgc3BlZWQpO1xyXG4gICAgICAgICAgICB0aGlzLm1pc3NpbGVzLmhpZGVJdGVtcygpO1xyXG4gICAgICAgICAgICAvL3RoaXMuc2hpZWxkLnJlc2V0KCk7XHJcblx0XHRcdHRoaXMuanVtcGluZyA9IGZhbHNlO1xyXG4gICAgICAgIFxyXG4gICAgfTtcclxuICAgIFxyXG4gICAgU3BhY2VjcmFmdC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgdGhpcy5jb2xsaWRpbmcgPSB0cnVlOyAgXHJcbiAgICAgICAgUmVzb3VyY2VMb2FkZXIuYXNzZXRzLmV4cGxvc2lvblNvdW5kLnBsYXkoKTtcclxuICAgIH07XHJcblxyXG5cdFNwYWNlY3JhZnQucHJvdG90eXBlLmp1bXAgPSBmdW5jdGlvbigpe1xyXG5cdFx0XHJcblx0XHQvL2lmIHNwYWNlY3JhZnQgaXMgbm90IGp1bXBpbmcsIGhhdmUgaXQgZmFjZSB0byB0aGUgcmlnaHQgYW5kIG5vIFkgdmVsb2NpdHkuXHJcblx0XHRpZighdGhpcy5qdW1waW5nKXtcclxuXHRcdFx0dGhpcy52ZWxZID0gdGhpcy5hbmdsZSA9IDA7XHJcblx0XHRcdHRoaXMudmVsWCA9IDE7XHJcblx0XHRcdHRoaXMuanVtcGluZyA9IHRydWU7XHJcblx0XHR9XHJcblx0XHRcclxuXHR9O1xyXG5cclxuICAgIFNwYWNlY3JhZnQucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbigpe1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vZHJhd3Mgc3BhY2VjcmFmdCBsYXVuY2hlZCBtaXNzaWxlc1xyXG4gICAgICAgIGZvcih2YXIgaT0wOyBpPHRoaXMubWlzc2lsZXMucG9vbC5sZW5ndGg7IGkrKyl7XHJcbiAgICAgICAgICAgIHZhciBjdXJyZW50TWlzc2lsZSA9IHRoaXMubWlzc2lsZXMucG9vbFtpXTsgICBcclxuICAgICAgICAgICAgaWYoY3VycmVudE1pc3NpbGUuYWxpdmUpe1xyXG4gICAgICAgICAgICAgICAgY3VycmVudE1pc3NpbGUuZHJhdygpOyAgIFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIGlmKHRoaXMuY29sbGlkaW5nKXtcdFxyXG4gICAgICAgICAgICAgICAgLy9pZiBzcGFjZWNyYWZ0IGlzIGNvbGxpZGluZywgY3JlYXRlIGFuIGV4cGxvc2lvblxyXG4gICAgICAgICAgICB0aGlzLmV4cGxvc2lvbi5jcmVhdGUodGhpcy54K3RoaXMuY2VudGVyWCwgdGhpcy55K3RoaXMuY2VudGVyWSk7XHJcbiAgICAgICAgICAgIHRoaXMuZXhwbG9zaW9uLmRyYXcoKTtcclxuICAgICAgICAgICAgICAgIC8vb25jZSB0aGUgZXhwbG9zaW9uIGlzIG5vdCBydW5uaW5nLCBraWxsIG9mZiBzcGFjZWNyYWZ0XHJcbiAgICAgICAgICAgIGlmKCF0aGlzLmV4cGxvc2lvbi5ydW5uaW5nKXtcclxuICAgICAgICAgICAgICAgIHRoaXMuYWxpdmUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29sbGlkaW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBpZih0aGlzLmF1dG9TcGF3bil7XHJcbiAgICAgICAgICAgICAgICAgdGhpcy5zcGF3bigpOyAgIFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvL3JldHVybiB3aGlsZSBjb2xsaWRpbmdcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgIH1cclxuICAgICAgICAgICAgLy9pZiBzaGllbGQgaXMgYWN0aXZlIGRyYXcgaXQuXHJcbiAgICAgICAgaWYodGhpcy5zaGllbGQuYWN0aXZlKXtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2hpZWxkLnggPSB0aGlzLngtdGhpcy5zaGllbGQuY2VudGVyWCt0aGlzLmNlbnRlclg7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNoaWVsZC55ID0gdGhpcy55LXRoaXMuc2hpZWxkLmNlbnRlclkrdGhpcy5jZW50ZXJZO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zaGllbGQuZHJhdygpO1xyXG4gICAgICAgIH1cclxuXHRcdFxyXG5cdFx0Ly9pZiBzcGFjZWNyYWZ0IGlzIGp1bXBpbmcsIGVhc2UgdGhlIHNwYWNlY3JhZnQgb3V0LlxyXG5cdFx0aWYodGhpcy5qdW1waW5nICYmIHRoaXMudmVsWCA8IDEwKXtcclxuXHRcdFx0XHJcblx0XHRcdHRoaXMudmVsWCArPSB0aGlzLnZlbFgqdGhpcy5lYXNlVmFsdWU7XHJcblx0XHRcdFxyXG5cdFx0fVxyXG5cdFx0XHJcblx0XHRcclxuICAgICAgICBcclxuICAgIH07XHJcbiAgICBcclxuICAgIFNwYWNlY3JhZnQucHJvdG90eXBlLnNob290ID0gZnVuY3Rpb24oKXtcclxuICAgICAgICBcclxuICAgICAgICAvL2lmIGluc3RhbmNlIGlzIG5vdCBhbGl2ZSwgaXMgY29sbGlkaW5nIG9yIG5vdCBtb3ZpbmcsIGl0IHdpbGwgTk9UIHNob290XHJcbiAgICAgICAgaWYoIXRoaXMuYWxpdmUgfHwgdGhpcy5jb2xsaWRpbmcgfHwgdGhpcy52ZWxYID09IDApe1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5taXNzaWxlcy5nZXQodGhpcy54KzEwLCB0aGlzLnkrMTAsIFwibWlzc2lsZVwiLCB0aGlzLmFuZ2xlLCB0aGlzLm1pc3NpbGVzU3BlZWQpO1xyXG5cdFx0XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICAvL2NsYXNzIGZvciB0aGUgcm9ja3MgZmxvYXRpbmdcclxuICAgIGZ1bmN0aW9uIFJvY2soKXtcclxuICAgICAgICBcclxuICAgICAgICAgICAgUGh5c2ljcy5jYWxsKHRoaXMpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHRoaXMuc2l6ZTtcclxuICAgICAgICB0aGlzLnNwcml0ZUFuaW1hdGlvbiA9IG5ldyBTcHJpdGVBbmltYXRpb24oKTtcclxuICAgICAgICB0aGlzLnNwcml0ZUFuaW1hdGlvbi5zZXRDYW52YXMobWFpbkNhbnZhcyk7XHJcbiAgICAgICAgdGhpcy5leHBsb3Npb24gPSBuZXcgRXhwbG9zaW9uKDcpO1xyXG4gICAgICAgIHRoaXMuZXhwbG9zaW9uLnNldENhbnZhcyhtYWluQ2FudmFzKTtcclxuICAgICAgICB0aGlzLnR5cGUgPSAncm9jayc7XHJcbiAgICBcclxuICAgIH1cclxuICAgIFxyXG4gICAgUm9jay5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKHNpemUpe1xyXG4gICAgICAgIFxyXG4gICAgICAgICAgdmFyIHNwcml0ZUFuaW1hdGlvbkluZm8sXHJcbiAgICAgICAgICAgICAgbGFyZ2VSb2NrU3BlZWQgPSAwLjUsXHJcbiAgICAgICAgICAgICAgbWVkaXVtUm9ja1NwZWVkID0gMSxcclxuICAgICAgICAgICAgICBzbWFsbFJvY2tTcGVlZCA9IDEuMixcclxuICAgICAgICAgICAgICByYW5kb21BbmdsZTtcclxuICAgICAgICBcclxuICAgICAgICAgIHRoaXMuc3ByaXRlID0gUmVzb3VyY2VMb2FkZXIuYXNzZXRzLm1ldGVvclNwcml0ZTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHNpemUgPSBzaXplIHx8IFwibGFyZ2VcIjtcclxuICAgIFxyXG4gICAgICAgICAgICBzd2l0Y2goc2l6ZSl7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwibGFyZ2VcIjpcclxuICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICBzcHJpdGVBbmltYXRpb25JbmZvID0ge3dpZHRoOjU2LGhlaWdodDo1NSwgb2Zmc2V0WDogMCwgb2Zmc2V0WTogMCwgbnVtQ29sOjIsIG51bVJvdzo5LGZwczo2MCxzcGVlZDo4LGxvb3A6ZmFsc2UsZnJvbTowLHRvOjE3fTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNwcml0ZUFuaW1hdGlvbi5pbml0KHNwcml0ZUFuaW1hdGlvbkluZm8pO1xyXG4gICAgICAgICAgICAgICAgICAgIHJhbmRvbUFuZ2xlID0gTWF0aC5yYW5kb20oKSooTWF0aC5QSSoyKTtcclxuICAgICAgICAgICAgICAgICAgICBEaXNwbGF5LnByb3RvdHlwZS5pbml0LmNhbGwodGhpcywgc3ByaXRlQW5pbWF0aW9uSW5mby53aWR0aCwgc3ByaXRlQW5pbWF0aW9uSW5mby5oZWlnaHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIFBoeXNpY3MucHJvdG90eXBlLnNwYXduLmNhbGwodGhpcywgMCwgMCwgcmFuZG9tQW5nbGUsIGxhcmdlUm9ja1NwZWVkKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFsaXZlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zaXplID0gXCJsYXJnZVwiO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHlwZSA9IFwibGFyZ2VSb2NrXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICBjYXNlIFwibWVkaXVtXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgc3ByaXRlQW5pbWF0aW9uSW5mbyA9IHt3aWR0aDo0NCxoZWlnaHQ6NDQsIG51bUNvbDozLCBudW1Sb3c6NixmcHM6NjAsb2Zmc2V0WDogMTMwLCBvZmZzZXRZIDogMCwgc3BlZWQ6MTIsbG9vcDp0cnVlLGZyb206MCx0bzoxN307ICAgXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zcHJpdGVBbmltYXRpb24uaW5pdChzcHJpdGVBbmltYXRpb25JbmZvKTtcclxuICAgICAgICAgICAgICAgICAgICByYW5kb21BbmdsZSA9IE1hdGgucmFuZG9tKCkqKE1hdGguUEkqMik7XHJcbiAgICAgICAgICAgICAgICAgICAgRGlzcGxheS5wcm90b3R5cGUuaW5pdC5jYWxsKHRoaXMsIHNwcml0ZUFuaW1hdGlvbkluZm8ud2lkdGgsIHNwcml0ZUFuaW1hdGlvbkluZm8uaGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgICAgICBQaHlzaWNzLnByb3RvdHlwZS5zcGF3bi5jYWxsKHRoaXMsIDAsIDAsIHJhbmRvbUFuZ2xlLCBtZWRpdW1Sb2NrU3BlZWQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWxpdmUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNpemUgPSBcIm1lZGl1bVwiO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHlwZSA9IFwibWVkaXVtUm9ja1wiO1xyXG4gICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgY2FzZSBcInNtYWxsXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgc3ByaXRlQW5pbWF0aW9uSW5mbyA9IHt3aWR0aDozMyxoZWlnaHQ6MzMsIG51bUNvbDozLG9mZnNldFg6IDI5MCwgb2Zmc2V0WTogMCwgbnVtUm93OjYsZnBzOjYwLHNwZWVkOjE1LGxvb3A6dHJ1ZSxmcm9tOjAsdG86MTd9O1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3ByaXRlQW5pbWF0aW9uLmluaXQoc3ByaXRlQW5pbWF0aW9uSW5mbyk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmFuZG9tQW5nbGUgPSBNYXRoLnJhbmRvbSgpKihNYXRoLlBJKjIpO1xyXG4gICAgICAgICAgICAgICAgICAgIERpc3BsYXkucHJvdG90eXBlLmluaXQuY2FsbCh0aGlzLCBzcHJpdGVBbmltYXRpb25JbmZvLndpZHRoLCBzcHJpdGVBbmltYXRpb25JbmZvLmhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICAgICAgUGh5c2ljcy5wcm90b3R5cGUuc3Bhd24uY2FsbCh0aGlzLCAwLCAwLCByYW5kb21BbmdsZSwgc21hbGxSb2NrU3BlZWQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWxpdmUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNpemUgPSBcInNtYWxsXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50eXBlID0gXCJzbWFsbFJvY2tcIjtcclxuICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgIH07XHJcbiAgICBcclxuICAgIFJvY2sucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICBcclxuXHRcdFx0aWYodGhpcy5jb2xsaWRpbmcpeyBcclxuICAgICAgICAgICAgLy93aGVuIG9iamVjdCBpcyBjb2xsaWRpbmcsIGNyZWF0ZXMgYW5kIGRyYXdzIGV4cGxvc2lvblxyXG5cdFx0XHR0aGlzLmV4cGxvc2lvbi5jcmVhdGUodGhpcy54K3RoaXMuY2VudGVyWCwgdGhpcy55K3RoaXMuY2VudGVyWSk7XHJcblx0XHRcdHRoaXMuZXhwbG9zaW9uLmRyYXcoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGVzdHJveSgpO1xyXG5cclxuXHRcdFx0ICAgICBpZighdGhpcy5leHBsb3Npb24ucnVubmluZyl7XHJcblx0XHRcdCAgICAgLy9vbmNlIGV4cGxvc2lvbiBpcyBvdmVyLCBraWxscyBvZmYgb2JqZWN0XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb2xsaWRpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFsaXZlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlIGV4cGxvc2lvbiBpcyBzdGlsbCBydW5uaW5nIHJldHVybiB0byBkcmF3aW5nIHRoZSBleHBsb3Npb25cclxuXHRcdFx0ICAgICByZXR1cm47XHJcblx0XHRcdH1cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHRoaXMueCArPSB0aGlzLnZlbFg7XHJcbiAgICAgICAgICAgIHRoaXMueSArPSB0aGlzLnZlbFk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB0aGlzLnNwcml0ZUFuaW1hdGlvbi5wbGF5KHRoaXMueCwgdGhpcy55LCB0aGlzLnNwcml0ZSk7ICAgIFxyXG4gICAgICAgICAgICBcclxuICAgICAgICB9O1xyXG4gICAgXHJcbiAgICBSb2NrLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKXtcclxuICAgICAgICBcclxuICAgICAgICAgICAgaWYodGhpcy5jb2xsaWRpbmcpe1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgICAgIFJlc291cmNlTG9hZGVyLmFzc2V0cy5tZXRlb3JFeHBsb3Npb25Tb3VuZC5wbGF5KCk7XHJcbiAgICAgICAgICAgIHRoaXMuY29sbGlkaW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIFB1YlN1Yi5wdWJsaXNoKCdtZXRlb3JfZXhwbG9zaW9uJywgdGhpcyk7XHJcbiAgICAgICAgXHJcbiAgICB9OyAgICBcclxuICAgIFxyXG5cdGZ1bmN0aW9uIEJhY2tncm91bmQoKXtcclxuICAgICAgICBcclxuICAgICAgICAgICAgRGlzcGxheS5jYWxsKHRoaXMpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHRoaXMudmVsWCA9IDA7XHJcbiAgICAgICAgdGhpcy52ZWxZID0gMDtcclxuXHRcdHRoaXMucHJvZ3Jlc3NCYXJXaWR0aCA9IDQwMDtcclxuXHRcdHRoaXMucHJvZ3Jlc3NCYXJIZWlnaHQgPSA0MDtcclxuXHR9XHJcbiAgICBcclxuICAgIEJhY2tncm91bmQucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICB0aGlzLnggKz0gdGhpcy52ZWxYO1xyXG5cdFx0XHR0aGlzLnkgKz0gdGhpcy52ZWxZO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgdGhpcy5jb250ZXh0LmRyYXdJbWFnZShSZXNvdXJjZUxvYWRlci5hc3NldHMuYmFja2dyb3VuZFNwcml0ZSwgMCwwLHRoaXMuY2FudmFzV2lkdGgsdGhpcy5jYW52YXNIZWlnaHQsdGhpcy54LXRoaXMuY2FudmFzV2lkdGgsIHRoaXMueSx0aGlzLmNhbnZhc1dpZHRoLHRoaXMuY2FudmFzSGVpZ2h0KTtcdFxyXG4gICAgICAgICAgICB0aGlzLmNvbnRleHQuZHJhd0ltYWdlKFJlc291cmNlTG9hZGVyLmFzc2V0cy5iYWNrZ3JvdW5kU3ByaXRlLCAwLDAsdGhpcy5jYW52YXNXaWR0aCx0aGlzLmNhbnZhc0hlaWdodCx0aGlzLngsdGhpcy55LHRoaXMuY2FudmFzV2lkdGgsdGhpcy5jYW52YXNIZWlnaHQpO1xyXG5cdFx0XHRcclxuXHRcdFx0aWYodGhpcy54PnRoaXMuY2FudmFzV2lkdGgpe1xyXG5cdFx0XHRcdHRoaXMueCA9IDA7XHJcblx0XHRcdH1cdFxyXG4gICAgfTtcclxuICAgIFxyXG5cdGZ1bmN0aW9uIFNoaXAoKXtcclxuICAgICAgICBcclxuICAgICAgICAgICAgICAgIFNwYWNlY3JhZnQuY2FsbCh0aGlzKTtcclxuICAgICAgICBcclxuICAgICAgICAgICAgdmFyIHNoaXBTcHJpdGVJbmZvID0ge3dpZHRoOjIxLGhlaWdodDoyMiwgbnVtQ29sOjEsIG51bVJvdzoyLGZwczo2MCxzcGVlZDozMCxsb29wOmZhbHNlLGZyb206MCx0bzowfTtcclxuICAgICAgICBcclxuICAgICAgICAgICAgdGhpcy50aHJ1c3QgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5hdXRvU3Bhd24gPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLnRocnVzdEFjY2VsID0gMC4wNDtcclxuICAgICAgICAgICAgdGhpcy5taXNzaWxlc1NwZWVkID0gMy4yO1xyXG4gICAgICAgICAgICB0aGlzLnNwcml0ZUFuaW1hdGlvbiA9IG5ldyBTcHJpdGVBbmltYXRpb24oKTtcclxuICAgICAgICAgICAgdGhpcy5zcHJpdGVBbmltYXRpb24uc2V0Q2FudmFzKG1haW5DYW52YXMpO1xyXG4gICAgICAgICAgICB0aGlzLnNwcml0ZUFuaW1hdGlvbi5pbml0KHNoaXBTcHJpdGVJbmZvKTsgXHJcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IFwiaHVtYW5TaGlwXCI7XHJcbiAgICAgICAgXHJcblx0fVxyXG4gICAgXHJcbiAgICBTaGlwLnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24oKXtcclxuICAgICAgICBcclxuICAgICAgICAgICBTcGFjZWNyYWZ0LnByb3RvdHlwZS5kcmF3LmNhbGwodGhpcyk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYodGhpcy5jb2xsaWRpbmcpe1xyXG4gICAgICAgICAgICByZXR1cm47ICAgXHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LnNhdmUoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuYWxwaGEgKz0gdGhpcy5hbHBoYVNwZWVkO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hbHBoYSA9ICh0aGlzLmFscGhhID49IDEpPyAxOiB0aGlzLmFscGhhO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0Lmdsb2JhbEFscGhhID0gdGhpcy5hbHBoYTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC50cmFuc2xhdGUodGhpcy54KzEwLCB0aGlzLnkrMTApO1x0XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQucm90YXRlKHRoaXMuYW5nbGUpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy54ICs9IHRoaXMudmVsWDtcclxuICAgICAgICAgICAgICAgIHRoaXMueSArPSB0aGlzLnZlbFk7XHJcbiAgICAgICAgICAgICAgICBpZih0aGlzLnRocnVzdCl7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zcHJpdGVBbmltYXRpb24uc3RhcnRGcmFtZSA9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zcHJpdGVBbmltYXRpb24uZmluYWxGcmFtZSA9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zcHJpdGVBbmltYXRpb24ucGxheSgtdGhpcy5jZW50ZXJYLCAtdGhpcy5jZW50ZXJZLCBSZXNvdXJjZUxvYWRlci5hc3NldHMucGxheWVyU3ByaXRlU2hlZXQpO1xyXG4gICAgICAgICAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgICAgICAgICAgLy90aGlzLmNvbnRleHQuZHJhd0ltYWdlKHNoaXBTcHJpdGUsIDAsIDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCAtMTAsLTEwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zcHJpdGVBbmltYXRpb24uc3RhcnRGcmFtZSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zcHJpdGVBbmltYXRpb24uZmluYWxGcmFtZSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zcHJpdGVBbmltYXRpb24ucGxheSgtdGhpcy5jZW50ZXJYLCAtdGhpcy5jZW50ZXJZLCBSZXNvdXJjZUxvYWRlci5hc3NldHMucGxheWVyU3ByaXRlU2hlZXQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LnJlc3RvcmUoKTtcclxuICAgIH07XHJcblx0XHJcblx0U2hpcC5wcm90b3R5cGUuc2hvb3QgPSBmdW5jdGlvbigpe1xyXG5cdFx0U3BhY2VjcmFmdC5wcm90b3R5cGUuc2hvb3QuY2FsbCh0aGlzKTtcclxuXHRcdFJlc291cmNlTG9hZGVyLmFzc2V0cy5wbGF5ZXJTaG9vdFNvdW5kLnBsYXkoKTtcclxuXHR9O1xyXG4gICAgXHJcbiAgICBmdW5jdGlvbiBQZXJrKCl7XHJcbiAgICAgICAgXHJcbiAgICAgICAgICAgIFBoeXNpY3MuY2FsbCh0aGlzKTtcclxuICAgICAgICBcclxuICAgICAgICB0aGlzLnNwcml0ZUFuaW1hdGlvbiA9IG5ldyBTcHJpdGVBbmltYXRpb24oKTsgXHJcbiAgICAgICAgdGhpcy5zcHJpdGVBbmltYXRpb24uc2V0Q2FudmFzKG1haW5DYW52YXMpO1xyXG4gICAgXHJcbiAgICAgICAgdGhpcy50eXBlID0gJ3BlcmsnOyAgICBcclxuICAgIH1cclxuXHJcbiAgICBQZXJrLnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24oKXtcclxuICAgICAgICBcclxuICAgICAgICBpZighdGhpcy5hbGl2ZSl7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgdGhpcy54ICs9IHRoaXMudmVsWDtcclxuICAgICAgICB0aGlzLnkgKz0gdGhpcy52ZWxZO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHRoaXMuc3ByaXRlQW5pbWF0aW9uLnBsYXkodGhpcy54LCB0aGlzLnksIFJlc291cmNlTG9hZGVyLmFzc2V0cy5wZXJrU3ByaXRlKTtcclxuICAgICAgICBcclxuICAgIH07XHJcblxyXG4gICAgUGVyay5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKHBlcmspe1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgdmFyIHNwcml0ZUluZm87IFxyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBzd2l0Y2gocGVyayl7XHJcbiAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICBjYXNlIFwic2hpZWxkXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwcml0ZUluZm8gPSB7d2lkdGg6MTgsaGVpZ2h0OjE5LCBudW1Db2w6MSwgbnVtUm93OjIsZnBzOjYwLHNwZWVkOjEsbG9vcDpmYWxzZSxmcm9tOjAsdG86MH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3ByaXRlQW5pbWF0aW9uLmluaXQoc3ByaXRlSW5mbyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIERpc3BsYXkucHJvdG90eXBlLmluaXQuY2FsbCh0aGlzLCBzcHJpdGVJbmZvLndpZHRoLCBzcHJpdGVJbmZvLmhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudHlwZSA9IFwic2hpZWxkXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICBjYXNlIFwibGlmZVwiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzcHJpdGVJbmZvID0ge3dpZHRoOjE4LGhlaWdodDoxOSwgbnVtQ29sOjEsIG51bVJvdzoyLGZwczo2MCxzcGVlZDoxLGxvb3A6ZmFsc2UsZnJvbToxLHRvOjF9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNwcml0ZUFuaW1hdGlvbi5pbml0KHNwcml0ZUluZm8pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBEaXNwbGF5LnByb3RvdHlwZS5pbml0LmNhbGwodGhpcywgc3ByaXRlSW5mby53aWR0aCwgc3ByaXRlSW5mby5oZWlnaHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnR5cGUgPSBcImxpZmVcIjtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgfTsgXHJcblx0XHJcblx0UGVyay5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCl7XHJcblx0XHRQaHlzaWNzLnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyk7XHJcblx0XHRSZXNvdXJjZUxvYWRlci5hc3NldHMucGVya1NvdW5kLnBsYXkoKTtcclxuXHR9OyAgICAgICAgXHJcbiAgICAvL21pc3NsZSBjb25zdHJ1Y3RvclxyXG4gICAgXHJcblx0ZnVuY3Rpb24gTWlzc2lsZSgpe1xyXG4gICAgICAgIFxyXG4gICAgICAgICAgICBQaHlzaWNzLmNhbGwodGhpcyk7XHJcbiAgICAgICAgXHJcblx0XHR0aGlzLnNwZWVkID0gMztcclxuXHRcdHRoaXMubGlmZSA9IDA7XHJcblx0XHR0aGlzLm1heExpZmUgPSAxMDA7XHJcbiAgICAgICAgdGhpcy50eXBlID0gXCJtaXNzaWxlXCI7XHJcblxyXG5cdH1cclxuICAgIFxyXG4gICAgTWlzc2lsZS5wcm90b3R5cGUuc3Bhd24gPSBmdW5jdGlvbih4LCB5LCBhbmdsZSwgc3BlZWQpe1xyXG4gICAgICAgIFBoeXNpY3MucHJvdG90eXBlLnNwYXduLmNhbGwodGhpcywgeCwgeSwgYW5nbGUsIHNwZWVkKTsgIFxyXG4gICAgICAgIHRoaXMubGlmZSA9IDA7XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICBNaXNzaWxlLnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24oKXtcclxuICAgICAgICBcclxuICAgICAgICB0aGlzLmxpZmUrKztcclxuXHRcdFx0aWYodGhpcy5saWZlPj10aGlzLm1heExpZmUpe1xyXG5cdFx0XHRcdHRoaXMubGlmZSA9IDA7XHJcblx0XHRcdFx0dGhpcy5hbGl2ZSA9IGZhbHNlO1xyXG5cdFx0XHR9XHJcblx0XHRcdHRoaXMueCArPSB0aGlzLnZlbFg7XHJcblx0XHRcdHRoaXMueSArPSB0aGlzLnZlbFk7XHJcblx0XHRcdHRoaXMuY29udGV4dC5maWxsU3R5bGUgPSB0aGlzLmNvbG9yO1xyXG5cdFx0XHR0aGlzLmNvbnRleHQuZmlsbFJlY3QodGhpcy54LCB0aGlzLnksIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcclxuICAgIFxyXG4gICAgfTtcclxuICAgIFxyXG5cdGZ1bmN0aW9uIEVuZW15KCl7XHJcbiAgICAgICAgXHJcbiAgICAgICAgICAgIFNwYWNlY3JhZnQuY2FsbCh0aGlzKTtcclxuICAgICAgICBcclxuXHRcdHRoaXMudGhydXN0QWNjZWwgPSAwLjAzO1xyXG4gICAgICAgIHRoaXMudHlwZSA9IFwiZW5lbXlcIjtcclxuICAgICAgICBcclxuXHRcdFxyXG4gICAgICAgIHZhciBzcHJpdGVSYW5kb21JbmRleCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSo0KTtcclxuICAgICAgICB0aGlzLnNwcml0ZUFuaW1hdGlvbiA9IG5ldyBTcHJpdGVBbmltYXRpb24oKTtcclxuICAgICAgICB0aGlzLnNwcml0ZUFuaW1hdGlvbi5zZXRDYW52YXMobWFpbkNhbnZhcyk7XHJcbiAgICAgICAgdmFyIGVuZW15U3ByaXRlSW5mbyA9IHt3aWR0aDoyMyxoZWlnaHQ6MjEsIG51bUNvbDoxLCBudW1Sb3c6NCxmcHM6NjAsc3BlZWQ6MzAsbG9vcDpmYWxzZSxmcm9tOnNwcml0ZVJhbmRvbUluZGV4LHRvOnNwcml0ZVJhbmRvbUluZGV4fTtcclxuICAgICAgICB0aGlzLnNwcml0ZUFuaW1hdGlvbi5pbml0KGVuZW15U3ByaXRlSW5mbyk7XHJcbiAgICBcclxuXHR9XHJcbiAgICBcclxuICAgIEVuZW15LnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24oKXtcclxuICAgICAgICBcclxuICAgICAgICAgICAgICAgIFNwYWNlY3JhZnQucHJvdG90eXBlLmRyYXcuY2FsbCh0aGlzKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGlmKHRoaXMuY29sbGlkaW5nIHx8ICF0aGlzLmFsaXZlKXtcclxuICAgICAgICAgICAgICAgIHJldHVybjsgICBcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgICAgICAgICAgdGhpcy54ICs9IHRoaXMudmVsWDtcclxuICAgICAgICAgICAgICAgIHRoaXMueSArPSB0aGlzLnZlbFk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuc2F2ZSgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LnRyYW5zbGF0ZSh0aGlzLngrdGhpcy5jZW50ZXJYLCB0aGlzLnkrdGhpcy5jZW50ZXJZKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5yb3RhdGUodGhpcy5hbmdsZSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNwcml0ZUFuaW1hdGlvbi5wbGF5KC10aGlzLmNlbnRlclgsIC10aGlzLmNlbnRlclgsIFJlc291cmNlTG9hZGVyLmFzc2V0cy5lbmVteVNwcml0ZVNoZWV0KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5yZXN0b3JlKCk7ICBcclxuICAgICAgICAgICAgICAgIFxyXG5cclxuICAgIH07XHJcbiAgICAgICAgXHJcbiAgICAvL21vdGhlcnNoaXAgY29uc3RydWN0b3JcclxuICAgIGZ1bmN0aW9uIE1vdGhlcnNoaXAoKXtcclxuICAgICAgICBcclxuICAgICAgICAgICAgIFNwYWNlY3JhZnQuY2FsbCh0aGlzKTtcclxuICAgICAgICBcclxuICAgICAgICBcclxuICAgICAgICB0aGlzLmhhc1JlbGVhc2VkU2hpcHMgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnNwcml0ZUFuaW1hdGlvbiA9IG5ldyBTcHJpdGVBbmltYXRpb24oKTtcclxuICAgICAgICB0aGlzLnNwcml0ZUFuaW1hdGlvbi5zZXRDYW52YXMobWFpbkNhbnZhcyk7XHJcbiAgICAgICAgdGhpcy50eXBlID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMubWlzc2lsZXNTcGVlZCA9IDM7XHJcbiAgICAgICAgdGhpcy5hbHBoYSA9IDA7XHJcbiAgICAgICAgdGhpcy5hbHBoYVNwZWVkID0gMC4wMjtcclxuICAgICAgICB0aGlzLm51bVNoaXBzID0gMDtcclxuICAgICAgICB0aGlzLnR5cGUgPSBcIm1vdGhlcnNoaXBcIjtcclxuICAgIFxyXG4gICAgfVxyXG4gICAgXHJcbiAgICBNb3RoZXJzaGlwLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24oc2hpcFR5cGUpe1xyXG4gICAgICAgIFxyXG4gICAgICAgICAgICBzd2l0Y2goc2hpcFR5cGUpe1xyXG4gICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgY2FzZSBcImh1bWFuXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgdmFyIHNwcml0ZVNoZWV0SW5mbyA9IHt3aWR0aDo1MSxoZWlnaHQ6NDYsIG51bUNvbDoxLCBudW1Sb3c6MixmcHM6NjAsc3BlZWQ6MzAsbG9vcDpmYWxzZSxmcm9tOjAsdG86MH07XHJcbiAgICAgICAgICAgICAgICAgdmFyIHNwcml0ZUluZGV4ID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpKnNwcml0ZVNoZWV0SW5mby50byk7XHJcbiAgICAgICAgICAgICAgICAgc3ByaXRlU2hlZXRJbmZvLmZyb20gPSBzcHJpdGVTaGVldEluZm8udG8gPSBzcHJpdGVJbmRleDtcclxuICAgICAgICAgICAgICAgICB0aGlzLnNwcml0ZUFuaW1hdGlvbi5pbml0KHNwcml0ZVNoZWV0SW5mbyk7XHJcbiAgICAgICAgICAgICAgICAgdGhpcy50eXBlID0gXCJodW1hblwiO1xyXG4gICAgICAgICAgICAgICAgIHRoaXMud2lkdGggPSBzcHJpdGVTaGVldEluZm8ud2lkdGg7XHJcbiAgICAgICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSBzcHJpdGVTaGVldEluZm8uaGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgIHRoaXMuY2VudGVyWCA9IHRoaXMud2lkdGggLyAyO1xyXG4gICAgICAgICAgICAgICAgIHRoaXMuY2VudGVyWSA9IHRoaXMuaGVpZ2h0IC8gMjtcclxuICAgICAgICAgICAgICAgICAgICBTcGFjZWNyYWZ0LnByb3RvdHlwZS5pbml0LmNhbGwodGhpcywgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgY2FzZSBcImFsaWVuXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICB2YXIgc3ByaXRlU2hlZXRJbmZvID0ge3dpZHRoOjUxLGhlaWdodDo0NiwgbnVtQ29sOjQsIG51bVJvdzoyLGZwczo2MCxzcGVlZDozMCxsb29wOmZhbHNlLGZyb206MCx0bzo0fTtcclxuICAgICAgICAgICAgICAgIHZhciBzcHJpdGVJbmRleCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSpzcHJpdGVTaGVldEluZm8udG8pO1xyXG4gICAgICAgICAgICAgICAgc3ByaXRlU2hlZXRJbmZvLmZyb20gPSBzcHJpdGVTaGVldEluZm8udG8gPSBzcHJpdGVJbmRleDtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3ByaXRlQW5pbWF0aW9uLmluaXQoc3ByaXRlU2hlZXRJbmZvKTtcclxuICAgICAgICAgICAgICAgIHRoaXMudHlwZSA9IFwiYWxpZW5cIjtcclxuICAgICAgICAgICAgICAgIHRoaXMud2lkdGggPSBzcHJpdGVTaGVldEluZm8ud2lkdGg7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmhlaWdodCA9IHNwcml0ZVNoZWV0SW5mby5oZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNlbnRlclggPSB0aGlzLndpZHRoIC8gMjtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2VudGVyWSA9IHRoaXMuaGVpZ2h0IC8gMjtcclxuICAgICAgICAgICAgICAgICAgICBTcGFjZWNyYWZ0LnByb3RvdHlwZS5pbml0LmNhbGwodGhpcywgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrOyAgICAgXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgfTtcclxuICAgIFxyXG4gICAgTW90aGVyc2hpcC5wcm90b3R5cGUuc2V0UmVsZWFzZSA9IGZ1bmN0aW9uKHNoaXBzUG9vbCwgbnVtU2hpcHMsIHRpbWUpe1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgaWYodGhpcy5oYXNSZWxlYXNlZFNoaXBzKXtcclxuICAgICAgICAgICAgICAgIHJldHVybjsgICBcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgLy9hc3NpZ25zIG51bWJlciBvZiBzaGlwcyB0byByZWxlYXNlXHJcbiAgICAgICAgICAgIHRoaXMubnVtU2hpcHMgPSBudW1TaGlwcztcclxuICAgICAgICAgICAgdGhpcy5zaGlwc1Bvb2wgPSBzaGlwc1Bvb2w7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvL2NoZWNrcyBpZiB0aW1lIHRvIHJlbGVhc2Ugc2hpcHMgd2FzIHBhc3NlZCBpblxyXG4gICAgICAgICAgICB0aW1lID0gKHR5cGVvZiB0aW1lICE9IFwibnVtYmVyXCIpPyA1MDAwOiB0aW1lO1xyXG5cdFx0XHJcblx0XHRcdHZhciBzZWxmID0gdGhpcztcclxuXHRcdFxyXG5cdFx0XHR0aGlzLmludGVydmFsID0gd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24oKXtcclxuXHRcdFx0XHQvL3JlbGVhc2Ugc2hpcHMgYWZ0ZXIgdGhlIHRpbWUgaGFzIHBhc3NlZFxyXG5cdFx0XHRcdE1vdGhlcnNoaXAucHJvdG90eXBlLnJlbGVhc2VTaGlwcy5jYWxsKHNlbGYpO1xyXG4gICAgICAgICAgICAgICAgXHJcblx0XHRcdH0sIHRpbWUpOyAgIFxyXG5cdFx0XHJcbiAgICAgICAgfTtcclxuICAgIFxyXG4gICAgTW90aGVyc2hpcC5wcm90b3R5cGUucmVsZWFzZVNoaXBzID0gZnVuY3Rpb24oKXtcclxuICAgICAgIFxyXG4gICAgICAgIGNvbnNvbGUubG9nKCdzaGlwIHJlbGVhc2UgZnVuY3Rpb24gaGFzIGJlZW4gY2FsbGVkJyk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB0aGlzLmhhc1JlbGVhc2VkU2hpcHMgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLnNoaWVsZC5hY3RpdmUgPSBmYWxzZTtcclxuICAgICAgICAgICAgXHJcblxyXG4gICAgICAgICAgICBmb3IodmFyIGk9MDsgaTx0aGlzLm51bVNoaXBzOyBpKyspe1xyXG4gICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgdmFyIHBvc2l0aW9uWCA9IHRoaXMueCArIHRoaXMuc2hpcHNQb29sLnBvb2xbaV0ud2lkdGgqaTtcclxuICAgICAgICAgICAgICAgIHZhciBwb3NpdGlvblkgPSB0aGlzLnkgKyB0aGlzLnNoaXBzUG9vbC5wb29sW2ldLmhlaWdodCppO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zaGlwc1Bvb2wuZ2V0KHBvc2l0aW9uWCwgcG9zaXRpb25ZLCAnZW5lbXknKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2hpcHNQb29sLnBvb2xbaV0uc2hpZWxkLmFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgfSBcclxuICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgfTtcclxuICAgIFxyXG4gICAgTW90aGVyc2hpcC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCl7XHJcblx0XHRTcGFjZWNyYWZ0LnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyk7XHJcblx0XHR3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMuaW50ZXJ2YWwpO1xyXG5cdH07XHJcblxyXG4gICAgTW90aGVyc2hpcC5wcm90b3R5cGUuc3Bhd24gPSBmdW5jdGlvbih4LCB5LCBhbmdsZSwgc3BlZWQpe1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgU3BhY2VjcmFmdC5wcm90b3R5cGUuc3Bhd24uY2FsbCh0aGlzLCB4LCB5LCBhbmdsZSwgc3BlZWQpO1xyXG4gICAgICAgICAgICB0aGlzLmhhc1JlbGVhc2VkU2hpcHMgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5hbHBoYSA9IDA7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgIH07XHJcbiAgICBcclxuICAgIE1vdGhlcnNoaXAucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgU3BhY2VjcmFmdC5wcm90b3R5cGUuZHJhdy5jYWxsKHRoaXMpO1xyXG4gICAgICAgIFxyXG4gICAgICAgICAgICBpZih0aGlzLmNvbGxpZGluZyB8fCAhdGhpcy5hbGl2ZSl7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnc2hpcHMgZGVhZCB3b250IGRyYXcgaXQnKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMueCArPSB0aGlzLnZlbFg7XHJcbiAgICAgICAgICAgIHRoaXMueSArPSB0aGlzLnZlbFk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgXHJcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5zYXZlKCk7XHJcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC50cmFuc2xhdGUodGhpcy54K3RoaXMuY2VudGVyWCwgdGhpcy55K3RoaXMuY2VudGVyWSk7XHJcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5yb3RhdGUodGhpcy5hbmdsZSk7XHJcbiAgICAgICAgICAgIGlmKHRoaXMuaGFzUmVsZWFzZWRTaGlwcyl7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFscGhhIC09IHRoaXMuYWxwaGFTcGVlZDsgICBcclxuICAgICAgICAgICAgICAgIHRoaXMuYWxwaGEgPSAodGhpcy5hbHBoYSA8PSAwKT8gMDogdGhpcy5hbHBoYTsgXHJcbiAgICAgICAgICAgICAgICB0aGlzLmFsaXZlID0gKHRoaXMuYWxwaGEgPD0gMCk/IGZhbHNlIDogdHJ1ZTtcclxuICAgICAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgIHRoaXMuYWxwaGEgKz0gdGhpcy5hbHBoYVNwZWVkO1xyXG4gICAgICAgICAgICB0aGlzLmFscGhhID0gKHRoaXMuYWxwaGEgPj0gMSk/IDE6IHRoaXMuYWxwaGE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5jb250ZXh0Lmdsb2JhbEFscGhhID0gdGhpcy5hbHBoYTtcclxuICAgICAgICAgICAgdGhpcy5zcHJpdGVBbmltYXRpb24ucGxheSgtdGhpcy5jZW50ZXJYLCAtdGhpcy5jZW50ZXJZLCBSZXNvdXJjZUxvYWRlci5hc3NldHMuTW90aGVyc2hpcFNwcml0ZVNoZWV0KTtcclxuICAgICAgICAgICAgdGhpcy5jb250ZXh0LnJlc3RvcmUoKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGlmKHRoaXMuYWxwaGEgPD0gMCl7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFsaXZlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH0gXHJcbiAgICAgICAgfTtcclxuICAgIFxyXG4gICAgLy8gZXhwbG9zaW9uIGNvbnN0cnVjdG9yXHJcblx0ZnVuY3Rpb24gRXhwbG9zaW9uKG51bVBhcnRpY2xlcyl7XHJcbiAgICAgICAgXHJcbiAgICAgICAgICAgIERpc3BsYXkuY2FsbCh0aGlzKTtcclxuICAgICAgICBcclxuXHRcdHRoaXMucnVubmluZyA9IGZhbHNlO1xyXG5cdFx0dGhpcy5wYXJ0aWNsZXMgPSBbXTtcclxuXHRcdHRoaXMuZGVhZFBhcnRpY2xlQ291bnRlciA9IDA7XHJcblx0XHR0aGlzLnNpemUgPSBudW1QYXJ0aWNsZXM7XHJcbiAgICAgICAgXHJcblx0XHRmb3IodmFyIGkgPSAwOyBpPG51bVBhcnRpY2xlczsgaSsrKXtcclxuXHRcdFx0dGhpcy5wYXJ0aWNsZXMucHVzaCh7eDowLHk6MCxhbGl2ZTpmYWxzZSxtYXhMaWZlOjAsdmVsWDowLHZlbFk6MCwgd2lkdGg6MiwgaGVpZ2h0OjIsIGxpZmU6MH0pO1xyXG5cdFx0fVxyXG5cdFx0XHRcclxuXHR9XHJcbiAgICBcclxuICAgIEV4cGxvc2lvbi5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24oeCwgeSl7XHJcbiAgICAgICAgaWYodGhpcy5ydW5uaW5nKXtcclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdH1cclxuXHRcdFx0XHJcblx0XHRcdGZvcih2YXIgaT0wO2k8dGhpcy5zaXplO2krKyl7XHJcblx0XHRcdFx0dmFyIGN1cnJlbnRQYXJ0aWNsZSA9IHRoaXMucGFydGljbGVzW2ldO1xyXG5cdFx0XHRcdGN1cnJlbnRQYXJ0aWNsZS54ID0geDtcclxuXHRcdFx0XHRjdXJyZW50UGFydGljbGUueSA9IHk7XHJcblx0XHRcdFx0Y3VycmVudFBhcnRpY2xlLm1heExpZmUgPSBNYXRoLnJhbmRvbSgpKjQ1KzE1O1xyXG5cdFx0XHRcdGN1cnJlbnRQYXJ0aWNsZS52ZWxYID0gTWF0aC5yYW5kb20oKSo0LTIuODtcclxuXHRcdFx0XHRjdXJyZW50UGFydGljbGUudmVsWSA9IE1hdGgucmFuZG9tKCkqNC0yLjg7XHJcblx0XHRcdFx0Y3VycmVudFBhcnRpY2xlLmFsaXZlID0gdHJ1ZTtcclxuXHRcdFx0XHRjdXJyZW50UGFydGljbGUubGlmZSA9IDA7XHJcblx0XHRcdH1cclxuXHRcdFx0dGhpcy5ydW5uaW5nID0gdHJ1ZTtcclxuXHRcdFx0dGhpcy5kZWFkUGFydGljbGVDb3VudGVyID0gMDtcclxuICAgIH07XHJcblxyXG4gICAgRXhwbG9zaW9uLnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24oKXtcclxuICAgICAgICBcclxuICAgICAgICBpZighdGhpcy5ydW5uaW5nKXtcclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdH1cclxuXHRcdFx0XHJcblx0XHRcdHRoaXMuY29udGV4dC5maWxsU3R5bGUgPSAnIzAwRkYwMCc7XHJcblx0XHRcdGZvcih2YXIgaT0wOyBpPHRoaXMuc2l6ZTsgaSsrKXtcclxuXHRcdFx0XHR2YXIgY3VycmVudFBhcnRpY2xlID0gdGhpcy5wYXJ0aWNsZXNbaV07XHJcblx0XHRcdFx0aWYoY3VycmVudFBhcnRpY2xlLmFsaXZlKXtcclxuXHRcdFx0XHRjdXJyZW50UGFydGljbGUueCArPSBjdXJyZW50UGFydGljbGUudmVsWDtcclxuXHRcdFx0XHRjdXJyZW50UGFydGljbGUueSArPSBjdXJyZW50UGFydGljbGUudmVsWTtcclxuXHRcdFx0XHRjdXJyZW50UGFydGljbGUubGlmZSsrO1xyXG5cdFx0XHRcdHRoaXMuY29udGV4dC5maWxsUmVjdChjdXJyZW50UGFydGljbGUueCwgY3VycmVudFBhcnRpY2xlLnksIGN1cnJlbnRQYXJ0aWNsZS53aWR0aCwgY3VycmVudFBhcnRpY2xlLmhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGN1cnJlbnRQYXJ0aWNsZS5saWZlID49IGN1cnJlbnRQYXJ0aWNsZS5tYXhMaWZlKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFBhcnRpY2xlLmFsaXZlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQYXJ0aWNsZS5saWZlID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWFkUGFydGljbGVDb3VudGVyKys7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRcclxuXHRcdFx0fVxyXG4vL2NoYW5nZSB0aGUgc3RhdGUgZnJvbSBydW5uaW5nIHRvIGZhbHNlIGJ5IGNoZWNraW5nIGlmIHRoZXJlIGFyZSBhbnkgcGFydGljbGVzIGFsaXZlIGxlZnRcclxuXHRcdFx0aWYodGhpcy5kZWFkUGFydGljbGVDb3VudGVyPj10aGlzLnNpemUpe1xyXG5cdFx0XHRcdHRoaXMucnVubmluZyA9IGZhbHNlO1xyXG5cdFx0XHR9XHJcbiAgICAgICAgXHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICAvL1NoaWVsZCBjb25zdHJ1Y3RvclxyXG5cdGZ1bmN0aW9uIFNoaWVsZCgpe1xyXG4gICAgICAgIFxyXG4gICAgICAgICAgICBEaXNwbGF5LmNhbGwodGhpcyk7XHJcbiAgICAgICAgXHJcblx0XHR0aGlzLnJhZGl1cyA9IDQwO1xyXG5cdFx0dGhpcy5tYXhSYWRpdXMgPSA0NTtcclxuICAgICAgICB0aGlzLmxpZmUgPSAxMDA7XHJcbiAgICAgICAgdGhpcy5kaXNhYmxlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuY29sb3IgPSAnIzAwMDBGRic7XHJcbiAgICAgICAgdGhpcy50eXBlID0gJ3NoaWVsZCc7XHJcbiAgICAgICAgdmFyIHNoaWVsZFN0YXRlID0gZmFsc2U7XHJcbiAgICBcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJhY3RpdmVcIiwge1xyXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIHJldHVybiBzaGllbGRTdGF0ZTtcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKXtcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgc2hpZWxkU3RhdGUgPSAodGhpcy5kaXNhYmxlZCk/IGZhbHNlOiB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuYWxpdmUgPSBzaGllbGRTdGF0ZTtcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICBcclxuICAgICAgICBcclxuXHR9XHJcbiAgICBcclxuICAgIFNoaWVsZC5wcm90b3R5cGUucmVkdWNlTGlmZSA9IGZ1bmN0aW9uKGFtb3VudCl7XHJcbiAgICAgICAgYW1vdW50ID0gKGFtb3VudCA9PT0gdW5kZWZpbmVkKT8gNTA6IGFtb3VudDtcclxuICAgICAgICB0aGlzLmxpZmUgLT0gYW1vdW50O1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgU2hpZWxkLnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24oKXtcclxuICAgICAgICBcclxuICAgICAgICAgICAgaWYoIXRoaXMuYWN0aXZlKXtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdzaGllbGQgaXMgZGlzYWJsZWQnKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZih0aGlzLmxpZmUgPD0gMCl7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxpZmUgPSAwO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kaXNhYmxlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cdFx0XHR0aGlzLmNvbnRleHQuc3Ryb2tlU3R5bGUgPSB0aGlzLmNvbG9yO1xyXG4gICAgICAgICAgICB0aGlzLmNvbnRleHQubGluZVdpZHRoID0gMTtcclxuXHRcdFx0dGhpcy5jb250ZXh0LmJlZ2luUGF0aCgpOyBcclxuXHRcdFx0dGhpcy5jb250ZXh0LmFyYyh0aGlzLngrdGhpcy5jZW50ZXJYLCB0aGlzLnkrdGhpcy5jZW50ZXJZLCB0aGlzLnJhZGl1cywgMCwgTWF0aC5QSSoyLCB0cnVlKTtcclxuXHRcdFx0dGhpcy5jb250ZXh0LmNsb3NlUGF0aCgpO1xyXG5cdFx0XHR0aGlzLmNvbnRleHQuc3Ryb2tlKCk7IFxyXG5cdFx0XHR0aGlzLnJhZGl1cyArPSAuMjU7XHJcblx0XHRcdHRoaXMucmFkaXVzID0gKHRoaXMucmFkaXVzPnRoaXMubWF4UmFkaXVzKT8gNDA6IHRoaXMucmFkaXVzO1xyXG4gICAgICAgIFxyXG4gICAgfTtcclxuICAgIFxyXG4gICAgU2hpZWxkLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgIHRoaXMubGlmZSA9IDEwMDtcclxuICAgICAgICAgICAgdGhpcy5kaXNhYmxlZCA9IGZhbHNlO1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgLy9tZXRlb3IgcG9vbFxyXG5cdGZ1bmN0aW9uIFBvb2wobWF4U2l6ZSl7XHJcbiAgICAgICAgXHJcblx0XHR2YXIgcG9vbCA9IFtdO1xyXG4gICAgICAgIFxyXG5cdFx0dGhpcy5wb29sID0gcG9vbDtcclxuICAgICAgICB0aGlzLnNpemUgPSBtYXhTaXplO1xyXG4gICAgICAgIFxyXG5cdH1cclxuICAgIFxyXG4gICAgUG9vbC5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKHR5cGUpe1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgc3dpdGNoKHR5cGUpe1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcIm1pc3NpbGVcIjpcclxuICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgZm9yKHZhciBpPTA7IGk8dGhpcy5zaXplOyBpKyspe1xyXG5cdFx0XHRcdFx0dmFyIG1pc3NpbGUgPSBuZXcgTWlzc2lsZSgpO1xyXG5cdFx0XHRcdFx0bWlzc2lsZS5zZXRDYW52YXMobWFpbkNhbnZhcyk7XHJcblx0XHRcdFx0XHRtaXNzaWxlLmluaXQoMiwyKTtcclxuXHRcdFx0XHRcdHRoaXMucG9vbFtpXSA9IG1pc3NpbGU7XHJcblx0XHRcdFx0fSAgXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICBjYXNlIFwiZW5lbXlcIjpcclxuICAgICAgICAgICAgICAgICAgIGZvcih2YXIgaj0wOyBqPHRoaXMuc2l6ZTsgaisrKXtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcmFuZG9tWCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSptYWluQ2FudmFzLndpZHRoKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcmFuZG9tWSA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSptYWluQ2FudmFzLmhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVuZW15ID0gbmV3IEVuZW15KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZW5lbXkuc2V0Q2FudmFzKG1haW5DYW52YXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGVuZW15LmluaXQoMjMsIDIxKTtcclxuICAgICAgICAgICAgICAgICAgICBlbmVteS54ID0gcmFuZG9tWDtcclxuICAgICAgICAgICAgICAgICAgICBlbmVteS55ID0gcmFuZG9tWTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wb29sW2pdID0gZW5lbXk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICB9IFxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgY2FzZSBcInBlcmtzXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zaXplID0gTWF0aC5mbG9vcih0aGlzLnNpemUgLyAyKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBrPTA7IGs8dGhpcy5zaXplOyBrKyspe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGlmZSA9IG5ldyBQZXJrKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpZmUuc2V0Q2FudmFzKG1haW5DYW52YXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsaWZlLmluaXQoXCJsaWZlXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBvb2wucHVzaChsaWZlKTsgXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBmb3IodmFyIGg9MDsgaDx0aGlzLnNpemU7IGgrKyl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzaGllbGQgPSBuZXcgUGVyaygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzaGllbGQuc2V0Q2FudmFzKG1haW5DYW52YXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzaGllbGQuaW5pdChcInNoaWVsZFwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wb29sLnB1c2goc2hpZWxkKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zaXplICo9IDI7XHJcbiAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICBjYXNlIFwicm9ja3NcIjpcclxuICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbnVtTWVkaXVtUm9ja3MgPSB0aGlzLnNpemUqMjtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbnVtU21hbGxSb2NrcyA9IG51bU1lZGl1bVJvY2tzKjI7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IodmFyIGw9MDsgbDx0aGlzLnNpemU7IGwrKyl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWV0ZW9yID0gbmV3IFJvY2soKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGVvci5zZXRDYW52YXMobWFpbkNhbnZhcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRlb3IuaW5pdChcImxhcmdlXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0ZW9yLnR5cGUgPSBcImxhcmdlUm9ja1wiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wb29sLnB1c2gobWV0ZW9yKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IodmFyIG09MDsgbTxudW1NZWRpdW1Sb2NrczsgbSsrKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtZXRlb3JNZWRpdW0gPSBuZXcgUm9jaygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0ZW9yTWVkaXVtLnNldENhbnZhcyhtYWluQ2FudmFzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGVvck1lZGl1bS5pbml0KFwibWVkaXVtXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0ZW9yTWVkaXVtLnR5cGUgPSBcIm1lZGl1bVJvY2tcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucG9vbC5wdXNoKG1ldGVvck1lZGl1bSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBuPTA7IG48bnVtU21hbGxSb2NrczsgbisrKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtZXRlb3JTbWFsbCA9IG5ldyBSb2NrKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRlb3JTbWFsbC5zZXRDYW52YXMobWFpbkNhbnZhcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRlb3JTbWFsbC5pbml0KFwic21hbGxcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRlb3JTbWFsbC50eXBlID0gXCJzbWFsbFJvY2tcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucG9vbC5wdXNoKG1ldGVvclNtYWxsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2l6ZSArPSAobnVtTWVkaXVtUm9ja3MrbnVtU21hbGxSb2Nrcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICBQb29sLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbih4LCB5LCB0eXBlLCBhbmdsZSwgc3BlZWQpe1xyXG4gICAgICAgIFxyXG4gICAgICAgICAgICB0eXBlID0gdHlwZSB8fCBcIm1pc3NpbGVcIjtcclxuICAgICAgICBcclxuICAgICAgICAgICAgLyogY29kZSBmcm9tIGJlZm9yZSBtaXhpbmcgYm90aCBwb29scyBtZXRlb3IgYW5kIHJlZ3VsYXIgXHJcblx0XHRcdGlmKCF0aGlzLnBvb2xbc2l6ZS0xXS5hbGl2ZSl7XHJcblx0XHRcdFx0dGhpcy5wb29sW3NpemUtMV0uc3Bhd24oeCx5LCBhbmdsZSwgc3BlZWQpO1xyXG5cdFx0XHRcdHRoaXMucG9vbC51bnNoaWZ0KHBvb2wucG9wKCkpO1xyXG5cdFx0XHR9XHJcbiAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHZhciBpID0gMDtcclxuXHJcbiAgICAgICAgICAgICAgICB3aGlsZShpPHRoaXMuc2l6ZSl7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYodGhpcy5wb29sW2ldLnR5cGUgPT09IHR5cGUgJiYgIXRoaXMucG9vbFtpXS5hbGl2ZSl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucG9vbFtpXS5zcGF3bih4LCB5LCBhbmdsZSwgc3BlZWQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaSsrOyAgICAgXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICB9O1xyXG5cclxuICAgIFBvb2wucHJvdG90eXBlLmlzQ29sbGlkaW5nV2l0aCA9IGZ1bmN0aW9uKGFyZ3Mpe1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgdmFyIGxlbmd0aCA9IHRoaXMucG9vbC5sZW5ndGg7XHJcbiAgICAgICAgICAgIHZhciBhcmdzTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGk8bGVuZ3RoOyBpKyspe1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICB2YXIgY3VycmVudEl0ZW0gPSB0aGlzLnBvb2xbaV07XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIGlmKGN1cnJlbnRJdGVtLmFsaXZlKXtcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgZm9yKHZhciBoID0gMDsgaDxhcmdzTGVuZ3RoOyBoKyspe1xyXG4gICAgICAgICAgICAgICAgICAgIC8vZWFjaCBhcmd1bWVudCByZXByZXNlbnRzIHRoZSBvYmplY3RzIGJlaW5nIHBhc3NlZCBpbiB0byB0aGlzIG1ldGhvZC5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgY3VycmVudEFyZ3VtZW50ID0gYXJndW1lbnRzW2hdO1xyXG5cdFx0XHRcdFx0XHJcblx0XHRcdFx0XHQvL2lmIG9uZSBvZiB0aGUgYXJndW1lbnRzIHRvIGNoZWNrIGZvciBjb2xsaXNpb24gaXMgYSBwb29sIG9mIG9iamVjdHMsIGl0ZXJhdGUgb3ZlciBlYWNoIGl0ZW0uXHJcblx0XHRcdFx0XHRpZihBcnJheS5pc0FycmF5KGN1cnJlbnRBcmd1bWVudCkpe1xyXG5cdFx0XHRcdFx0XHRmb3IodmFyIGogPSAwLCBsZW4gPSBjdXJyZW50QXJndW1lbnQubGVuZ3RoOyBqIDwgbGVuOyBqKyspe1xyXG5cdFx0XHRcdFx0XHRcdHZhciBjdXJyZW50UG9vbEl0ZW0gPSBjdXJyZW50QXJndW1lbnRbal07XHJcblx0XHRcdFx0XHRcdFx0Y2hlY2tDb2xsaXNpb24oY3VycmVudEl0ZW0sIGN1cnJlbnRQb29sSXRlbSk7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1lbHNle1xyXG5cdFx0XHRcdFx0XHRcdGNoZWNrQ29sbGlzaW9uKGN1cnJlbnRJdGVtLCBjdXJyZW50QXJndW1lbnQpO1xyXG5cdFx0XHRcdFx0ICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICB9XHJcblx0XHRcdC8vZnVuY3Rpb24gaW4gY2hhcmdlIG9mIHRlc3RpbmcgZm9yIGNvbGxpc2lvbiBhbmQgZXhlY3V0aW5nIHdoYXQgdG8gZG8gd2hlbiB0aGVyZSBpcyBhIGNvbGxpc2lvbiwgaXQgYWxzbyBtYWtlcyBhIGNhbGwgdG8gdGhlIHJlY29yZENvbGxpc2lvbiBmdW5jdGlvbiB3aGljaCBoYW5kbGVzIHRoZSByZWNvcmRpbmcgb2YgY29sbGlzaW9ucyBmb3IgcG9pbnRzIGFuZCBzY29yZS5cclxuXHRcdFx0ZnVuY3Rpb24gY2hlY2tDb2xsaXNpb24oaXRlbTEsIGl0ZW0yKXtcclxuXHRcdFx0XHRcclxuXHRcdFx0XHRcdGlmKEFsZ29yaXRobXMuaGl0VGVzdChpdGVtMSwgaXRlbTIpKXtcclxuXHRcdFx0XHRcdFx0XHRpZihpdGVtMiBpbnN0YW5jZW9mIFNoaWVsZCl7XHJcblx0XHRcdFx0XHRcdFx0XHRpZighKGl0ZW0xIGluc3RhbmNlb2YgUm9jaykpe1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGl0ZW0xLmRlc3Ryb3koKTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpdGVtMi5yZWR1Y2VMaWZlKDEwKTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvL3JlY29yZENvbGxpc2lvbihpdGVtMS50eXBlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFB1YlN1Yi5wdWJsaXNoKCdjb2xsaXNpb24nLCBpdGVtMS50eXBlKTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdFx0fWVsc2UgaWYoaXRlbTEgaW5zdGFuY2VvZiBQZXJrKXtcclxuXHRcdFx0XHRcdFx0XHRcdFx0aXRlbTEuZGVzdHJveSgpO1xyXG5cdFx0XHRcdFx0XHRcdFx0XHQvL3JlY29yZENvbGxpc2lvbihpdGVtMS50eXBlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUHViU3ViLnB1Ymxpc2goJ2NvbGxpc2lvbicsIGl0ZW0xLnR5cGUpO1xyXG5cdFx0XHRcdFx0XHRcdFx0fWVsc2V7XHJcblx0XHRcdFx0XHRcdFx0XHRcdGl0ZW0yLmRlc3Ryb3koKTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0aXRlbTEuZGVzdHJveSgpO1xyXG5cdFx0XHRcdFx0XHRcdFx0XHQvL3JlY29yZENvbGxpc2lvbihpdGVtMi50eXBlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUHViU3ViLnB1Ymxpc2goJ2NvbGxpc2lvbicsIGl0ZW0yLnR5cGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBQdWJTdWIucHVibGlzaCgnY29sbGlzaW9uJywgaXRlbTEudHlwZSk7XHJcblx0XHRcdFx0XHRcdFx0XHRcdC8vcmVjb3JkQ29sbGlzaW9uKGl0ZW0xLnR5cGUpO1xyXG5cdFx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICBQb29sLnByb3RvdHlwZS5oaWRlSXRlbXMgID0gZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgdmFyIGxlbmd0aCA9IHRoaXMucG9vbC5sZW5ndGg7XHJcbiAgICAgICAgICAgIGZvcih2YXIgaT0wOyBpPGxlbmd0aDsgaSsrKXtcclxuICAgICAgICAgICAgICAgIHRoaXMucG9vbFtpXS5hbGl2ZSA9IGZhbHNlOyBcclxuICAgICAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBmdW5jdGlvbiBTcHJpdGVBbmltYXRpb24oKXtcclxuXHRcdCBcclxuICAgICAgICB0aGlzLndpZHRoO1xyXG4gICAgICAgIHRoaXMuaGVpZ2h0O1xyXG4gICAgICAgIHRoaXMueDtcclxuICAgICAgICB0aGlzLnk7XHJcblx0XHR0aGlzLm9mZnNldFggPSAwO1xyXG5cdFx0dGhpcy5vZmZzZXRZID0gMDtcclxuICAgICAgICB0aGlzLmNvbnRleHQ7XHJcbiAgICAgICAgdGhpcy5jYW52YXNIZWlnaHQ7XHJcbiAgICAgICAgdGhpcy5jYW52YXNXaWR0aDtcclxuICAgICAgICB0aGlzLnNwZWVkO1xyXG4gICAgICAgIHRoaXMubnVtQ29sO1xyXG4gICAgICAgIHRoaXMubnVtUm93O1xyXG4gICAgICAgIHRoaXMuY3VycmVudEZyYW1lO1xyXG4gICAgICAgIHRoaXMuZmluYWxGcmFtZTtcclxuICAgICAgICB0aGlzLnN0YXJ0RnJhbWU7XHJcbiAgICAgICAgdGhpcy50b3RhbEZyYW1lcztcclxuICAgICAgICB0aGlzLmFwcEZQUztcclxuXHRcdCAvL3Nwcml0ZXNoZWV0IGFuaW1hdGlvbnMgbG9vcHMgYnkgZGVmYXVsdFxyXG4gICAgICAgIHRoaXMubG9vcCA9IHRydWU7XHJcblx0XHQgICAgLy9wcml2YXRlIG1lbWJlcnMgXHJcbiAgICAgXHR0aGlzLl9mcmFtZXMgPSBbXTtcclxuICAgICAgICB0aGlzLl9mcmFtZUluY3JlbWVudDtcclxuICAgICAgICB0aGlzLl9mcmFtZUluZGV4O1xyXG5cclxuXHRcdCBcclxuXHQgfVxyXG5cdFxyXG4gICAgIFNwcml0ZUFuaW1hdGlvbi5wcm90b3R5cGUuc2V0Q2FudmFzID0gZnVuY3Rpb24oY2FudmFzKXtcclxuICAgICAgICAgICAgdGhpcy5jb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XHJcbiAgICAgICAgICAgIHRoaXMuY2FudmFzSGVpZ2h0ID0gY2FudmFzLmhlaWdodDtcclxuICAgICAgICAgICAgdGhpcy5jYW52YXNXaWR0aCA9IGNhbnZhcy53aWR0aDtcclxuICAgICAgfTtcclxuXHRcclxuICAgICBTcHJpdGVBbmltYXRpb24ucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbihzcHJpdGVPYmplY3Qpe1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgLy9zZXRzIHVwIHNwcml0ZSBwcm9wZXJ0aWVzIGZyb20gdGhlIHNwcml0ZXNoZWV0IGluZm8gb2JqZWN0IGJlaW5nIHBhc3NlZCBpbi5cclxuICAgICAgICAgICAgdGhpcy53aWR0aCA9IHNwcml0ZU9iamVjdC53aWR0aCB8fCAzMjtcclxuICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSBzcHJpdGVPYmplY3QuaGVpZ2h0IHx8IDMyO1xyXG4gICAgICAgICAgICB0aGlzLm51bUNvbCA9IHNwcml0ZU9iamVjdC5udW1Db2wgfHwgMTtcclxuICAgICAgICAgICAgdGhpcy5udW1Sb3cgPSBzcHJpdGVPYmplY3QubnVtUm93IHx8IDE7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhcnRGcmFtZSA9IHNwcml0ZU9iamVjdC5mcm9tIHx8IDA7XHJcbiAgICAgICAgICAgIHRoaXMuZmluYWxGcmFtZSA9IHNwcml0ZU9iamVjdC50byB8fCAwO1xyXG4gICAgICAgICAgICB0aGlzLnNwZWVkID0gc3ByaXRlT2JqZWN0LnNwZWVkIHx8IDE1O1xyXG5cdFx0IFx0dGhpcy5vZmZzZXRYID0gc3ByaXRlT2JqZWN0Lm9mZnNldFggfHwgMDtcclxuXHRcdCBcdHRoaXMub2Zmc2V0WSA9IHNwcml0ZU9iamVjdC5vZmZzZXRZIHx8IDA7XHJcbiAgICAgICAgICAgIHRoaXMudG90YWxGcmFtZXMgPSBzcHJpdGVPYmplY3QubnVtQ29sICogc3ByaXRlT2JqZWN0Lm51bVJvdyAtIDE7XHJcbiAgICAgICAgICAgIHRoaXMubG9vcCA9IHNwcml0ZU9iamVjdC5sb29wIHx8IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuYXBwRlBTID0gc3ByaXRlT2JqZWN0LmZwcztcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIC8vY3JlYXRlcyB0aGUgZGVjaW1hbCBvZiBpbmNyZW1lbnQgZm9yIGVhY2ggc2Vjb25kXHJcbiAgICAgICAgICAgIHRoaXMuX2ZyYW1lSW5jcmVtZW50ID0gdGhpcy5zcGVlZC9zcHJpdGVPYmplY3QuZnBzO1xyXG4gICAgICAgICAgICB0aGlzLl9mcmFtZUluZGV4ID0gdGhpcy5zdGFydEZyYW1lOyAgICAgICAgXHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvL2NyZWF0ZXMgYSB2YXJpYWJsZSBob2xkaW5nIHRoZSBsZW5ndGggb2YgdGhlIGFycmF5IGhvbGRpbmcgdGhlIGZyYW1lc1xyXG4gICAgICAgICAgICB2YXIgdG90YWxGcmFtZXNMZW5ndGggPSBzcHJpdGVPYmplY3QubnVtQ29sICogc3ByaXRlT2JqZWN0Lm51bVJvdztcclxuXHJcbiAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0b3RhbEZyYW1lc0xlbmd0aDsgaSsrKXtcclxuICAgICAgICAgICAgICAgIHZhciBmcmFtZSA9IHt9O1xyXG5cdFx0XHRcdFx0ZnJhbWUucmVnWCA9IHRoaXMub2Zmc2V0WDtcclxuXHRcdFx0XHRcdGZyYW1lLnJlZ1kgPSB0aGlzLm9mZnNldFk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgZnJhbWUucmVnWCArPSAoaSAlIHRoaXMubnVtQ29sKSp0aGlzLndpZHRoO1xyXG4gICAgICAgICAgICAgICAgZnJhbWUucmVnWSArPSAoaSAlIHRoaXMubnVtUm93KSp0aGlzLmhlaWdodDtcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgLy9wdXNoZXMgdGhlIG9iamVjdHMgd2l0aCB0aGUgcmVnWCBhbmQgcmVnWSBmb3IgZWFjaCBmcmFtZSBpbnRvIGEgZnJhbWUgYXJyYXkuXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9mcmFtZXMucHVzaChmcmFtZSk7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy91c2UgdGhpcyBtZXRob2QgdG8gbG9jYXRlIG9yIG1vdmUgdGhlIHNwcml0ZSBzaGVldCB0byBhIGNvcmRpbmF0ZVxyXG4gICAgIFNwcml0ZUFuaW1hdGlvbi5wcm90b3R5cGUucGxheSA9IGZ1bmN0aW9uKHgsIHksIHNwcml0ZSl7XHJcbiAgICAgICAgICAgIHRoaXMueCA9IHggfHwgMDtcclxuICAgICAgICAgICAgdGhpcy55ID0geSB8fCAwO1xyXG5cclxuICAgICAgICAgICAgLy9ubyBhbmltYXRpb24gd2lsbCBiZSBwbGF5ZWVkIGlmIHRoZSBzdGFydGluZyBmcmFtZSBpcyBlcXVhbCB0byB0aGUgZmluYWwgZnJhbWUuXHJcbiAgICAgICAgICAgIGlmKHRoaXMuc3RhcnRGcmFtZSA9PT0gdGhpcy5maW5hbEZyYW1lKXtcclxuXHRcdFx0XHRcclxuXHQvL3N1cnJvdW5kcyB0aGUgc3ByaXRlIGludG8gYSB3aGl0ZSBibG9jayBmb3IgZGVidWdnaW5nIHB1cnBvc2VzLCB5b3UgY2FuIHJlbW92ZSB0aGlzIGluIHlvdXIgZmluYWwgYXBwXHJcbiAgICAgICAgICAgICAgICAvL3RoaXMuY29udGV4dC5zdHJva2VTdHlsZSA9ICcjRkZGRkZGJztcclxuICAgICAgICAgICAgICAgIC8vdGhpcy5jb250ZXh0LnN0cm9rZVJlY3QodGhpcy54LCB0aGlzLnksIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRGcmFtZSA9IHRoaXMuX2ZyYW1lc1t0aGlzLnN0YXJ0RnJhbWVdO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmRyYXdJbWFnZShzcHJpdGUsIHRoaXMuY3VycmVudEZyYW1lLnJlZ1gsIHRoaXMuY3VycmVudEZyYW1lLnJlZ1ksIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCB0aGlzLngsIHRoaXMueSwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICAgICAgLy9pbmNyZW1lbnRzIHRoZSBmcmFtZUluZGV4IGJ5IGEgZGVjaW1hbCwgdGhpcyB3aWxsIGJlIGZsb29yZWQgYmVjYXVzZSBpdCBpcyB1c2VkIHRvIGZpbmQgYW4gaXRlbSBpbiB0aGUgZnJhbWUgYXJyYXkuXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9mcmFtZUluZGV4ICs9IHRoaXMuX2ZyYW1lSW5jcmVtZW50O1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICBpZih0aGlzLl9mcmFtZUluZGV4ID49IHRoaXMuZmluYWxGcmFtZSArIDEpe1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2ZyYW1lSW5kZXggPSAodGhpcy5sb29wKT8gdGhpcy5zdGFydEZyYW1lOiB0aGlzLmZpbmFsRnJhbWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvL2Zsb29ycyB0aGUgY3VycmVudCBpbmRleCB0byBhIHdob2xlIG51bWJlciBzbyB0byBmaW5kIGFuIG9iamVjdCBpbiB0aGUgZnJhbWUgYXJyYXlcclxuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudEZyYW1lID0gdGhpcy5fZnJhbWVzW01hdGguZmxvb3IodGhpcy5fZnJhbWVJbmRleCldO1xyXG4gICAgICAgICAgICAgICAgLy9zdXJyb3VuZHMgdGhlIHNwcml0ZSBpbnRvIGEgd2hpdGUgYmxvY2sgZm9yIGRlYnVnZ2luZyBwdXJwb3NlcywgeW91IGNhbiByZW1vdmUgdGhpcyBpbiB5b3VyIGZpbmFsIGFwcFxyXG4gICAgICAgICAgICAgICAgLy90aGlzLmNvbnRleHQuc3Ryb2tlU3R5bGUgPSAnI0ZGRkZGRic7XHJcbiAgICAgICAgICAgICAgICAvL3RoaXMuY29udGV4dC5zdHJva2VSZWN0KHRoaXMueCwgdGhpcy55LCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICAvL2RyYXdzIHRoZSBzZWN0aW9uIG9mIHRoZSBpbWFnZSBnaXZlbiB0aGUgcmVnWCBhbmQgcmVnWSBhcyB3ZWxsIGFzIHRoZSB3aWR0aCBhbmQgaGVpZ2h0XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuZHJhd0ltYWdlKHNwcml0ZSwgdGhpcy5jdXJyZW50RnJhbWUucmVnWCwgdGhpcy5jdXJyZW50RnJhbWUucmVnWSwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQsIHRoaXMueCwgdGhpcy55LCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7IFxyXG4gICAgICAgICAgICB9IFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy91c2UgdGhpcyBtZXRob2QgdG8gY2hhbmdlIHRoZSBmcHMgc3BlZWQgb2YgeW91ciBzcHJpdGUgc2hlZXQgYW5pbWF0aW9uXHJcbiAgICAgU3ByaXRlQW5pbWF0aW9uLnByb3RvdHlwZS5zZXRTcGVlZCA9IGZ1bmN0aW9uKHNwZWVkKXtcclxuICAgICAgICAgICAgLy9yZWFzb24gd2h5IGEgbWV0aG9kIGZvciB0aGlzIGlzIG5lZWRlZCBpcyBiZWNhdXNlIHRoZXJlIGlzICBtYXRoIHRvIGJlIGRvbmUgd2hlbiBzcGVlZCBpcyBjaGFuZ2VkLlxyXG4gICAgICAgICAgdGhpcy5zcGVlZCA9IHNwZWVkIHx8IHRoaXMuc3BlZWQ7XHJcbiAgICAgICAgICAgIHRoaXMuX2ZyYW1lSW5jcmVtZW50ID0gdGhpcy5zcGVlZCAvIHRoaXMuYXBwRlBTO1xyXG4gICAgICAgICAgICB0aGlzLl9mcmFtZUluZGV4ID0gdGhpcy5zdGFydEZyYW1lOyAgIFxyXG4gICAgICAgIH07IFxyXG5cdFxyXG4gICAgIFNwcml0ZUFuaW1hdGlvbi5wcm90b3R5cGUuZ2V0RnJhbWUgPSBmdW5jdGlvbihmcmFtZUluZGV4KXtcclxuICAgICAgICAgICAgdGhpcy5fZnJhbWVJbmRleCA9IChmcmFtZUluZGV4ID09IHVuZGVmaW5lZCk/IDA6IGZyYW1lSW5kZXg7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9mcmFtZXNbdGhpcy5fZnJhbWVJbmRleF07XHJcbiAgICAgICAgfTtcclxuICAgIFxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgIFxyXG4gICAgRGlzcGxheSA6IERpc3BsYXksXHJcbiAgICBQaHlpc2NzIDogUGh5c2ljcyxcclxuICAgIFNwYWNlY3JhZnQgOiBTcGFjZWNyYWZ0LFxyXG4gICAgUm9jayA6IFJvY2ssXHJcbiAgICBCYWNrZ3JvdW5kIDogQmFja2dyb3VuZCxcclxuICAgIFNoaXAgOiBTaGlwLFxyXG4gICAgUGVyayA6IFBlcmssXHJcbiAgICBNaXNzaWxlIDogTWlzc2lsZSxcclxuICAgIEVuZW15IDogRW5lbXksXHJcbiAgICBNb3RoZXJzaGlwIDogTW90aGVyc2hpcCxcclxuICAgIEV4cGxvc2lvbiA6IEV4cGxvc2lvbixcclxuICAgIFNoaWVsZCA6IFNoaWVsZCxcclxuICAgIFBvb2wgOiBQb29sLFxyXG4gICAgU3ByaXRlQW5pbWF0aW9uIDogU3ByaXRlQW5pbWF0aW9uXHJcbiAgICBcclxufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vanMvQ29uc3RydWN0b3JzLmpzXG4gKiogbW9kdWxlIGlkID0gNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy9jaGVja3MgaWYgYW4gb2JqZWN0IGhhcyBsZWZ0IHRoZSBjYW52YXMgYm91ZGluZyBib3hcclxuZnVuY3Rpb24gY2hlY2tCb3VuZGFyeShvYmplY3Qpe1xyXG5cclxuXHRcdGlmKG9iamVjdC54ID49IG9iamVjdC5jYW52YXNXaWR0aCl7XHJcblx0XHRcdG9iamVjdC54ID0gMDtcclxuXHRcdH1lbHNlIGlmKG9iamVjdC54IDw9IC1vYmplY3Qud2lkdGgpe1xyXG5cdFx0XHRvYmplY3QueCA9IG9iamVjdC5jYW52YXNXaWR0aC1vYmplY3Qud2lkdGg7XHJcblx0XHR9ZWxzZSBpZihvYmplY3QueSA+PSBvYmplY3QuY2FudmFzSGVpZ2h0K29iamVjdC5oZWlnaHQpe1xyXG5cdFx0XHRvYmplY3QueSA9IDA7XHJcblx0XHR9ZWxzZSBpZihvYmplY3QueSA8PSAtb2JqZWN0LmhlaWdodCl7XHJcblx0XHRcdG9iamVjdC55ID0gb2JqZWN0LmNhbnZhc0hlaWdodC1vYmplY3QuaGVpZ2h0O1xyXG5cdFx0fVx0XHJcblx0fVxyXG5cdFxyXG5cdC8vY29sbGlzaW9uIGRldGVjdGlvbi5cclxuZnVuY3Rpb24gaGl0VGVzdChvYmplY3QxLCBvYmplY3QyKXtcclxuICAgXHRcdHZhciBsZWZ0MSA9IG9iamVjdDEueDtcclxuICAgXHRcdHZhciBsZWZ0MiA9IG9iamVjdDIueDtcclxuICAgXHRcdHZhciByaWdodDEgPSBvYmplY3QxLnggKyBvYmplY3QxLndpZHRoO1xyXG4gICBcdFx0dmFyIHJpZ2h0MiA9IG9iamVjdDIueCArIG9iamVjdDIud2lkdGg7XHJcbiAgIFx0XHR2YXIgdG9wMSA9IG9iamVjdDEueTtcclxuICAgXHRcdHZhciB0b3AyID0gb2JqZWN0Mi55O1xyXG4gICBcdFx0dmFyIGJvdHRvbTEgPSBvYmplY3QxLnkgKyBvYmplY3QxLmhlaWdodDtcclxuICAgXHRcdHZhciBib3R0b20yID0gb2JqZWN0Mi55ICsgb2JqZWN0Mi5oZWlnaHQ7XHJcblxyXG4gICBcdFx0aWYgKGJvdHRvbTEgPCB0b3AyKSByZXR1cm4oZmFsc2UpO1xyXG4gICBcdFx0aWYgKHRvcDEgPiBib3R0b20yKSByZXR1cm4oZmFsc2UpO1xyXG4gICBcdFx0aWYgKHJpZ2h0MSA8IGxlZnQyKSByZXR1cm4oZmFsc2UpO1xyXG4gICBcdFx0aWYgKGxlZnQxID4gcmlnaHQyKSByZXR1cm4oZmFsc2UpO1xyXG4gICAgICAgIGlmICghb2JqZWN0MS5hbGl2ZSB8fCBvYmplY3QxLmNvbGxpZGluZyB8fCBvYmplY3QyLmNvbGxpZGluZyB8fCAhb2JqZWN0Mi5hbGl2ZSkgcmV0dXJuKGZhbHNlKTtcclxuICAgICAgICBcclxuICAgICAgICBpZiAob2JqZWN0MS50eXBlID09IFwiaHVtYW5TaGlwXCIgJiYgb2JqZWN0MS52ZWxYID09IDApIHJldHVybihmYWxzZSk7XHJcbiAgICAgICAgaWYgKG9iamVjdDIudHlwZSA9PSBcImh1bWFuU2hpcFwiICYmIG9iamVjdDIudmVsWCA9PSAwKSByZXR1cm4oZmFsc2UpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmKG9iamVjdDIuaGFzT3duUHJvcGVydHkoJ3NoaWVsZCcpKXtcclxuICAgICAgICAgICAgaWYob2JqZWN0Mi5zaGllbGQuYWN0aXZlKXtcclxuICAgICAgICAgICAgICAgIHJldHVybiAoZmFsc2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmKG9iamVjdDEuaGFzT3duUHJvcGVydHkoJ3NoaWVsZCcpKXtcclxuICAgICAgICAgICAgaWYob2JqZWN0MS5zaGllbGQuYWN0aXZlKXtcclxuICAgICAgICAgICAgICAgIHJldHVybiAoZmFsc2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG5cclxuICAgICAgICAvL290aGVyd2lzZSByZXR1cm4gdHJ1ZSBcclxuICAgXHRcdHJldHVybih0cnVlKTtcclxuXHJcblx0fVxyXG5cclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG4gICAgXHJcbiAgICBjaGVja0JvdW5kYXJ5IDogY2hlY2tCb3VuZGFyeSxcclxuICAgIGhpdFRlc3QgOiBoaXRUZXN0XHJcbiAgICBcclxufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vanMvQWxnb3JpdGhtcy5qc1xuICoqIG1vZHVsZSBpZCA9IDVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBQdWJTdWIgPSByZXF1aXJlKCcuL1B1YlN1YicpLFxyXG5cclxuXHQvL3N0YXRlIGRpY3Rpb25hcnkgZ2l2ZW4gcHJvcGVydHkgbmFtZXMgZm9yIGVhY2ggc3RhdGUuIFxyXG4gICAgc3RhdGUgPSB7XHJcbiAgICAgICAgbG9hZGluZzogMCxcclxuICAgICAgICBzdG9yeUxpbmUgOiAxLFxyXG5cdCAgICB0aXRsZVNjcmVlbiA6IDIsXHJcbiAgICAgICAgZ2FtZVBsYXkgOiAzLFxyXG4gICAgICAgIGxldmVsVHJhbnNpdGlvbiA6IDQsXHJcbiAgICAgICAgYmVhdEdhbWUgOiA1LFxyXG4gICAgICAgIGdhbWVPdmVyIDogNixcclxuICAgICAgICBjcmVkaXRzIDogNyxcclxuICAgICAgICBob3dUb1BsYXkgOiA4LFxyXG4gICAgICAgIG9uUGF1c2UgOiA5LFxyXG4gICAgICAgIHNoaXBKdW1wIDogMTAsXHJcbiAgICAgICAgc2V0VXBMZXZlbDogMTEsXHJcblxyXG4gICAgICAgIGN1cnJlbnQgOiAtMSBcclxuICAgIH07XHJcblxyXG5mdW5jdGlvbiBpbml0KCl7XHJcbiAgICBcclxuICAgIGlmKHRoaXMuaGFzSW5pdGlhbGl6ZWQpIHJldHVybiB0aGlzO1xyXG4gICAgIFxyXG4gICAgdGhpcy5oYXNJbml0aWFsaXplZCA9IHRydWU7XHJcbiAgICB0aGlzLnBhZ2VzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnYXBwUGFnZScpO1xyXG4gICAgdGhpcy5pbnRlcmZhY2UgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnaW50ZXJmYWNlV3JhcHBlcicpO1xyXG4gICAgdGhpcy5jb3VudGVycyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ2NvdW50ZXInKTtcclxuICAgIHRoaXMuc3ViSWQgPSBQdWJTdWIuc3Vic2NyaWJlKCdzdGF0ZWNoYW5nZScsIGhhbmRsZVN0YXRlQ2hhbmdlLmJpbmQodGhpcykpO1xyXG4gICAgLy9BZGRzIG1vdXNlZG93biBldmVudCBsaXN0ZW5lciB0byB0aGUgZGl2IGNvbnRhaW5pbmcgYWxsIHRoZSBhcHAgcGFnZXNcclxuXHR0aGlzLmludGVyZmFjZS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBoYW5kbGVDbGljayk7XHJcbiAgICBcclxuICAgIHJldHVybiB0aGlzO1xyXG4gICAgXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGhhbmRsZUNsaWNrKGV2ZW50KXtcclxuICAgIFxyXG4gICAgdmFyIGJ1dHRvbiA9IGV2ZW50LnRhcmdldCxcclxuICAgICAgICBmcm9tID0gYnV0dG9uLmdldEF0dHJpYnV0ZSgnZGF0YS1mcm9tJyksXHJcbiAgICAgICAgdG8gPSBidXR0b24uZ2V0QXR0cmlidXRlKCdkYXRhLXRvJyk7XHJcbiAgICBcclxuXHQvL2lmIHRoZSBlbGVtZW50IHRoYXQgdHJpZ2dlcmVkIGV2ZW50IGhhcyBkYXRhLXRvIGFuZCBmcm9tIGF0dHJpYnV0ZXMsIHRyaWdnZXIgZXZlbnQuXHJcbiAgICBpZihmcm9tICYmIHRvKXtcclxuICAgICAgICAgUHViU3ViLnB1Ymxpc2goJ3N0YXRlY2hhbmdlJywge2Zyb206IHN0YXRlW2Zyb21dLCB0bzogc3RhdGVbdG9dfSk7ICAgXHJcbiAgICB9XHJcbiAgICBcclxufVxyXG5cclxuZnVuY3Rpb24gdXBkYXRlQ291bnRlcnMoY291bnRlciwgdmFsdWUpe1xyXG4gICAgXHJcblx0Ly9pZiB0aGUgY291bnRlciBleGlzdHMgdXBkYXRlIGl0cyB2YWx1ZS5cclxuXHRpZih0aGlzLmNvdW50ZXJzW2NvdW50ZXJdKXtcclxuXHJcblx0XHQgdGhpcy5jb3VudGVyc1tjb3VudGVyXS5pbm5lckhUTUwgPSB2YWx1ZTtcclxuXHRcdFxyXG5cdH1cclxuICAgXHJcbiAgICBcclxuICAgIHJldHVybiB0aGlzO1xyXG4gICAgXHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNob3cocGFnZU5hbWUpe1xyXG5cdFxyXG4gICAgLy9pZiB0aGUgcGFnZSBleGlzdHMgc2hvdyBpdC4gXHJcbiAgICBpZih0aGlzLnBhZ2VzW3BhZ2VOYW1lXSl7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdGhpcy5wYWdlc1twYWdlTmFtZV0uc2V0QXR0cmlidXRlKCdzdHlsZScsICdkaXNwbGF5OiBibG9jazsnKTtcclxuICAgICAgICBcclxuICAgIH1cclxuICAgIFxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgICBcclxufVxyXG5cclxuZnVuY3Rpb24gaGlkZShwYWdlTmFtZSl7XHJcbiAgICBcclxuXHQvL2lmIHRoZSBwYWdlIGlzIGRlZmluZWQsIGhpZGUgaXQuIFxyXG4gICAgaWYodGhpcy5wYWdlc1twYWdlTmFtZV0pe1xyXG4gICAgICAgIFxyXG4gICAgICAgIHRoaXMucGFnZXNbcGFnZU5hbWVdLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCAnZGlzcGxheTogbm9uZTsnKTtcclxuICAgICAgICBcclxuICAgIH1cclxuICAgIFxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgICBcclxufVxyXG5cclxuZnVuY3Rpb24gaGlkZUFsbCgpe1xyXG4gICAgXHJcbiAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblx0XHJcbiBcdC8vZGVsZWdhdGVzIHRoZSBmb3JFYWNoIGFycmF5IG1ldGhvZCB0byBpdGVyYXRlIGFuZCBoaWRlIGVhY2ggcGFnZS5cclxuICAgIFtdLmZvckVhY2guY2FsbCh0aGlzLnBhZ2VzLCBmdW5jdGlvbihjdXJyZXRQYWdlLCBpbmRleCl7XHJcbiAgICAgICBcclxuXHRcdC8vY2FsbHMgdGhlIG1vZHVsZSBoaWRlIG1ldGhvZCB3aXRoIHRoZSBjdXJyZW50IGNvbnRleHQuXHJcbiAgICAgICAgaGlkZS5jYWxsKHNlbGYsIGluZGV4KTtcclxuICAgICAgICBcclxuICAgIH0pO1xyXG4gICAgXHJcbiAgICByZXR1cm4gc2VsZjtcclxuICAgIFxyXG59XHJcblxyXG5cclxuZnVuY3Rpb24gaGFuZGxlU3RhdGVDaGFuZ2UoZXZlbnQsIGRhdGEpe1xyXG4gICAgXHJcblx0Ly9oaWRlcyBhd2F5IGN1cnJlbnQgc3RhdGUgcGFnZSBhbmQgc2hvd3MgbmV3IHN0YXRlIHBhZ2UuXHJcbiAgICBoaWRlLmNhbGwodGhpcywgZGF0YS5mcm9tKTtcclxuICAgIHNob3cuY2FsbCh0aGlzLCBkYXRhLnRvKTtcclxuICAgIFxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgIFxyXG4gICAgaW5pdCA6IGluaXQsXHJcbiAgICBzaG93IDogc2hvdyxcclxuICAgIGhpZGUgOiBoaWRlLFxyXG4gICAgaGlkZUFsbCA6IGhpZGVBbGwsXHJcbiAgICBoYXNJbml0aWFsaXplZCA6IGZhbHNlLFxyXG4gICAgdXBkYXRlQ291bnRlciA6IHVwZGF0ZUNvdW50ZXJzXHJcbiAgICBcclxuICAgIFxyXG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9qcy9VSUNvbnRyb2xsZXIuanNcbiAqKiBtb2R1bGUgaWQgPSA2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgUmVzb3VyY2VMb2FkZXIgPSByZXF1aXJlKCcuL1Jlc291cmNlTG9hZGVyLmpzJyksXHJcbiAgICBrZXlib2FyZENvbnRyb2wgPSByZXF1aXJlKCcuL2tleWJvYXJkQ29udHJvbC5qcycpLFxyXG4gICAgQ29uc3RydWN0b3JzID0gcmVxdWlyZSgnLi9Db25zdHJ1Y3RvcnMnKSxcclxuICAgIFB1YlN1YiA9IHJlcXVpcmUoJy4vUHViU3ViJyksXHJcbiAgICBVSUNvbnRyb2xsZXIgPSByZXF1aXJlKCcuL1VJQ29udHJvbGxlcicpLFxyXG4gICAgQWxnb3JpdGhtcyA9IHJlcXVpcmUoJy4vQWxnb3JpdGhtcycpLFxyXG4gICAgbWFpbkNhbnZhcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdiZ0NhbnZhcycpLFxyXG4gICAgbWFpbkNvbnRleHQgPSBtYWluQ2FudmFzLmdldENvbnRleHQoJzJkJylcclxuICAgIG1vdXNlID0ge3g6IDIwMCwgeToyMDB9LFxyXG4gICAgY2VudGVyWCA9IG1haW5DYW52YXMud2lkdGggLyAyLFxyXG4gICAgY2VudGVyWSA9IG1haW5DYW52YXMuaGVpZ2h0IC8gMixcclxuICAgIEZSQU1FX1JBVEUgPSAxMDAwLzYwLFxyXG4gICAgXHJcbiAgICBzdGF0ZSA9IHtcclxuICAgICAgICBJTklUIDogLTEsXHJcbiAgICAgICAgTE9BRElORzogMCxcclxuICAgICAgICBTVE9SWV9MSU5FIDogMSxcclxuXHQgICAgVElUTEVfU0NSRUVOIDogMixcclxuICAgICAgICBHQU1FX1BMQVkgOiAzLFxyXG4gICAgICAgIExFVkVMX1RSQU5TSVRJT04gOiA0LFxyXG4gICAgICAgIEJFQVRfR0FNRSA6IDUsXHJcbiAgICAgICAgR0FNRV9PVkVSIDogNixcclxuICAgICAgICBDUkVESVRTIDogNyxcclxuICAgICAgICBIT1dfVE9fUExBWSA6IDgsXHJcbiAgICAgICAgUEFVU0VEIDogOSxcclxuICAgICAgICBTSElQX0pVTVAgOiAxMCxcclxuICAgICAgICBTRVRfVVBfTEVWRUw6IDExLFxyXG5cclxuICAgICAgICBDVVJSRU5UIDogLTEgXHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICBzdGF0ZUhhbmRsZXJzID0ge30sXHJcbiAgICBcclxuICAgIGxvb3BPbiA9IGZhbHNlOyAgXHJcblxyXG4gICAgdmFyIHRvdGFsRW5lbWllcyA9IDgsXHJcbiAgICAgICAgdG90YWxSb2NrcyA9IDEwLFxyXG4gICAgICAgIGxldmVsUm9ja3MgPSA1LFxyXG4gICAgICAgIGxldmVsRW5lbWllcyA9IDgsXHJcbiAgICAgICAgbGV2ZWxQZXJrcyA9IDQsXHJcbiAgICAgICAgZW5lbWllc0tpbGxlZCA9IDBcclxuICAgICAgICBjdXJyZW50U2NvcmUgPSAwLFxyXG4gICAgICAgIHNoaXBMaXZlcyA9IDQsXHJcbiAgICAgICAgcm9ja3NEZXN0cm95ZWQgPSAwLFxyXG4gICAgICAgIGN1cnJlbnRMZXZlbCA9IDAsXHJcbiAgICAgICAgbGFzdExldmVsID0gMTQ7XHJcblxyXG5cdC8vVEVNUDogcGxheWVyIGluc3RhbmNlIGFuZCBlbmVtaWVzXHJcbiAgICB2YXIgcGxheWVyU2hpcCxcclxuXHQgICAgYWxpZW5Nb3RoZXJzaGlwLFxyXG4gICAgICAgIGh1bWFuTW90aGVyc2hpcCxcclxuXHQgICAgYmFja2dyb3VuZDtcclxuXHJcbiAgICAgLy9wb29scyBob2xkaW5nIGVuZW1pZXMgYW5kIHJvY2tzXHJcbiAgICB2YXIgZW5lbXlTaGlwc1Bvb2wsXHJcbiAgICAgICAgaHVtYW5TaGlwc1Bvb2wsXHJcbiAgICAgICAgcGVya3NQb29sLFxyXG4gICAgICAgIG1ldGVvclBvb2w7ICAgXHJcblxyXG5mdW5jdGlvbiBpbml0KCl7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgXHJcbiAgICAgICAgYXR0YWNoU3RhdGVIYW5kbGVycygpO1xyXG4gICAgXHJcbiAgICAgICAgcGxheWVyU2hpcCA9IG5ldyBDb25zdHJ1Y3RvcnMuU2hpcCgpO1xyXG5cdCAgICBhbGllbk1vdGhlcnNoaXAgPSBuZXcgQ29uc3RydWN0b3JzLk1vdGhlcnNoaXAoKTtcclxuICAgICAgICBodW1hbk1vdGhlcnNoaXAgPSBuZXcgQ29uc3RydWN0b3JzLk1vdGhlcnNoaXAoKTtcclxuXHQgICAgYmFja2dyb3VuZCA9IG5ldyBDb25zdHJ1Y3RvcnMuQmFja2dyb3VuZCgpO1xyXG5cclxuICAgICAvL3Bvb2xzIGhvbGRpbmcgZW5lbWllcyBhbmQgcm9ja3NcclxuICAgICAgICBlbmVteVNoaXBzUG9vbCA9IG5ldyBDb25zdHJ1Y3RvcnMuUG9vbCh0b3RhbEVuZW1pZXMpO1xyXG4gICAgICAgIGh1bWFuU2hpcHNQb29sID0gbmV3IENvbnN0cnVjdG9ycy5Qb29sKDEwKTtcclxuICAgICAgICBwZXJrc1Bvb2wgPSBuZXcgQ29uc3RydWN0b3JzLlBvb2woMTApO1xyXG4gICAgICAgIG1ldGVvclBvb2wgPSBuZXcgQ29uc3RydWN0b3JzLlBvb2wodG90YWxSb2Nrcyk7ICAgXHJcblxyXG4gICAgICAgIGJhY2tncm91bmQuc2V0Q2FudmFzKG1haW5DYW52YXMpO1xyXG5cdFx0YmFja2dyb3VuZC5pbml0KDEwMDAsIDQ4MCk7XHJcblx0XHRiYWNrZ3JvdW5kLnZlbFggPSAxO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHBlcmtzUG9vbC5pbml0KFwicGVya3NcIik7XHJcbiAgICAgICAgbWV0ZW9yUG9vbC5pbml0KFwicm9ja3NcIik7XHJcbiAgICAgICAgZW5lbXlTaGlwc1Bvb2wuaW5pdCgnZW5lbXknKTtcclxuICAgICAgICBcclxuICAgICAgICBhbGllbk1vdGhlcnNoaXAuc2V0Q2FudmFzKG1haW5DYW52YXMpO1xyXG4gICAgICAgIGFsaWVuTW90aGVyc2hpcC5pbml0KCdhbGllbicpO1xyXG5cclxuICAgICAgICBwbGF5ZXJTaGlwLnNldENhbnZhcyhtYWluQ2FudmFzKTtcclxuICAgICAgICBwbGF5ZXJTaGlwLmluaXQoMjMsIDIzKTtcclxuICAgICAgICBwbGF5ZXJTaGlwLnNwYXduKGNlbnRlclgsIGNlbnRlclkpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBvbk1vdXNlTW92ZSwgZmFsc2UpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vYWRkIGdhbWUgY29udHJvbCBmb3IgZGVza3RvcCBiYXNlZCBvbiBrZXlib2FyZCBldmVudHNcclxuICAgICAgICBrZXlib2FyZENvbnRyb2wuaW5pdChwbGF5ZXJTaGlwKTtcclxuICAgIFxyXG4gICAgICAgIFxyXG4gICAgICAgIC8vc2lnbiB1cCBmb3Igc3Vic2NyaXB0aW9uc1xyXG4gICAgICAgIHZhciBzdWJJRDEgPSBQdWJTdWIuc3Vic2NyaWJlKCdzdGF0ZWNoYW5nZScsIGhhbmRsZVN0YXRlQ2hhbmdlLmJpbmQoc2VsZikpO1xyXG4gICAgICAgIHZhciBzdWJJRDIgPSBQdWJTdWIuc3Vic2NyaWJlKCdtZXRlb3JfZXhwbG9zaW9uJywgaGFuZGxlTWV0ZW9yRXhwbG9zaW9uLmJpbmQoc2VsZikpO1xyXG4gICAgICAgIHZhciBzdWJJRDMgPSBQdWJTdWIuc3Vic2NyaWJlKCdjb2xsaXNpb24nLCByZWNvcmRDb2xsaXNpb24uYmluZChzZWxmKSk7XHJcbiAgICBcclxuXHR3aW5kb3cuYWxpZW5Nb3RoZXJzaGlwID0gYWxpZW5Nb3RoZXJzaGlwO1xyXG5cdHdpbmRvdy5wbGF5ZXJTaGlwID0gcGxheWVyU2hpcDtcclxuICAgIFxyXG59XHJcblxyXG5cclxuZnVuY3Rpb24gb25Nb3VzZU1vdmUoZSl7XHJcbiAgICBcclxuICAgIFxyXG4gICAgXHJcbiAgICBcclxufVxyXG5cclxuXHJcbi8vZnVuY3Rpb24gaW4gY2hhcmdlZCBvZiBzZXR0aW5nIHVwIHRoZSBlbmVtaWVzIGFuZCByb2NrcyBpbiB0aGUgbmV3IGxldmVsIGdpdmVuIHRoZSBjdXJyZW50IGxldmVsXHJcbmZ1bmN0aW9uIGhhbmRsZVNldFVwTGV2ZWwoKXtcclxuICAgIFxyXG4gICAgICAgIFxyXG4gICAgICAgIFxyXG4gICAgICAgIGNvbnNvbGUubG9nKCdTZXQgVXAgTGV2ZWwgZnVuY3Rpb24gQ0FMTEVEJyk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy9zZXRzIHVwIHJhbmRvbSBsb2NhdGlvbiBmb3Igcm9ja3MgYW5kIG1vdGhlcnNoaXBcclxuICAgICAgICAgICAgdmFyIHJhbmRvbVgsIHJhbmRvbVk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy9pbmNyZWFzZXMgbGV2ZWwgYnkgMVxyXG4gICAgICAgIGN1cnJlbnRMZXZlbCArPSAxO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vY2hlY2tzIGlmIGdhbWUgaXMgb3ZlclxyXG4gICAgICAgIGlmKGN1cnJlbnRMZXZlbCA+IGxhc3RMZXZlbCl7XHJcbiAgICAgICAgICAgIHVzZXJCZWF0R2FtZSA9IHRydWU7XHJcbiAgICAgICAgICAgIFB1YlN1Yi5wdWJsaXNoKCdzdGF0ZWNoYW5nZScsIHtmcm9tOiBzdGF0ZS5DVVJSRU5ULCB0bzogc3RhdGUuQkVBVF9HQU1FfSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgICAgXHJcbiAgICAgICAgaWYoY3VycmVudExldmVsID09IGxhc3RMZXZlbCl7XHJcbiAgICAgICAgICAgIFJlc291cmNlTG9hZGVyLmFzc2V0cy5sYXN0TGV2ZWxTb3VuZC5wbGF5KCk7XHJcbiAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgIC8vYmVnaW5zIG5vcm1hbCBzb3VuZHRyYWNrIFxyXG5cdFx0ICAgUmVzb3VyY2VMb2FkZXIuYXNzZXRzLnNvdW5kVHJhY2sucGxheSgpO1xyXG4gICAgICAgIH1cclxuXHRcdFxyXG4gICAgICAgIC8vcmVzZXRzIGVuZW15IGtpbGxlZCBhbmQgcm9ja3MgZGVzdHJveWVkIGNvdW50ZXIgYW5kIHNoaXAgbGl2ZXNcclxuICAgICAgICBlbmVtaWVzS2lsbGVkID0gMDtcclxuICAgICAgICByb2Nrc0Rlc3Ryb3llZCA9IDA7XHJcbiAgICBcclxuICAgICAgICBpZihjdXJyZW50TGV2ZWwgPT0gMSl7XHJcbiAgICAgICAgICAgIHNoaXBMaXZlcyA9IDQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vc2V0cyB1cCBudW1iZXIgb2Ygcm9ja3MgYW5kIGVuZW1pZXMgdGhhdCB3aWxsIGJlIGRpc3BsYXllZFxyXG4gICAgICAgIGxldmVsRW5lbWllcyA9IGN1cnJlbnRMZXZlbCsxO1xyXG4gICAgICAgIGxldmVsUm9ja3MgPSBjdXJyZW50TGV2ZWwrMjtcclxuICAgICAgICBcclxuICAgICAgICAvL2NoZWNrcyB0byBzZWUgaWYgdGhlIGxldmVsIHJvY2tzIGFuZCBlbmVtaWVzIGV4Y2VlZCB0b3RhbCBpbiBwb29sLlxyXG4gICAgICAgIGxldmVsRW5lbWllcyA9IChsZXZlbEVuZW1pZXM+PXRvdGFsRW5lbWllcyk/IHRvdGFsRW5lbWllcyA6IGxldmVsRW5lbWllcztcclxuICAgICAgICBsZXZlbFJvY2tzID0gKGxldmVsUm9ja3M+PXRvdGFsUm9ja3MpPyB0b3RhbFJvY2tzIDogbGV2ZWxSb2NrcztcclxuICAgICAgICBcclxuICAgICAgICAvL2NlbnRlcnMgc2hpcCBhbmQgaGlkZSBhbGwgb2YgaXRzIG1pc3NpbGVzXHJcbiAgICAgICAgcGxheWVyU2hpcC5zcGF3bihjZW50ZXJYLCBjZW50ZXJZKTtcclxuICAgICAgICBcclxuICAgICAgICAvL2tpbGwgb2ZmIGFueSBhbGl2ZSByb2NrcyBhbmQgZW5lbWllc1xyXG4gICAgICAgIHBlcmtzUG9vbC5oaWRlSXRlbXMoKTtcclxuICAgICAgICBlbmVteVNoaXBzUG9vbC5oaWRlSXRlbXMoKTtcclxuICAgICAgICBtZXRlb3JQb29sLmhpZGVJdGVtcygpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vaW5pdHMgdGhlIHJvY2tzXHJcbiAgICAgICAgZm9yKHZhciBpPTA7IGk8bGV2ZWxSb2NrczsgaSsrKXtcclxuICAgICAgICAgICAgcmFuZG9tWCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSoobWFpbkNhbnZhcy53aWR0aC01MCkpLFxyXG4gICAgICAgICAgICByYW5kb21ZID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpKihtYWluQ2FudmFzLmhlaWdodC01MCkpO1xyXG4gICAgICAgICAgICBtZXRlb3JQb29sLmdldChyYW5kb21YLCByYW5kb21ZLCBcImxhcmdlUm9ja1wiKTtcclxuICAgICAgICAgICAgbWV0ZW9yUG9vbC5nZXQocmFuZG9tWCwgcmFuZG9tWSwgXCJzbWFsbFJvY2tcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIGZvcih2YXIgaD0wOyBoPGxldmVsUGVya3M7IGgrKyl7XHJcbiAgICAgICAgICAgIHJhbmRvbVggPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkqKG1haW5DYW52YXMud2lkdGgtNTApKSxcclxuICAgICAgICAgICAgcmFuZG9tWSA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSoobWFpbkNhbnZhcy5oZWlnaHQtNTApKTtcclxuICAgICAgICAgICAgcGVya3NQb29sLmdldChyYW5kb21YLCByYW5kb21ZLCBcImxpZmVcIik7XHJcbiAgICAgICAgICAgIHBlcmtzUG9vbC5nZXQocmFuZG9tWSwgcmFuZG9tWCwgXCJzaGllbGRcIik7XHJcbiAgICAgICAgfVxyXG4gICAgXHJcbiAgICAgICAgLy9hbGllbk1vdGhlcnNoaXAuaW5pdChcImFsaWVuXCIpO1xyXG4gICAgICAgIGFsaWVuTW90aGVyc2hpcC5zcGF3bihyYW5kb21YLCByYW5kb21ZKTtcclxuICAgICAgICBhbGllbk1vdGhlcnNoaXAuc2hpZWxkLmFjdGl2ZSA9IHRydWU7XHJcbiAgICAgICAgYWxpZW5Nb3RoZXJzaGlwLnNldFJlbGVhc2UoZW5lbXlTaGlwc1Bvb2wsIGxldmVsRW5lbWllcywgODAwMCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy91cGRhdGVDb3VudGVyKCdsZXZlbCcpO1xyXG4gICAgICAgIC8vdXBkYXRlQ291bnRlcignbGlmZScpO1xyXG4gICAgICAgIC8vdXBkYXRlQ291bnRlcignc2NvcmUnKTtcclxuICAgIFxyXG4gICAgICAgIFVJQ29udHJvbGxlci51cGRhdGVDb3VudGVyKCdsZXZlbCcsIGN1cnJlbnRMZXZlbCk7XHJcbiAgICAgICAgVUlDb250cm9sbGVyLnVwZGF0ZUNvdW50ZXIoJ2xpdmVzJywgc2hpcExpdmVzKTtcclxuICAgICAgICBVSUNvbnRyb2xsZXIudXBkYXRlQ291bnRlcignc2NvcmUnLCBjdXJyZW50U2NvcmUpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIFB1YlN1Yi5wdWJsaXNoKCdzdGF0ZWNoYW5nZScsIHtmcm9tOiBzdGF0ZS5TRVRfVVBfTEVWRUwsIHRvOiBzdGF0ZS5HQU1FX1BMQVl9KTtcclxuICAgIFxyXG59XHJcblxyXG5mdW5jdGlvbiBhdHRhY2hTdGF0ZUhhbmRsZXJzKCl7XHJcbiAgICBcclxuICAgIHN0YXRlSGFuZGxlcnNbc3RhdGUuTE9BRElOR10gPSBoYW5kbGVMb2FkaW5nO1xyXG4gICAgc3RhdGVIYW5kbGVyc1tzdGF0ZS5TVE9SWV9MSU5FXSA9IGhhbmRsZVN0b3J5TGluZTtcclxuICAgIHN0YXRlSGFuZGxlcnNbc3RhdGUuVElUTEVfU0NSRUVOXSA9IGhhbmRsZVRpdGxlU2NyZWVuO1xyXG4gICAgc3RhdGVIYW5kbGVyc1tzdGF0ZS5TRVRfVVBfTEVWRUxdID0gaGFuZGxlU2V0VXBMZXZlbDtcclxuICAgIHN0YXRlSGFuZGxlcnNbc3RhdGUuR0FNRV9QTEFZXSA9IGhhbmRsZUdhbWVQbGF5O1xyXG4gICAgc3RhdGVIYW5kbGVyc1tzdGF0ZS5TSElQX0pVTVBdID0gaGFuZGxlU2hpcEp1bXA7XHJcbiAgICBzdGF0ZUhhbmRsZXJzW3N0YXRlLkxFVkVMX1RSQU5TSVRJT05dID0gaGFuZGxlTGV2ZWxUcmFuc2l0aW9uO1xyXG4gICAgc3RhdGVIYW5kbGVyc1tzdGF0ZS5CRUFUX0dBTUVdID0gaGFuZGxlQmVhdEdhbWU7XHJcbiAgICBzdGF0ZUhhbmRsZXJzW3N0YXRlLkdBTUVfT1ZFUl0gPSBoYW5kbGVHYW1lT3ZlcjtcclxuICAgIHN0YXRlSGFuZGxlcnNbc3RhdGUuQ1JFRElUU10gPSBoYW5kbGVDcmVkaXRzO1xyXG4gICAgc3RhdGVIYW5kbGVyc1tzdGF0ZS5IT1dfVE9fUExBWV0gPSBoYW5kbGVIb3dUb1BsYXk7XHJcbiAgICBzdGF0ZUhhbmRsZXJzW3N0YXRlLlBBVVNFRF0gPSBoYW5kbGVQYXVzZTtcclxuICAgICAgICBcclxufVxyXG5cclxuZnVuY3Rpb24gaGFuZGxlTG9hZGluZygpe1xyXG4gICAgLy9kbyBub3RoaW5nICAgXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGhhbmRsZVN0b3J5TGluZSgpe1xyXG5cclxuICAgIGlmKCFsb29wT24pe1xyXG4gICAgIFxyXG4gICAgICAgIGxvb3BPbiA9IHRydWU7XHJcbiAgICAgICAgZ2FtZUxvb3AoKTtcclxuICAgICAgICBcclxuICAgIH1cclxuICAgIFxyXG4gICAgYmFja2dyb3VuZC5kcmF3KCk7XHJcbiAgICBcclxufVxyXG5cclxuZnVuY3Rpb24gaGFuZGxlVGl0bGVTY3JlZW4oKXtcclxuICAgIFxyXG4gICAgaWYoIWxvb3BPbil7XHJcbiAgICAgICAgXHJcbiAgICAgICAgbG9vcE9uID0gdHJ1ZTtcclxuICAgICAgICBnYW1lTG9vcCgpO1xyXG4gICAgICAgIFxyXG4gICAgfVxyXG4gICAgXHJcbiAgICBiYWNrZ3JvdW5kLmRyYXcoKTtcclxuICAgIG1haW5Db250ZXh0LmRyYXdJbWFnZShSZXNvdXJjZUxvYWRlci5hc3NldHMuZWFydGhTcHJpdGUsIChtYWluQ2FudmFzLndpZHRoLzItKFJlc291cmNlTG9hZGVyLmFzc2V0cy5lYXJ0aFNwcml0ZS53aWR0aC8yKSksIDApO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGZvcih2YXIgaT0wOyBpPDc7IGkrKyl7XHJcbiAgICAgICAgICAgIHZhciBjdXJyZW50RW5lbXkgPSBlbmVteVNoaXBzUG9vbC5wb29sW2ldO1xyXG4gICAgICAgICAgICBjdXJyZW50RW5lbXkuZHJhdygpO1xyXG4gICAgICAgICAgICBjdXJyZW50RW5lbXkuZm9sbG93KG1vdXNlKTtcclxuICAgICAgICAgICAgQWxnb3JpdGhtcy5jaGVja0JvdW5kYXJ5KGN1cnJlbnRFbmVteSk7XHJcbiAgICAgICAgfVxyXG4gICAgXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGhhbmRsZUdhbWVQbGF5KCl7XHJcbiAgICBcclxuICAgIGlmKCFsb29wT24pe1xyXG4gICAgICAgIFxyXG4gICAgICAgIFJlc291cmNlTG9hZGVyLmFzc2V0cy5zb3VuZFRyYWNrLnBsYXkoKTtcclxuICAgICAgICBsb29wT24gPSB0cnVlO1xyXG4gICAgICAgIGdhbWVMb29wKCk7XHJcbiAgICAgICAgICAgXHJcbiAgICB9XHJcbiAgICBcclxuICAgICBiYWNrZ3JvdW5kLmRyYXcoKTtcclxuXHJcbiAgICAgICAgaWYoYWxpZW5Nb3RoZXJzaGlwLmFsaXZlKXtcclxuICAgICAgICAgICAgYWxpZW5Nb3RoZXJzaGlwLmRyYXcoKTtcclxuICAgICAgICAgICAgQWxnb3JpdGhtcy5jaGVja0JvdW5kYXJ5KGFsaWVuTW90aGVyc2hpcCk7XHJcbiAgICAgICAgICAgIGFsaWVuTW90aGVyc2hpcC5mb2xsb3cocGxheWVyU2hpcCk7XHJcbiAgICAgICAgICAgIGFsaWVuTW90aGVyc2hpcC5hdHRhY2socGxheWVyU2hpcCk7XHJcbiAgICAgICAgICAgIGFsaWVuTW90aGVyc2hpcC5taXNzaWxlcy5pc0NvbGxpZGluZ1dpdGgocGxheWVyU2hpcCwgcGxheWVyU2hpcC5zaGllbGQpO1xyXG4gICAgICAgICAgICBwbGF5ZXJTaGlwLm1pc3NpbGVzLmlzQ29sbGlkaW5nV2l0aChhbGllbk1vdGhlcnNoaXAsIGFsaWVuTW90aGVyc2hpcC5zaGllbGQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGZvcih2YXIgbT0wOyBtPHBlcmtzUG9vbC5wb29sLmxlbmd0aDsgbSsrKXtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY3VycmVudFBlcmsgPSBwZXJrc1Bvb2wucG9vbFttXTtcclxuICAgICAgICAgICAgICAgICAgICBpZihjdXJyZW50UGVyay5hbGl2ZSl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQZXJrLmRyYXcoKTsgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihBbGdvcml0aG1zLmhpdFRlc3QoY3VycmVudFBlcmssIHBsYXllclNoaXApKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdERVRFQ1RJT04gQ09ORklSTUVEISEnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGN1cnJlbnRQZXJrKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKHBsYXllclNoaXApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFBlcmsuZGVzdHJveSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgUHViU3ViLnB1Ymxpc2goJ2NvbGxpc2lvbicsIGN1cnJlbnRQZXJrLnR5cGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGk8bWV0ZW9yUG9vbC5wb29sLmxlbmd0aDsgaSsrKXtcclxuICAgICAgICAgICBcclxuICAgICAgICAgICAgdmFyIGN1cnJlbnRNZXRlb3IgPSBtZXRlb3JQb29sLnBvb2xbaV07XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBpZihjdXJyZW50TWV0ZW9yLmFsaXZlKXtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRNZXRlb3IuZHJhdygpO1xyXG4gICAgICAgICAgICAgICAgQWxnb3JpdGhtcy5jaGVja0JvdW5kYXJ5KGN1cnJlbnRNZXRlb3IpO1xyXG4gICAgICAgICAgICAgICAgcGxheWVyU2hpcC5taXNzaWxlcy5pc0NvbGxpZGluZ1dpdGgoY3VycmVudE1ldGVvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgbWV0ZW9yUG9vbC5pc0NvbGxpZGluZ1dpdGgocGxheWVyU2hpcCwgcGxheWVyU2hpcC5zaGllbGQpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGZvcih2YXIgaCA9IDA7IGg8ZW5lbXlTaGlwc1Bvb2wucG9vbC5sZW5ndGg7IGgrKyl7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB2YXIgY3VycmVudEVuZW15ID0gZW5lbXlTaGlwc1Bvb2wucG9vbFtoXTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGlmKGN1cnJlbnRFbmVteS5hbGl2ZSl7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRFbmVteS5kcmF3KCk7XHJcbiAgICAgICAgICAgICAgICBBbGdvcml0aG1zLmNoZWNrQm91bmRhcnkoY3VycmVudEVuZW15KTtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRFbmVteS5mb2xsb3cocGxheWVyU2hpcCk7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50RW5lbXkuYXR0YWNrKHBsYXllclNoaXApO1xyXG4gICAgICAgICAgICAgICAgY3VycmVudEVuZW15Lm1pc3NpbGVzLmlzQ29sbGlkaW5nV2l0aChwbGF5ZXJTaGlwLCBwbGF5ZXJTaGlwLnNoaWVsZCwgbWV0ZW9yUG9vbC5wb29sKTtcclxuICAgICAgICAgICAgICAgIHBsYXllclNoaXAubWlzc2lsZXMuaXNDb2xsaWRpbmdXaXRoKGN1cnJlbnRFbmVteSwgY3VycmVudEVuZW15LnNoaWVsZCk7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIGlmKEFsZ29yaXRobXMuaGl0VGVzdChjdXJyZW50RW5lbXksIHBsYXllclNoaXApKXtcclxuICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50RW5lbXkuZGVzdHJveSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHBsYXllclNoaXAuZGVzdHJveSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIFB1YlN1Yi5wdWJsaXNoKCdjb2xsaXNpb24nLCBjdXJyZW50RW5lbXkudHlwZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgUHViU3ViLnB1Ymxpc2goJ2NvbGxpc2lvbicsIHBsYXllclNoaXAudHlwZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICB9XHJcbiAgICBcclxuICAgICAgICAvL2NoZWNrIGZyYW1lc1xyXG5cdFx0XHJcbiAgICAgICAgaWYocGxheWVyU2hpcC5hbGl2ZSl7XHJcblx0XHRcdGtleWJvYXJkQ29udHJvbC51cGRhdGUoKTtcclxuICAgICAgICAgICAgQWxnb3JpdGhtcy5jaGVja0JvdW5kYXJ5KHBsYXllclNoaXApO1xyXG4gICAgICAgICAgICBwbGF5ZXJTaGlwLmRyYXcoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYoc2hpcExpdmVzIDw9IDAgJiYgIXBsYXllclNoaXAuY29sbGlkaW5nICYmIHN0YXRlLkNVUlJFTlQgPT0gc3RhdGUuR0FNRV9QTEFZKXtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgaWYoY3VycmVudExldmVsID09IGxhc3RMZXZlbCl7XHJcblx0XHRcdFx0XHRcdFJlc291cmNlTG9hZGVyLmFzc2V0cy5sYXN0TGV2ZWxTb3VuZC5zdG9wKCk7XHJcblx0XHRcdFx0XHR9ZWxzZXtcclxuXHRcdFx0XHRcdFx0UmVzb3VyY2VMb2FkZXIuYXNzZXRzLnNvdW5kVHJhY2suc3RvcCgpOyBcclxuXHRcdFx0XHRcdH1cclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgUHViU3ViLnB1Ymxpc2goJ3N0YXRlY2hhbmdlJywge2Zyb206IHN0YXRlLkdBTUVfUExBWSwgdG86IHN0YXRlLkdBTUVfT1ZFUn0pO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRMZXZlbCA9IDA7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgIH1lbHNlIGlmKGxldmVsRW5lbWllcyA8PSAwICYmICFwbGF5ZXJTaGlwLmNvbGxpZGluZyAmJiBwbGF5ZXJTaGlwLmFsaXZlICYmIHN0YXRlLkNVUlJFTlQgPT0gc3RhdGUuR0FNRV9QTEFZKXtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgaWYoY3VycmVudExldmVsID09IGxhc3RMZXZlbCl7XHJcblx0XHRcdFx0XHRcdFJlc291cmNlTG9hZGVyLmFzc2V0cy5sYXN0TGV2ZWxTb3VuZC5zdG9wKCk7XHJcblx0XHRcdFx0XHR9ZWxzZXtcclxuXHRcdFx0XHRcdFx0UmVzb3VyY2VMb2FkZXIuYXNzZXRzLnNvdW5kVHJhY2suc3RvcCgpOyBcclxuXHRcdFx0XHRcdH1cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIFB1YlN1Yi5wdWJsaXNoKCdzdGF0ZWNoYW5nZScsIHtmcm9tOiBzdGF0ZS5HQU1FX1BMQVksIHRvOiBzdGF0ZS5TSElQX0pVTVB9KTtcclxuXHJcbiAgICAgICAgfVxyXG4gICAgXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGhhbmRsZUxldmVsVHJhbnNpdGlvbigpe1xyXG4gICAgXHJcbiAgICBpZihsb29wT24pe1xyXG4gICAgIFxyXG4gICAgICAgIGxvb3BPbiA9IGZhbHNlO1xyXG4gICAgICAgIGdhbWVMb29wKCk7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIFxyXG4gICAgVUlDb250cm9sbGVyLnVwZGF0ZUNvdW50ZXIoJ3JlcG9ydFNjb3JlJywgY3VycmVudFNjb3JlKTtcclxuICAgIFVJQ29udHJvbGxlci51cGRhdGVDb3VudGVyKCdyZXBvcnRDYXJuYWdlJywgZW5lbWllc0tpbGxlZCk7ICAgXHJcbiAgICBVSUNvbnRyb2xsZXIudXBkYXRlQ291bnRlcigncmVwb3J0QXN0ZXJvaWRzJywgcm9ja3NEZXN0cm95ZWQpO1xyXG5cclxuICAgIFxyXG59XHJcblxyXG5mdW5jdGlvbiBoYW5kbGVNZXRlb3JFeHBsb3Npb24oZXZlbnQsIG1ldGVvcil7XHJcbiAgICBcclxuICAgIFxyXG4gICAgICAgICAgICBzd2l0Y2gobWV0ZW9yLnNpemUpe1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcImxhcmdlXCI6XHJcbiAgICAgICAgICAgICAgICBtZXRlb3JQb29sLmdldChtZXRlb3IueCwgbWV0ZW9yLnksIFwibWVkaXVtUm9ja1wiKTtcclxuICAgICAgICAgICAgICAgIG1ldGVvclBvb2wuZ2V0KG1ldGVvci54LCBtZXRlb3IueSwgXCJtZWRpdW1Sb2NrXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcIm1lZGl1bVwiOlxyXG4gICAgICAgICAgICAgICAgbWV0ZW9yUG9vbC5nZXQobWV0ZW9yLngsIG1ldGVvci55LCBcInNtYWxsUm9ja1wiKTtcclxuICAgICAgICAgICAgICAgIG1ldGVvclBvb2wuZ2V0KG1ldGVvci54LCBtZXRlb3IueSwgXCJzbWFsbFJvY2tcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwic21hbGxcIjpcclxuICAgICAgICAgICAgICAgICAgICAvL25vIHJvY2tzXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7ICAgICBcclxuICAgICAgICAgICAgfSBcclxuICAgIFxyXG59XHJcblxyXG5mdW5jdGlvbiBoYW5kbGVTaGlwSnVtcCgpe1xyXG4gICAgXHJcbiAgICBpZighbG9vcE9uKXtcclxuICAgICAgICBcclxuICAgICAgICBsb29wT24gPSB0cnVlO1xyXG4gICAgICAgIGdhbWVMb29wKCk7XHJcbiAgICAgICAgXHJcbiAgICB9XHJcbiAgICBcclxuICAgIFxyXG4gICAgLy9kcmF3IGJhY2tncm91bmRcclxuICAgICAgICBiYWNrZ3JvdW5kLmRyYXcoKTtcclxuICAgICAgICBcclxuICAgICAgICAvL2RyYXdSZW1haW5pbmcgcm9ja3NcclxuICAgICAgICBmb3IodmFyIGs9MDsgazxtZXRlb3JQb29sLnBvb2wubGVuZ3RoOyBrKyspe1xyXG4gICAgICAgICAgICB2YXIgY3VycmVudFJvY2sgPSBtZXRlb3JQb29sLnBvb2xba107XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvL2lmIHJvY2sgYWxpdmUgZHJhdyBpdFxyXG4gICAgICAgICAgICBpZihjdXJyZW50Um9jay5hbGl2ZSl7XHJcbiAgICAgICAgICAgICAgICBBbGdvcml0aG1zLmNoZWNrQm91bmRhcnkoY3VycmVudFJvY2spO1xyXG4gICAgICAgICAgICAgICAgY3VycmVudFJvY2suZHJhdygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIGVuZW15U2hpcHNQb29sLnBvb2wuZm9yRWFjaChmdW5jdGlvbihlbmVteSl7XHJcbiAgICAgICAgICAgIGlmKGVuZW15LmFsaXZlKXtcclxuICAgICAgICAgICAgICAgIGVuZW15LmRyYXcoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIFxyXG5cdFx0cGxheWVyU2hpcC5qdW1wKCk7XHJcbiAgICAgICAgcGxheWVyU2hpcC5kcmF3KCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYocGxheWVyU2hpcC54ID49IDEwMjAtcGxheWVyU2hpcC53aWR0aCl7IFxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgUHViU3ViLnB1Ymxpc2goJ3N0YXRlY2hhbmdlJywge2Zyb206IHN0YXRlLlNISVBfSlVNUCwgdG86IHN0YXRlLkxFVkVMX1RSQU5TSVRJT059KTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgfVxyXG4gICAgXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGhhbmRsZVBhdXNlKCl7XHJcbiBcclxuICAgIFJlc291cmNlTG9hZGVyLmFzc2V0cy5zb3VuZFRyYWNrLnBhdXNlKCk7XHJcbiAgICBSZXNvdXJjZUxvYWRlci5hc3NldHMubGFzdExldmVsU291bmQucGF1c2UoKTtcclxuICAgIGxvb3BPbiA9IGZhbHNlO1xyXG4gICAgXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGhhbmRsZUJlYXRHYW1lKCl7XHJcbiAgICBcclxuICAgICAgICBpZihsb29wT24pe1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgbG9vcE9uID0gZmFsc2U7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgIH1cclxuXHRcdFxyXG4gICAgICAgIC8vb3V0cHV0cyB0aGUgZmluYWwgc2NvcmUgdG8gdGhlIHdpbm5lciBnYW1lciA6KVxyXG4gICAgICAgIC8vUmVzb3VyY2VMb2FkZXIuZmluYWxMZXZlbFNvdW5kLnN0b3AoKTsgICAgICAgXHJcbiAgICAgICAgLy9iZWF0R2FtZVNjb3JlLmlubmVySFRNTCA9IFwiWW91ciBTY29yZTogXCIrY3VycmVudFNjb3JlO1xyXG4gICAgXHJcbiAgICAgICAgVUlDb250cm9sbGVyLnVwZGF0ZUNvdW50ZXIoJ2JlYXRHYW1lU2NvcmUnLCBjdXJyZW50U2NvcmUpO1xyXG4gICAgICAgIHVzZXJCZWF0R2FtZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgUmVzb3VyY2VMb2FkZXIuYXNzZXRzLnZpY3RvcnlTb3VuZC5wbGF5KCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy9yZXNldHMgdGhhdCBzY29yZVxyXG4gICAgICAgIGN1cnJlbnRTY29yZSA9IDA7XHJcbiAgICAgICAgY3VycmVudExldmVsID0gMDtcclxuICAgICAgIFxyXG59XHJcblxyXG5mdW5jdGlvbiBoYW5kbGVHYW1lT3Zlcigpe1xyXG4gICAgXHJcbiAgICAgICAgaWYobG9vcE9uKXtcclxuICAgICAgICAgXHJcbiAgICAgICAgICAgIGxvb3BPbiA9IGZhbHNlO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy9jaGVja3MgdG8gc2VlIHdoaWNoIHNvdW5kIHRvIHN0b3AgcGxheWluZyBnaXZlbiB0aGUgbGV2ZWwgdGhlIHVzZXIgd2FzIGJlZm9yZSBkeWluZ1xyXG5cdFx0UmVzb3VyY2VMb2FkZXIuYXNzZXRzLmdhbWVPdmVyU291bmQucGxheSgpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vcmVzZXRzIHRoZSBzY29yZSBhbmQgbGV2ZWxcclxuICAgICAgICBjdXJyZW50TGV2ZWwgPSAwO1xyXG4gICAgICAgIGN1cnJlbnRTY29yZSA9IDA7XHJcbiAgICBcclxufVxyXG5cclxuZnVuY3Rpb24gcmVjb3JkQ29sbGlzaW9uKGV2ZW50LCBvYmplY3RUeXBlKXtcclxuICAgIFxyXG4gICAgICAgIHN3aXRjaChvYmplY3RUeXBlKXtcclxuICAgICAgICAgICAgY2FzZSBcImxhcmdlUm9ja1wiOlxyXG4gICAgICAgICAgICAgICAgY3VycmVudFNjb3JlICs9IDIwO1xyXG4gICAgICAgICAgICAgICAgVUlDb250cm9sbGVyLnVwZGF0ZUNvdW50ZXIoJ3Njb3JlJywgY3VycmVudFNjb3JlKTtcclxuICAgICAgICAgICAgICAgIHJvY2tzRGVzdHJveWVkKys7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBjYXNlIFwibWVkaXVtUm9ja1wiOlxyXG4gICAgICAgICAgICAgICAgY3VycmVudFNjb3JlICs9IDEwO1xyXG4gICAgICAgICAgICAgICAgVUlDb250cm9sbGVyLnVwZGF0ZUNvdW50ZXIoJ3Njb3JlJywgY3VycmVudFNjb3JlKTtcclxuICAgICAgICAgICAgICAgIHJvY2tzRGVzdHJveWVkKys7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBjYXNlIFwic21hbGxSb2NrXCI6XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50U2NvcmUgKz0gNTtcclxuICAgICAgICAgICAgICAgIFVJQ29udHJvbGxlci51cGRhdGVDb3VudGVyKCdzY29yZScsIGN1cnJlbnRTY29yZSk7XHJcbiAgICAgICAgICAgICAgICByb2Nrc0Rlc3Ryb3llZCsrO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgY2FzZSBcImh1bWFuU2hpcFwiOlxyXG4gICAgICAgICAgICAgICAgc2hpcExpdmVzLS07XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50U2NvcmUgLT0gNTA7XHJcbiAgICAgICAgICAgICAgICBVSUNvbnRyb2xsZXIudXBkYXRlQ291bnRlcignc2NvcmUnLCBjdXJyZW50U2NvcmUpO1xyXG4gICAgICAgICAgICAgICAgVUlDb250cm9sbGVyLnVwZGF0ZUNvdW50ZXIoJ2xpdmVzJywgc2hpcExpdmVzKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGNhc2UgXCJlbmVteVwiOlxyXG4gICAgICAgICAgICAgICAgY3VycmVudFNjb3JlICs9IDUwO1xyXG4gICAgICAgICAgICAgICAgVUlDb250cm9sbGVyLnVwZGF0ZUNvdW50ZXIoJ3Njb3JlJywgY3VycmVudFNjb3JlKTtcclxuICAgICAgICAgICAgICAgIGxldmVsRW5lbWllcy0tO1xyXG4gICAgICAgICAgICAgICAgZW5lbWllc0tpbGxlZCsrO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgY2FzZSBcImxpZmVcIjpcclxuICAgICAgICAgICAgICAgIHNoaXBMaXZlcysrO1xyXG4gICAgICAgICAgICAgICAgVUlDb250cm9sbGVyLnVwZGF0ZUNvdW50ZXIoJ2xpdmVzJywgc2hpcExpdmVzKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGNhc2UgXCJzaGllbGRcIjpcclxuICAgICAgICAgICAgICAgIHBsYXllclNoaXAuc2hpZWxkLnJlc2V0KCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcImNhc2hcIjpcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxufVxyXG5cclxuZnVuY3Rpb24gaGFuZGxlQ3JlZGl0cygpe1xyXG4gICAgXHJcblx0aWYobG9vcE9uKXtcclxuXHRcdGxvb3BPbiA9IGZhbHNlO1xyXG5cdH1cclxuICAgIFxyXG4gICAgXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGhhbmRsZUhvd1RvUGxheSgpe1xyXG4gICAgXHJcblx0aWYobG9vcE9uKXtcclxuXHRcdGxvb3BPbiA9IGZhbHNlO1xyXG5cdH1cclxuICAgIFxyXG4gICAgXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGhhbmRsZVN0YXRlQ2hhbmdlKGV2ZW50LCBkYXRhKXtcclxuICAgIFxyXG4gICAgc3RhdGUuQ1VSUkVOVCA9IGRhdGEudG87XHJcbiAgICBcclxuICAgIHJ1blN0YXRlKGRhdGEudG8pO1xyXG4gICAgXHJcbiAgICBcclxufVxyXG5cclxuZnVuY3Rpb24gcnVuU3RhdGUoc3RhdGUpe1xyXG4gICAgXHJcbiAgICAgc3RhdGVIYW5kbGVyc1tzdGF0ZV0oKTtcclxuICAgIFxyXG59XHJcbiAgICBcclxuZnVuY3Rpb24gZ2FtZUxvb3AoKXtcclxuICAgIFxyXG4gICAgaWYobG9vcE9uKXtcclxuICAgICBcclxuXHRcdHJlcXVlc3RBbmltRnJhbWUoZ2FtZUxvb3AsIEZSQU1FX1JBVEUpO1xyXG5cdFx0XHRcclxuXHRcdHJ1blN0YXRlKHN0YXRlLkNVUlJFTlQpO1xyXG5cdFx0XHJcblx0XHRjb25zb2xlLmxvZygnZ2FtZSBsb29wIHJ1bm5pbmcnKTtcclxuXHRcdFxyXG5cdFx0XHJcblx0XHR9XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG4gICAgXHJcbiAgICBpbml0IDogaW5pdFxyXG4gICAgXHJcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2pzL0dhbWUuanNcbiAqKiBtb2R1bGUgaWQgPSA3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcclxudmFyIFB1YlN1YiA9IHJlcXVpcmUoJy4vUHViU3ViLmpzJyk7XHJcblxyXG52YXIga2V5Ym9hcmRDb250cm9sID0gZnVuY3Rpb24oKXtcclxuXHRcclxuXHQvL2NvbnRyb2wga2V5c1xyXG5cdGNvbnN0IFVQX0FSUk9XID0gMzgsXHJcblx0XHRMRUZUX0FSUk9XID0gMzcsXHJcblx0XHRSSUdIVF9BUlJPVyA9IDM5LFxyXG5cdFx0RE9XTl9BUlJPVyA9IDQwLFxyXG5cdFx0WF9LRVkgPSA4OCxcclxuXHRcdFNQQUNFX0JBUiA9IDMyLFxyXG5cdFx0TEVUVEVSX1AgPSA4MCxcclxuICAgICAgICAgIFxyXG4gICAgICAgIHN0YXRlID0ge1xyXG4gICAgICAgICAgICBJTklUIDogLTEsXHJcbiAgICAgICAgICAgIExPQURJTkc6IDAsXHJcbiAgICAgICAgICAgIFNUT1JZX0xJTkUgOiAxLFxyXG4gICAgICAgICAgICBUSVRMRV9TQ1JFRU4gOiAyLFxyXG4gICAgICAgICAgICBHQU1FX1BMQVkgOiAzLFxyXG4gICAgICAgICAgICBMRVZFTF9UUkFOU0lUSU9OIDogNCxcclxuICAgICAgICAgICAgQkVBVF9HQU1FIDogNSxcclxuICAgICAgICAgICAgR0FNRV9PVkVSIDogNixcclxuICAgICAgICAgICAgQ1JFRElUUyA6IDcsXHJcbiAgICAgICAgICAgIEhPV19UT19QTEFZIDogOCxcclxuICAgICAgICAgICAgUEFVU0VEIDogOSxcclxuICAgICAgICAgICAgU0hJUF9KVU1QIDogMTAsXHJcbiAgICAgICAgICAgIFNFVF9VUF9MRVZFTDogMTEsXHJcblxyXG4gICAgICAgICAgICBDVVJSRU5UIDogLTEgXHJcbiAgICB9O1xyXG5cdFxyXG5cdC8vYXJyYXkgb2YgYWN0aXZlIGFuZCBkZWFjdGl2ZSBrZXlzXHJcblx0dmFyIGtleVByZXNzTGlzdCA9IFtdLFxyXG5cdFx0b2JqZWN0cyA9IFtdLFxyXG5cdFx0aW5pdGlhbGl6ZWQgPSBmYWxzZSxcclxuXHRcdGluR2FtZVBsYXkgPSBmYWxzZTtcclxuXHRcclxuXHRmdW5jdGlvbiBpbml0KG9iamVjdHNUb0NvbnRyb2wpe1xyXG5cdFx0XHJcblx0XHQvL3B1c2hlcyB0aGUgZWxlbWVudHMgdG8gYmUgbWFuaXB1bGF0ZWQgYnkgdGhlIGtleXdvcmQga2V5c1xyXG5cdFx0aWYoIW9iamVjdHMubGVuZ3RoKXtcclxuXHRcdFx0Zm9yKGVsZW1lbnQgaW4gYXJndW1lbnRzKXtcclxuXHRcdFx0XHRvYmplY3RzLnB1c2goYXJndW1lbnRzW2VsZW1lbnRdKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFxyXG5cdFx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5dXAnLCBvbktleVVwLCBmYWxzZSk7XHJcblx0XHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgb25LZXlEb3duLCBmYWxzZSk7XHJcblx0XHRpbml0aWFsaXplZCA9IHRydWU7XHJcblx0XHRjb25zb2xlLmxvZygnS2V5d29yZCBDb250cm9sIE1vZHVsZSBJbml0aWFsaXplZCcpO1xyXG4gICAgICAgIFB1YlN1Yi5zdWJzY3JpYmUoJ3N0YXRlY2hhbmdlJywgaGFuZGxlU3RhdGVDaGFuZ2UpO1xyXG5cdFx0XHJcblx0fVxyXG5cdFxyXG5cdGZ1bmN0aW9uIGhhbmRsZVN0YXRlQ2hhbmdlKGV2ZW50LCBkYXRhKXtcclxuXHRcdHN0YXRlLkNVUlJFTlQgPSBkYXRhLnRvO1xyXG5cdH1cclxuXHRcclxuXHRmdW5jdGlvbiBvbktleVVwKGUpe1xyXG4gICAgICAgIFxyXG5cdFx0aWYoIWluaXRpYWxpemVkKSByZXR1cm4oY29uc29sZS5sb2coJ0tleXdvcmQgTW9kdWxlIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZC4uLicpKTtcclxuXHRcdGUucHJldmVudERlZmF1bHQoKTtcclxuXHRcdGtleVByZXNzTGlzdFtlLmtleUNvZGVdID0gZmFsc2U7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYoa2V5UHJlc3NMaXN0W0xFVFRFUl9QXSA9PSBmYWxzZSAmJiBzdGF0ZS5DVVJSRU5UID09PSBzdGF0ZS5QQVVTRUQpe1xyXG5cdFx0XHRcdGtleVByZXNzTGlzdFtMRVRURVJfUF0gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgUHViU3ViLnB1Ymxpc2goJ3N0YXRlY2hhbmdlJywge2Zyb206IHN0YXRlLlBBVVNFRCwgdG86IHN0YXRlLkdBTUVfUExBWX0pO1xyXG5cdFx0XHRcdGNvbnNvbGUubG9nKCdMZXR0ZXIgUCBoYXMgYmVlbiBwcmVzc2VkJyk7XHJcblxyXG5cdFx0XHR9XHJcbiAgICAgICAgXHJcblx0fVxyXG5cdFxyXG5cdGZ1bmN0aW9uIG9uS2V5RG93bihlKXtcclxuXHRcdGlmKCFpbml0aWFsaXplZCkgcmV0dXJuKGNvbnNvbGUubG9nKCdLZXl3b3JkIE1vZHVsZSBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQuLi4nKSk7XHJcblx0XHRlLnByZXZlbnREZWZhdWx0KCk7XHJcblx0XHRrZXlQcmVzc0xpc3RbZS5rZXlDb2RlXSA9IHRydWU7IFxyXG5cdH1cclxuXHRcclxuXHRmdW5jdGlvbiBydW5LZXlzKCl7XHJcbiAgICAgICAgXHJcblx0XHR2YXIgbGVuZ3RoID0gb2JqZWN0cy5sZW5ndGg7XHJcblx0XHRcclxuXHRcdGZvcih2YXIgaSA9IDA7IGk8bGVuZ3RoOyBpKyspe1xyXG5cdFx0XHRcclxuXHRcdFx0dmFyIG9iamVjdCA9IG9iamVjdHNbaV07XHJcblx0XHRcdFxyXG5cdFx0XHRpZihrZXlQcmVzc0xpc3RbTEVGVF9BUlJPV10pe1xyXG5cdFx0XHRcdG9iamVjdC5hbmdsZSAtPSA1Kk1hdGguUEkvMTgwO1xyXG5cdFx0XHR9ZWxzZSBpZihrZXlQcmVzc0xpc3RbUklHSFRfQVJST1ddKXtcclxuXHRcdFx0XHRvYmplY3QuYW5nbGUgKz0gNSpNYXRoLlBJLzE4MDtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZihrZXlQcmVzc0xpc3RbVVBfQVJST1ddKXtcclxuXHRcdFx0XHRvYmplY3QudGhydXN0ID0gdHJ1ZTtcclxuXHRcdFx0XHR2YXIgZmFjZVggPSBNYXRoLmNvcyhvYmplY3QuYW5nbGUpO1xyXG5cdFx0XHRcdHZhciBmYWNlWSA9IE1hdGguc2luKG9iamVjdC5hbmdsZSk7XHJcblx0XHRcdFx0dmFyIG5ld1ZlbFggPSBvYmplY3QudmVsWCtmYWNlWCpvYmplY3QudGhydXN0QWNjZWw7XHJcblx0XHRcdFx0dmFyIG5ld1ZlbFkgPSBvYmplY3QudmVsWStmYWNlWSpvYmplY3QudGhydXN0QWNjZWw7XHJcblxyXG5cdFx0XHRcdHZhciBmdXR1cmVWZWxvY2l0eSA9IE1hdGguc3FydCgobmV3VmVsWCpuZXdWZWxYKSsobmV3VmVsWSpuZXdWZWxZKSk7XHJcblxyXG5cdFx0XHRcdGlmKGZ1dHVyZVZlbG9jaXR5ID4gb2JqZWN0Lm1heFZlbG9jaXR5KXtcclxuXHRcdFx0XHRcdG5ld1ZlbFggPSBvYmplY3QudmVsWDtcclxuXHRcdFx0XHRcdG5ld1ZlbFkgPSBvYmplY3QudmVsWTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdG9iamVjdC52ZWxYID0gbmV3VmVsWDtcclxuXHRcdFx0XHRvYmplY3QudmVsWSA9IG5ld1ZlbFk7XHRcclxuXHJcblx0XHRcdH1lbHNle1xyXG5cdFx0XHRcdG9iamVjdC50aHJ1c3QgPSBmYWxzZTtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZihrZXlQcmVzc0xpc3RbU1BBQ0VfQkFSXSA9PSBmYWxzZSl7ICAgICAgICAgICAgICAgIFxyXG5cdFx0XHRcdGtleVByZXNzTGlzdFtTUEFDRV9CQVJdID0gdHJ1ZTtcclxuXHRcdFx0XHRpZighb2JqZWN0LnNoaWVsZC5hY3RpdmUpe1xyXG5cdFx0XHRcdG9iamVjdC5zaG9vdCgpO1xyXG5cdFx0XHRcdH1cdFx0XHRcdFxyXG5cdFx0XHR9XHJcblx0XHRcdGlmKGtleVByZXNzTGlzdFtYX0tFWV0pe1xyXG5cdFx0XHRcdG9iamVjdC5zaGllbGQuYWN0aXZlID0gdHJ1ZTtcclxuXHJcblx0XHRcdH1lbHNlIGlmKGtleVByZXNzTGlzdFtYX0tFWV0gPT0gZmFsc2Upe1xyXG5cdFx0XHRcdG9iamVjdC5zaGllbGQuYWN0aXZlID0gZmFsc2U7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYoa2V5UHJlc3NMaXN0W0xFVFRFUl9QXSA9PSBmYWxzZSl7XHJcblx0XHRcdFx0a2V5UHJlc3NMaXN0W0xFVFRFUl9QXSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBQdWJTdWIucHVibGlzaCgnc3RhdGVjaGFuZ2UnLCB7ZnJvbTogc3RhdGUuR0FNRV9QTEFZLCB0bzogc3RhdGUuUEFVU0VEfSk7XHJcblx0XHRcdFx0Y29uc29sZS5sb2coJ0xldHRlciBQIGhhcyBiZWVuIHByZXNzZWQnKTtcclxuXHJcblx0XHRcdH1cclxuXHRcdFx0XHJcblx0XHR9XHJcblx0XHRcclxuXHR9XHJcblx0XHJcblx0ZnVuY3Rpb24gZW5kKCl7XHJcblx0XHRkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXl1cCcsIG9uS2V5VXAsIGZhbHNlKTtcclxuXHRcdGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBvbktleURvd24sIGZhbHNlKTtcclxuXHRcdGluaXRpYWxpemVkID0gZmFsc2U7XHJcblx0XHRjb25zb2xlLmxvZygnS2V5d29yZCBNb2R1bGUgVGVybWluYXRlZCcpO1xyXG5cdH1cclxuXHRcclxuXHRyZXR1cm57XHJcblx0XHRpbml0IDogaW5pdCxcclxuXHRcdHVwZGF0ZSA6IHJ1bktleXMsXHJcblx0XHRlbmQgOiBlbmRcclxuXHR9XHJcblx0XHJcbn0oKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0ga2V5Ym9hcmRDb250cm9sO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9qcy9rZXlib2FyZENvbnRyb2wuanNcbiAqKiBtb2R1bGUgaWQgPSA4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9