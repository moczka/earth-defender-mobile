/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	window.addEventListener('load', onWindowLoad, false);
	
	function onWindowLoad(){
	    
	    
	    canvasApp();
	    
	}
	
	
	function canvasApp(){	
		
			var ResourceLoader = __webpack_require__(1),
	            PubSub = __webpack_require__(3),
	            Consctructors = __webpack_require__(4),
	            UIController = __webpack_require__(6),
	            Game = __webpack_require__(7);
	    
				//sets up game engine
			window.requestAnimFrame = (function(){
		return  window.requestAnimationFrame   ||
				window.webkitRequestAnimationFrame ||
				window.mozRequestAnimationFrame    ||
				window.oRequestAnimationFrame      ||
				window.msRequestAnimationFrame     ||
				function(/* function */ callback, /* DOMElement */ element){
					window.setTimeout(callback, FRAME_RATE);
				};
	        })(); 
	    
	    var state = {
	            INIT : -1,
	            LOADING: 0,
	            STORY_LINE : 1,
	            TITLE_SCREEN : 2,
	            GAME_PLAY : 3,
	            LEVEL_TRANSITION : 4,
	            BEAT_GAME : 5,
	            GAME_OVER : 6,
	            CREDITS : 7,
	            HOW_TO_PLAY : 8,
	            PAUSED : 9,
	            SHIP_JUMP : 10,
	            SET_UP_LEVEL: 11,
	
	            CURRENT : -1 
	    };
	    
	    
	    window.ResourceLoader = ResourceLoader;
		//adding the state object to the keyboardControl state property
	    var preloadImage = document.getElementById('preload');
	    
	    preloadImage.setAttribute('style', 'display: none;');
		
		//frame, assets counter and audio support
		var frameRate = new FrameRateCounter();
	
		
	    var loadBar = document.getElementById('loadBar');
	    
		//set up loader
		var loaderOptions = {
				assets : {
					imgs : {
	                    earthSprite : "assets/sprites/earth.png",
	                    playerSpriteSheet : "assets/sprites/playerShip.png",
	                    enemySpriteSheet : "assets/sprites/enemyShips.png",
	                    MothershipSpriteSheet : "assets/sprites/motherships.png",
	                    backgroundSprite : "assets/sprites/background.png",
	                    meteorSprite : "assets/sprites/meteorSprite.png",
	                    perkSprite : "assets/sprites/perks.png"
					},
	                sounds : {
	                    soundTrack : {
	                        src: ['assets/sounds/soundtrack.mp3','assets/sounds/soundtrack.wav'],
	                        volume: 0.5,
	                        loop: false
	                        },
	                    lastLevelSound : {
	                         src: ['assets/sounds/finalLevelSound.mp3','assets/sounds/finalLevelSound.wav'],
	                         volume: 1,
	                        },
	                    meteorExplosionSound : {
	                        src: ['assets/sounds/meteorExplosion.mp3','assets/sounds/meteorExplosion.wav'],
	                        volume: 1,
	                        },
	                    playerShootSound : {
	                        src: ['assets/sounds/shoot.mp3','assets/sounds/shoot.wav'],
	                        volume: 0.3,
	                        },
	                    explosionSound : {
	                        src: ['assets/sounds/explosion.mp3','assets/sounds/explosion.wav'],
	                        volume: 0.2,
	                        },
	                    perkSound : {
	                        src: ['assets/sounds/perk.mp3','assets/sounds/perk.wav'],
	                        volume: 1.0,
	                        },
	                    victorySound : {
	                        src: ['assets/sounds/victory.mp3','assets/sounds/victory.wav'],
	                        volume: 1.0,
	                        },
	                    gameOverSound : {
	                        src: ['assets/sounds/gameover.mp3','assets/sounds/gameover.wav'],
	                        volume: 1.0,
	                        }
	                }
				},
	            useHowl : true,
	        
				onload : function(item){
					loadBar.setAttribute('style', 'width: '+ResourceLoader.loaded*100+'%;');
				},
	        
				final : function(){
	                Game.init();
					PubSub.publish('statechange', {from:state.LOADING, to:state.STORY_LINE});
				}
			};
	    
	    UIController.init();
	    ResourceLoader.init(loaderOptions);
	    ResourceLoader.downloadAll();
	    
	    
	   
	    
	    
	    
	    //PubSub.publish('statechange', {from: state.LOADING, to: state.STORY_LINE});
	    
		
		//counters
		var scoreCounter = document.getElementById('scoreCounter');
		var levelCounter = document.getElementById('levelCounter');
		var livesCounter = document.getElementById('livesCounter');
		var frameRateCounter = document.getElementById('frameRate');
	    var reportEnemiesKilled = document.getElementById('reportCarnage');
	    var reportRocksDestroyed = document.getElementById('eportAsteroids');
	    var reportScore = document.getElementById('reportScore');
	    var beatGameScore = document.getElementById('beatGameScore');
		
	
		
	
	        
	    //game score tracker
	    
	    function recordCollision(objectType){
	        switch(objectType){
	            case "largeRock":
	                currentScore += 20;
	                updateCounter('score');
	                rocksDestroyed++;
	                break;
	                
	            case "mediumRock":
	                currentScore += 10;
	                updateCounter('score');
	                rocksDestroyed++;
	                break;
	                
	            case "smallRock":
	                currentScore += 5;
	                updateCounter('score');
	                rocksDestroyed++;
	                break;
	                
	            case "humanShip":
	                shipLives--;
	                currentScore -= 50;
	                updateCounter('score');
	                updateCounter('life');
	                break;
	                
	            case "enemy":
	                currentScore += 50;
	                updateCounter('score');
	                levelEnemies--;
	                enemiesKilled++;
	                break;
	                
	            case "life":
	                shipLives++;
	                updateCounter('life');
	                break;
	                
	            case "shield":
	                playerShip.shield.reset();
	                break;
	            case "cash":
	                break;
	        }
	        
	    }
	    
		//handles the mousemove interaction at title screen.
		function onMouseMove(event){
	        
			if(state.CURRENT != state.TITLE_SCREEN){
	            return;
	        }
	        
			if ( event.layerX ||  event.layerX == 0) { // Firefox
	   			mouse.x = event.layerX ;
	    		mouse.y = event.layerY;
	  		} else if (event.offsetX || event.offsetX == 0) { // Opera
	    		mouse.x = event.offsetX;
	    		mouse.y = event.offsetY;
	  		}
			
		}
		
		//Checks for device orientation
		function onOrientationChange(e){
	
			if(window.innerHeight>= window.innerWidth){
				userAgent.portrait = true;
				orientationMessageHolder.setAttribute('style', 'display: block;');
				canvasHolder.setAttribute('style', 'display:none;');
	            interfaceWrapper.setAttribute('style', 'display: none;');
			}else if(window.innerHeight<=window.innerWidth){
				orientationMessageHolder.setAttribute('style', '');
				canvasHolder.setAttribute('style', '');
	            interfaceWrapper.setAttribute('style', '');
				userAgent.portrait = false;
			}
			
		}
		
		//removes the default behavior of pinching zoom on Mobile
		function onTouchMove(e){
			
			e.preventDefault();
		}
	
		//FramRate Class
		
		function FrameRateCounter() {
	
	        this.lastFrameCount = 0;
	        var dateTemp = new Date();
	        this.frameLast = dateTemp.getTime();
	        delete dateTemp;
	        this.frameCtr = 0;
	    }
	
	    FrameRateCounter.prototype.countFrames=function() {
	       var dateTemp = new Date();
	       this.frameCtr++;
	
	       if (dateTemp.getTime() >=this.frameLast+1000) {
	          //ConsoleLog.log("frame event");
	          this.lastFrameCount = this.frameCtr;
	          this.frameLast = dateTemp.getTime();
	          this.frameCtr = 0;
	       }
	
	       delete dateTemp;
	    }
	
	}


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	var Howl = __webpack_require__(2).Howl;
	var PubSub = __webpack_require__(3);
	
	
	var ResourceLoader = (function(){
		
		var totalAssets = 0,
			loadedAssets = 0,
			assetsDownloaded = false,
			UserOptions,
			percentageLoaded,
			audioSupport,
			assets = {};
		
			//default options if no option argument is passed by user.
			var defaultOptions = {
						  onload: function(){ 
							console.log('No callback was passed in..');
							},
						  final : function(){
							  console.log('No final function to call was passed in..');
						  },
						 assets : []
						 };
		
		/* Example of options:
		
		{
			assets : {
			
				imgs : {
					//img names with URLs
					bg_black : "assets/img/background.png,
					meteorSprite : "assets/img/meteor.png,
					enemiesSprite : "assets/img/enemies.png,
					enemyShipSprites: "assets/img/enemyShips.png
				},
				sounds : {
					//sounds name with URLs
					soundtrack : ["assets/sounds/player.mp3", "assets/sounds/player.wav"],
					endSound : ["assets/sounds/gameover.mp3", "assets/sounds/gameover.wav"]
				}
			}
	        useHowl : false,
				//function that is called on every item loaded
			onload : updateLoaderDisplayer,
				//function that is called once all have loaded
			final : finalFunctionToCall
		}
	
		*/
			
		function init(options){
			UserOptions = options || defaultOptions;
		}
		
		function download(){
			
			//return if all assets have already loaded and indexed.
			if(assetsDownloaded) return;
	        
	        PubSub.publish('statechange', {from: state.INIT, to: state.LOADING});
			
			//sets to true so this method (downloadAll()) is called only onced.
			assetsDownloaded = true;
			//creates the sound and image elements for each asset in the options argument.
			for(var item in UserOptions.assets.imgs){
				assets[item] = new Image();
				assets[item].src = UserOptions.assets.imgs[item];
				assets[item].addEventListener('load', onLoad, false);
				totalAssets++;
			}
			//arrays are passed for each sound asset containing the source to the sound.
	        if(!UserOptions.useHowl){
	            for(var item in UserOptions.assets.sounds){
	                for(var i=0, j=UserOptions.assets.sounds[item].length; i<j; i++){
	                var currentSound = UserOptions.assets.sounds[item][i];
	                    //analyzes the extension and picks the first one that is supported by the browser.
	                    if(isAudioSupport(currentSound.slice(-3))){
	                        assets[item] = new Audio();
	                        assets[item].src = UserOptions.assets.sounds[item][i];
	                        assets[item].addEventListener('canplaythrough', onLoad, false);
	                        totalAssets++;
	                        break;
	                    }
	                }
	
	            }
	        }else{
	            //creates howl instance and passes in howl options given by the user.
	            for(var item in UserOptions.assets.sounds){
	                var howlOptions = UserOptions.assets.sounds[item];
	                howlOptions.onload = onLoad;
	                assets[item] = new Howl(howlOptions); 
	                totalAssets++;
	                
	            }
	        }
			
		}
		
		function onLoad(item){
	        
	        //increments load count and remove listeners.
			loadedAssets++;
	        
	        var itemLoaded;
	
	        if(item){
	            if(item.target.tagName === "AUDIO"){
	                itemLoaded = item.target;
	                item.target.removeEventListener('canplaythrough', onLoad, false);
	            }else if (item.target.tagName === "IMG"){
	                itemLoaded = item.target;
	                item.target.removeEventListener('load', onLoad, false);
	            }
	        }else{
	            itemLoaded = {name: "Howl sound", src: "Howl sound check sound"};   
	        }
	        
			//calculates the decimal value from ratio
			percentageLoaded = Math.floor((loadedAssets / totalAssets)*100)/100;
			
			//call the appropriate callback function given the ammount of assets loaded.
			if(UserOptions.onload){
				UserOptions.onload(itemLoaded);
			}
			if(loadedAssets >= totalAssets && UserOptions.final){
				UserOptions.final(itemLoaded);
			}
			
		}
		
		//gets the appropriate supported audio format.
		function isAudioSupport(extension){
			
			var audio = new Audio();
			var supportValue = audio.canPlayType("audio/"+extension);
			if( supportValue === "maybe" || supportValue === "probably" ){
				return true;
			}else{
				return false;
			}
		}
		
		return {
			init : init,
			assets : assets,
			get loaded(){
				return percentageLoaded;
			},
	    	downloadAll : download
		}
		
	})();
	
	module.exports = ResourceLoader;

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(global) {/*!
	 *  howler.js v2.0.0
	 *  howlerjs.com
	 *
	 *  (c) 2013-2016, James Simpson of GoldFire Studios
	 *  goldfirestudios.com
	 *
	 *  MIT License
	 */
	
	(function() {
	
	  'use strict';
	
	  /** Global Methods **/
	  /***************************************************************************/
	
	  /**
	   * Create the global controller. All contained methods and properties apply
	   * to all sounds that are currently playing or will be in the future.
	   */
	  var HowlerGlobal = function() {
	    this.init();
	  };
	  HowlerGlobal.prototype = {
	    /**
	     * Initialize the global Howler object.
	     * @return {Howler}
	     */
	    init: function() {
	      var self = this || Howler;
	
	      // Internal properties.
	      self._codecs = {};
	      self._howls = [];
	      self._muted = false;
	      self._volume = 1;
	      self._canPlayEvent = 'canplaythrough';
	      self._navigator = (typeof window !== 'undefined' && window.navigator) ? window.navigator : null;
	
	      // Public properties.
	      self.masterGain = null;
	      self.noAudio = false;
	      self.usingWebAudio = true;
	      self.autoSuspend = true;
	      self.ctx = null;
	
	      // Set to false to disable the auto iOS enabler.
	      self.mobileAutoEnable = true;
	
	      // Setup the various state values for global tracking.
	      self._setup();
	
	      return self;
	    },
	
	    /**
	     * Get/set the global volume for all sounds.
	     * @param  {Float} vol Volume from 0.0 to 1.0.
	     * @return {Howler/Float}     Returns self or current volume.
	     */
	    volume: function(vol) {
	      var self = this || Howler;
	      vol = parseFloat(vol);
	
	      // If we don't have an AudioContext created yet, run the setup.
	      if (!self.ctx) {
	        setupAudioContext();
	      }
	
	      if (typeof vol !== 'undefined' && vol >= 0 && vol <= 1) {
	        self._volume = vol;
	
	        // Don't update any of the nodes if we are muted.
	        if (self._muted) {
	          return self;
	        }
	
	        // When using Web Audio, we just need to adjust the master gain.
	        if (self.usingWebAudio) {
	          self.masterGain.gain.value = vol;
	        }
	
	        // Loop through and change volume for all HTML5 audio nodes.
	        for (var i=0; i<self._howls.length; i++) {
	          if (!self._howls[i]._webAudio) {
	            // Get all of the sounds in this Howl group.
	            var ids = self._howls[i]._getSoundIds();
	
	            // Loop through all sounds and change the volumes.
	            for (var j=0; j<ids.length; j++) {
	              var sound = self._howls[i]._soundById(ids[j]);
	
	              if (sound && sound._node) {
	                sound._node.volume = sound._volume * vol;
	              }
	            }
	          }
	        }
	
	        return self;
	      }
	
	      return self._volume;
	    },
	
	    /**
	     * Handle muting and unmuting globally.
	     * @param  {Boolean} muted Is muted or not.
	     */
	    mute: function(muted) {
	      var self = this || Howler;
	
	      // If we don't have an AudioContext created yet, run the setup.
	      if (!self.ctx) {
	        setupAudioContext();
	      }
	
	      self._muted = muted;
	
	      // With Web Audio, we just need to mute the master gain.
	      if (self.usingWebAudio) {
	        self.masterGain.gain.value = muted ? 0 : self._volume;
	      }
	
	      // Loop through and mute all HTML5 Audio nodes.
	      for (var i=0; i<self._howls.length; i++) {
	        if (!self._howls[i]._webAudio) {
	          // Get all of the sounds in this Howl group.
	          var ids = self._howls[i]._getSoundIds();
	
	          // Loop through all sounds and mark the audio node as muted.
	          for (var j=0; j<ids.length; j++) {
	            var sound = self._howls[i]._soundById(ids[j]);
	
	            if (sound && sound._node) {
	              sound._node.muted = (muted) ? true : sound._muted;
	            }
	          }
	        }
	      }
	
	      return self;
	    },
	
	    /**
	     * Unload and destroy all currently loaded Howl objects.
	     * @return {Howler}
	     */
	    unload: function() {
	      var self = this || Howler;
	
	      for (var i=self._howls.length-1; i>=0; i--) {
	        self._howls[i].unload();
	      }
	
	      // Create a new AudioContext to make sure it is fully reset.
	      if (self.usingWebAudio && typeof self.ctx.close !== 'undefined') {
	        self.ctx.close();
	        self.ctx = null;
	        setupAudioContext();
	      }
	
	      return self;
	    },
	
	    /**
	     * Check for codec support of specific extension.
	     * @param  {String} ext Audio file extention.
	     * @return {Boolean}
	     */
	    codecs: function(ext) {
	      return (this || Howler)._codecs[ext];
	    },
	
	    /**
	     * Setup various state values for global tracking.
	     * @return {Howler}
	     */
	    _setup: function() {
	      var self = this || Howler;
	
	      // Keeps track of the suspend/resume state of the AudioContext.
	      self.state = self.ctx ? self.ctx.state || 'running' : 'running';
	
	      // Automatically begin the 30-second suspend process
	      self._autoSuspend();
	
	      // Check for supported codecs.
	      if (!self.noAudio) {
	        self._setupCodecs();
	      }
	
	      return self;
	    },
	
	    /**
	     * Check for browser support for various codecs and cache the results.
	     * @return {Howler}
	     */
	    _setupCodecs: function() {
	      var self = this || Howler;
	      var audioTest = (typeof Audio !== 'undefined') ? new Audio() : null;
	
	      if (!audioTest || typeof audioTest.canPlayType !== 'function') {
	        return self;
	      }
	
	      var mpegTest = audioTest.canPlayType('audio/mpeg;').replace(/^no$/, '');
	
	      // Opera version <33 has mixed MP3 support, so we need to check for and block it.
	      var checkOpera = self._navigator && self._navigator.userAgent.match(/OPR\/([0-6].)/g);
	      var isOldOpera = (checkOpera && parseInt(checkOpera[0].split('/')[1], 10) < 33);
	
	      self._codecs = {
	        mp3: !!(!isOldOpera && (mpegTest || audioTest.canPlayType('audio/mp3;').replace(/^no$/, ''))),
	        mpeg: !!mpegTest,
	        opus: !!audioTest.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/, ''),
	        ogg: !!audioTest.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ''),
	        oga: !!audioTest.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ''),
	        wav: !!audioTest.canPlayType('audio/wav; codecs="1"').replace(/^no$/, ''),
	        aac: !!audioTest.canPlayType('audio/aac;').replace(/^no$/, ''),
	        caf: !!audioTest.canPlayType('audio/x-caf;').replace(/^no$/, ''),
	        m4a: !!(audioTest.canPlayType('audio/x-m4a;') || audioTest.canPlayType('audio/m4a;') || audioTest.canPlayType('audio/aac;')).replace(/^no$/, ''),
	        mp4: !!(audioTest.canPlayType('audio/x-mp4;') || audioTest.canPlayType('audio/mp4;') || audioTest.canPlayType('audio/aac;')).replace(/^no$/, ''),
	        weba: !!audioTest.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, ''),
	        webm: !!audioTest.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, ''),
	        dolby: !!audioTest.canPlayType('audio/mp4; codecs="ec-3"').replace(/^no$/, '')
	      };
	
	      return self;
	    },
	
	    /**
	     * Mobile browsers will only allow audio to be played after a user interaction.
	     * Attempt to automatically unlock audio on the first user interaction.
	     * Concept from: http://paulbakaus.com/tutorials/html5/web-audio-on-ios/
	     * @return {Howler}
	     */
	    _enableMobileAudio: function() {
	      var self = this || Howler;
	
	      // Only run this on mobile devices if audio isn't already eanbled.
	      var isMobile = /iPhone|iPad|iPod|Android|BlackBerry|BB10|Silk|Mobi/i.test(self._navigator && self._navigator.userAgent);
	      var isTouch = !!(('ontouchend' in window) || (self._navigator && self._navigator.maxTouchPoints > 0) || (self._navigator && self._navigator.msMaxTouchPoints > 0));
	      if (self._mobileEnabled || !self.ctx || (!isMobile && !isTouch)) {
	        return;
	      }
	
	      self._mobileEnabled = false;
	
	      // Some mobile devices/platforms have distortion issues when opening/closing tabs and/or web views.
	      // Bugs in the browser (especially Mobile Safari) can cause the sampleRate to change from 44100 to 48000.
	      // By calling Howler.unload(), we create a new AudioContext with the correct sampleRate.
	      if (!self._mobileUnloaded && self.ctx.sampleRate !== 44100) {
	        self._mobileUnloaded = true;
	        self.unload();
	      }
	
	      // Scratch buffer for enabling iOS to dispose of web audio buffers correctly, as per:
	      // http://stackoverflow.com/questions/24119684
	      self._scratchBuffer = self.ctx.createBuffer(1, 1, 22050);
	
	      // Call this method on touch start to create and play a buffer,
	      // then check if the audio actually played to determine if
	      // audio has now been unlocked on iOS, Android, etc.
	      var unlock = function() {
	        // Create an empty buffer.
	        var source = self.ctx.createBufferSource();
	        source.buffer = self._scratchBuffer;
	        source.connect(self.ctx.destination);
	
	        // Play the empty buffer.
	        if (typeof source.start === 'undefined') {
	          source.noteOn(0);
	        } else {
	          source.start(0);
	        }
	
	        // Setup a timeout to check that we are unlocked on the next event loop.
	        source.onended = function() {
	          source.disconnect(0);
	
	          // Update the unlocked state and prevent this check from happening again.
	          self._mobileEnabled = true;
	          self.mobileAutoEnable = false;
	
	          // Remove the touch start listener.
	          document.removeEventListener('touchend', unlock, true);
	        };
	      };
	
	      // Setup a touch start listener to attempt an unlock in.
	      document.addEventListener('touchend', unlock, true);
	
	      return self;
	    },
	
	    /**
	     * Automatically suspend the Web Audio AudioContext after no sound has played for 30 seconds.
	     * This saves processing/energy and fixes various browser-specific bugs with audio getting stuck.
	     * @return {Howler}
	     */
	    _autoSuspend: function() {
	      var self = this;
	
	      if (!self.autoSuspend || !self.ctx || typeof self.ctx.suspend === 'undefined' || !Howler.usingWebAudio) {
	        return;
	      }
	
	      // Check if any sounds are playing.
	      for (var i=0; i<self._howls.length; i++) {
	        if (self._howls[i]._webAudio) {
	          for (var j=0; j<self._howls[i]._sounds.length; j++) {
	            if (!self._howls[i]._sounds[j]._paused) {
	              return self;
	            }
	          }
	        }
	      }
	
	      if (self._suspendTimer) {
	        clearTimeout(self._suspendTimer);
	      }
	
	      // If no sound has played after 30 seconds, suspend the context.
	      self._suspendTimer = setTimeout(function() {
	        if (!self.autoSuspend) {
	          return;
	        }
	
	        self._suspendTimer = null;
	        self.state = 'suspending';
	        self.ctx.suspend().then(function() {
	          self.state = 'suspended';
	
	          if (self._resumeAfterSuspend) {
	            delete self._resumeAfterSuspend;
	            self._autoResume();
	          }
	        });
	      }, 30000);
	
	      return self;
	    },
	
	    /**
	     * Automatically resume the Web Audio AudioContext when a new sound is played.
	     * @return {Howler}
	     */
	    _autoResume: function() {
	      var self = this;
	
	      if (!self.ctx || typeof self.ctx.resume === 'undefined' || !Howler.usingWebAudio) {
	        return;
	      }
	
	      if (self.state === 'running' && self._suspendTimer) {
	        clearTimeout(self._suspendTimer);
	        self._suspendTimer = null;
	      } else if (self.state === 'suspended') {
	        self.state = 'resuming';
	        self.ctx.resume().then(function() {
	          self.state = 'running';
	        });
	
	        if (self._suspendTimer) {
	          clearTimeout(self._suspendTimer);
	          self._suspendTimer = null;
	        }
	      } else if (self.state === 'suspending') {
	        self._resumeAfterSuspend = true;
	      }
	
	      return self;
	    }
	  };
	
	  // Setup the global audio controller.
	  var Howler = new HowlerGlobal();
	
	  /** Group Methods **/
	  /***************************************************************************/
	
	  /**
	   * Create an audio group controller.
	   * @param {Object} o Passed in properties for this group.
	   */
	  var Howl = function(o) {
	    var self = this;
	
	    // Throw an error if no source is provided.
	    if (!o.src || o.src.length === 0) {
	      console.error('An array of source files must be passed with any new Howl.');
	      return;
	    }
	
	    self.init(o);
	  };
	  Howl.prototype = {
	    /**
	     * Initialize a new Howl group object.
	     * @param  {Object} o Passed in properties for this group.
	     * @return {Howl}
	     */
	    init: function(o) {
	      var self = this;
	
	      // If we don't have an AudioContext created yet, run the setup.
	      if (!Howler.ctx) {
	        setupAudioContext();
	      }
	
	      // Setup user-defined default properties.
	      self._autoplay = o.autoplay || false;
	      self._format = (typeof o.format !== 'string') ? o.format : [o.format];
	      self._html5 = o.html5 || false;
	      self._muted = o.mute || false;
	      self._loop = o.loop || false;
	      self._pool = o.pool || 5;
	      self._preload = (typeof o.preload === 'boolean') ? o.preload : true;
	      self._rate = o.rate || 1;
	      self._sprite = o.sprite || {};
	      self._src = (typeof o.src !== 'string') ? o.src : [o.src];
	      self._volume = o.volume !== undefined ? o.volume : 1;
	
	      // Setup all other default properties.
	      self._duration = 0;
	      self._state = 'unloaded';
	      self._sounds = [];
	      self._endTimers = {};
	      self._queue = [];
	
	      // Setup event listeners.
	      self._onend = o.onend ? [{fn: o.onend}] : [];
	      self._onfade = o.onfade ? [{fn: o.onfade}] : [];
	      self._onload = o.onload ? [{fn: o.onload}] : [];
	      self._onloaderror = o.onloaderror ? [{fn: o.onloaderror}] : [];
	      self._onpause = o.onpause ? [{fn: o.onpause}] : [];
	      self._onplay = o.onplay ? [{fn: o.onplay}] : [];
	      self._onstop = o.onstop ? [{fn: o.onstop}] : [];
	      self._onmute = o.onmute ? [{fn: o.onmute}] : [];
	      self._onvolume = o.onvolume ? [{fn: o.onvolume}] : [];
	      self._onrate = o.onrate ? [{fn: o.onrate}] : [];
	      self._onseek = o.onseek ? [{fn: o.onseek}] : [];
	
	      // Web Audio or HTML5 Audio?
	      self._webAudio = Howler.usingWebAudio && !self._html5;
	
	      // Automatically try to enable audio on iOS.
	      if (typeof Howler.ctx !== 'undefined' && Howler.ctx && Howler.mobileAutoEnable) {
	        Howler._enableMobileAudio();
	      }
	
	      // Keep track of this Howl group in the global controller.
	      Howler._howls.push(self);
	
	      // Load the source file unless otherwise specified.
	      if (self._preload) {
	        self.load();
	      }
	
	      return self;
	    },
	
	    /**
	     * Load the audio file.
	     * @return {Howler}
	     */
	    load: function() {
	      var self = this;
	      var url = null;
	
	      // If no audio is available, quit immediately.
	      if (Howler.noAudio) {
	        self._emit('loaderror', null, 'No audio support.');
	        return;
	      }
	
	      // Make sure our source is in an array.
	      if (typeof self._src === 'string') {
	        self._src = [self._src];
	      }
	
	      // Loop through the sources and pick the first one that is compatible.
	      for (var i=0; i<self._src.length; i++) {
	        var ext, str;
	
	        if (self._format && self._format[i]) {
	          // If an extension was specified, use that instead.
	          ext = self._format[i];
	        } else {
	          // Make sure the source is a string.
	          str = self._src[i];
	          if (typeof str !== 'string') {
	            self._emit('loaderror', null, 'Non-string found in selected audio sources - ignoring.');
	            continue;
	          }
	
	          // Extract the file extension from the URL or base64 data URI.
	          ext = /^data:audio\/([^;,]+);/i.exec(str);
	          if (!ext) {
	            ext = /\.([^.]+)$/.exec(str.split('?', 1)[0]);
	          }
	
	          if (ext) {
	            ext = ext[1].toLowerCase();
	          }
	        }
	
	        // Check if this extension is available.
	        if (Howler.codecs(ext)) {
	          url = self._src[i];
	          break;
	        }
	      }
	
	      if (!url) {
	        self._emit('loaderror', null, 'No codec support for selected audio sources.');
	        return;
	      }
	
	      self._src = url;
	      self._state = 'loading';
	
	      // If the hosting page is HTTPS and the source isn't,
	      // drop down to HTML5 Audio to avoid Mixed Content errors.
	      if (window.location.protocol === 'https:' && url.slice(0, 5) === 'http:') {
	        self._html5 = true;
	        self._webAudio = false;
	      }
	
	      // Create a new sound object and add it to the pool.
	      new Sound(self);
	
	      // Load and decode the audio data for playback.
	      if (self._webAudio) {
	        loadBuffer(self);
	      }
	
	      return self;
	    },
	
	    /**
	     * Play a sound or resume previous playback.
	     * @param  {String/Number} sprite   Sprite name for sprite playback or sound id to continue previous.
	     * @param  {Boolean} internal Internal Use: true prevents event firing.
	     * @return {Number}          Sound ID.
	     */
	    play: function(sprite, internal) {
	      var self = this;
	      var id = null;
	
	      // Determine if a sprite, sound id or nothing was passed
	      if (typeof sprite === 'number') {
	        id = sprite;
	        sprite = null;
	      } else if (typeof sprite === 'string' && self._state === 'loaded' && !self._sprite[sprite]) {
	        // If the passed sprite doesn't exist, do nothing.
	        return null;
	      } else if (typeof sprite === 'undefined') {
	        // Use the default sound sprite (plays the full audio length).
	        sprite = '__default';
	
	        // Check if there is a single paused sound that isn't ended.
	        // If there is, play that sound. If not, continue as usual.
	        var num = 0;
	        for (var i=0; i<self._sounds.length; i++) {
	          if (self._sounds[i]._paused && !self._sounds[i]._ended) {
	            num++;
	            id = self._sounds[i]._id;
	          }
	        }
	
	        if (num === 1) {
	          sprite = null;
	        } else {
	          id = null;
	        }
	      }
	
	      // Get the selected node, or get one from the pool.
	      var sound = id ? self._soundById(id) : self._inactiveSound();
	
	      // If the sound doesn't exist, do nothing.
	      if (!sound) {
	        return null;
	      }
	
	      // Select the sprite definition.
	      if (id && !sprite) {
	        sprite = sound._sprite || '__default';
	      }
	
	      // If we have no sprite and the sound hasn't loaded, we must wait
	      // for the sound to load to get our audio's duration.
	      if (self._state !== 'loaded' && !self._sprite[sprite]) {
	        self._queue.push({
	          event: 'play',
	          action: function() {
	            self.play(self._soundById(sound._id) ? sound._id : undefined);
	          }
	        });
	
	        return sound._id;
	      }
	
	      // Don't play the sound if an id was passed and it is already playing.
	      if (id && !sound._paused) {
	        // Trigger the play event, in order to keep iterating through queue.
	        if (!internal) {
	          setTimeout(function() {
	            self._emit('play', sound._id);
	          }, 0);
	        }
	
	        return sound._id;
	      }
	
	      // Make sure the AudioContext isn't suspended, and resume it if it is.
	      if (self._webAudio) {
	        Howler._autoResume();
	      }
	
	      // Determine how long to play for and where to start playing.
	      var seek = sound._seek > 0 ? sound._seek : self._sprite[sprite][0] / 1000;
	      var duration = ((self._sprite[sprite][0] + self._sprite[sprite][1]) / 1000) - seek;
	      var timeout = (duration * 1000) / Math.abs(sound._rate);
	
	      // Update the parameters of the sound
	      sound._paused = false;
	      sound._ended = false;
	      sound._sprite = sprite;
	      sound._seek = seek;
	      sound._start = self._sprite[sprite][0] / 1000;
	      sound._stop = (self._sprite[sprite][0] + self._sprite[sprite][1]) / 1000;
	      sound._loop = !!(sound._loop || self._sprite[sprite][2]);
	
	      // Begin the actual playback.
	      var node = sound._node;
	      if (self._webAudio) {
	        // Fire this when the sound is ready to play to begin Web Audio playback.
	        var playWebAudio = function() {
	          self._refreshBuffer(sound);
	
	          // Setup the playback params.
	          var vol = (sound._muted || self._muted) ? 0 : sound._volume;
	          node.gain.setValueAtTime(vol, Howler.ctx.currentTime);
	          sound._playStart = Howler.ctx.currentTime;
	
	          // Play the sound using the supported method.
	          if (typeof node.bufferSource.start === 'undefined') {
	            sound._loop ? node.bufferSource.noteGrainOn(0, seek, 86400) : node.bufferSource.noteGrainOn(0, seek, duration);
	          } else {
	            sound._loop ? node.bufferSource.start(0, seek, 86400) : node.bufferSource.start(0, seek, duration);
	          }
	
	          // Start a new timer if none is present.
	          if (timeout !== Infinity) {
	            self._endTimers[sound._id] = setTimeout(self._ended.bind(self, sound), timeout);
	          }
	
	          if (!internal) {
	            setTimeout(function() {
	              self._emit('play', sound._id);
	            }, 0);
	          }
	        };
	
	        if (self._state === 'loaded') {
	          playWebAudio();
	        } else {
	          // Wait for the audio to load and then begin playback.
	          self.once('load', playWebAudio, sound._id);
	
	          // Cancel the end timer.
	          self._clearTimer(sound._id);
	        }
	      } else {
	        // Fire this when the sound is ready to play to begin HTML5 Audio playback.
	        var playHtml5 = function() {
	          node.currentTime = seek;
	          node.muted = sound._muted || self._muted || Howler._muted || node.muted;
	          node.volume = sound._volume * Howler.volume();
	          node.playbackRate = sound._rate;
	
	          setTimeout(function() {
	            node.play();
	
	            // Setup the new end timer.
	            if (timeout !== Infinity) {
	              self._endTimers[sound._id] = setTimeout(self._ended.bind(self, sound), timeout);
	            }
	
	            if (!internal) {
	              self._emit('play', sound._id);
	            }
	          }, 0);
	        };
	
	        // Play immediately if ready, or wait for the 'canplaythrough'e vent.
	        var loadedNoReadyState = (self._state === 'loaded' && (window && window.ejecta || !node.readyState && Howler._navigator.isCocoonJS));
	        if (node.readyState === 4 || loadedNoReadyState) {
	          playHtml5();
	        } else {
	          var listener = function() {
	            // Begin playback.
	            playHtml5();
	
	            // Clear this listener.
	            node.removeEventListener(Howler._canPlayEvent, listener, false);
	          };
	          node.addEventListener(Howler._canPlayEvent, listener, false);
	
	          // Cancel the end timer.
	          self._clearTimer(sound._id);
	        }
	      }
	
	      return sound._id;
	    },
	
	    /**
	     * Pause playback and save current position.
	     * @param  {Number} id The sound ID (empty to pause all in group).
	     * @return {Howl}
	     */
	    pause: function(id) {
	      var self = this;
	
	      // If the sound hasn't loaded, add it to the load queue to pause when capable.
	      if (self._state !== 'loaded') {
	        self._queue.push({
	          event: 'pause',
	          action: function() {
	            self.pause(id);
	          }
	        });
	
	        return self;
	      }
	
	      // If no id is passed, get all ID's to be paused.
	      var ids = self._getSoundIds(id);
	
	      for (var i=0; i<ids.length; i++) {
	        // Clear the end timer.
	        self._clearTimer(ids[i]);
	
	        // Get the sound.
	        var sound = self._soundById(ids[i]);
	
	        if (sound && !sound._paused) {
	          // Reset the seek position.
	          sound._seek = self.seek(ids[i]);
	          sound._rateSeek = 0;
	          sound._paused = true;
	
	          // Stop currently running fades.
	          self._stopFade(ids[i]);
	
	          if (sound._node) {
	            if (self._webAudio) {
	              // make sure the sound has been created
	              if (!sound._node.bufferSource) {
	                return self;
	              }
	
	              if (typeof sound._node.bufferSource.stop === 'undefined') {
	                sound._node.bufferSource.noteOff(0);
	              } else {
	                sound._node.bufferSource.stop(0);
	              }
	
	              // Clean up the buffer source.
	              self._cleanBuffer(sound._node);
	            } else if (!isNaN(sound._node.duration) || sound._node.duration === Infinity) {
	              sound._node.pause();
	            }
	          }
	
	          // Fire the pause event, unless `true` is passed as the 2nd argument.
	          if (!arguments[1]) {
	            self._emit('pause', sound._id);
	          }
	        }
	      }
	
	      return self;
	    },
	
	    /**
	     * Stop playback and reset to start.
	     * @param  {Number} id The sound ID (empty to stop all in group).
	     * @param  {Boolean} internal Internal Use: true prevents event firing.
	     * @return {Howl}
	     */
	    stop: function(id, internal) {
	      var self = this;
	
	      // If the sound hasn't loaded, add it to the load queue to stop when capable.
	      if (self._state !== 'loaded') {
	        self._queue.push({
	          event: 'stop',
	          action: function() {
	            self.stop(id);
	          }
	        });
	
	        return self;
	      }
	
	      // If no id is passed, get all ID's to be stopped.
	      var ids = self._getSoundIds(id);
	
	      for (var i=0; i<ids.length; i++) {
	        // Clear the end timer.
	        self._clearTimer(ids[i]);
	
	        // Get the sound.
	        var sound = self._soundById(ids[i]);
	
	        if (sound && !sound._paused) {
	          // Reset the seek position.
	          sound._seek = sound._start || 0;
	          sound._rateSeek = 0;
	          sound._paused = true;
	          sound._ended = true;
	
	          // Stop currently running fades.
	          self._stopFade(ids[i]);
	
	          if (sound._node) {
	            if (self._webAudio) {
	              // make sure the sound has been created
	              if (!sound._node.bufferSource) {
	                return self;
	              }
	
	              if (typeof sound._node.bufferSource.stop === 'undefined') {
	                sound._node.bufferSource.noteOff(0);
	              } else {
	                sound._node.bufferSource.stop(0);
	              }
	
	              // Clean up the buffer source.
	              self._cleanBuffer(sound._node);
	            } else if (!isNaN(sound._node.duration) || sound._node.duration === Infinity) {
	              sound._node.currentTime = sound._start || 0;
	              sound._node.pause();
	            }
	          }
	        }
	
	        if (sound && !internal) {
	          self._emit('stop', sound._id);
	        }
	      }
	
	      return self;
	    },
	
	    /**
	     * Mute/unmute a single sound or all sounds in this Howl group.
	     * @param  {Boolean} muted Set to true to mute and false to unmute.
	     * @param  {Number} id    The sound ID to update (omit to mute/unmute all).
	     * @return {Howl}
	     */
	    mute: function(muted, id) {
	      var self = this;
	
	      // If the sound hasn't loaded, add it to the load queue to mute when capable.
	      if (self._state !== 'loaded') {
	        self._queue.push({
	          event: 'mute',
	          action: function() {
	            self.mute(muted, id);
	          }
	        });
	
	        return self;
	      }
	
	      // If applying mute/unmute to all sounds, update the group's value.
	      if (typeof id === 'undefined') {
	        if (typeof muted === 'boolean') {
	          self._muted = muted;
	        } else {
	          return self._muted;
	        }
	      }
	
	      // If no id is passed, get all ID's to be muted.
	      var ids = self._getSoundIds(id);
	
	      for (var i=0; i<ids.length; i++) {
	        // Get the sound.
	        var sound = self._soundById(ids[i]);
	
	        if (sound) {
	          sound._muted = muted;
	
	          if (self._webAudio && sound._node) {
	            sound._node.gain.setValueAtTime(muted ? 0 : sound._volume, Howler.ctx.currentTime);
	          } else if (sound._node) {
	            sound._node.muted = Howler._muted ? true : muted;
	          }
	
	          self._emit('mute', sound._id);
	        }
	      }
	
	      return self;
	    },
	
	    /**
	     * Get/set the volume of this sound or of the Howl group. This method can optionally take 0, 1 or 2 arguments.
	     *   volume() -> Returns the group's volume value.
	     *   volume(id) -> Returns the sound id's current volume.
	     *   volume(vol) -> Sets the volume of all sounds in this Howl group.
	     *   volume(vol, id) -> Sets the volume of passed sound id.
	     * @return {Howl/Number} Returns self or current volume.
	     */
	    volume: function() {
	      var self = this;
	      var args = arguments;
	      var vol, id;
	
	      // Determine the values based on arguments.
	      if (args.length === 0) {
	        // Return the value of the groups' volume.
	        return self._volume;
	      } else if (args.length === 1) {
	        // First check if this is an ID, and if not, assume it is a new volume.
	        var ids = self._getSoundIds();
	        var index = ids.indexOf(args[0]);
	        if (index >= 0) {
	          id = parseInt(args[0], 10);
	        } else {
	          vol = parseFloat(args[0]);
	        }
	      } else if (args.length >= 2) {
	        vol = parseFloat(args[0]);
	        id = parseInt(args[1], 10);
	      }
	
	      // Update the volume or return the current volume.
	      var sound;
	      if (typeof vol !== 'undefined' && vol >= 0 && vol <= 1) {
	        // If the sound hasn't loaded, add it to the load queue to change volume when capable.
	        if (self._state !== 'loaded') {
	          self._queue.push({
	            event: 'volume',
	            action: function() {
	              self.volume.apply(self, args);
	            }
	          });
	
	          return self;
	        }
	
	        // Set the group volume.
	        if (typeof id === 'undefined') {
	          self._volume = vol;
	        }
	
	        // Update one or all volumes.
	        id = self._getSoundIds(id);
	        for (var i=0; i<id.length; i++) {
	          // Get the sound.
	          sound = self._soundById(id[i]);
	
	          if (sound) {
	            sound._volume = vol;
	
	            // Stop currently running fades.
	            if (!args[2]) {
	              self._stopFade(id[i]);
	            }
	
	            if (self._webAudio && sound._node && !sound._muted) {
	              sound._node.gain.setValueAtTime(vol, Howler.ctx.currentTime);
	            } else if (sound._node && !sound._muted) {
	              sound._node.volume = vol * Howler.volume();
	            }
	
	            self._emit('volume', sound._id);
	          }
	        }
	      } else {
	        sound = id ? self._soundById(id) : self._sounds[0];
	        return sound ? sound._volume : 0;
	      }
	
	      return self;
	    },
	
	    /**
	     * Fade a currently playing sound between two volumes (if no id is passsed, all sounds will fade).
	     * @param  {Number} from The value to fade from (0.0 to 1.0).
	     * @param  {Number} to   The volume to fade to (0.0 to 1.0).
	     * @param  {Number} len  Time in milliseconds to fade.
	     * @param  {Number} id   The sound id (omit to fade all sounds).
	     * @return {Howl}
	     */
	    fade: function(from, to, len, id) {
	      var self = this;
	      var diff = Math.abs(from - to);
	      var dir = from > to ? 'out' : 'in';
	      var steps = diff / 0.01;
	      var stepLen = len / steps;
	
	      // If the sound hasn't loaded, add it to the load queue to fade when capable.
	      if (self._state !== 'loaded') {
	        self._queue.push({
	          event: 'fade',
	          action: function() {
	            self.fade(from, to, len, id);
	          }
	        });
	
	        return self;
	      }
	
	      // Set the volume to the start position.
	      self.volume(from, id);
	
	      // Fade the volume of one or all sounds.
	      var ids = self._getSoundIds(id);
	      for (var i=0; i<ids.length; i++) {
	        // Get the sound.
	        var sound = self._soundById(ids[i]);
	
	        // Create a linear fade or fall back to timeouts with HTML5 Audio.
	        if (sound) {
	          // Stop the previous fade if no sprite is being used (otherwise, volume handles this).
	          if (!id) {
	            self._stopFade(ids[i]);
	          }
	
	          // If we are using Web Audio, let the native methods do the actual fade.
	          if (self._webAudio && !sound._muted) {
	            var currentTime = Howler.ctx.currentTime;
	            var end = currentTime + (len / 1000);
	            sound._volume = from;
	            sound._node.gain.setValueAtTime(from, currentTime);
	            sound._node.gain.linearRampToValueAtTime(to, end);
	          }
	
	          var vol = from;
	          sound._interval = setInterval(function(soundId, sound) {
	            // Update the volume amount.
	            vol += (dir === 'in' ? 0.01 : -0.01);
	
	            // Make sure the volume is in the right bounds.
	            vol = Math.max(0, vol);
	            vol = Math.min(1, vol);
	
	            // Round to within 2 decimal points.
	            vol = Math.round(vol * 100) / 100;
	
	            // Change the volume.
	            if (self._webAudio) {
	              if (typeof id === 'undefined') {
	                self._volume = vol;
	              }
	
	              sound._volume = vol;
	            } else {
	              self.volume(vol, soundId, true);
	            }
	
	            // When the fade is complete, stop it and fire event.
	            if (vol === to) {
	              clearInterval(sound._interval);
	              sound._interval = null;
	              self.volume(vol, soundId);
	              self._emit('fade', soundId);
	            }
	          }.bind(self, ids[i], sound), stepLen);
	        }
	      }
	
	      return self;
	    },
	
	    /**
	     * Internal method that stops the currently playing fade when
	     * a new fade starts, volume is changed or the sound is stopped.
	     * @param  {Number} id The sound id.
	     * @return {Howl}
	     */
	    _stopFade: function(id) {
	      var self = this;
	      var sound = self._soundById(id);
	
	      if (sound && sound._interval) {
	        if (self._webAudio) {
	          sound._node.gain.cancelScheduledValues(Howler.ctx.currentTime);
	        }
	
	        clearInterval(sound._interval);
	        sound._interval = null;
	        self._emit('fade', id);
	      }
	
	      return self;
	    },
	
	    /**
	     * Get/set the loop parameter on a sound. This method can optionally take 0, 1 or 2 arguments.
	     *   loop() -> Returns the group's loop value.
	     *   loop(id) -> Returns the sound id's loop value.
	     *   loop(loop) -> Sets the loop value for all sounds in this Howl group.
	     *   loop(loop, id) -> Sets the loop value of passed sound id.
	     * @return {Howl/Boolean} Returns self or current loop value.
	     */
	    loop: function() {
	      var self = this;
	      var args = arguments;
	      var loop, id, sound;
	
	      // Determine the values for loop and id.
	      if (args.length === 0) {
	        // Return the grou's loop value.
	        return self._loop;
	      } else if (args.length === 1) {
	        if (typeof args[0] === 'boolean') {
	          loop = args[0];
	          self._loop = loop;
	        } else {
	          // Return this sound's loop value.
	          sound = self._soundById(parseInt(args[0], 10));
	          return sound ? sound._loop : false;
	        }
	      } else if (args.length === 2) {
	        loop = args[0];
	        id = parseInt(args[1], 10);
	      }
	
	      // If no id is passed, get all ID's to be looped.
	      var ids = self._getSoundIds(id);
	      for (var i=0; i<ids.length; i++) {
	        sound = self._soundById(ids[i]);
	
	        if (sound) {
	          sound._loop = loop;
	          if (self._webAudio && sound._node && sound._node.bufferSource) {
	            sound._node.bufferSource.loop = loop;
	          }
	        }
	      }
	
	      return self;
	    },
	
	    /**
	     * Get/set the playback rate of a sound. This method can optionally take 0, 1 or 2 arguments.
	     *   rate() -> Returns the first sound node's current playback rate.
	     *   rate(id) -> Returns the sound id's current playback rate.
	     *   rate(rate) -> Sets the playback rate of all sounds in this Howl group.
	     *   rate(rate, id) -> Sets the playback rate of passed sound id.
	     * @return {Howl/Number} Returns self or the current playback rate.
	     */
	    rate: function() {
	      var self = this;
	      var args = arguments;
	      var rate, id;
	
	      // Determine the values based on arguments.
	      if (args.length === 0) {
	        // We will simply return the current rate of the first node.
	        id = self._sounds[0]._id;
	      } else if (args.length === 1) {
	        // First check if this is an ID, and if not, assume it is a new rate value.
	        var ids = self._getSoundIds();
	        var index = ids.indexOf(args[0]);
	        if (index >= 0) {
	          id = parseInt(args[0], 10);
	        } else {
	          rate = parseFloat(args[0]);
	        }
	      } else if (args.length === 2) {
	        rate = parseFloat(args[0]);
	        id = parseInt(args[1], 10);
	      }
	
	      // Update the playback rate or return the current value.
	      var sound;
	      if (typeof rate === 'number') {
	        // If the sound hasn't loaded, add it to the load queue to change playback rate when capable.
	        if (self._state !== 'loaded') {
	          self._queue.push({
	            event: 'rate',
	            action: function() {
	              self.rate.apply(self, args);
	            }
	          });
	
	          return self;
	        }
	
	        // Set the group rate.
	        if (typeof id === 'undefined') {
	          self._rate = rate;
	        }
	
	        // Update one or all volumes.
	        id = self._getSoundIds(id);
	        for (var i=0; i<id.length; i++) {
	          // Get the sound.
	          sound = self._soundById(id[i]);
	
	          if (sound) {
	            // Keep track of our position when the rate changed and update the playback
	            // start position so we can properly adjust the seek position for time elapsed.
	            sound._rateSeek = self.seek(id[i]);
	            sound._playStart = self._webAudio ? Howler.ctx.currentTime : sound._playStart;
	            sound._rate = rate;
	
	            // Change the playback rate.
	            if (self._webAudio && sound._node && sound._node.bufferSource) {
	              sound._node.bufferSource.playbackRate.value = rate;
	            } else if (sound._node) {
	              sound._node.playbackRate = rate;
	            }
	
	            // Reset the timers.
	            var seek = self.seek(id[i]);
	            var duration = ((self._sprite[sound._sprite][0] + self._sprite[sound._sprite][1]) / 1000) - seek;
	            var timeout = (duration * 1000) / Math.abs(sound._rate);
	
	            // Start a new end timer if sound is already playing.
	            if (self._endTimers[id[i]] || !sound._paused) {
	              self._clearTimer(id[i]);
	              self._endTimers[id[i]] = setTimeout(self._ended.bind(self, sound), timeout);
	            }
	
	            self._emit('rate', sound._id);
	          }
	        }
	      } else {
	        sound = self._soundById(id);
	        return sound ? sound._rate : self._rate;
	      }
	
	      return self;
	    },
	
	    /**
	     * Get/set the seek position of a sound. This method can optionally take 0, 1 or 2 arguments.
	     *   seek() -> Returns the first sound node's current seek position.
	     *   seek(id) -> Returns the sound id's current seek position.
	     *   seek(seek) -> Sets the seek position of the first sound node.
	     *   seek(seek, id) -> Sets the seek position of passed sound id.
	     * @return {Howl/Number} Returns self or the current seek position.
	     */
	    seek: function() {
	      var self = this;
	      var args = arguments;
	      var seek, id;
	
	      // Determine the values based on arguments.
	      if (args.length === 0) {
	        // We will simply return the current position of the first node.
	        id = self._sounds[0]._id;
	      } else if (args.length === 1) {
	        // First check if this is an ID, and if not, assume it is a new seek position.
	        var ids = self._getSoundIds();
	        var index = ids.indexOf(args[0]);
	        if (index >= 0) {
	          id = parseInt(args[0], 10);
	        } else {
	          id = self._sounds[0]._id;
	          seek = parseFloat(args[0]);
	        }
	      } else if (args.length === 2) {
	        seek = parseFloat(args[0]);
	        id = parseInt(args[1], 10);
	      }
	
	      // If there is no ID, bail out.
	      if (typeof id === 'undefined') {
	        return self;
	      }
	
	      // If the sound hasn't loaded, add it to the load queue to seek when capable.
	      if (self._state !== 'loaded') {
	        self._queue.push({
	          event: 'seek',
	          action: function() {
	            self.seek.apply(self, args);
	          }
	        });
	
	        return self;
	      }
	
	      // Get the sound.
	      var sound = self._soundById(id);
	
	      if (sound) {
	        if (typeof seek === 'number' && seek >= 0) {
	          // Pause the sound and update position for restarting playback.
	          var playing = self.playing(id);
	          if (playing) {
	            self.pause(id, true);
	          }
	
	          // Move the position of the track and cancel timer.
	          sound._seek = seek;
	          sound._ended = false;
	          self._clearTimer(id);
	
	          // Restart the playback if the sound was playing.
	          if (playing) {
	            self.play(id, true);
	          }
	
	          // Update the seek position for HTML5 Audio.
	          if (!self._webAudio && sound._node) {
	            sound._node.currentTime = seek;
	          }
	
	          self._emit('seek', id);
	        } else {
	          if (self._webAudio) {
	            var realTime = self.playing(id) ? Howler.ctx.currentTime - sound._playStart : 0;
	            var rateSeek = sound._rateSeek ? sound._rateSeek - sound._seek : 0;
	            return sound._seek + (rateSeek + realTime * Math.abs(sound._rate));
	          } else {
	            return sound._node.currentTime;
	          }
	        }
	      }
	
	      return self;
	    },
	
	    /**
	     * Check if a specific sound is currently playing or not (if id is provided), or check if at least one of the sounds in the group is playing or not.
	     * @param  {Number}  id The sound id to check. If none is passed, the whole sound group is checked.
	     * @return {Boolean} True if playing and false if not.
	     */
	    playing: function(id) {
	      var self = this;
	
	      // Check the passed sound ID (if any).
	      if (typeof id === 'number') {
	        var sound = self._soundById(id);
	        return sound ? !sound._paused : false;
	      }
	
	      // Otherwise, loop through all sounds and check if any are playing.
	      for (var i=0; i<self._sounds.length; i++) {
	        if (!self._sounds[i]._paused) {
	          return true;
	        }
	      }
	
	      return false;
	    },
	
	    /**
	     * Get the duration of this sound. Passing a sound id will return the sprite duration.
	     * @param  {Number} id The sound id to check. If none is passed, return full source duration.
	     * @return {Number} Audio duration in seconds.
	     */
	    duration: function(id) {
	      var self = this;
	      var duration = self._duration;
	
	      // If we pass an ID, get the sound and return the sprite length.
	      var sound = self._soundById(id);
	      if (sound) {
	        duration = self._sprite[sound._sprite][1] / 1000;
	      }
	
	      return duration;
	    },
	
	    /**
	     * Returns the current loaded state of this Howl.
	     * @return {String} 'unloaded', 'loading', 'loaded'
	     */
	    state: function() {
	      return this._state;
	    },
	
	    /**
	     * Unload and destroy the current Howl object.
	     * This will immediately stop all sound instances attached to this group.
	     */
	    unload: function() {
	      var self = this;
	
	      // Stop playing any active sounds.
	      var sounds = self._sounds;
	      for (var i=0; i<sounds.length; i++) {
	        // Stop the sound if it is currently playing.
	        if (!sounds[i]._paused) {
	          self.stop(sounds[i]._id);
	          self._emit('end', sounds[i]._id);
	        }
	
	        // Remove the source or disconnect.
	        if (!self._webAudio) {
	          // Set the source to 0-second silence to stop any downloading.
	          sounds[i]._node.src = 'data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQAAAAA=';
	
	          // Remove any event listeners.
	          sounds[i]._node.removeEventListener('error', sounds[i]._errorFn, false);
	          sounds[i]._node.removeEventListener(Howler._canPlayEvent, sounds[i]._loadFn, false);
	        }
	
	        // Empty out all of the nodes.
	        delete sounds[i]._node;
	
	        // Make sure all timers are cleared out.
	        self._clearTimer(sounds[i]._id);
	
	        // Remove the references in the global Howler object.
	        var index = Howler._howls.indexOf(self);
	        if (index >= 0) {
	          Howler._howls.splice(index, 1);
	        }
	      }
	
	      // Delete this sound from the cache (if no other Howl is using it).
	      var remCache = true;
	      for (i=0; i<Howler._howls.length; i++) {
	        if (Howler._howls[i]._src === self._src) {
	          remCache = false;
	          break;
	        }
	      }
	
	      if (cache && remCache) {
	        delete cache[self._src];
	      }
	
	      // Clear out `self`.
	      self._state = 'unloaded';
	      self._sounds = [];
	      self = null;
	
	      return null;
	    },
	
	    /**
	     * Listen to a custom event.
	     * @param  {String}   event Event name.
	     * @param  {Function} fn    Listener to call.
	     * @param  {Number}   id    (optional) Only listen to events for this sound.
	     * @param  {Number}   once  (INTERNAL) Marks event to fire only once.
	     * @return {Howl}
	     */
	    on: function(event, fn, id, once) {
	      var self = this;
	      var events = self['_on' + event];
	
	      if (typeof fn === 'function') {
	        events.push(once ? {id: id, fn: fn, once: once} : {id: id, fn: fn});
	      }
	
	      return self;
	    },
	
	    /**
	     * Remove a custom event. Call without parameters to remove all events.
	     * @param  {String}   event Event name.
	     * @param  {Function} fn    Listener to remove. Leave empty to remove all.
	     * @param  {Number}   id    (optional) Only remove events for this sound.
	     * @return {Howl}
	     */
	    off: function(event, fn, id) {
	      var self = this;
	      var events = self['_on' + event];
	      var i = 0;
	
	      if (fn) {
	        // Loop through event store and remove the passed function.
	        for (i=0; i<events.length; i++) {
	          if (fn === events[i].fn && id === events[i].id) {
	            events.splice(i, 1);
	            break;
	          }
	        }
	      } else if (event) {
	        // Clear out all events of this type.
	        self['_on' + event] = [];
	      } else {
	        // Clear out all events of every type.
	        var keys = Object.keys(self);
	        for (i=0; i<keys.length; i++) {
	          if ((keys[i].indexOf('_on') === 0) && Array.isArray(self[keys[i]])) {
	            self[keys[i]] = [];
	          }
	        }
	      }
	
	      return self;
	    },
	
	    /**
	     * Listen to a custom event and remove it once fired.
	     * @param  {String}   event Event name.
	     * @param  {Function} fn    Listener to call.
	     * @param  {Number}   id    (optional) Only listen to events for this sound.
	     * @return {Howl}
	     */
	    once: function(event, fn, id) {
	      var self = this;
	
	      // Setup the event listener.
	      self.on(event, fn, id, 1);
	
	      return self;
	    },
	
	    /**
	     * Emit all events of a specific type and pass the sound id.
	     * @param  {String} event Event name.
	     * @param  {Number} id    Sound ID.
	     * @param  {Number} msg   Message to go with event.
	     * @return {Howl}
	     */
	    _emit: function(event, id, msg) {
	      var self = this;
	      var events = self['_on' + event];
	
	      // Loop through event store and fire all functions.
	      for (var i=events.length-1; i>=0; i--) {
	        if (!events[i].id || events[i].id === id || event === 'load') {
	          setTimeout(function(fn) {
	            fn.call(this, id, msg);
	          }.bind(self, events[i].fn), 0);
	
	          // If this event was setup with `once`, remove it.
	          if (events[i].once) {
	            self.off(event, events[i].fn, events[i].id);
	          }
	        }
	      }
	
	      return self;
	    },
	
	    /**
	     * Queue of actions initiated before the sound has loaded.
	     * These will be called in sequence, with the next only firing
	     * after the previous has finished executing (even if async like play).
	     * @return {Howl}
	     */
	    _loadQueue: function() {
	      var self = this;
	
	      if (self._queue.length > 0) {
	        var task = self._queue[0];
	
	        // don't move onto the next task until this one is done
	        self.once(task.event, function() {
	          self._queue.shift();
	          self._loadQueue();
	        });
	
	        task.action();
	      }
	
	      return self;
	    },
	
	    /**
	     * Fired when playback ends at the end of the duration.
	     * @param  {Sound} sound The sound object to work with.
	     * @return {Howl}
	     */
	    _ended: function(sound) {
	      var self = this;
	      var sprite = sound._sprite;
	
	      // Should this sound loop?
	      var loop = !!(sound._loop || self._sprite[sprite][2]);
	
	      // Fire the ended event.
	      self._emit('end', sound._id);
	
	      // Restart the playback for HTML5 Audio loop.
	      if (!self._webAudio && loop) {
	        self.stop(sound._id, true).play(sound._id);
	      }
	
	      // Restart this timer if on a Web Audio loop.
	      if (self._webAudio && loop) {
	        self._emit('play', sound._id);
	        sound._seek = sound._start || 0;
	        sound._rateSeek = 0;
	        sound._playStart = Howler.ctx.currentTime;
	
	        var timeout = ((sound._stop - sound._start) * 1000) / Math.abs(sound._rate);
	        self._endTimers[sound._id] = setTimeout(self._ended.bind(self, sound), timeout);
	      }
	
	      // Mark the node as paused.
	      if (self._webAudio && !loop) {
	        sound._paused = true;
	        sound._ended = true;
	        sound._seek = sound._start || 0;
	        sound._rateSeek = 0;
	        self._clearTimer(sound._id);
	
	        // Clean up the buffer source.
	        self._cleanBuffer(sound._node);
	
	        // Attempt to auto-suspend AudioContext if no sounds are still playing.
	        Howler._autoSuspend();
	      }
	
	      // When using a sprite, end the track.
	      if (!self._webAudio && !loop) {
	        self.stop(sound._id);
	      }
	
	      return self;
	    },
	
	    /**
	     * Clear the end timer for a sound playback.
	     * @param  {Number} id The sound ID.
	     * @return {Howl}
	     */
	    _clearTimer: function(id) {
	      var self = this;
	
	      if (self._endTimers[id]) {
	        clearTimeout(self._endTimers[id]);
	        delete self._endTimers[id];
	      }
	
	      return self;
	    },
	
	    /**
	     * Return the sound identified by this ID, or return null.
	     * @param  {Number} id Sound ID
	     * @return {Object}    Sound object or null.
	     */
	    _soundById: function(id) {
	      var self = this;
	
	      // Loop through all sounds and find the one with this ID.
	      for (var i=0; i<self._sounds.length; i++) {
	        if (id === self._sounds[i]._id) {
	          return self._sounds[i];
	        }
	      }
	
	      return null;
	    },
	
	    /**
	     * Return an inactive sound from the pool or create a new one.
	     * @return {Sound} Sound playback object.
	     */
	    _inactiveSound: function() {
	      var self = this;
	
	      self._drain();
	
	      // Find the first inactive node to recycle.
	      for (var i=0; i<self._sounds.length; i++) {
	        if (self._sounds[i]._ended) {
	          return self._sounds[i].reset();
	        }
	      }
	
	      // If no inactive node was found, create a new one.
	      return new Sound(self);
	    },
	
	    /**
	     * Drain excess inactive sounds from the pool.
	     */
	    _drain: function() {
	      var self = this;
	      var limit = self._pool;
	      var cnt = 0;
	      var i = 0;
	
	      // If there are less sounds than the max pool size, we are done.
	      if (self._sounds.length < limit) {
	        return;
	      }
	
	      // Count the number of inactive sounds.
	      for (i=0; i<self._sounds.length; i++) {
	        if (self._sounds[i]._ended) {
	          cnt++;
	        }
	      }
	
	      // Remove excess inactive sounds, going in reverse order.
	      for (i=self._sounds.length - 1; i>=0; i--) {
	        if (cnt <= limit) {
	          return;
	        }
	
	        if (self._sounds[i]._ended) {
	          // Disconnect the audio source when using Web Audio.
	          if (self._webAudio && self._sounds[i]._node) {
	            self._sounds[i]._node.disconnect(0);
	          }
	
	          // Remove sounds until we have the pool size.
	          self._sounds.splice(i, 1);
	          cnt--;
	        }
	      }
	    },
	
	    /**
	     * Get all ID's from the sounds pool.
	     * @param  {Number} id Only return one ID if one is passed.
	     * @return {Array}    Array of IDs.
	     */
	    _getSoundIds: function(id) {
	      var self = this;
	
	      if (typeof id === 'undefined') {
	        var ids = [];
	        for (var i=0; i<self._sounds.length; i++) {
	          ids.push(self._sounds[i]._id);
	        }
	
	        return ids;
	      } else {
	        return [id];
	      }
	    },
	
	    /**
	     * Load the sound back into the buffer source.
	     * @param  {Sound} sound The sound object to work with.
	     * @return {Howl}
	     */
	    _refreshBuffer: function(sound) {
	      var self = this;
	
	      // Setup the buffer source for playback.
	      sound._node.bufferSource = Howler.ctx.createBufferSource();
	      sound._node.bufferSource.buffer = cache[self._src];
	
	      // Connect to the correct node.
	      if (sound._panner) {
	        sound._node.bufferSource.connect(sound._panner);
	      } else {
	        sound._node.bufferSource.connect(sound._node);
	      }
	
	      // Setup looping and playback rate.
	      sound._node.bufferSource.loop = sound._loop;
	      if (sound._loop) {
	        sound._node.bufferSource.loopStart = sound._start || 0;
	        sound._node.bufferSource.loopEnd = sound._stop;
	      }
	      sound._node.bufferSource.playbackRate.value = sound._rate;
	
	      return self;
	    },
	
	    /**
	     * Prevent memory leaks by cleaning up the buffer source after playback.
	     * @param  {Object} node Sound's audio node containing the buffer source.
	     * @return {Howl}
	     */
	    _cleanBuffer: function(node) {
	      var self = this;
	
	      if (self._scratchBuffer) {
	        node.bufferSource.onended = null;
	        node.bufferSource.disconnect(0);
	        try { node.bufferSource.buffer = self._scratchBuffer; } catch(e) {}
	      }
	      node.bufferSource = null;
	
	      return self;
	    }
	  };
	
	  /** Single Sound Methods **/
	  /***************************************************************************/
	
	  /**
	   * Setup the sound object, which each node attached to a Howl group is contained in.
	   * @param {Object} howl The Howl parent group.
	   */
	  var Sound = function(howl) {
	    this._parent = howl;
	    this.init();
	  };
	  Sound.prototype = {
	    /**
	     * Initialize a new Sound object.
	     * @return {Sound}
	     */
	    init: function() {
	      var self = this;
	      var parent = self._parent;
	
	      // Setup the default parameters.
	      self._muted = parent._muted;
	      self._loop = parent._loop;
	      self._volume = parent._volume;
	      self._muted = parent._muted;
	      self._rate = parent._rate;
	      self._seek = 0;
	      self._paused = true;
	      self._ended = true;
	      self._sprite = '__default';
	
	      // Generate a unique ID for this sound.
	      self._id = Math.round(Date.now() * Math.random());
	
	      // Add itself to the parent's pool.
	      parent._sounds.push(self);
	
	      // Create the new node.
	      self.create();
	
	      return self;
	    },
	
	    /**
	     * Create and setup a new sound object, whether HTML5 Audio or Web Audio.
	     * @return {Sound}
	     */
	    create: function() {
	      var self = this;
	      var parent = self._parent;
	      var volume = (Howler._muted || self._muted || self._parent._muted) ? 0 : self._volume;
	
	      if (parent._webAudio) {
	        // Create the gain node for controlling volume (the source will connect to this).
	        self._node = (typeof Howler.ctx.createGain === 'undefined') ? Howler.ctx.createGainNode() : Howler.ctx.createGain();
	        self._node.gain.setValueAtTime(volume, Howler.ctx.currentTime);
	        self._node.paused = true;
	        self._node.connect(Howler.masterGain);
	      } else {
	        self._node = new Audio();
	
	        // Listen for errors (http://dev.w3.org/html5/spec-author-view/spec.html#mediaerror).
	        self._errorFn = self._errorListener.bind(self);
	        self._node.addEventListener('error', self._errorFn, false);
	
	        // Listen for 'canplaythrough' event to let us know the sound is ready.
	        self._loadFn = self._loadListener.bind(self);
	        self._node.addEventListener(Howler._canPlayEvent, self._loadFn, false);
	
	        // Setup the new audio node.
	        self._node.src = parent._src;
	        self._node.preload = 'auto';
	        self._node.volume = volume * Howler.volume();
	
	        // Begin loading the source.
	        self._node.load();
	      }
	
	      return self;
	    },
	
	    /**
	     * Reset the parameters of this sound to the original state (for recycle).
	     * @return {Sound}
	     */
	    reset: function() {
	      var self = this;
	      var parent = self._parent;
	
	      // Reset all of the parameters of this sound.
	      self._muted = parent._muted;
	      self._loop = parent._loop;
	      self._volume = parent._volume;
	      self._muted = parent._muted;
	      self._rate = parent._rate;
	      self._seek = 0;
	      self._rateSeek = 0;
	      self._paused = true;
	      self._ended = true;
	      self._sprite = '__default';
	
	      // Generate a new ID so that it isn't confused with the previous sound.
	      self._id = Math.round(Date.now() * Math.random());
	
	      return self;
	    },
	
	    /**
	     * HTML5 Audio error listener callback.
	     */
	    _errorListener: function() {
	      var self = this;
	
	      if (self._node.error && self._node.error.code === 4) {
	        Howler.noAudio = true;
	      }
	
	      // Fire an error event and pass back the code.
	      self._parent._emit('loaderror', self._id, self._node.error ? self._node.error.code : 0);
	
	      // Clear the event listener.
	      self._node.removeEventListener('error', self._errorListener, false);
	    },
	
	    /**
	     * HTML5 Audio canplaythrough listener callback.
	     */
	    _loadListener: function() {
	      var self = this;
	      var parent = self._parent;
	
	      // Round up the duration to account for the lower precision in HTML5 Audio.
	      parent._duration = Math.ceil(self._node.duration * 10) / 10;
	
	      // Setup a sprite if none is defined.
	      if (Object.keys(parent._sprite).length === 0) {
	        parent._sprite = {__default: [0, parent._duration * 1000]};
	      }
	
	      if (parent._state !== 'loaded') {
	        parent._state = 'loaded';
	        parent._emit('load');
	        parent._loadQueue();
	      }
	
	      if (parent._autoplay) {
	        parent.play();
	      }
	
	      // Clear the event listener.
	      self._node.removeEventListener(Howler._canPlayEvent, self._loadFn, false);
	    }
	  };
	
	  /** Helper Methods **/
	  /***************************************************************************/
	
	  var cache = {};
	
	  /**
	   * Buffer a sound from URL, Data URI or cache and decode to audio source (Web Audio API).
	   * @param  {Howl} self
	   */
	  var loadBuffer = function(self) {
	    var url = self._src;
	
	    // Check if the buffer has already been cached and use it instead.
	    if (cache[url]) {
	      // Set the duration from the cache.
	      self._duration = cache[url].duration;
	
	      // Load the sound into this Howl.
	      loadSound(self);
	
	      return;
	    }
	
	    if (/^data:[^;]+;base64,/.test(url)) {
	      // Decode the base64 data URI without XHR, since some browsers don't support it.
	      var data = atob(url.split(',')[1]);
	      var dataView = new Uint8Array(data.length);
	      for (var i=0; i<data.length; ++i) {
	        dataView[i] = data.charCodeAt(i);
	      }
	
	      decodeAudioData(dataView.buffer, self);
	    } else {
	      // Load the buffer from the URL.
	      var xhr = new XMLHttpRequest();
	      xhr.open('GET', url, true);
	      xhr.responseType = 'arraybuffer';
	      xhr.onload = function() {
	        // Make sure we get a successful response back.
	        var code = (xhr.status + '')[0];
	        if (code !== '0' && code !== '2' && code !== '3') {
	          self._emit('loaderror', null, 'Failed loading audio file with status: ' + xhr.status + '.');
	          return;
	        }
	
	        decodeAudioData(xhr.response, self);
	      };
	      xhr.onerror = function() {
	        // If there is an error, switch to HTML5 Audio.
	        if (self._webAudio) {
	          self._html5 = true;
	          self._webAudio = false;
	          self._sounds = [];
	          delete cache[url];
	          self.load();
	        }
	      };
	      safeXhrSend(xhr);
	    }
	  };
	
	  /**
	   * Send the XHR request wrapped in a try/catch.
	   * @param  {Object} xhr XHR to send.
	   */
	  var safeXhrSend = function(xhr) {
	    try {
	      xhr.send();
	    } catch (e) {
	      xhr.onerror();
	    }
	  };
	
	  /**
	   * Decode audio data from an array buffer.
	   * @param  {ArrayBuffer} arraybuffer The audio data.
	   * @param  {Howl}        self
	   */
	  var decodeAudioData = function(arraybuffer, self) {
	    // Decode the buffer into an audio source.
	    Howler.ctx.decodeAudioData(arraybuffer, function(buffer) {
	      if (buffer && self._sounds.length > 0) {
	        cache[self._src] = buffer;
	        loadSound(self, buffer);
	      }
	    }, function() {
	      self._emit('loaderror', null, 'Decoding audio data failed.');
	    });
	  };
	
	  /**
	   * Sound is now loaded, so finish setting everything up and fire the loaded event.
	   * @param  {Howl} self
	   * @param  {Object} buffer The decoded buffer sound source.
	   */
	  var loadSound = function(self, buffer) {
	    // Set the duration.
	    if (buffer && !self._duration) {
	      self._duration = buffer.duration;
	    }
	
	    // Setup a sprite if none is defined.
	    if (Object.keys(self._sprite).length === 0) {
	      self._sprite = {__default: [0, self._duration * 1000]};
	    }
	
	    // Fire the loaded event.
	    if (self._state !== 'loaded') {
	      self._state = 'loaded';
	      self._emit('load');
	      self._loadQueue();
	    }
	
	    // Begin playback if specified.
	    if (self._autoplay) {
	      self.play();
	    }
	  };
	
	  /**
	   * Setup the audio context when available, or switch to HTML5 Audio mode.
	   */
	  var setupAudioContext = function() {
	    Howler.noAudio = false;
	
	    // Check if we are using Web Audio and setup the AudioContext if we are.
	    try {
	      if (typeof AudioContext !== 'undefined') {
	        Howler.ctx = new AudioContext();
	      } else if (typeof webkitAudioContext !== 'undefined') {
	        Howler.ctx = new webkitAudioContext();
	      } else {
	        Howler.usingWebAudio = false;
	      }
	    } catch(e) {
	      Howler.usingWebAudio = false;
	    }
	
	    if (!Howler.usingWebAudio) {
	      // No audio is available on this system if noAudio is set to true.
	      if (typeof Audio !== 'undefined') {
	        try {
	          var test = new Audio();
	
	          // Check if the canplaythrough event is available.
	          if (typeof test.oncanplaythrough === 'undefined') {
	            Howler._canPlayEvent = 'canplay';
	          }
	        } catch(e) {
	          Howler.noAudio = true;
	        }
	      } else {
	        Howler.noAudio = true;
	      }
	    }
	
	    // Test to make sure audio isn't disabled in Internet Explorer
	    try {
	      var test = new Audio();
	      if (test.muted) {
	        Howler.noAudio = true;
	      }
	    } catch (e) {}
	
	    // Check if a webview is being used on iOS8 or earlier (rather than the browser).
	    // If it is, disable Web Audio as it causes crashing.
	    var iOS = (/iP(hone|od|ad)/.test(Howler._navigator && Howler._navigator.platform));
	    var appVersion = Howler._navigator && Howler._navigator.appVersion.match(/OS (\d+)_(\d+)_?(\d+)?/);
	    var version = appVersion ? parseInt(appVersion[1], 10) : null;
	    if (iOS && version && version < 9) {
	      var safari = /safari/.test(Howler._navigator && Howler._navigator.userAgent.toLowerCase());
	      if (Howler._navigator && Howler._navigator.standalone && !safari || Howler._navigator && !Howler._navigator.standalone && !safari) {
	        Howler.usingWebAudio = false;
	      }
	    }
	
	    // Create and expose the master GainNode when using Web Audio (useful for plugins or advanced usage).
	    if (Howler.usingWebAudio) {
	      Howler.masterGain = (typeof Howler.ctx.createGain === 'undefined') ? Howler.ctx.createGainNode() : Howler.ctx.createGain();
	      Howler.masterGain.gain.value = 1;
	      Howler.masterGain.connect(Howler.ctx.destination);
	    }
	
	    // Re-run the setup on Howler.
	    Howler._setup();
	  };
	
	  // Add support for AMD (Asynchronous Module Definition) libraries such as require.js.
	  if (true) {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {
	      return {
	        Howler: Howler,
	        Howl: Howl
	      };
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  }
	
	  // Add support for CommonJS libraries such as browserify.
	  if (true) {
	    exports.Howler = Howler;
	    exports.Howl = Howl;
	  }
	
	  // Define globally in case AMD is not available or unused.
	  if (typeof window !== 'undefined') {
	    window.HowlerGlobal = HowlerGlobal;
	    window.Howler = Howler;
	    window.Howl = Howl;
	    window.Sound = Sound;
	  } else if (typeof global !== 'undefined') { // Add to global in Node.js (for testing, etc).
	    global.HowlerGlobal = HowlerGlobal;
	    global.Howler = Howler;
	    global.Howl = Howl;
	    global.Sound = Sound;
	  }
	})();
	
	
	/*!
	 *  Spatial Plugin - Adds support for stereo and 3D audio where Web Audio is supported.
	 *  
	 *  howler.js v2.0.0
	 *  howlerjs.com
	 *
	 *  (c) 2013-2016, James Simpson of GoldFire Studios
	 *  goldfirestudios.com
	 *
	 *  MIT License
	 */
	
	(function() {
	
	  'use strict';
	
	  // Setup default properties.
	  HowlerGlobal.prototype._pos = [0, 0, 0];
	  HowlerGlobal.prototype._orientation = [0, 0, -1, 0, 1, 0];
	  
	  /** Global Methods **/
	  /***************************************************************************/
	
	  /**
	   * Helper method to update the stereo panning position of all current Howls.
	   * Future Howls will not use this value unless explicitely set.
	   * @param  {Number} pan A value of -1.0 is all the way left and 1.0 is all the way right.
	   * @return {Howler/Number}     Self or current stereo panning value.
	   */
	  HowlerGlobal.prototype.stereo = function(pan) {
	    var self = this;
	
	    // Stop right here if not using Web Audio.
	    if (!self.ctx || !self.ctx.listener) {
	      return self;
	    }
	
	    // Loop through all Howls and update their stereo panning.
	    for (var i=self._howls.length-1; i>=0; i--) {
	      self._howls[i].stereo(pan);
	    }
	
	    return self;
	  };
	
	  /**
	   * Get/set the position of the listener in 3D cartesian space. Sounds using
	   * 3D position will be relative to the listener's position.
	   * @param  {Number} x The x-position of the listener.
	   * @param  {Number} y The y-position of the listener.
	   * @param  {Number} z The z-position of the listener.
	   * @return {Howler/Array}   Self or current listener position.
	   */
	  HowlerGlobal.prototype.pos = function(x, y, z) {
	    var self = this;
	
	    // Stop right here if not using Web Audio.
	    if (!self.ctx || !self.ctx.listener) {
	      return self;
	    }
	
	    // Set the defaults for optional 'y' & 'z'.
	    y = (typeof y !== 'number') ? self._pos[1] : y;
	    z = (typeof z !== 'number') ? self._pos[2] : z;
	
	    if (typeof x === 'number') {
	      self._pos = [x, y, z];
	      self.ctx.listener.setPosition(self._pos[0], self._pos[1], self._pos[2]);
	    } else {
	      return self._pos;
	    }
	
	    return self;
	  };
	
	  /**
	   * Get/set the direction the listener is pointing in the 3D cartesian space.
	   * A front and up vector must be provided. The front is the direction the
	   * face of the listener is pointing, and up is the direction the top of the
	   * listener is pointing. Thus, these values are expected to be at right angles
	   * from each other.
	   * @param  {Number} x   The x-orientation of the listener.
	   * @param  {Number} y   The y-orientation of the listener.
	   * @param  {Number} z   The z-orientation of the listener.
	   * @param  {Number} xUp The x-orientation of the top of the listener.
	   * @param  {Number} yUp The y-orientation of the top of the listener.
	   * @param  {Number} zUp The z-orientation of the top of the listener.
	   * @return {Howler/Array}     Returns self or the current orientation vectors.
	   */
	  HowlerGlobal.prototype.orientation = function(x, y, z, xUp, yUp, zUp) {
	    var self = this;
	
	    // Stop right here if not using Web Audio.
	    if (!self.ctx || !self.ctx.listener) {
	      return self;
	    }
	
	    // Set the defaults for optional 'y' & 'z'.
	    var or = self._orientation;
	    y = (typeof y !== 'number') ? or[1] : y;
	    z = (typeof z !== 'number') ? or[2] : z;
	    xUp = (typeof xUp !== 'number') ? or[3] : xUp;
	    yUp = (typeof yUp !== 'number') ? or[4] : yUp;
	    zUp = (typeof zUp !== 'number') ? or[5] : zUp;
	
	    if (typeof x === 'number') {
	      self._orientation = [x, y, z, xUp, yUp, zUp];
	      self.ctx.listener.setOrientation(x, y, z, xUp, yUp, zUp);
	    } else {
	      return or;
	    }
	
	    return self;
	  };
	
	  /** Group Methods **/
	  /***************************************************************************/
	
	  /**
	   * Add new properties to the core init.
	   * @param  {Function} _super Core init method.
	   * @return {Howl}
	   */
	  Howl.prototype.init = (function(_super) {
	    return function(o) {
	      var self = this;
	
	      // Setup user-defined default properties.
	      self._orientation = o.orientation || [1, 0, 0];
	      self._stereo = o.stereo || null;
	      self._pos = o.pos || null;
	      self._pannerAttr = {
	        coneInnerAngle: typeof o.coneInnerAngle !== 'undefined' ? o.coneInnerAngle : 360,
	        coneOuterAngle: typeof o.coneOuterAngle !== 'undefined' ? o.coneOuterAngle : 360,
	        coneOuterGain: typeof o.coneOuterGain !== 'undefined' ? o.coneOuterGain : 0,
	        distanceModel: typeof o.distanceModel !== 'undefined' ? o.distanceModel : 'inverse',
	        maxDistance: typeof o.maxDistance !== 'undefined' ? o.maxDistance : 10000,
	        panningModel: typeof o.panningModel !== 'undefined' ? o.panningModel : 'HRTF',
	        refDistance: typeof o.refDistance !== 'undefined' ? o.refDistance : 1,
	        rolloffFactor: typeof o.rolloffFactor !== 'undefined' ? o.rolloffFactor : 1
	      };
	
	      // Setup event listeners.
	      self._onstereo = o.onstereo ? [{fn: o.onstereo}] : [];
	      self._onpos = o.onpos ? [{fn: o.onpos}] : [];
	      self._onorientation = o.onorientation ? [{fn: o.onorientation}] : [];
	
	      // Complete initilization with howler.js core's init function.
	      return _super.call(this, o);
	    };
	  })(Howl.prototype.init);
	
	  /**
	   * Get/set the stereo panning of the audio source for this sound or all in the group.
	   * @param  {Number} pan  A value of -1.0 is all the way left and 1.0 is all the way right.
	   * @param  {Number} id (optional) The sound ID. If none is passed, all in group will be updated.
	   * @return {Howl/Number}    Returns self or the current stereo panning value.
	   */
	  Howl.prototype.stereo = function(pan, id) {
	    var self = this;
	
	    // Stop right here if not using Web Audio.
	    if (!self._webAudio) {
	      return self;
	    }
	
	    // If the sound hasn't loaded, add it to the load queue to change stereo pan when capable.
	    if (self._state !== 'loaded') {
	      self._queue.push({
	        event: 'stereo',
	        action: function() {
	          self.stereo(pan, id);
	        }
	      });
	
	      return self;
	    }
	
	    // Check for PannerStereoNode support and fallback to PannerNode if it doesn't exist.
	    var pannerType = (typeof Howler.ctx.createStereoPanner === 'undefined') ? 'spatial' : 'stereo';
	
	    // Setup the group's stereo panning if no ID is passed.
	    if (typeof id === 'undefined') {
	      // Return the group's stereo panning if no parameters are passed.
	      if (typeof pan === 'number') {
	        self._stereo = pan;
	        self._pos = [pan, 0, 0];
	      } else {
	        return self._stereo;
	      }
	    }
	
	    // Change the streo panning of one or all sounds in group.
	    var ids = self._getSoundIds(id);
	    for (var i=0; i<ids.length; i++) {
	      // Get the sound.
	      var sound = self._soundById(ids[i]);
	
	      if (sound) {
	        if (typeof pan === 'number') {
	          sound._stereo = pan;
	          sound._pos = [pan, 0, 0];
	
	          if (sound._node) {
	            // If we are falling back, make sure the panningModel is equalpower.
	            sound._pannerAttr.panningModel = 'equalpower';
	
	            // Check if there is a panner setup and create a new one if not.
	            if (!sound._panner || !sound._panner.pan) {
	              setupPanner(sound, pannerType);
	            }
	
	            if (pannerType === 'spatial') {
	              sound._panner.setPosition(pan, 0, 0);
	            } else {
	              sound._panner.pan.value = pan;
	            }
	          }
	
	          self._emit('stereo', sound._id);
	        } else {
	          return sound._stereo;
	        }
	      }
	    }
	
	    return self;
	  };
	
	  /**
	   * Get/set the 3D spatial position of the audio source for this sound or
	   * all in the group. The most common usage is to set the 'x' position for
	   * left/right panning. Setting any value higher than 1.0 will begin to
	   * decrease the volume of the sound as it moves further away.
	   * @param  {Number} x  The x-position of the audio from -1000.0 to 1000.0.
	   * @param  {Number} y  The y-position of the audio from -1000.0 to 1000.0.
	   * @param  {Number} z  The z-position of the audio from -1000.0 to 1000.0.
	   * @param  {Number} id (optional) The sound ID. If none is passed, all in group will be updated.
	   * @return {Howl/Array}    Returns self or the current 3D spatial position: [x, y, z].
	   */
	  Howl.prototype.pos = function(x, y, z, id) {
	    var self = this;
	
	    // Stop right here if not using Web Audio.
	    if (!self._webAudio) {
	      return self;
	    }
	
	    // If the sound hasn't loaded, add it to the load queue to change position when capable.
	    if (self._state !== 'loaded') {
	      self._queue.push({
	        event: 'pos',
	        action: function() {
	          self.pos(x, y, z, id);
	        }
	      });
	
	      return self;
	    }
	
	    // Set the defaults for optional 'y' & 'z'.
	    y = (typeof y !== 'number') ? 0 : y;
	    z = (typeof z !== 'number') ? -0.5 : z;
	
	    // Setup the group's spatial position if no ID is passed.
	    if (typeof id === 'undefined') {
	      // Return the group's spatial position if no parameters are passed.
	      if (typeof x === 'number') {
	        self._pos = [x, y, z];
	      } else {
	        return self._pos;
	      }
	    }
	
	    // Change the spatial position of one or all sounds in group.
	    var ids = self._getSoundIds(id);
	    for (var i=0; i<ids.length; i++) {
	      // Get the sound.
	      var sound = self._soundById(ids[i]);
	
	      if (sound) {
	        if (typeof x === 'number') {
	          sound._pos = [x, y, z];
	
	          if (sound._node) {
	            // Check if there is a panner setup and create a new one if not.
	            if (!sound._panner || sound._panner.pan) {
	              setupPanner(sound, 'spatial');
	            }
	
	            sound._panner.setPosition(x, y, z);
	          }
	
	          self._emit('pos', sound._id);
	        } else {
	          return sound._pos;
	        }
	      }
	    }
	
	    return self;
	  };
	
	  /**
	   * Get/set the direction the audio source is pointing in the 3D cartesian coordinate
	   * space. Depending on how direction the sound is, based on the `cone` attributes,
	   * a sound pointing away from the listener can be quiet or silent.
	   * @param  {Number} x  The x-orientation of the source.
	   * @param  {Number} y  The y-orientation of the source.
	   * @param  {Number} z  The z-orientation of the source.
	   * @param  {Number} id (optional) The sound ID. If none is passed, all in group will be updated.
	   * @return {Howl/Array}    Returns self or the current 3D spatial orientation: [x, y, z].
	   */
	  Howl.prototype.orientation = function(x, y, z, id) {
	    var self = this;
	
	    // Stop right here if not using Web Audio.
	    if (!self._webAudio) {
	      return self;
	    }
	
	    // If the sound hasn't loaded, add it to the load queue to change orientation when capable.
	    if (self._state !== 'loaded') {
	      self._queue.push({
	        event: 'orientation',
	        action: function() {
	          self.orientation(x, y, z, id);
	        }
	      });
	
	      return self;
	    }
	
	    // Set the defaults for optional 'y' & 'z'.
	    y = (typeof y !== 'number') ? self._orientation[1] : y;
	    z = (typeof z !== 'number') ? self._orientation[2] : z;
	
	    // Setup the group's spatial orientation if no ID is passed.
	    if (typeof id === 'undefined') {
	      // Return the group's spatial orientation if no parameters are passed.
	      if (typeof x === 'number') {
	        self._orientation = [x, y, z];
	      } else {
	        return self._orientation;
	      }
	    }
	
	    // Change the spatial orientation of one or all sounds in group.
	    var ids = self._getSoundIds(id);
	    for (var i=0; i<ids.length; i++) {
	      // Get the sound.
	      var sound = self._soundById(ids[i]);
	
	      if (sound) {
	        if (typeof x === 'number') {
	          sound._orientation = [x, y, z];
	
	          if (sound._node) {
	            // Check if there is a panner setup and create a new one if not.
	            if (!sound._panner) {
	              // Make sure we have a position to setup the node with.
	              if (!sound._pos) {
	                sound._pos = self._pos || [0, 0, -0.5];
	              }
	
	              setupPanner(sound, 'spatial');
	            }
	
	            sound._panner.setOrientation(x, y, z);
	          }
	
	          self._emit('orientation', sound._id);
	        } else {
	          return sound._orientation;
	        }
	      }
	    }
	
	    return self;
	  };
	
	  /**
	   * Get/set the panner node's attributes for a sound or group of sounds.
	   * This method can optionall take 0, 1 or 2 arguments.
	   *   pannerAttr() -> Returns the group's values.
	   *   pannerAttr(id) -> Returns the sound id's values.
	   *   pannerAttr(o) -> Set's the values of all sounds in this Howl group.
	   *   pannerAttr(o, id) -> Set's the values of passed sound id.
	   *
	   *   Attributes:
	   *     coneInnerAngle - (360 by default) There will be no volume reduction inside this angle.
	   *     coneOuterAngle - (360 by default) The volume will be reduced to a constant value of
	   *                      `coneOuterGain` outside this angle.
	   *     coneOuterGain - (0 by default) The amount of volume reduction outside of `coneOuterAngle`.
	   *     distanceModel - ('inverse' by default) Determines algorithm to use to reduce volume as audio moves
	   *                      away from listener. Can be `linear`, `inverse` or `exponential`.
	   *     maxDistance - (10000 by default) Volume won't reduce between source/listener beyond this distance.
	   *     panningModel - ('HRTF' by default) Determines which spatialization algorithm is used to position audio.
	   *                     Can be `HRTF` or `equalpower`.
	   *     refDistance - (1 by default) A reference distance for reducing volume as the source
	   *                    moves away from the listener.
	   *     rolloffFactor - (1 by default) How quickly the volume reduces as source moves from listener.
	   * 
	   * @return {Howl/Object} Returns self or current panner attributes.
	   */
	  Howl.prototype.pannerAttr = function() {
	    var self = this;
	    var args = arguments;
	    var o, id, sound;
	
	    // Stop right here if not using Web Audio.
	    if (!self._webAudio) {
	      return self;
	    }
	
	    // Determine the values based on arguments.
	    if (args.length === 0) {
	      // Return the group's panner attribute values.
	      return self._pannerAttr;
	    } else if (args.length === 1) {
	      if (typeof args[0] === 'object') {
	        o = args[0];
	
	        // Set the grou's panner attribute values.
	        if (typeof id === 'undefined') {
	          self._pannerAttr = {
	            coneInnerAngle: typeof o.coneInnerAngle !== 'undefined' ? o.coneInnerAngle : self._coneInnerAngle,
	            coneOuterAngle: typeof o.coneOuterAngle !== 'undefined' ? o.coneOuterAngle : self._coneOuterAngle,
	            coneOuterGain: typeof o.coneOuterGain !== 'undefined' ? o.coneOuterGain : self._coneOuterGain,
	            distanceModel: typeof o.distanceModel !== 'undefined' ? o.distanceModel : self._distanceModel,
	            maxDistance: typeof o.maxDistance !== 'undefined' ? o.maxDistance : self._maxDistance,
	            panningModel: typeof o.panningModel !== 'undefined' ? o.panningModel : self._panningModel,
	            refDistance: typeof o.refDistance !== 'undefined' ? o.refDistance : self._refDistance,
	            rolloffFactor: typeof o.rolloffFactor !== 'undefined' ? o.rolloffFactor : self._rolloffFactor
	          };
	        }
	      } else {
	        // Return this sound's panner attribute values.
	        sound = self._soundById(parseInt(args[0], 10));
	        return sound ? sound._pannerAttr : self._pannerAttr;
	      }
	    } else if (args.length === 2) {
	      o = args[0];
	      id = parseInt(args[1], 10);
	    }
	
	    // Update the values of the specified sounds.
	    var ids = self._getSoundIds(id);
	    for (var i=0; i<ids.length; i++) {
	      sound = self._soundById(ids[i]);
	
	      if (sound) {
	        // Merge the new values into the sound.
	        var pa = sound._pannerAttr;
	        pa = {
	          coneInnerAngle: typeof o.coneInnerAngle !== 'undefined' ? o.coneInnerAngle : pa.coneInnerAngle,
	          coneOuterAngle: typeof o.coneOuterAngle !== 'undefined' ? o.coneOuterAngle : pa.coneOuterAngle,
	          coneOuterGain: typeof o.coneOuterGain !== 'undefined' ? o.coneOuterGain : pa.coneOuterGain,
	          distanceModel: typeof o.distanceModel !== 'undefined' ? o.distanceModel : pa.distanceModel,
	          maxDistance: typeof o.maxDistance !== 'undefined' ? o.maxDistance : pa.maxDistance,
	          panningModel: typeof o.panningModel !== 'undefined' ? o.panningModel : pa.panningModel,
	          refDistance: typeof o.refDistance !== 'undefined' ? o.refDistance : pa.refDistance,
	          rolloffFactor: typeof o.rolloffFactor !== 'undefined' ? o.rolloffFactor : pa.rolloffFactor
	        };
	
	        // Update the panner values or create a new panner if none exists.
	        var panner = sound._panner;
	        if (panner) {
	          panner.coneInnerAngle = pa.coneInnerAngle;
	          panner.coneOuterAngle = pa.coneOuterAngle;
	          panner.coneOuterGain = pa.coneOuterGain;
	          panner.distanceModel = pa.distanceModel;
	          panner.maxDistance = pa.maxDistance;
	          panner.panningModel = pa.panningModel;
	          panner.refDistance = pa.refDistance;
	          panner.rolloffFactor = pa.rolloffFactor;
	        } else {
	          // Make sure we have a position to setup the node with.
	          if (!sound._pos) {
	            sound._pos = self._pos || [0, 0, -0.5];
	          }
	
	          // Create a new panner node.
	          setupPanner(sound, 'spatial');
	        }
	      }
	    }
	
	    return self;
	  };
	
	  /** Single Sound Methods **/
	  /***************************************************************************/
	
	  /**
	   * Add new properties to the core Sound init.
	   * @param  {Function} _super Core Sound init method.
	   * @return {Sound}
	   */
	  Sound.prototype.init = (function(_super) {
	    return function() {
	      var self = this;
	      var parent = self._parent;
	
	      // Setup user-defined default properties.
	      self._orientation = parent._orientation;
	      self._stereo = parent._stereo;
	      self._pos = parent._pos;
	      self._pannerAttr = parent._pannerAttr;
	
	      // Complete initilization with howler.js core Sound's init function.
	      _super.call(this);
	
	      // If a stereo or position was specified, set it up.
	      if (self._stereo) {
	        parent.stereo(self._stereo);
	      } else if (self._pos) {
	        parent.pos(self._pos[0], self._pos[1], self._pos[2], self._id);
	      }
	    };
	  })(Sound.prototype.init);
	
	  /**
	   * Override the Sound.reset method to clean up properties from the spatial plugin.
	   * @param  {Function} _super Sound reset method.
	   * @return {Sound}
	   */
	  Sound.prototype.reset = (function(_super) {
	    return function() {
	      var self = this;
	      var parent = self._parent;
	
	      // Reset all spatial plugin properties on this sound.
	      self._orientation = parent._orientation;
	      self._pos = parent._pos;
	      self._pannerAttr = parent._pannerAttr;
	
	      // Complete resetting of the sound.
	      return _super.call(this);
	    };
	  })(Sound.prototype.reset);
	
	  /** Helper Methods **/
	  /***************************************************************************/
	
	  /**
	   * Create a new panner node and save it on the sound.
	   * @param  {Sound} sound Specific sound to setup panning on.
	   * @param {String} type Type of panner to create: 'stereo' or 'spatial'.
	   */
	  var setupPanner = function(sound, type) {
	    type = type || 'spatial';
	
	    // Create the new panner node.
	    if (type === 'spatial') {
	      sound._panner = Howler.ctx.createPanner();
	      sound._panner.coneInnerAngle = sound._pannerAttr.coneInnerAngle;
	      sound._panner.coneOuterAngle = sound._pannerAttr.coneOuterAngle;
	      sound._panner.coneOuterGain = sound._pannerAttr.coneOuterGain;
	      sound._panner.distanceModel = sound._pannerAttr.distanceModel;
	      sound._panner.maxDistance = sound._pannerAttr.maxDistance;
	      sound._panner.panningModel = sound._pannerAttr.panningModel;
	      sound._panner.refDistance = sound._pannerAttr.refDistance;
	      sound._panner.rolloffFactor = sound._pannerAttr.rolloffFactor;
	      sound._panner.setPosition(sound._pos[0], sound._pos[1], sound._pos[2]);
	      sound._panner.setOrientation(sound._orientation[0], sound._orientation[1], sound._orientation[2]);
	    } else {
	      sound._panner = Howler.ctx.createStereoPanner();
	      sound._panner.pan.value = sound._stereo;
	    }
	
	    sound._panner.connect(sound._node);
	
	    // Update the connections.
	    if (!sound._paused) {
	      sound._parent.pause(sound._id, true).play(sound._id);
	    }
	  };
	})();
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 3 */
/***/ function(module, exports) {

	
	
	
		
		var events = {},
			idRegistry = 9100;
		
		
		function Subscribe(event, func){
			if(!events.hasOwnProperty(event)){
				events[event] = [];
			}
			
			var eventID = ++idRegistry;
			
			events[event].push({
				
				id : eventID,
				handler : func
							   
				});
			
			return eventID;
	
		}
		
		function Publish(){
	        
	        
	        
	        var event = arguments[0],
	            data = arguments[1],
	            realOne = arguments[2];
			
	        
	        
				if(!events.hasOwnProperty(event)){
					return false;
				}
				
			var subs = events[event];
	
			for(var i = 0, j = subs.length; i<j; i++){
				
				subs[i].handler(event, data);
				
			}
			
		}
		
		function Unsubscribe(id){
			
			for(var event in events){
				if(events.hasOwnProperty(event)){
					for(var i = 0, j = events[event].length; i<j; i++){
						if(events[event][i].id === id){
							events[event].splice(i, 1);
							return id;
						}
					}
				}
			}
			
		}
	
	
	
	module.exports = {
	    
	    subscribe : Subscribe,
	    publish : Publish,
	    unsubscribe : Unsubscribe
	    
	};

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	var ResourceLoader = __webpack_require__(1),
	    Algorithms = __webpack_require__(5),
	    mainCanvas = document.getElementById('bgCanvas'),
	    PubSub = __webpack_require__(3),
	    centerX = mainCanvas.width / 2,
	    centerY = mainCanvas.height / 2;
	
	
	        inheritFrom(Display, Physics);
	        inheritFrom(Physics, Spacecraft);
	        inheritFrom(Display, Background);
	        //make custom classes inherit display class
	        inheritFrom(Physics, Missile);
	        inheritFrom(Display, Shield);
	        inheritFrom(Spacecraft, Ship);
	        inheritFrom(Display, Explosion);
	        inheritFrom(Spacecraft, Enemy);
	        inheritFrom(Physics, Rock);
	        inheritFrom(Spacecraft, Mothership);
	        inheritFrom(Physics, Perk);   
	    
	
	
	    //inheriter function
	    function inheritFrom(parent, child){
	        var copyOfParent = Object.create(parent.prototype);
	        copyOfParent.constructor = child;
	        child.prototype = copyOfParent;
	    }
	
	    //custom classes
		function Display(){
	       
			this.canvasWidth = 0;
			this.canvasHeight = 0;
			this.centerX = 0;
			this.centerY = 0;
			this.height = 0;
			this.width = 0;
			this.x = 0;
			this.y = 0;
			this.color = "#00FF00";
			this.alpha = 1;
	        this.alive = false;  
	        this.context = undefined;
	        this.type = "display";
	       
		}
	        //temp proto method....
	    Display.prototype.reset = function(){
				this.x = 0;
				this.y = 0;
				this.angle = 0;
				this.velX = 0;
				this.velY = 0;
				this.alive = false;
				this.colliding = false;
			};
	    
	    Display.prototype.setCanvas = function(canvas){
				this.context = canvas.getContext('2d');
				this.canvasWidth = canvas.width;
				this.canvasHeight = canvas.height;
			};
	    
	    Display.prototype.init = function(width, height){
				this.width = width || 20;
				this.height = height || 20;
				this.centerX = width/2;
				this.centerY = height/2;
				this.alive = false;
			};
	
	    function Physics(){
	        
	            Display.call(this);
	        
	        this.velX = 0;
	        this.velY = 0;
	        this.acelX = 0;
	        this.acelY = 0;
	        this.colliding = false;
	        this.speed = 0; 
	        this.thrust = 0;
	        this.angle = 0;
	    }
	    
	    Physics.prototype.spawn = function(x, y, angle, speed){
	        
	        this.x = x || centerX;
	        this.y = y || centerY;
	        this.colliding = false;
	        this.alive = true;
	        this.angle = angle || this.angle;
	        this.speed = speed || this.speed;
	        this.velX = Math.cos(this.angle)*this.speed;
	        this.velY = Math.sin(this.angle)*this.speed;
	        
	    };
	    
	    Physics.prototype.destroy = function(){
	        this.alive = false; 
	    };
	    
	    //spaceCraft function constructor 
	    function Spacecraft(){
	            
	           Physics.call(this);
	        
	        this.autoSpawn = false;
	        this.thrustAccel = 0.03;
	        this.alphaSpeed = 0.03;
	        this.shieldActive = false;
	        this.shieldDisabled = false;
			this.maxVelocity = 4;
	        this.missilesSpeed = 2.5;
			this.easeValue = 0.03;
			this.jumping = false;
	        
	    }
			
	    Spacecraft.prototype.init = function(width, height){
	        
	            Display.prototype.init.call(this, width, height);
	        
	        var shield = new Shield();
	            shield.setCanvas(mainCanvas);
	            shield.init(80,80);
			var missilePool = new Pool(10);
				missilePool.init('missile');
	            
	        var explosion = new Explosion(15);
	            explosion.setCanvas(mainCanvas);
	            
	            
	        this.explosion = explosion;
	        this.shield = shield;
	        this.missiles = missilePool;
	        
	    };    
		
	    Spacecraft.prototype.follow = function(object){
	        
				if(!object.alive || this.jumping){
					return;
				}	
				var dx, dy, distance, newVelX, newVelY, futureVel, direction;
				dx = object.x - this.x;
				dy = object.y - this.y;
				distance = Math.sqrt(dx*dx+dy*dy);
				direction = Math.atan2(dy, dx);
				this.angle = direction;
				
				if(distance>=140){
				newVelX = this.velX+Math.cos(this.angle)*this.thrustAccel;
				newVelY = this.velY+Math.sin(this.angle)*this.thrustAccel;	
				futureVel = Math.sqrt(newVelX*newVelX + newVelY*newVelY);	
						if(futureVel>1.5){
					newVelX = this.velX;
					newVelY = this.velY;
					}else{
					this.velX = newVelX;
					this.velY = newVelY;
					}
				}	
	    };
	    
	    Spacecraft.prototype.attack = function(object){
				if(Math.random() >= 0.005 || !this.alive || !object.alive){
					return;
				}
				this.shoot();
	    };
	    
	    Spacecraft.prototype.spawn = function(x, y, angle, speed){
	        
	            Physics.prototype.spawn.call(this, x, y, angle, speed);
	            this.missiles.hideItems();
	            //this.shield.reset();
				this.jumping = false;
	        
	    };
	    
	    Spacecraft.prototype.destroy = function(){
	        this.colliding = true;  
	        ResourceLoader.assets.explosionSound.play();
	    };
	
		Spacecraft.prototype.jump = function(){
			
			//if spacecraft is not jumping, have it face to the right and no Y velocity.
			if(!this.jumping){
				this.velY = this.angle = 0;
				this.velX = 1;
				this.jumping = true;
			}
			
		};
	
	    Spacecraft.prototype.draw = function(){
	        
	        //draws spacecraft launched missiles
	        for(var i=0; i<this.missiles.pool.length; i++){
	            var currentMissile = this.missiles.pool[i];   
	            if(currentMissile.alive){
	                currentMissile.draw();   
	            }
	        }
	        
	        if(this.colliding){	
	                //if spacecraft is colliding, create an explosion
	            this.explosion.create(this.x+this.centerX, this.y+this.centerY);
	            this.explosion.draw();
	                //once the explosion is not running, kill off spacecraft
	            if(!this.explosion.running){
	                this.alive = false;
	                this.colliding = false;
	                if(this.autoSpawn){
	                 this.spawn();   
	                }
	            }
	                //return while colliding
	            return;
	                    
	        }
	            //if shield is active draw it.
	        if(this.shield.active){
	                this.shield.x = this.x-this.shield.centerX+this.centerX;
	                this.shield.y = this.y-this.shield.centerY+this.centerY;
	                this.shield.draw();
	        }
			
			//if spacecraft is jumping, ease the spacecraft out.
			if(this.jumping && this.velX < 10){
				
				this.velX += this.velX*this.easeValue;
				
			}
			
			
	        
	    };
	    
	    Spacecraft.prototype.shoot = function(){
	        
	        //if instance is not alive, is colliding or not moving, it will NOT shoot
	        if(!this.alive || this.colliding || this.velX == 0){
	                return;
	        }
	
	        this.missiles.get(this.x+10, this.y+10, "missile", this.angle, this.missilesSpeed);
			
	    };
	    
	    //class for the rocks floating
	    function Rock(){
	        
	            Physics.call(this);
	        
	        this.size;
	        this.spriteAnimation = new SpriteAnimation();
	        this.spriteAnimation.setCanvas(mainCanvas);
	        this.explosion = new Explosion(7);
	        this.explosion.setCanvas(mainCanvas);
	        this.type = 'rock';
	    
	    }
	    
	    Rock.prototype.init = function(size){
	        
	          var spriteAnimationInfo,
	              largeRockSpeed = 0.5,
	              mediumRockSpeed = 1,
	              smallRockSpeed = 1.2,
	              randomAngle;
	        
	          this.sprite = ResourceLoader.assets.meteorSprite;
	            
	            size = size || "large";
	    
	            switch(size){
	                case "large":
	                    
	                    spriteAnimationInfo = {width:56,height:55, offsetX: 0, offsetY: 0, numCol:2, numRow:9,fps:60,speed:8,loop:false,from:0,to:17};
	                    this.spriteAnimation.init(spriteAnimationInfo);
	                    randomAngle = Math.random()*(Math.PI*2);
	                    Display.prototype.init.call(this, spriteAnimationInfo.width, spriteAnimationInfo.height);
	                    Physics.prototype.spawn.call(this, 0, 0, randomAngle, largeRockSpeed);
	                    this.alive = false;
	                    this.size = "large";
	                    this.type = "largeRock";
	                    
	                    break;
	                    
	                case "medium":
	                    
	                    spriteAnimationInfo = {width:44,height:44, numCol:3, numRow:6,fps:60,offsetX: 130, offsetY : 0, speed:12,loop:true,from:0,to:17};   
	                    this.spriteAnimation.init(spriteAnimationInfo);
	                    randomAngle = Math.random()*(Math.PI*2);
	                    Display.prototype.init.call(this, spriteAnimationInfo.width, spriteAnimationInfo.height);
	                    Physics.prototype.spawn.call(this, 0, 0, randomAngle, mediumRockSpeed);
	                    this.alive = false;
	                    this.size = "medium";
	                    this.type = "mediumRock";
	                    
	                    break;
	                    
	                case "small":
	                    
	                    spriteAnimationInfo = {width:33,height:33, numCol:3,offsetX: 290, offsetY: 0, numRow:6,fps:60,speed:15,loop:true,from:0,to:17};
	                    this.spriteAnimation.init(spriteAnimationInfo);
	                    randomAngle = Math.random()*(Math.PI*2);
	                    Display.prototype.init.call(this, spriteAnimationInfo.width, spriteAnimationInfo.height);
	                    Physics.prototype.spawn.call(this, 0, 0, randomAngle, smallRockSpeed);
	                    this.alive = false;
	                    this.size = "small";
	                    this.type = "smallRock";
	                    
	                    break;
	            }
	            
	    };
	    
	    Rock.prototype.draw = function(){
	            
				if(this.colliding){ 
	            //when object is colliding, creates and draws explosion
				this.explosion.create(this.x+this.centerX, this.y+this.centerY);
				this.explosion.draw();
	                this.destroy();
	
				     if(!this.explosion.running){
				     //once explosion is over, kills off object
	                    this.colliding = false;
	                    this.alive = false;
	                    }
	                // if the explosion is still running return to drawing the explosion
				     return;
				}
	            
	            this.x += this.velX;
	            this.y += this.velY;
	            
	            this.spriteAnimation.play(this.x, this.y, this.sprite);    
	            
	        };
	    
	    Rock.prototype.destroy = function(){
	        
	            if(this.colliding){
	                return;
	            }
	        
	            ResourceLoader.assets.meteorExplosionSound.play();
	            this.colliding = true;
	            
	            PubSub.publish('meteor_explosion', this);
	        
	    };    
	    
		function Background(){
	        
	            Display.call(this);
	        
	        this.velX = 0;
	        this.velY = 0;
			this.progressBarWidth = 400;
			this.progressBarHeight = 40;
		}
	    
	    Background.prototype.draw = function(){
	            this.x += this.velX;
				this.y += this.velY;
	            
	            this.context.drawImage(ResourceLoader.assets.backgroundSprite, 0,0,this.canvasWidth,this.canvasHeight,this.x-this.canvasWidth, this.y,this.canvasWidth,this.canvasHeight);	
	            this.context.drawImage(ResourceLoader.assets.backgroundSprite, 0,0,this.canvasWidth,this.canvasHeight,this.x,this.y,this.canvasWidth,this.canvasHeight);
				
				if(this.x>this.canvasWidth){
					this.x = 0;
				}	
	    };
	    
		function Ship(){
	        
	                Spacecraft.call(this);
	        
	            var shipSpriteInfo = {width:21,height:22, numCol:1, numRow:2,fps:60,speed:30,loop:false,from:0,to:0};
	        
	            this.thrust = false;
	            this.autoSpawn = true;
	            this.thrustAccel = 0.04;
	            this.missilesSpeed = 3.2;
	            this.spriteAnimation = new SpriteAnimation();
	            this.spriteAnimation.setCanvas(mainCanvas);
	            this.spriteAnimation.init(shipSpriteInfo); 
	            this.type = "humanShip";
	        
		}
	    
	    Ship.prototype.draw = function(){
	        
	           Spacecraft.prototype.draw.call(this);
	        
	        if(this.colliding){
	            return;   
	        }
	        
	                this.context.save();
	                this.alpha += this.alphaSpeed;
	                this.alpha = (this.alpha >= 1)? 1: this.alpha;
	                this.context.globalAlpha = this.alpha;
	                this.context.translate(this.x+10, this.y+10);	
	                this.context.rotate(this.angle);
	                this.x += this.velX;
	                this.y += this.velY;
	                if(this.thrust){
	                    this.spriteAnimation.startFrame = 1;
	                    this.spriteAnimation.finalFrame = 1;
	                    this.spriteAnimation.play(-this.centerX, -this.centerY, ResourceLoader.assets.playerSpriteSheet);
	                }else{
	                    //this.context.drawImage(shipSprite, 0, 0, this.width, this.height, -10,-10, this.width, this.height);
	                    this.spriteAnimation.startFrame = 0;
	                    this.spriteAnimation.finalFrame = 0;
	                    this.spriteAnimation.play(-this.centerX, -this.centerY, ResourceLoader.assets.playerSpriteSheet);
	                }
	                this.context.restore();
	    };
		
		Ship.prototype.shoot = function(){
			Spacecraft.prototype.shoot.call(this);
			ResourceLoader.assets.playerShootSound.play();
		};
	    
	    function Perk(){
	        
	            Physics.call(this);
	        
	        this.spriteAnimation = new SpriteAnimation(); 
	        this.spriteAnimation.setCanvas(mainCanvas);
	    
	        this.type = 'perk';    
	    }
	
	    Perk.prototype.draw = function(){
	        
	        if(!this.alive){
	            return;
	        }
	        
	        this.x += this.velX;
	        this.y += this.velY;
	        
	        this.spriteAnimation.play(this.x, this.y, ResourceLoader.assets.perkSprite);
	        
	    };
	
	    Perk.prototype.init = function(perk){
	            
	            var spriteInfo; 
	                
	            
	            switch(perk){
	                    
	                case "shield":
	                        spriteInfo = {width:18,height:19, numCol:1, numRow:2,fps:60,speed:1,loop:false,from:0,to:0};
	                        this.spriteAnimation.init(spriteInfo);
	                        Display.prototype.init.call(this, spriteInfo.width, spriteInfo.height);
	                        this.type = "shield";
	                    break;
	                    
	                case "life":
	                        spriteInfo = {width:18,height:19, numCol:1, numRow:2,fps:60,speed:1,loop:false,from:1,to:1};
	                        this.spriteAnimation.init(spriteInfo);
	                        Display.prototype.init.call(this, spriteInfo.width, spriteInfo.height);
	                        this.type = "life";
	                    break;
	            }
	    }; 
		
		Perk.prototype.destroy = function(){
			Physics.prototype.destroy.call(this);
			ResourceLoader.assets.perkSound.play();
		};        
	    //missle constructor
	    
		function Missile(){
	        
	            Physics.call(this);
	        
			this.speed = 3;
			this.life = 0;
			this.maxLife = 100;
	        this.type = "missile";
	
		}
	    
	    Missile.prototype.spawn = function(x, y, angle, speed){
	        Physics.prototype.spawn.call(this, x, y, angle, speed);  
	        this.life = 0;
	    };
	    
	    Missile.prototype.draw = function(){
	        
	        this.life++;
				if(this.life>=this.maxLife){
					this.life = 0;
					this.alive = false;
				}
				this.x += this.velX;
				this.y += this.velY;
				this.context.fillStyle = this.color;
				this.context.fillRect(this.x, this.y, this.width, this.height);
	    
	    };
	    
		function Enemy(){
	        
	            Spacecraft.call(this);
	        
			this.thrustAccel = 0.03;
	        this.type = "enemy";
	        
			
	        var spriteRandomIndex = Math.floor(Math.random()*4);
	        this.spriteAnimation = new SpriteAnimation();
	        this.spriteAnimation.setCanvas(mainCanvas);
	        var enemySpriteInfo = {width:23,height:21, numCol:1, numRow:4,fps:60,speed:30,loop:false,from:spriteRandomIndex,to:spriteRandomIndex};
	        this.spriteAnimation.init(enemySpriteInfo);
	    
		}
	    
	    Enemy.prototype.draw = function(){
	        
	                Spacecraft.prototype.draw.call(this);
	            
	            if(this.colliding || !this.alive){
	                return;   
	            }
	        
	                this.x += this.velX;
	                this.y += this.velY;
	                this.context.save();
	                this.context.translate(this.x+this.centerX, this.y+this.centerY);
	                this.context.rotate(this.angle);
	                this.spriteAnimation.play(-this.centerX, -this.centerX, ResourceLoader.assets.enemySpriteSheet);
	                this.context.restore();  
	                
	
	    };
	        
	    //mothership constructor
	    function Mothership(){
	        
	             Spacecraft.call(this);
	        
	        
	        this.hasReleasedShips = false;
	        this.spriteAnimation = new SpriteAnimation();
	        this.spriteAnimation.setCanvas(mainCanvas);
	        this.type = undefined;
	        this.missilesSpeed = 3;
	        this.alpha = 0;
	        this.alphaSpeed = 0.02;
	        this.numShips = 0;
	        this.type = "mothership";
	    
	    }
	    
	    Mothership.prototype.init = function(shipType){
	        
	            switch(shipType){
	                    
	                case "human":
	                    
	                 var spriteSheetInfo = {width:51,height:46, numCol:1, numRow:2,fps:60,speed:30,loop:false,from:0,to:0};
	                 var spriteIndex = Math.floor(Math.random()*spriteSheetInfo.to);
	                 spriteSheetInfo.from = spriteSheetInfo.to = spriteIndex;
	                 this.spriteAnimation.init(spriteSheetInfo);
	                 this.type = "human";
	                 this.width = spriteSheetInfo.width;
	                 this.height = spriteSheetInfo.height;
	                 this.centerX = this.width / 2;
	                 this.centerY = this.height / 2;
	                    Spacecraft.prototype.init.call(this, this.width, this.height);
	                    break;
	                    
	                case "alien":
	                    
	                var spriteSheetInfo = {width:51,height:46, numCol:4, numRow:2,fps:60,speed:30,loop:false,from:0,to:4};
	                var spriteIndex = Math.floor(Math.random()*spriteSheetInfo.to);
	                spriteSheetInfo.from = spriteSheetInfo.to = spriteIndex;
	                this.spriteAnimation.init(spriteSheetInfo);
	                this.type = "alien";
	                this.width = spriteSheetInfo.width;
	                this.height = spriteSheetInfo.height;
	                this.centerX = this.width / 2;
	                this.centerY = this.height / 2;
	                    Spacecraft.prototype.init.call(this, this.width, this.height);
	                    
	                    break;     
	            }
	            
	        };
	    
	    Mothership.prototype.setRelease = function(shipsPool, numShips, time){
	            
	            if(this.hasReleasedShips){
	                return;   
	            }
	            
	            //assigns number of ships to release
	            this.numShips = numShips;
	            this.shipsPool = shipsPool;
	            
	            //checks if time to release ships was passed in
	            time = (typeof time != "number")? 5000: time;
			
				var self = this;
			
				this.interval = window.setTimeout(function(){
					//release ships after the time has passed
					Mothership.prototype.releaseShips.call(self);
	                
				}, time);   
			
	        };
	    
	    Mothership.prototype.releaseShips = function(){
	       
	        console.log('ship release function has been called');
	            
	            this.hasReleasedShips = true;
	            this.shield.active = false;
	            
	
	            for(var i=0; i<this.numShips; i++){
	                    
	                var positionX = this.x + this.shipsPool.pool[i].width*i;
	                var positionY = this.y + this.shipsPool.pool[i].height*i;
	                this.shipsPool.get(positionX, positionY, 'enemy');
	                this.shipsPool.pool[i].shield.active = false;
	                        
	            } 
	                    
	            
	        };
	    
	    Mothership.prototype.destroy = function(){
			Spacecraft.prototype.destroy.call(this);
			window.clearTimeout(this.interval);
		};
	
	    Mothership.prototype.spawn = function(x, y, angle, speed){
	            
	            Spacecraft.prototype.spawn.call(this, x, y, angle, speed);
	            this.hasReleasedShips = false;
	            this.alpha = 0;
	            
	        };
	    
	    Mothership.prototype.draw = function(){
	            
	            Spacecraft.prototype.draw.call(this);
	        
	            if(this.colliding || !this.alive){
	                console.log('ships dead wont draw it');
	                return;
	                
	            }
	            this.x += this.velX;
	            this.y += this.velY;
	        
	        
	            this.context.save();
	            this.context.translate(this.x+this.centerX, this.y+this.centerY);
	            this.context.rotate(this.angle);
	            if(this.hasReleasedShips){
	                this.alpha -= this.alphaSpeed;   
	                this.alpha = (this.alpha <= 0)? 0: this.alpha; 
	                this.alive = (this.alpha <= 0)? false : true;
	            }else{
	            this.alpha += this.alphaSpeed;
	            this.alpha = (this.alpha >= 1)? 1: this.alpha;
	            }
	            this.context.globalAlpha = this.alpha;
	            this.spriteAnimation.play(-this.centerX, -this.centerY, ResourceLoader.assets.MothershipSpriteSheet);
	            this.context.restore();
	            
	            if(this.alpha <= 0){
	                this.alive = false;
	            } 
	        };
	    
	    // explosion constructor
		function Explosion(numParticles){
	        
	            Display.call(this);
	        
			this.running = false;
			this.particles = [];
			this.deadParticleCounter = 0;
			this.size = numParticles;
	        
			for(var i = 0; i<numParticles; i++){
				this.particles.push({x:0,y:0,alive:false,maxLife:0,velX:0,velY:0, width:2, height:2, life:0});
			}
				
		}
	    
	    Explosion.prototype.create = function(x, y){
	        if(this.running){
					return;
				}
				
				for(var i=0;i<this.size;i++){
					var currentParticle = this.particles[i];
					currentParticle.x = x;
					currentParticle.y = y;
					currentParticle.maxLife = Math.random()*45+15;
					currentParticle.velX = Math.random()*4-2.8;
					currentParticle.velY = Math.random()*4-2.8;
					currentParticle.alive = true;
					currentParticle.life = 0;
				}
				this.running = true;
				this.deadParticleCounter = 0;
	    };
	
	    Explosion.prototype.draw = function(){
	        
	        if(!this.running){
					return;
				}
				
				this.context.fillStyle = '#00FF00';
				for(var i=0; i<this.size; i++){
					var currentParticle = this.particles[i];
					if(currentParticle.alive){
					currentParticle.x += currentParticle.velX;
					currentParticle.y += currentParticle.velY;
					currentParticle.life++;
					this.context.fillRect(currentParticle.x, currentParticle.y, currentParticle.width, currentParticle.height);
	                        if(currentParticle.life >= currentParticle.maxLife){
	                        currentParticle.alive = false;
	                        currentParticle.life = 0;
	                        this.deadParticleCounter++;
	                    }
					}
					
				}
	//change the state from running to false by checking if there are any particles alive left
				if(this.deadParticleCounter>=this.size){
					this.running = false;
				}
	        
	    };
	    
	    //Shield constructor
		function Shield(){
	        
	            Display.call(this);
	        
			this.radius = 40;
			this.maxRadius = 45;
	        this.life = 100;
	        this.disabled = false;
	        this.color = '#0000FF';
	        this.type = 'shield';
	        var shieldState = false;
	    
	        Object.defineProperty(this, "active", {
	            get: function(){
	                
	                return shieldState;
	                
	            },
	            set: function(value){
	                
	                shieldState = (this.disabled)? false: value;
	                this.alive = shieldState;
	                
	            },
	            configurable: true,
	            enumerable: true
	        });
	        
	        
		}
	    
	    Shield.prototype.reduceLife = function(amount){
	        amount = (amount === undefined)? 50: amount;
	        this.life -= amount;
	    };
	    
	    Shield.prototype.draw = function(){
	        
	            if(!this.active){
	                console.log('shield is disabled');
	                return;
	            }
	            if(this.life <= 0){
	                this.life = 0;
	                this.disabled = true;
	                this.active = false;
	                    return;
	            }
				this.context.strokeStyle = this.color;
	            this.context.lineWidth = 1;
				this.context.beginPath(); 
				this.context.arc(this.x+this.centerX, this.y+this.centerY, this.radius, 0, Math.PI*2, true);
				this.context.closePath();
				this.context.stroke(); 
				this.radius += .25;
				this.radius = (this.radius>this.maxRadius)? 40: this.radius;
	        
	    };
	    
	    Shield.prototype.reset = function(){
	            this.life = 100;
	            this.disabled = false;
	    };
	    
	    //meteor pool
		function Pool(maxSize){
	        
			var pool = [];
	        
			this.pool = pool;
	        this.size = maxSize;
	        
		}
	    
	    Pool.prototype.init = function(type){
	            
	            switch(type){
	                case "missile":
	                    
	                  for(var i=0; i<this.size; i++){
						var missile = new Missile();
						missile.setCanvas(mainCanvas);
						missile.init(2,2);
						this.pool[i] = missile;
					}  
	                    break;
	                    
	                case "enemy":
	                   for(var j=0; j<this.size; j++){
	                    var randomX = Math.floor(Math.random()*mainCanvas.width);
	                    var randomY = Math.floor(Math.random()*mainCanvas.height);
	                    
	                    var enemy = new Enemy();
	                    enemy.setCanvas(mainCanvas);
	                    enemy.init(23, 21);
	                    enemy.x = randomX;
	                    enemy.y = randomY;
	
	                    this.pool[j] = enemy;
	                       
	                } 
	                    break;
	                    
	                case "perks":
	                    this.size = Math.floor(this.size / 2);
	
	                    for(var k=0; k<this.size; k++){
	                        var life = new Perk();
	                        life.setCanvas(mainCanvas);
	                        life.init("life");
	                        this.pool.push(life); 
	                    }
	
	                    for(var h=0; h<this.size; h++){
	                        var shield = new Perk();
	                        shield.setCanvas(mainCanvas);
	                        shield.init("shield");
	                        this.pool.push(shield);
	                    }
	                    
	                    this.size *= 2;
	                    
	                    break;
	                    
	                case "rocks":
	                    
	                    var numMediumRocks = this.size*2;
	                    var numSmallRocks = numMediumRocks*2;
	
	                        for(var l=0; l<this.size; l++){
	                            var meteor = new Rock();
	                            meteor.setCanvas(mainCanvas);
	                            meteor.init("large");
	                            meteor.type = "largeRock";
	                            this.pool.push(meteor);
	                        }
	                        for(var m=0; m<numMediumRocks; m++){
	                            var meteorMedium = new Rock();
	                            meteorMedium.setCanvas(mainCanvas);
	                            meteorMedium.init("medium");
	                            meteorMedium.type = "mediumRock";
	                            this.pool.push(meteorMedium);
	                        }
	                        for(var n=0; n<numSmallRocks; n++){
	                            var meteorSmall = new Rock();
	                            meteorSmall.setCanvas(mainCanvas);
	                            meteorSmall.init("small");
	                            meteorSmall.type = "smallRock";
	                            this.pool.push(meteorSmall);
	                        }
	                    
	                    this.size += (numMediumRocks+numSmallRocks);
	                    
	                    break;
	            }
	            
	    };
	    
	    Pool.prototype.get = function(x, y, type, angle, speed){
	        
	            type = type || "missile";
	        
	            /* code from before mixing both pools meteor and regular 
				if(!this.pool[size-1].alive){
					this.pool[size-1].spawn(x,y, angle, speed);
					this.pool.unshift(pool.pop());
				}
	            */
	            var i = 0;
	
	                while(i<this.size){
	                    if(this.pool[i].type === type && !this.pool[i].alive){
	                        this.pool[i].spawn(x, y, angle, speed);
	                        break;
	                    }
	                    i++;     
	                }
	        
	    };
	
	    Pool.prototype.isCollidingWith = function(args){
	            
	            var length = this.pool.length;
	            var argsLength = arguments.length;
	            
	            for(var i = 0; i<length; i++){
	                
	                var currentItem = this.pool[i];
	                
	                if(currentItem.alive){
	                
	                for(var h = 0; h<argsLength; h++){
	                    //each argument represents the objects being passed in to this method.
	                    var currentArgument = arguments[h];
						
						//if one of the arguments to check for collision is a pool of objects, iterate over each item.
						if(Array.isArray(currentArgument)){
							for(var j = 0, len = currentArgument.length; j < len; j++){
								var currentPoolItem = currentArgument[j];
								checkCollision(currentItem, currentPoolItem);
							}
						}else{
								checkCollision(currentItem, currentArgument);
						   }
	                }
	            }
	                
	        }
				//function in charge of testing for collision and executing what to do when there is a collision, it also makes a call to the recordCollision function which handles the recording of collisions for points and score.
				function checkCollision(item1, item2){
					
						if(Algorithms.hitTest(item1, item2)){
								if(item2 instanceof Shield){
									if(!(item1 instanceof Rock)){
											item1.destroy();
											item2.reduceLife(10);
											//recordCollision(item1.type);
	                                        PubSub.publish('collision', item1.type);
										}
									}else if(item1 instanceof Perk){
										item1.destroy();
										//recordCollision(item1.type);
	                                    PubSub.publish('collision', item1.type);
									}else{
										item2.destroy();
										item1.destroy();
										//recordCollision(item2.type);
	                                    PubSub.publish('collision', item2.type);
	                                    PubSub.publish('collision', item1.type);
										//recordCollision(item1.type);
									}
							}
	
				}
	    };
	    
	    Pool.prototype.hideItems  = function(){
	            var length = this.pool.length;
	            for(var i=0; i<length; i++){
	                this.pool[i].alive = false; 
	            }
	    };
	
	    function SpriteAnimation(){
			 
	        this.width;
	        this.height;
	        this.x;
	        this.y;
			this.offsetX = 0;
			this.offsetY = 0;
	        this.context;
	        this.canvasHeight;
	        this.canvasWidth;
	        this.speed;
	        this.numCol;
	        this.numRow;
	        this.currentFrame;
	        this.finalFrame;
	        this.startFrame;
	        this.totalFrames;
	        this.appFPS;
			 //spritesheet animations loops by default
	        this.loop = true;
			    //private members 
	     	this._frames = [];
	        this._frameIncrement;
	        this._frameIndex;
	
			 
		 }
		
	     SpriteAnimation.prototype.setCanvas = function(canvas){
	            this.context = canvas.getContext('2d');
	            this.canvasHeight = canvas.height;
	            this.canvasWidth = canvas.width;
	      };
		
	     SpriteAnimation.prototype.init = function(spriteObject){
	            
	            //sets up sprite properties from the spritesheet info object being passed in.
	            this.width = spriteObject.width || 32;
	            this.height = spriteObject.height || 32;
	            this.numCol = spriteObject.numCol || 1;
	            this.numRow = spriteObject.numRow || 1;
	            this.startFrame = spriteObject.from || 0;
	            this.finalFrame = spriteObject.to || 0;
	            this.speed = spriteObject.speed || 15;
			 	this.offsetX = spriteObject.offsetX || 0;
			 	this.offsetY = spriteObject.offsetY || 0;
	            this.totalFrames = spriteObject.numCol * spriteObject.numRow - 1;
	            this.loop = spriteObject.loop || true;
	            this.appFPS = spriteObject.fps;
	            
	            //creates the decimal of increment for each second
	            this._frameIncrement = this.speed/spriteObject.fps;
	            this._frameIndex = this.startFrame;        
	            
	            //creates a variable holding the length of the array holding the frames
	            var totalFramesLength = spriteObject.numCol * spriteObject.numRow;
	
	            for(var i = 0; i < totalFramesLength; i++){
	                var frame = {};
						frame.regX = this.offsetX;
						frame.regY = this.offsetY;
	            
	                frame.regX += (i % this.numCol)*this.width;
	                frame.regY += (i % this.numRow)*this.height;
	                
	                //pushes the objects with the regX and regY for each frame into a frame array.
	                this._frames.push(frame);
	                
	            }
	              
	        };
	        //use this method to locate or move the sprite sheet to a cordinate
	     SpriteAnimation.prototype.play = function(x, y, sprite){
	            this.x = x || 0;
	            this.y = y || 0;
	
	            //no animation will be playeed if the starting frame is equal to the final frame.
	            if(this.startFrame === this.finalFrame){
					
		//surrounds the sprite into a white block for debugging purposes, you can remove this in your final app
	                //this.context.strokeStyle = '#FFFFFF';
	                //this.context.strokeRect(this.x, this.y, this.width, this.height);
	               
	                this.currentFrame = this._frames[this.startFrame];
	                this.context.drawImage(sprite, this.currentFrame.regX, this.currentFrame.regY, this.width, this.height, this.x, this.y, this.width, this.height);
	                
	            }else{
	                //increments the frameIndex by a decimal, this will be floored because it is used to find an item in the frame array.
	                this._frameIndex += this._frameIncrement;
	                
	                if(this._frameIndex >= this.finalFrame + 1){
	                    this._frameIndex = (this.loop)? this.startFrame: this.finalFrame;
	                }
	                //floors the current index to a whole number so to find an object in the frame array
	                this.currentFrame = this._frames[Math.floor(this._frameIndex)];
	                //surrounds the sprite into a white block for debugging purposes, you can remove this in your final app
	                //this.context.strokeStyle = '#FFFFFF';
	                //this.context.strokeRect(this.x, this.y, this.width, this.height);
	                //draws the section of the image given the regX and regY as well as the width and height
	                this.context.drawImage(sprite, this.currentFrame.regX, this.currentFrame.regY, this.width, this.height, this.x, this.y, this.width, this.height); 
	            } 
	        };
	        //use this method to change the fps speed of your sprite sheet animation
	     SpriteAnimation.prototype.setSpeed = function(speed){
	            //reason why a method for this is needed is because there is  math to be done when speed is changed.
	          this.speed = speed || this.speed;
	            this._frameIncrement = this.speed / this.appFPS;
	            this._frameIndex = this.startFrame;   
	        }; 
		
	     SpriteAnimation.prototype.getFrame = function(frameIndex){
	            this._frameIndex = (frameIndex == undefined)? 0: frameIndex;
	            return this._frames[this._frameIndex];
	        };
	    
	module.exports = {
	    
	    Display : Display,
	    Phyiscs : Physics,
	    Spacecraft : Spacecraft,
	    Rock : Rock,
	    Background : Background,
	    Ship : Ship,
	    Perk : Perk,
	    Missile : Missile,
	    Enemy : Enemy,
	    Mothership : Mothership,
	    Explosion : Explosion,
	    Shield : Shield,
	    Pool : Pool,
	    SpriteAnimation : SpriteAnimation
	    
	};

/***/ },
/* 5 */
/***/ function(module, exports) {

	//checks if an object has left the canvas bouding box
	function checkBoundary(object){
	
			if(object.x >= object.canvasWidth){
				object.x = 0;
			}else if(object.x <= -object.width){
				object.x = object.canvasWidth-object.width;
			}else if(object.y >= object.canvasHeight+object.height){
				object.y = 0;
			}else if(object.y <= -object.height){
				object.y = object.canvasHeight-object.height;
			}	
		}
		
		//collision detection.
	function hitTest(object1, object2){
	   		var left1 = object1.x;
	   		var left2 = object2.x;
	   		var right1 = object1.x + object1.width;
	   		var right2 = object2.x + object2.width;
	   		var top1 = object1.y;
	   		var top2 = object2.y;
	   		var bottom1 = object1.y + object1.height;
	   		var bottom2 = object2.y + object2.height;
	
	   		if (bottom1 < top2) return(false);
	   		if (top1 > bottom2) return(false);
	   		if (right1 < left2) return(false);
	   		if (left1 > right2) return(false);
	        if (!object1.alive || object1.colliding || object2.colliding || !object2.alive) return(false);
	        
	        if (object1.type == "humanShip" && object1.velX == 0) return(false);
	        if (object2.type == "humanShip" && object2.velX == 0) return(false);
	        
	        if(object2.hasOwnProperty('shield')){
	            if(object2.shield.active){
	                return (false);
	            }
	        }
	        if(object1.hasOwnProperty('shield')){
	            if(object1.shield.active){
	                return (false);
	            }
	        }
	        
	
	        //otherwise return true 
	   		return(true);
	
		}
	
	
	module.exports = {
	    
	    checkBoundary : checkBoundary,
	    hitTest : hitTest
	    
	};

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	var PubSub = __webpack_require__(3),
	
		//state dictionary given property names for each state. 
	    state = {
	        loading: 0,
	        storyLine : 1,
		    titleScreen : 2,
	        gamePlay : 3,
	        levelTransition : 4,
	        beatGame : 5,
	        gameOver : 6,
	        credits : 7,
	        howToPlay : 8,
	        onPause : 9,
	        shipJump : 10,
	        setUpLevel: 11,
	
	        current : -1 
	    };
	
	function init(){
	    
	    if(this.hasInitialized) return this;
	     
	    this.hasInitialized = true;
	    this.pages = document.getElementsByClassName('appPage');
	    this.interface = document.getElementById('interfaceWrapper');
	    this.counters = document.getElementsByClassName('counter');
	    this.subId = PubSub.subscribe('statechange', handleStateChange.bind(this));
	    //Adds mousedown event listener to the div containing all the app pages
		this.interface.addEventListener('mousedown', handleClick);
	    
	    return this;
	    
	}
	
	function handleClick(event){
	    
	    var button = event.target,
	        from = button.getAttribute('data-from'),
	        to = button.getAttribute('data-to');
	    
		//if the element that triggered event has data-to and from attributes, trigger event.
	    if(from && to){
	         PubSub.publish('statechange', {from: state[from], to: state[to]});   
	    }
	    
	}
	
	function updateCounters(counter, value){
	    
		//if the counter exists update its value.
		if(this.counters[counter]){
	
			 this.counters[counter].innerHTML = value;
			
		}
	   
	    
	    return this;
	    
	}
	
	function show(pageName){
		
	    //if the page exists show it. 
	    if(this.pages[pageName]){
	        
	        this.pages[pageName].setAttribute('style', 'display: block;');
	        
	    }
	    
	    return this;
	    
	}
	
	function hide(pageName){
	    
		//if the page is defined, hide it. 
	    if(this.pages[pageName]){
	        
	        this.pages[pageName].setAttribute('style', 'display: none;');
	        
	    }
	    
	    return this;
	    
	}
	
	function hideAll(){
	    
	    var self = this;
		
	 	//delegates the forEach array method to iterate and hide each page.
	    [].forEach.call(this.pages, function(curretPage, index){
	       
			//calls the module hide method with the current context.
	        hide.call(self, index);
	        
	    });
	    
	    return self;
	    
	}
	
	
	function handleStateChange(event, data){
	    
		//hides away current state page and shows new state page.
	    hide.call(this, data.from);
	    show.call(this, data.to);
	    
	}
	
	module.exports = {
	    
	    init : init,
	    show : show,
	    hide : hide,
	    hideAll : hideAll,
	    hasInitialized : false,
	    updateCounter : updateCounters
	    
	    
	};

/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	var ResourceLoader = __webpack_require__(1),
	    keyboardControl = __webpack_require__(8),
	    Constructors = __webpack_require__(4),
	    PubSub = __webpack_require__(3),
	    UIController = __webpack_require__(6),
	    Algorithms = __webpack_require__(5),
	    mainCanvas = document.getElementById('bgCanvas'),
	    mainContext = mainCanvas.getContext('2d')
	    mouse = {x: 200, y:200},
	    centerX = mainCanvas.width / 2,
	    centerY = mainCanvas.height / 2,
	    FRAME_RATE = 1000/60,
	    
	    state = {
	        INIT : -1,
	        LOADING: 0,
	        STORY_LINE : 1,
		    TITLE_SCREEN : 2,
	        GAME_PLAY : 3,
	        LEVEL_TRANSITION : 4,
	        BEAT_GAME : 5,
	        GAME_OVER : 6,
	        CREDITS : 7,
	        HOW_TO_PLAY : 8,
	        PAUSED : 9,
	        SHIP_JUMP : 10,
	        SET_UP_LEVEL: 11,
	
	        CURRENT : -1 
	    },
	    
	    stateHandlers = {},
	    
	    loopOn = false;  
	
	    var totalEnemies = 8,
	        totalRocks = 10,
	        levelRocks = 5,
	        levelEnemies = 8,
	        levelPerks = 4,
	        enemiesKilled = 0
	        currentScore = 0,
	        shipLives = 4,
	        rocksDestroyed = 0,
	        currentLevel = 0,
	        lastLevel = 14;
	
		//TEMP: player instance and enemies
	    var playerShip,
		    alienMothership,
	        humanMothership,
		    background;
	
	     //pools holding enemies and rocks
	    var enemyShipsPool,
	        humanShipsPool,
	        perksPool,
	        meteorPool;   
	
	function init(){
	        
	        var self = this;
	    
	        attachStateHandlers();
	    
	        playerShip = new Constructors.Ship();
		    alienMothership = new Constructors.Mothership();
	        humanMothership = new Constructors.Mothership();
		    background = new Constructors.Background();
	
	     //pools holding enemies and rocks
	        enemyShipsPool = new Constructors.Pool(totalEnemies);
	        humanShipsPool = new Constructors.Pool(10);
	        perksPool = new Constructors.Pool(10);
	        meteorPool = new Constructors.Pool(totalRocks);   
	
	        background.setCanvas(mainCanvas);
			background.init(1000, 480);
			background.velX = 1;
	        
	        perksPool.init("perks");
	        meteorPool.init("rocks");
	        enemyShipsPool.init('enemy');
	        
	        alienMothership.setCanvas(mainCanvas);
	        alienMothership.init('alien');
	
	        playerShip.setCanvas(mainCanvas);
	        playerShip.init(23, 23);
	        playerShip.spawn(centerX, centerY);
	        
	        window.addEventListener('mousemove', onMouseMove, false);
	        
	        //add game control for desktop based on keyboard events
	        keyboardControl.init(playerShip);
	    
	        
	        //sign up for subscriptions
	        var subID1 = PubSub.subscribe('statechange', handleStateChange.bind(self));
	        var subID2 = PubSub.subscribe('meteor_explosion', handleMeteorExplosion.bind(self));
	        var subID3 = PubSub.subscribe('collision', recordCollision.bind(self));
	    
		window.alienMothership = alienMothership;
		window.playerShip = playerShip;
	    
	}
	
	
	function onMouseMove(e){
	    
	    
	    
	    
	}
	
	
	//function in charged of setting up the enemies and rocks in the new level given the current level
	function handleSetUpLevel(){
	    
	        
	        
	        console.log('Set Up Level function CALLED');
	        
	        //sets up random location for rocks and mothership
	            var randomX, randomY;
	        
	        //increases level by 1
	        currentLevel += 1;
	        
	        //checks if game is over
	        if(currentLevel > lastLevel){
	            userBeatGame = true;
	            PubSub.publish('statechange', {from: state.CURRENT, to: state.BEAT_GAME});
	            return;
	        }
	           
	        if(currentLevel == lastLevel){
	            ResourceLoader.assets.lastLevelSound.play();
	        }else{
	            //begins normal soundtrack 
			   ResourceLoader.assets.soundTrack.play();
	        }
			
	        //resets enemy killed and rocks destroyed counter and ship lives
	        enemiesKilled = 0;
	        rocksDestroyed = 0;
	    
	        if(currentLevel == 1){
	            shipLives = 4;
	        }
	        //sets up number of rocks and enemies that will be displayed
	        levelEnemies = currentLevel+1;
	        levelRocks = currentLevel+2;
	        
	        //checks to see if the level rocks and enemies exceed total in pool.
	        levelEnemies = (levelEnemies>=totalEnemies)? totalEnemies : levelEnemies;
	        levelRocks = (levelRocks>=totalRocks)? totalRocks : levelRocks;
	        
	        //centers ship and hide all of its missiles
	        playerShip.spawn(centerX, centerY);
	        
	        //kill off any alive rocks and enemies
	        perksPool.hideItems();
	        enemyShipsPool.hideItems();
	        meteorPool.hideItems();
	        
	        //inits the rocks
	        for(var i=0; i<levelRocks; i++){
	            randomX = Math.floor(Math.random()*(mainCanvas.width-50)),
	            randomY = Math.floor(Math.random()*(mainCanvas.height-50));
	            meteorPool.get(randomX, randomY, "largeRock");
	            meteorPool.get(randomX, randomY, "smallRock");
	        }
	        
	        for(var h=0; h<levelPerks; h++){
	            randomX = Math.floor(Math.random()*(mainCanvas.width-50)),
	            randomY = Math.floor(Math.random()*(mainCanvas.height-50));
	            perksPool.get(randomX, randomY, "life");
	            perksPool.get(randomY, randomX, "shield");
	        }
	    
	        //alienMothership.init("alien");
	        alienMothership.spawn(randomX, randomY);
	        alienMothership.shield.active = true;
	        alienMothership.setRelease(enemyShipsPool, levelEnemies, 8000);
	        
	        //updateCounter('level');
	        //updateCounter('life');
	        //updateCounter('score');
	    
	        UIController.updateCounter('level', currentLevel);
	        UIController.updateCounter('lives', shipLives);
	        UIController.updateCounter('score', currentScore);
	        
	        PubSub.publish('statechange', {from: state.SET_UP_LEVEL, to: state.GAME_PLAY});
	    
	}
	
	function attachStateHandlers(){
	    
	    stateHandlers[state.LOADING] = handleLoading;
	    stateHandlers[state.STORY_LINE] = handleStoryLine;
	    stateHandlers[state.TITLE_SCREEN] = handleTitleScreen;
	    stateHandlers[state.SET_UP_LEVEL] = handleSetUpLevel;
	    stateHandlers[state.GAME_PLAY] = handleGamePlay;
	    stateHandlers[state.SHIP_JUMP] = handleShipJump;
	    stateHandlers[state.LEVEL_TRANSITION] = handleLevelTransition;
	    stateHandlers[state.BEAT_GAME] = handleBeatGame;
	    stateHandlers[state.GAME_OVER] = handleGameOver;
	    stateHandlers[state.CREDITS] = handleCredits;
	    stateHandlers[state.HOW_TO_PLAY] = handleHowToPlay;
	    stateHandlers[state.PAUSED] = handlePause;
	        
	}
	
	function handleLoading(){
	    //do nothing   
	}
	
	function handleStoryLine(){
	
	    if(!loopOn){
	     
	        loopOn = true;
	        gameLoop();
	        
	    }
	    
	    background.draw();
	    
	}
	
	function handleTitleScreen(){
	    
	    if(!loopOn){
	        
	        loopOn = true;
	        gameLoop();
	        
	    }
	    
	    background.draw();
	    mainContext.drawImage(ResourceLoader.assets.earthSprite, (mainCanvas.width/2-(ResourceLoader.assets.earthSprite.width/2)), 0);
	        
	        for(var i=0; i<7; i++){
	            var currentEnemy = enemyShipsPool.pool[i];
	            currentEnemy.draw();
	            currentEnemy.follow(mouse);
	            Algorithms.checkBoundary(currentEnemy);
	        }
	    
	}
	
	function handleGamePlay(){
	    
	    if(!loopOn){
	        
	        ResourceLoader.assets.soundTrack.play();
	        loopOn = true;
	        gameLoop();
	           
	    }
	    
	     background.draw();
	
	        if(alienMothership.alive){
	            alienMothership.draw();
	            Algorithms.checkBoundary(alienMothership);
	            alienMothership.follow(playerShip);
	            alienMothership.attack(playerShip);
	            alienMothership.missiles.isCollidingWith(playerShip, playerShip.shield);
	            playerShip.missiles.isCollidingWith(alienMothership, alienMothership.shield);
	        }
	
	            for(var m=0; m<perksPool.pool.length; m++){
	                    var currentPerk = perksPool.pool[m];
	                    if(currentPerk.alive){
	                        currentPerk.draw(); 
	                        
	                        if(Algorithms.hitTest(currentPerk, playerShip)){
	                            console.log('DETECTION CONFIRMED!!');
	                            console.log(currentPerk);
	                            console.log(playerShip);
	                            currentPerk.destroy();
	                            PubSub.publish('collision', currentPerk.type);
	                        }
	                    }
	                }
	        
	        for(var i = 0; i<meteorPool.pool.length; i++){
	           
	            var currentMeteor = meteorPool.pool[i];
	            
	            if(currentMeteor.alive){
	                currentMeteor.draw();
	                Algorithms.checkBoundary(currentMeteor);
	                playerShip.missiles.isCollidingWith(currentMeteor);
	            }
	        }
	        
	        meteorPool.isCollidingWith(playerShip, playerShip.shield);
	        
	        for(var h = 0; h<enemyShipsPool.pool.length; h++){
	            
	            var currentEnemy = enemyShipsPool.pool[h];
	            
	            if(currentEnemy.alive){
	                
	                currentEnemy.draw();
	                Algorithms.checkBoundary(currentEnemy);
	                currentEnemy.follow(playerShip);
	                currentEnemy.attack(playerShip);
	                currentEnemy.missiles.isCollidingWith(playerShip, playerShip.shield, meteorPool.pool);
	                playerShip.missiles.isCollidingWith(currentEnemy, currentEnemy.shield);
	                
	                if(Algorithms.hitTest(currentEnemy, playerShip)){
	                    
	                    currentEnemy.destroy();
	                    playerShip.destroy();
	                    PubSub.publish('collision', currentEnemy.type);
	                    PubSub.publish('collision', playerShip.type);
	                    
	                }
	                
	            }
	            
	        }
	    
	        //check frames
			
	        if(playerShip.alive){
				keyboardControl.update();
	            Algorithms.checkBoundary(playerShip);
	            playerShip.draw();
	        }
	        
	        
	        if(shipLives <= 0 && !playerShip.colliding && state.CURRENT == state.GAME_PLAY){
	            
	                    if(currentLevel == lastLevel){
							ResourceLoader.assets.lastLevelSound.stop();
						}else{
							ResourceLoader.assets.soundTrack.stop(); 
						}
	                
	                PubSub.publish('statechange', {from: state.GAME_PLAY, to: state.GAME_OVER});
	            
	                currentLevel = 0;
	            
	        }else if(levelEnemies <= 0 && !playerShip.colliding && playerShip.alive && state.CURRENT == state.GAME_PLAY){
	            
	                    if(currentLevel == lastLevel){
							ResourceLoader.assets.lastLevelSound.stop();
						}else{
							ResourceLoader.assets.soundTrack.stop(); 
						}
	            
	            PubSub.publish('statechange', {from: state.GAME_PLAY, to: state.SHIP_JUMP});
	
	        }
	    
	}
	
	function handleLevelTransition(){
	    
	    if(loopOn){
	     
	        loopOn = false;
	        gameLoop();
	
	    }
	
	    
	    UIController.updateCounter('reportScore', currentScore);
	    UIController.updateCounter('reportCarnage', enemiesKilled);   
	    UIController.updateCounter('reportAsteroids', rocksDestroyed);
	
	    
	}
	
	function handleMeteorExplosion(event, meteor){
	    
	    
	            switch(meteor.size){
	                case "large":
	                meteorPool.get(meteor.x, meteor.y, "mediumRock");
	                meteorPool.get(meteor.x, meteor.y, "mediumRock");
	                    break;
	                case "medium":
	                meteorPool.get(meteor.x, meteor.y, "smallRock");
	                meteorPool.get(meteor.x, meteor.y, "smallRock");
	                    break;
	                case "small":
	                    //no rocks
	                    break;     
	            } 
	    
	}
	
	function handleShipJump(){
	    
	    if(!loopOn){
	        
	        loopOn = true;
	        gameLoop();
	        
	    }
	    
	    
	    //draw background
	        background.draw();
	        
	        //drawRemaining rocks
	        for(var k=0; k<meteorPool.pool.length; k++){
	            var currentRock = meteorPool.pool[k];
	            
	            //if rock alive draw it
	            if(currentRock.alive){
	                Algorithms.checkBoundary(currentRock);
	                currentRock.draw();
	            }
	        }
	        
	        enemyShipsPool.pool.forEach(function(enemy){
	            if(enemy.alive){
	                enemy.draw();
	            }
	        });
	        
			playerShip.jump();
	        playerShip.draw();
	        
	        
	        if(playerShip.x >= 1020-playerShip.width){ 
	            
	            PubSub.publish('statechange', {from: state.SHIP_JUMP, to: state.LEVEL_TRANSITION});
	            
	        }
	    
	}
	
	function handlePause(){
	 
	    ResourceLoader.assets.soundTrack.pause();
	    ResourceLoader.assets.lastLevelSound.pause();
	    loopOn = false;
	    
	}
	
	function handleBeatGame(){
	    
	        if(loopOn){
	            
	            loopOn = false;
	            
	        }
			
	        //outputs the final score to the winner gamer :)
	        //ResourceLoader.finalLevelSound.stop();       
	        //beatGameScore.innerHTML = "Your Score: "+currentScore;
	    
	        UIController.updateCounter('beatGameScore', currentScore);
	        userBeatGame = false;
	                
	        ResourceLoader.assets.victorySound.play();
	        
	        //resets that score
	        currentScore = 0;
	        currentLevel = 0;
	       
	}
	
	function handleGameOver(){
	    
	        if(loopOn){
	         
	            loopOn = false;
	            
	        }
	        
	        //checks to see which sound to stop playing given the level the user was before dying
			ResourceLoader.assets.gameOverSound.play();
	        
	        //resets the score and level
	        currentLevel = 0;
	        currentScore = 0;
	    
	}
	
	function recordCollision(event, objectType){
	    
	        switch(objectType){
	            case "largeRock":
	                currentScore += 20;
	                UIController.updateCounter('score', currentScore);
	                rocksDestroyed++;
	                break;
	                
	            case "mediumRock":
	                currentScore += 10;
	                UIController.updateCounter('score', currentScore);
	                rocksDestroyed++;
	                break;
	                
	            case "smallRock":
	                currentScore += 5;
	                UIController.updateCounter('score', currentScore);
	                rocksDestroyed++;
	                break;
	                
	            case "humanShip":
	                shipLives--;
	                currentScore -= 50;
	                UIController.updateCounter('score', currentScore);
	                UIController.updateCounter('lives', shipLives);
	                break;
	                
	            case "enemy":
	                currentScore += 50;
	                UIController.updateCounter('score', currentScore);
	                levelEnemies--;
	                enemiesKilled++;
	                break;
	                
	            case "life":
	                shipLives++;
	                UIController.updateCounter('lives', shipLives);
	                break;
	                
	            case "shield":
	                playerShip.shield.reset();
	                break;
	            case "cash":
	                break;
	        }
	        
	}
	
	function handleCredits(){
	    
		if(loopOn){
			loopOn = false;
		}
	    
	    
	}
	
	function handleHowToPlay(){
	    
		if(loopOn){
			loopOn = false;
		}
	    
	    
	}
	
	function handleStateChange(event, data){
	    
	    state.CURRENT = data.to;
	    
	    runState(data.to);
	    
	    
	}
	
	function runState(state){
	    
	     stateHandlers[state]();
	    
	}
	    
	function gameLoop(){
	    
	    if(loopOn){
	     
			requestAnimFrame(gameLoop, FRAME_RATE);
				
			runState(state.CURRENT);
			
			console.log('game loop running');
			
			
			}
	}
	
	module.exports = {
	    
	    init : init
	    
	};

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	
	var PubSub = __webpack_require__(3);
	
	var keyboardControl = function(){
		
		//control keys
		const UP_ARROW = 38,
			LEFT_ARROW = 37,
			RIGHT_ARROW = 39,
			DOWN_ARROW = 40,
			X_KEY = 88,
			SPACE_BAR = 32,
			LETTER_P = 80,
	          
	        state = {
	            INIT : -1,
	            LOADING: 0,
	            STORY_LINE : 1,
	            TITLE_SCREEN : 2,
	            GAME_PLAY : 3,
	            LEVEL_TRANSITION : 4,
	            BEAT_GAME : 5,
	            GAME_OVER : 6,
	            CREDITS : 7,
	            HOW_TO_PLAY : 8,
	            PAUSED : 9,
	            SHIP_JUMP : 10,
	            SET_UP_LEVEL: 11,
	
	            CURRENT : -1 
	    };
		
		//array of active and deactive keys
		var keyPressList = [],
			objects = [],
			initialized = false,
			inGamePlay = false;
		
		function init(objectsToControl){
			
			//pushes the elements to be manipulated by the keyword keys
			if(!objects.length){
				for(element in arguments){
					objects.push(arguments[element]);
				}
			}
		
			document.addEventListener('keyup', onKeyUp, false);
			document.addEventListener('keydown', onKeyDown, false);
			initialized = true;
			console.log('Keyword Control Module Initialized');
	        PubSub.subscribe('statechange', handleStateChange);
			
		}
		
		function handleStateChange(event, data){
			state.CURRENT = data.to;
		}
		
		function onKeyUp(e){
	        
			if(!initialized) return(console.log('Keyword Module has not been initialized...'));
			e.preventDefault();
			keyPressList[e.keyCode] = false;
	        
	        if(keyPressList[LETTER_P] == false && state.CURRENT === state.PAUSED){
					keyPressList[LETTER_P] = true;
	                PubSub.publish('statechange', {from: state.PAUSED, to: state.GAME_PLAY});
					console.log('Letter P has been pressed');
	
				}
	        
		}
		
		function onKeyDown(e){
			if(!initialized) return(console.log('Keyword Module has not been initialized...'));
			e.preventDefault();
			keyPressList[e.keyCode] = true; 
		}
		
		function runKeys(){
	        
			var length = objects.length;
			
			for(var i = 0; i<length; i++){
				
				var object = objects[i];
				
				if(keyPressList[LEFT_ARROW]){
					object.angle -= 5*Math.PI/180;
				}else if(keyPressList[RIGHT_ARROW]){
					object.angle += 5*Math.PI/180;
				}
				if(keyPressList[UP_ARROW]){
					object.thrust = true;
					var faceX = Math.cos(object.angle);
					var faceY = Math.sin(object.angle);
					var newVelX = object.velX+faceX*object.thrustAccel;
					var newVelY = object.velY+faceY*object.thrustAccel;
	
					var futureVelocity = Math.sqrt((newVelX*newVelX)+(newVelY*newVelY));
	
					if(futureVelocity > object.maxVelocity){
						newVelX = object.velX;
						newVelY = object.velY;
					}
	
					object.velX = newVelX;
					object.velY = newVelY;	
	
				}else{
					object.thrust = false;
				}
				if(keyPressList[SPACE_BAR] == false){                
					keyPressList[SPACE_BAR] = true;
					if(!object.shield.active){
					object.shoot();
					}				
				}
				if(keyPressList[X_KEY]){
					object.shield.active = true;
	
				}else if(keyPressList[X_KEY] == false){
					object.shield.active = false;
				}
				if(keyPressList[LETTER_P] == false){
					keyPressList[LETTER_P] = true;
	                PubSub.publish('statechange', {from: state.GAME_PLAY, to: state.PAUSED});
					console.log('Letter P has been pressed');
	
				}
				
			}
			
		}
		
		function end(){
			document.removeEventListener('keyup', onKeyUp, false);
			document.removeEventListener('keydown', onKeyDown, false);
			initialized = false;
			console.log('Keyword Module Terminated');
		}
		
		return{
			init : init,
			update : runKeys,
			end : end
		}
		
	}();
	
	module.exports = keyboardControl;

/***/ }
/******/ ]);
