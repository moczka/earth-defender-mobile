/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	window.addEventListener('load', onWindowLoad, false);
	
	function onWindowLoad(){
	    
	    
	    canvasApp();
	    
	}
	
	
	function canvasApp(){	
		
			var ResourceLoader = __webpack_require__(1),
	            PubSub = __webpack_require__(3),
	            Consctructors = __webpack_require__(4),
	            UIController = __webpack_require__(6),
	            Game = __webpack_require__(7);
	    
				//sets up game engine
			window.requestAnimFrame = (function(){
		return  window.requestAnimationFrame   ||
				window.webkitRequestAnimationFrame ||
				window.mozRequestAnimationFrame    ||
				window.oRequestAnimationFrame      ||
				window.msRequestAnimationFrame     ||
				function(/* function */ callback, /* DOMElement */ element){
					window.setTimeout(callback, FRAME_RATE);
				};
	        })();
	
	
	    
	    var state = {
	            INIT : -1,
	            LOADING: 0,
	            STORY_LINE : 1,
	            TITLE_SCREEN : 2,
	            GAME_PLAY : 3,
	            LEVEL_TRANSITION : 4,
	            BEAT_GAME : 5,
	            GAME_OVER : 6,
	            CREDITS : 7,
	            HOW_TO_PLAY : 8,
	            PAUSED : 9,
	            SHIP_JUMP : 10,
	            SET_UP_LEVEL: 11,
	
	            CURRENT : -1 
	    };
	    
	    
	    window.ResourceLoader = ResourceLoader;
		//adding the state object to the keyboardControl state property
	    var preloadImage = document.getElementById('preload');
	    
	    preloadImage.setAttribute('style', 'display: none;');
		
		//frame, assets counter and audio support
		var frameRate = new FrameRateCounter();
	
		
	    var loadBar = document.getElementById('loadBar');
	    
		//set up loader
		var loaderOptions = {
				assets : {
					imgs : {
	                    earthSprite : "assets/sprites/earth.png",
	                    playerSpriteSheet : "assets/sprites/playerShip.png",
	                    enemySpriteSheet : "assets/sprites/enemyShips.png",
	                    MothershipSpriteSheet : "assets/sprites/motherships.png",
	                    backgroundSprite : "assets/sprites/background.png",
	                    meteorSprite : "assets/sprites/meteorSprite.png",
	                    perkSprite : "assets/sprites/perks.png"
					},
	                sounds : {
	                    soundTrack : {
	                        src: ['assets/sounds/soundtrack.mp3','assets/sounds/soundtrack.wav'],
	                        volume: 0.5,
	                        loop: false
	                        },
	                    lastLevelSound : {
	                         src: ['assets/sounds/finalLevelSound.mp3','assets/sounds/finalLevelSound.wav'],
	                         volume: 1,
	                        },
	                    meteorExplosionSound : {
	                        src: ['assets/sounds/meteorExplosion.mp3','assets/sounds/meteorExplosion.wav'],
	                        volume: 1,
	                        },
	                    playerShootSound : {
	                        src: ['assets/sounds/shoot.mp3','assets/sounds/shoot.wav'],
	                        volume: 0.3,
	                        },
	                    explosionSound : {
	                        src: ['assets/sounds/explosion.mp3','assets/sounds/explosion.wav'],
	                        volume: 0.2,
	                        },
	                    perkSound : {
	                        src: ['assets/sounds/perk.mp3','assets/sounds/perk.wav'],
	                        volume: 1.0,
	                        },
	                    victorySound : {
	                        src: ['assets/sounds/victory.mp3','assets/sounds/victory.wav'],
	                        volume: 1.0,
	                        },
	                    gameOverSound : {
	                        src: ['assets/sounds/gameover.mp3','assets/sounds/gameover.wav'],
	                        volume: 1.0,
	                        }
	                }
				},
	            useHowl : true,
	        
				onload : function(item){
					loadBar.setAttribute('style', 'width: '+ResourceLoader.loaded*100+'%;');
				},
	        
				final : function(){
	                Game.init();
					PubSub.publish('statechange', {from:state.LOADING, to:state.STORY_LINE});
				}
			};
	    
	    UIController.init();
	    ResourceLoader.init(loaderOptions);
	    ResourceLoader.downloadAll();
	    
	    
	   
	    
	    
	    
	    //PubSub.publish('statechange', {from: state.LOADING, to: state.STORY_LINE});
	    
		
		//counters
		var scoreCounter = document.getElementById('scoreCounter');
		var levelCounter = document.getElementById('levelCounter');
		var livesCounter = document.getElementById('livesCounter');
		var frameRateCounter = document.getElementById('frameRate');
	    var reportEnemiesKilled = document.getElementById('reportCarnage');
	    var reportRocksDestroyed = document.getElementById('eportAsteroids');
	    var reportScore = document.getElementById('reportScore');
	    var beatGameScore = document.getElementById('beatGameScore');
		
	
		
	
	        
	    //game score tracker
	    
	    function recordCollision(objectType){
	        switch(objectType){
	            case "largeRock":
	                currentScore += 20;
	                updateCounter('score');
	                rocksDestroyed++;
	                break;
	                
	            case "mediumRock":
	                currentScore += 10;
	                updateCounter('score');
	                rocksDestroyed++;
	                break;
	                
	            case "smallRock":
	                currentScore += 5;
	                updateCounter('score');
	                rocksDestroyed++;
	                break;
	                
	            case "humanShip":
	                shipLives--;
	                currentScore -= 50;
	                updateCounter('score');
	                updateCounter('life');
	                break;
	                
	            case "enemy":
	                currentScore += 50;
	                updateCounter('score');
	                levelEnemies--;
	                enemiesKilled++;
	                break;
	                
	            case "life":
	                shipLives++;
	                updateCounter('life');
	                break;
	                
	            case "shield":
	                playerShip.shield.reset();
	                break;
	            case "cash":
	                break;
	        }
	        
	    }
	    
		//handles the mousemove interaction at title screen.
		function onMouseMove(event){
	        
			if(state.CURRENT != state.TITLE_SCREEN){
	            return;
	        }
	        
			if ( event.layerX ||  event.layerX == 0) { // Firefox
	   			mouse.x = event.layerX ;
	    		mouse.y = event.layerY;
	  		} else if (event.offsetX || event.offsetX == 0) { // Opera
	    		mouse.x = event.offsetX;
	    		mouse.y = event.offsetY;
	  		}
			
		}
		
		//Checks for device orientation
		function onOrientationChange(e){
	
			if(window.innerHeight>= window.innerWidth){
				userAgent.portrait = true;
				orientationMessageHolder.setAttribute('style', 'display: block;');
				canvasHolder.setAttribute('style', 'display:none;');
	            interfaceWrapper.setAttribute('style', 'display: none;');
			}else if(window.innerHeight<=window.innerWidth){
				orientationMessageHolder.setAttribute('style', '');
				canvasHolder.setAttribute('style', '');
	            interfaceWrapper.setAttribute('style', '');
				userAgent.portrait = false;
			}
			
		}
		
		//removes the default behavior of pinching zoom on Mobile
		function onTouchMove(e){
			
			e.preventDefault();
		}
	
		//FramRate Class
		
		function FrameRateCounter() {
	
	        this.lastFrameCount = 0;
	        var dateTemp = new Date();
	        this.frameLast = dateTemp.getTime();
	        delete dateTemp;
	        this.frameCtr = 0;
	    }
	
	    FrameRateCounter.prototype.countFrames=function() {
	       var dateTemp = new Date();
	       this.frameCtr++;
	
	       if (dateTemp.getTime() >=this.frameLast+1000) {
	          //ConsoleLog.log("frame event");
	          this.lastFrameCount = this.frameCtr;
	          this.frameLast = dateTemp.getTime();
	          this.frameCtr = 0;
	       }
	
	       delete dateTemp;
	    }
	
	}


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	var Howl = __webpack_require__(2).Howl;
	var PubSub = __webpack_require__(3);
	
	
	var ResourceLoader = (function(){
		
		var totalAssets = 0,
			loadedAssets = 0,
			assetsDownloaded = false,
			UserOptions,
			percentageLoaded,
			audioSupport,
			assets = {};
		
			//default options if no option argument is passed by user.
			var defaultOptions = {
						  onload: function(){ 
							console.log('No callback was passed in..');
							},
						  final : function(){
							  console.log('No final function to call was passed in..');
						  },
						 assets : []
						 };
		
		/* Example of options:
		
		{
			assets : {
			
				imgs : {
					//img names with URLs
					bg_black : "assets/img/background.png,
					meteorSprite : "assets/img/meteor.png,
					enemiesSprite : "assets/img/enemies.png,
					enemyShipSprites: "assets/img/enemyShips.png
				},
				sounds : {
					//sounds name with URLs
					soundtrack : ["assets/sounds/player.mp3", "assets/sounds/player.wav"],
					endSound : ["assets/sounds/gameover.mp3", "assets/sounds/gameover.wav"]
				}
			}
	        useHowl : false,
				//function that is called on every item loaded
			onload : updateLoaderDisplayer,
				//function that is called once all have loaded
			final : finalFunctionToCall
		}
	
		*/
			
		function init(options){
			UserOptions = options || defaultOptions;
		}
		
		function download(){
			
			//return if all assets have already loaded and indexed.
			if(assetsDownloaded) return;
	        
	        PubSub.publish('statechange', {from: state.INIT, to: state.LOADING});
			
			//sets to true so this method (downloadAll()) is called only onced.
			assetsDownloaded = true;
			//creates the sound and image elements for each asset in the options argument.
			for(var item in UserOptions.assets.imgs){
				assets[item] = new Image();
				assets[item].src = UserOptions.assets.imgs[item];
				assets[item].addEventListener('load', onLoad, false);
				totalAssets++;
			}
			//arrays are passed for each sound asset containing the source to the sound.
	        if(!UserOptions.useHowl){
	            for(var item in UserOptions.assets.sounds){
	                for(var i=0, j=UserOptions.assets.sounds[item].length; i<j; i++){
	                var currentSound = UserOptions.assets.sounds[item][i];
	                    //analyzes the extension and picks the first one that is supported by the browser.
	                    if(isAudioSupport(currentSound.slice(-3))){
	                        assets[item] = new Audio();
	                        assets[item].src = UserOptions.assets.sounds[item][i];
	                        assets[item].addEventListener('canplaythrough', onLoad, false);
	                        totalAssets++;
	                        break;
	                    }
	                }
	
	            }
	        }else{
	            //creates howl instance and passes in howl options given by the user.
	            for(var item in UserOptions.assets.sounds){
	                var howlOptions = UserOptions.assets.sounds[item];
	                howlOptions.onload = onLoad;
	                assets[item] = new Howl(howlOptions); 
	                totalAssets++;
	                
	            }
	        }
			
		}
		
		function onLoad(item){
	        
	        //increments load count and remove listeners.
			loadedAssets++;
	        
	        var itemLoaded;
	
	        if(item){
	            if(item.target.tagName === "AUDIO"){
	                itemLoaded = item.target;
	                item.target.removeEventListener('canplaythrough', onLoad, false);
	            }else if (item.target.tagName === "IMG"){
	                itemLoaded = item.target;
	                item.target.removeEventListener('load', onLoad, false);
	            }
	        }else{
	            itemLoaded = {name: "Howl sound", src: "Howl sound check sound"};   
	        }
	        
			//calculates the decimal value from ratio
			percentageLoaded = Math.floor((loadedAssets / totalAssets)*100)/100;
			
			//call the appropriate callback function given the ammount of assets loaded.
			if(UserOptions.onload){
				UserOptions.onload(itemLoaded);
			}
			if(loadedAssets >= totalAssets && UserOptions.final){
				UserOptions.final(itemLoaded);
			}
			
		}
		
		//gets the appropriate supported audio format.
		function isAudioSupport(extension){
			
			var audio = new Audio();
			var supportValue = audio.canPlayType("audio/"+extension);
			if( supportValue === "maybe" || supportValue === "probably" ){
				return true;
			}else{
				return false;
			}
		}
		
		return {
			init : init,
			assets : assets,
			get loaded(){
				return percentageLoaded;
			},
	    	downloadAll : download
		}
		
	})();
	
	module.exports = ResourceLoader;

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(global) {/*!
	 *  howler.js v2.0.0
	 *  howlerjs.com
	 *
	 *  (c) 2013-2016, James Simpson of GoldFire Studios
	 *  goldfirestudios.com
	 *
	 *  MIT License
	 */
	
	(function() {
	
	  'use strict';
	
	  /** Global Methods **/
	  /***************************************************************************/
	
	  /**
	   * Create the global controller. All contained methods and properties apply
	   * to all sounds that are currently playing or will be in the future.
	   */
	  var HowlerGlobal = function() {
	    this.init();
	  };
	  HowlerGlobal.prototype = {
	    /**
	     * Initialize the global Howler object.
	     * @return {Howler}
	     */
	    init: function() {
	      var self = this || Howler;
	
	      // Internal properties.
	      self._codecs = {};
	      self._howls = [];
	      self._muted = false;
	      self._volume = 1;
	      self._canPlayEvent = 'canplaythrough';
	      self._navigator = (typeof window !== 'undefined' && window.navigator) ? window.navigator : null;
	
	      // Public properties.
	      self.masterGain = null;
	      self.noAudio = false;
	      self.usingWebAudio = true;
	      self.autoSuspend = true;
	      self.ctx = null;
	
	      // Set to false to disable the auto iOS enabler.
	      self.mobileAutoEnable = true;
	
	      // Setup the various state values for global tracking.
	      self._setup();
	
	      return self;
	    },
	
	    /**
	     * Get/set the global volume for all sounds.
	     * @param  {Float} vol Volume from 0.0 to 1.0.
	     * @return {Howler/Float}     Returns self or current volume.
	     */
	    volume: function(vol) {
	      var self = this || Howler;
	      vol = parseFloat(vol);
	
	      // If we don't have an AudioContext created yet, run the setup.
	      if (!self.ctx) {
	        setupAudioContext();
	      }
	
	      if (typeof vol !== 'undefined' && vol >= 0 && vol <= 1) {
	        self._volume = vol;
	
	        // Don't update any of the nodes if we are muted.
	        if (self._muted) {
	          return self;
	        }
	
	        // When using Web Audio, we just need to adjust the master gain.
	        if (self.usingWebAudio) {
	          self.masterGain.gain.value = vol;
	        }
	
	        // Loop through and change volume for all HTML5 audio nodes.
	        for (var i=0; i<self._howls.length; i++) {
	          if (!self._howls[i]._webAudio) {
	            // Get all of the sounds in this Howl group.
	            var ids = self._howls[i]._getSoundIds();
	
	            // Loop through all sounds and change the volumes.
	            for (var j=0; j<ids.length; j++) {
	              var sound = self._howls[i]._soundById(ids[j]);
	
	              if (sound && sound._node) {
	                sound._node.volume = sound._volume * vol;
	              }
	            }
	          }
	        }
	
	        return self;
	      }
	
	      return self._volume;
	    },
	
	    /**
	     * Handle muting and unmuting globally.
	     * @param  {Boolean} muted Is muted or not.
	     */
	    mute: function(muted) {
	      var self = this || Howler;
	
	      // If we don't have an AudioContext created yet, run the setup.
	      if (!self.ctx) {
	        setupAudioContext();
	      }
	
	      self._muted = muted;
	
	      // With Web Audio, we just need to mute the master gain.
	      if (self.usingWebAudio) {
	        self.masterGain.gain.value = muted ? 0 : self._volume;
	      }
	
	      // Loop through and mute all HTML5 Audio nodes.
	      for (var i=0; i<self._howls.length; i++) {
	        if (!self._howls[i]._webAudio) {
	          // Get all of the sounds in this Howl group.
	          var ids = self._howls[i]._getSoundIds();
	
	          // Loop through all sounds and mark the audio node as muted.
	          for (var j=0; j<ids.length; j++) {
	            var sound = self._howls[i]._soundById(ids[j]);
	
	            if (sound && sound._node) {
	              sound._node.muted = (muted) ? true : sound._muted;
	            }
	          }
	        }
	      }
	
	      return self;
	    },
	
	    /**
	     * Unload and destroy all currently loaded Howl objects.
	     * @return {Howler}
	     */
	    unload: function() {
	      var self = this || Howler;
	
	      for (var i=self._howls.length-1; i>=0; i--) {
	        self._howls[i].unload();
	      }
	
	      // Create a new AudioContext to make sure it is fully reset.
	      if (self.usingWebAudio && typeof self.ctx.close !== 'undefined') {
	        self.ctx.close();
	        self.ctx = null;
	        setupAudioContext();
	      }
	
	      return self;
	    },
	
	    /**
	     * Check for codec support of specific extension.
	     * @param  {String} ext Audio file extention.
	     * @return {Boolean}
	     */
	    codecs: function(ext) {
	      return (this || Howler)._codecs[ext];
	    },
	
	    /**
	     * Setup various state values for global tracking.
	     * @return {Howler}
	     */
	    _setup: function() {
	      var self = this || Howler;
	
	      // Keeps track of the suspend/resume state of the AudioContext.
	      self.state = self.ctx ? self.ctx.state || 'running' : 'running';
	
	      // Automatically begin the 30-second suspend process
	      self._autoSuspend();
	
	      // Check for supported codecs.
	      if (!self.noAudio) {
	        self._setupCodecs();
	      }
	
	      return self;
	    },
	
	    /**
	     * Check for browser support for various codecs and cache the results.
	     * @return {Howler}
	     */
	    _setupCodecs: function() {
	      var self = this || Howler;
	      var audioTest = (typeof Audio !== 'undefined') ? new Audio() : null;
	
	      if (!audioTest || typeof audioTest.canPlayType !== 'function') {
	        return self;
	      }
	
	      var mpegTest = audioTest.canPlayType('audio/mpeg;').replace(/^no$/, '');
	
	      // Opera version <33 has mixed MP3 support, so we need to check for and block it.
	      var checkOpera = self._navigator && self._navigator.userAgent.match(/OPR\/([0-6].)/g);
	      var isOldOpera = (checkOpera && parseInt(checkOpera[0].split('/')[1], 10) < 33);
	
	      self._codecs = {
	        mp3: !!(!isOldOpera && (mpegTest || audioTest.canPlayType('audio/mp3;').replace(/^no$/, ''))),
	        mpeg: !!mpegTest,
	        opus: !!audioTest.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/, ''),
	        ogg: !!audioTest.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ''),
	        oga: !!audioTest.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ''),
	        wav: !!audioTest.canPlayType('audio/wav; codecs="1"').replace(/^no$/, ''),
	        aac: !!audioTest.canPlayType('audio/aac;').replace(/^no$/, ''),
	        caf: !!audioTest.canPlayType('audio/x-caf;').replace(/^no$/, ''),
	        m4a: !!(audioTest.canPlayType('audio/x-m4a;') || audioTest.canPlayType('audio/m4a;') || audioTest.canPlayType('audio/aac;')).replace(/^no$/, ''),
	        mp4: !!(audioTest.canPlayType('audio/x-mp4;') || audioTest.canPlayType('audio/mp4;') || audioTest.canPlayType('audio/aac;')).replace(/^no$/, ''),
	        weba: !!audioTest.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, ''),
	        webm: !!audioTest.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, ''),
	        dolby: !!audioTest.canPlayType('audio/mp4; codecs="ec-3"').replace(/^no$/, '')
	      };
	
	      return self;
	    },
	
	    /**
	     * Mobile browsers will only allow audio to be played after a user interaction.
	     * Attempt to automatically unlock audio on the first user interaction.
	     * Concept from: http://paulbakaus.com/tutorials/html5/web-audio-on-ios/
	     * @return {Howler}
	     */
	    _enableMobileAudio: function() {
	      var self = this || Howler;
	
	      // Only run this on mobile devices if audio isn't already eanbled.
	      var isMobile = /iPhone|iPad|iPod|Android|BlackBerry|BB10|Silk|Mobi/i.test(self._navigator && self._navigator.userAgent);
	      var isTouch = !!(('ontouchend' in window) || (self._navigator && self._navigator.maxTouchPoints > 0) || (self._navigator && self._navigator.msMaxTouchPoints > 0));
	      if (self._mobileEnabled || !self.ctx || (!isMobile && !isTouch)) {
	        return;
	      }
	
	      self._mobileEnabled = false;
	
	      // Some mobile devices/platforms have distortion issues when opening/closing tabs and/or web views.
	      // Bugs in the browser (especially Mobile Safari) can cause the sampleRate to change from 44100 to 48000.
	      // By calling Howler.unload(), we create a new AudioContext with the correct sampleRate.
	      if (!self._mobileUnloaded && self.ctx.sampleRate !== 44100) {
	        self._mobileUnloaded = true;
	        self.unload();
	      }
	
	      // Scratch buffer for enabling iOS to dispose of web audio buffers correctly, as per:
	      // http://stackoverflow.com/questions/24119684
	      self._scratchBuffer = self.ctx.createBuffer(1, 1, 22050);
	
	      // Call this method on touch start to create and play a buffer,
	      // then check if the audio actually played to determine if
	      // audio has now been unlocked on iOS, Android, etc.
	      var unlock = function() {
	        // Create an empty buffer.
	        var source = self.ctx.createBufferSource();
	        source.buffer = self._scratchBuffer;
	        source.connect(self.ctx.destination);
	
	        // Play the empty buffer.
	        if (typeof source.start === 'undefined') {
	          source.noteOn(0);
	        } else {
	          source.start(0);
	        }
	
	        // Setup a timeout to check that we are unlocked on the next event loop.
	        source.onended = function() {
	          source.disconnect(0);
	
	          // Update the unlocked state and prevent this check from happening again.
	          self._mobileEnabled = true;
	          self.mobileAutoEnable = false;
	
	          // Remove the touch start listener.
	          document.removeEventListener('touchend', unlock, true);
	        };
	      };
	
	      // Setup a touch start listener to attempt an unlock in.
	      document.addEventListener('touchend', unlock, true);
	
	      return self;
	    },
	
	    /**
	     * Automatically suspend the Web Audio AudioContext after no sound has played for 30 seconds.
	     * This saves processing/energy and fixes various browser-specific bugs with audio getting stuck.
	     * @return {Howler}
	     */
	    _autoSuspend: function() {
	      var self = this;
	
	      if (!self.autoSuspend || !self.ctx || typeof self.ctx.suspend === 'undefined' || !Howler.usingWebAudio) {
	        return;
	      }
	
	      // Check if any sounds are playing.
	      for (var i=0; i<self._howls.length; i++) {
	        if (self._howls[i]._webAudio) {
	          for (var j=0; j<self._howls[i]._sounds.length; j++) {
	            if (!self._howls[i]._sounds[j]._paused) {
	              return self;
	            }
	          }
	        }
	      }
	
	      if (self._suspendTimer) {
	        clearTimeout(self._suspendTimer);
	      }
	
	      // If no sound has played after 30 seconds, suspend the context.
	      self._suspendTimer = setTimeout(function() {
	        if (!self.autoSuspend) {
	          return;
	        }
	
	        self._suspendTimer = null;
	        self.state = 'suspending';
	        self.ctx.suspend().then(function() {
	          self.state = 'suspended';
	
	          if (self._resumeAfterSuspend) {
	            delete self._resumeAfterSuspend;
	            self._autoResume();
	          }
	        });
	      }, 30000);
	
	      return self;
	    },
	
	    /**
	     * Automatically resume the Web Audio AudioContext when a new sound is played.
	     * @return {Howler}
	     */
	    _autoResume: function() {
	      var self = this;
	
	      if (!self.ctx || typeof self.ctx.resume === 'undefined' || !Howler.usingWebAudio) {
	        return;
	      }
	
	      if (self.state === 'running' && self._suspendTimer) {
	        clearTimeout(self._suspendTimer);
	        self._suspendTimer = null;
	      } else if (self.state === 'suspended') {
	        self.state = 'resuming';
	        self.ctx.resume().then(function() {
	          self.state = 'running';
	        });
	
	        if (self._suspendTimer) {
	          clearTimeout(self._suspendTimer);
	          self._suspendTimer = null;
	        }
	      } else if (self.state === 'suspending') {
	        self._resumeAfterSuspend = true;
	      }
	
	      return self;
	    }
	  };
	
	  // Setup the global audio controller.
	  var Howler = new HowlerGlobal();
	
	  /** Group Methods **/
	  /***************************************************************************/
	
	  /**
	   * Create an audio group controller.
	   * @param {Object} o Passed in properties for this group.
	   */
	  var Howl = function(o) {
	    var self = this;
	
	    // Throw an error if no source is provided.
	    if (!o.src || o.src.length === 0) {
	      console.error('An array of source files must be passed with any new Howl.');
	      return;
	    }
	
	    self.init(o);
	  };
	  Howl.prototype = {
	    /**
	     * Initialize a new Howl group object.
	     * @param  {Object} o Passed in properties for this group.
	     * @return {Howl}
	     */
	    init: function(o) {
	      var self = this;
	
	      // If we don't have an AudioContext created yet, run the setup.
	      if (!Howler.ctx) {
	        setupAudioContext();
	      }
	
	      // Setup user-defined default properties.
	      self._autoplay = o.autoplay || false;
	      self._format = (typeof o.format !== 'string') ? o.format : [o.format];
	      self._html5 = o.html5 || false;
	      self._muted = o.mute || false;
	      self._loop = o.loop || false;
	      self._pool = o.pool || 5;
	      self._preload = (typeof o.preload === 'boolean') ? o.preload : true;
	      self._rate = o.rate || 1;
	      self._sprite = o.sprite || {};
	      self._src = (typeof o.src !== 'string') ? o.src : [o.src];
	      self._volume = o.volume !== undefined ? o.volume : 1;
	
	      // Setup all other default properties.
	      self._duration = 0;
	      self._state = 'unloaded';
	      self._sounds = [];
	      self._endTimers = {};
	      self._queue = [];
	
	      // Setup event listeners.
	      self._onend = o.onend ? [{fn: o.onend}] : [];
	      self._onfade = o.onfade ? [{fn: o.onfade}] : [];
	      self._onload = o.onload ? [{fn: o.onload}] : [];
	      self._onloaderror = o.onloaderror ? [{fn: o.onloaderror}] : [];
	      self._onpause = o.onpause ? [{fn: o.onpause}] : [];
	      self._onplay = o.onplay ? [{fn: o.onplay}] : [];
	      self._onstop = o.onstop ? [{fn: o.onstop}] : [];
	      self._onmute = o.onmute ? [{fn: o.onmute}] : [];
	      self._onvolume = o.onvolume ? [{fn: o.onvolume}] : [];
	      self._onrate = o.onrate ? [{fn: o.onrate}] : [];
	      self._onseek = o.onseek ? [{fn: o.onseek}] : [];
	
	      // Web Audio or HTML5 Audio?
	      self._webAudio = Howler.usingWebAudio && !self._html5;
	
	      // Automatically try to enable audio on iOS.
	      if (typeof Howler.ctx !== 'undefined' && Howler.ctx && Howler.mobileAutoEnable) {
	        Howler._enableMobileAudio();
	      }
	
	      // Keep track of this Howl group in the global controller.
	      Howler._howls.push(self);
	
	      // Load the source file unless otherwise specified.
	      if (self._preload) {
	        self.load();
	      }
	
	      return self;
	    },
	
	    /**
	     * Load the audio file.
	     * @return {Howler}
	     */
	    load: function() {
	      var self = this;
	      var url = null;
	
	      // If no audio is available, quit immediately.
	      if (Howler.noAudio) {
	        self._emit('loaderror', null, 'No audio support.');
	        return;
	      }
	
	      // Make sure our source is in an array.
	      if (typeof self._src === 'string') {
	        self._src = [self._src];
	      }
	
	      // Loop through the sources and pick the first one that is compatible.
	      for (var i=0; i<self._src.length; i++) {
	        var ext, str;
	
	        if (self._format && self._format[i]) {
	          // If an extension was specified, use that instead.
	          ext = self._format[i];
	        } else {
	          // Make sure the source is a string.
	          str = self._src[i];
	          if (typeof str !== 'string') {
	            self._emit('loaderror', null, 'Non-string found in selected audio sources - ignoring.');
	            continue;
	          }
	
	          // Extract the file extension from the URL or base64 data URI.
	          ext = /^data:audio\/([^;,]+);/i.exec(str);
	          if (!ext) {
	            ext = /\.([^.]+)$/.exec(str.split('?', 1)[0]);
	          }
	
	          if (ext) {
	            ext = ext[1].toLowerCase();
	          }
	        }
	
	        // Check if this extension is available.
	        if (Howler.codecs(ext)) {
	          url = self._src[i];
	          break;
	        }
	      }
	
	      if (!url) {
	        self._emit('loaderror', null, 'No codec support for selected audio sources.');
	        return;
	      }
	
	      self._src = url;
	      self._state = 'loading';
	
	      // If the hosting page is HTTPS and the source isn't,
	      // drop down to HTML5 Audio to avoid Mixed Content errors.
	      if (window.location.protocol === 'https:' && url.slice(0, 5) === 'http:') {
	        self._html5 = true;
	        self._webAudio = false;
	      }
	
	      // Create a new sound object and add it to the pool.
	      new Sound(self);
	
	      // Load and decode the audio data for playback.
	      if (self._webAudio) {
	        loadBuffer(self);
	      }
	
	      return self;
	    },
	
	    /**
	     * Play a sound or resume previous playback.
	     * @param  {String/Number} sprite   Sprite name for sprite playback or sound id to continue previous.
	     * @param  {Boolean} internal Internal Use: true prevents event firing.
	     * @return {Number}          Sound ID.
	     */
	    play: function(sprite, internal) {
	      var self = this;
	      var id = null;
	
	      // Determine if a sprite, sound id or nothing was passed
	      if (typeof sprite === 'number') {
	        id = sprite;
	        sprite = null;
	      } else if (typeof sprite === 'string' && self._state === 'loaded' && !self._sprite[sprite]) {
	        // If the passed sprite doesn't exist, do nothing.
	        return null;
	      } else if (typeof sprite === 'undefined') {
	        // Use the default sound sprite (plays the full audio length).
	        sprite = '__default';
	
	        // Check if there is a single paused sound that isn't ended.
	        // If there is, play that sound. If not, continue as usual.
	        var num = 0;
	        for (var i=0; i<self._sounds.length; i++) {
	          if (self._sounds[i]._paused && !self._sounds[i]._ended) {
	            num++;
	            id = self._sounds[i]._id;
	          }
	        }
	
	        if (num === 1) {
	          sprite = null;
	        } else {
	          id = null;
	        }
	      }
	
	      // Get the selected node, or get one from the pool.
	      var sound = id ? self._soundById(id) : self._inactiveSound();
	
	      // If the sound doesn't exist, do nothing.
	      if (!sound) {
	        return null;
	      }
	
	      // Select the sprite definition.
	      if (id && !sprite) {
	        sprite = sound._sprite || '__default';
	      }
	
	      // If we have no sprite and the sound hasn't loaded, we must wait
	      // for the sound to load to get our audio's duration.
	      if (self._state !== 'loaded' && !self._sprite[sprite]) {
	        self._queue.push({
	          event: 'play',
	          action: function() {
	            self.play(self._soundById(sound._id) ? sound._id : undefined);
	          }
	        });
	
	        return sound._id;
	      }
	
	      // Don't play the sound if an id was passed and it is already playing.
	      if (id && !sound._paused) {
	        // Trigger the play event, in order to keep iterating through queue.
	        if (!internal) {
	          setTimeout(function() {
	            self._emit('play', sound._id);
	          }, 0);
	        }
	
	        return sound._id;
	      }
	
	      // Make sure the AudioContext isn't suspended, and resume it if it is.
	      if (self._webAudio) {
	        Howler._autoResume();
	      }
	
	      // Determine how long to play for and where to start playing.
	      var seek = sound._seek > 0 ? sound._seek : self._sprite[sprite][0] / 1000;
	      var duration = ((self._sprite[sprite][0] + self._sprite[sprite][1]) / 1000) - seek;
	      var timeout = (duration * 1000) / Math.abs(sound._rate);
	
	      // Update the parameters of the sound
	      sound._paused = false;
	      sound._ended = false;
	      sound._sprite = sprite;
	      sound._seek = seek;
	      sound._start = self._sprite[sprite][0] / 1000;
	      sound._stop = (self._sprite[sprite][0] + self._sprite[sprite][1]) / 1000;
	      sound._loop = !!(sound._loop || self._sprite[sprite][2]);
	
	      // Begin the actual playback.
	      var node = sound._node;
	      if (self._webAudio) {
	        // Fire this when the sound is ready to play to begin Web Audio playback.
	        var playWebAudio = function() {
	          self._refreshBuffer(sound);
	
	          // Setup the playback params.
	          var vol = (sound._muted || self._muted) ? 0 : sound._volume;
	          node.gain.setValueAtTime(vol, Howler.ctx.currentTime);
	          sound._playStart = Howler.ctx.currentTime;
	
	          // Play the sound using the supported method.
	          if (typeof node.bufferSource.start === 'undefined') {
	            sound._loop ? node.bufferSource.noteGrainOn(0, seek, 86400) : node.bufferSource.noteGrainOn(0, seek, duration);
	          } else {
	            sound._loop ? node.bufferSource.start(0, seek, 86400) : node.bufferSource.start(0, seek, duration);
	          }
	
	          // Start a new timer if none is present.
	          if (timeout !== Infinity) {
	            self._endTimers[sound._id] = setTimeout(self._ended.bind(self, sound), timeout);
	          }
	
	          if (!internal) {
	            setTimeout(function() {
	              self._emit('play', sound._id);
	            }, 0);
	          }
	        };
	
	        if (self._state === 'loaded') {
	          playWebAudio();
	        } else {
	          // Wait for the audio to load and then begin playback.
	          self.once('load', playWebAudio, sound._id);
	
	          // Cancel the end timer.
	          self._clearTimer(sound._id);
	        }
	      } else {
	        // Fire this when the sound is ready to play to begin HTML5 Audio playback.
	        var playHtml5 = function() {
	          node.currentTime = seek;
	          node.muted = sound._muted || self._muted || Howler._muted || node.muted;
	          node.volume = sound._volume * Howler.volume();
	          node.playbackRate = sound._rate;
	
	          setTimeout(function() {
	            node.play();
	
	            // Setup the new end timer.
	            if (timeout !== Infinity) {
	              self._endTimers[sound._id] = setTimeout(self._ended.bind(self, sound), timeout);
	            }
	
	            if (!internal) {
	              self._emit('play', sound._id);
	            }
	          }, 0);
	        };
	
	        // Play immediately if ready, or wait for the 'canplaythrough'e vent.
	        var loadedNoReadyState = (self._state === 'loaded' && (window && window.ejecta || !node.readyState && Howler._navigator.isCocoonJS));
	        if (node.readyState === 4 || loadedNoReadyState) {
	          playHtml5();
	        } else {
	          var listener = function() {
	            // Begin playback.
	            playHtml5();
	
	            // Clear this listener.
	            node.removeEventListener(Howler._canPlayEvent, listener, false);
	          };
	          node.addEventListener(Howler._canPlayEvent, listener, false);
	
	          // Cancel the end timer.
	          self._clearTimer(sound._id);
	        }
	      }
	
	      return sound._id;
	    },
	
	    /**
	     * Pause playback and save current position.
	     * @param  {Number} id The sound ID (empty to pause all in group).
	     * @return {Howl}
	     */
	    pause: function(id) {
	      var self = this;
	
	      // If the sound hasn't loaded, add it to the load queue to pause when capable.
	      if (self._state !== 'loaded') {
	        self._queue.push({
	          event: 'pause',
	          action: function() {
	            self.pause(id);
	          }
	        });
	
	        return self;
	      }
	
	      // If no id is passed, get all ID's to be paused.
	      var ids = self._getSoundIds(id);
	
	      for (var i=0; i<ids.length; i++) {
	        // Clear the end timer.
	        self._clearTimer(ids[i]);
	
	        // Get the sound.
	        var sound = self._soundById(ids[i]);
	
	        if (sound && !sound._paused) {
	          // Reset the seek position.
	          sound._seek = self.seek(ids[i]);
	          sound._rateSeek = 0;
	          sound._paused = true;
	
	          // Stop currently running fades.
	          self._stopFade(ids[i]);
	
	          if (sound._node) {
	            if (self._webAudio) {
	              // make sure the sound has been created
	              if (!sound._node.bufferSource) {
	                return self;
	              }
	
	              if (typeof sound._node.bufferSource.stop === 'undefined') {
	                sound._node.bufferSource.noteOff(0);
	              } else {
	                sound._node.bufferSource.stop(0);
	              }
	
	              // Clean up the buffer source.
	              self._cleanBuffer(sound._node);
	            } else if (!isNaN(sound._node.duration) || sound._node.duration === Infinity) {
	              sound._node.pause();
	            }
	          }
	
	          // Fire the pause event, unless `true` is passed as the 2nd argument.
	          if (!arguments[1]) {
	            self._emit('pause', sound._id);
	          }
	        }
	      }
	
	      return self;
	    },
	
	    /**
	     * Stop playback and reset to start.
	     * @param  {Number} id The sound ID (empty to stop all in group).
	     * @param  {Boolean} internal Internal Use: true prevents event firing.
	     * @return {Howl}
	     */
	    stop: function(id, internal) {
	      var self = this;
	
	      // If the sound hasn't loaded, add it to the load queue to stop when capable.
	      if (self._state !== 'loaded') {
	        self._queue.push({
	          event: 'stop',
	          action: function() {
	            self.stop(id);
	          }
	        });
	
	        return self;
	      }
	
	      // If no id is passed, get all ID's to be stopped.
	      var ids = self._getSoundIds(id);
	
	      for (var i=0; i<ids.length; i++) {
	        // Clear the end timer.
	        self._clearTimer(ids[i]);
	
	        // Get the sound.
	        var sound = self._soundById(ids[i]);
	
	        if (sound && !sound._paused) {
	          // Reset the seek position.
	          sound._seek = sound._start || 0;
	          sound._rateSeek = 0;
	          sound._paused = true;
	          sound._ended = true;
	
	          // Stop currently running fades.
	          self._stopFade(ids[i]);
	
	          if (sound._node) {
	            if (self._webAudio) {
	              // make sure the sound has been created
	              if (!sound._node.bufferSource) {
	                return self;
	              }
	
	              if (typeof sound._node.bufferSource.stop === 'undefined') {
	                sound._node.bufferSource.noteOff(0);
	              } else {
	                sound._node.bufferSource.stop(0);
	              }
	
	              // Clean up the buffer source.
	              self._cleanBuffer(sound._node);
	            } else if (!isNaN(sound._node.duration) || sound._node.duration === Infinity) {
	              sound._node.currentTime = sound._start || 0;
	              sound._node.pause();
	            }
	          }
	        }
	
	        if (sound && !internal) {
	          self._emit('stop', sound._id);
	        }
	      }
	
	      return self;
	    },
	
	    /**
	     * Mute/unmute a single sound or all sounds in this Howl group.
	     * @param  {Boolean} muted Set to true to mute and false to unmute.
	     * @param  {Number} id    The sound ID to update (omit to mute/unmute all).
	     * @return {Howl}
	     */
	    mute: function(muted, id) {
	      var self = this;
	
	      // If the sound hasn't loaded, add it to the load queue to mute when capable.
	      if (self._state !== 'loaded') {
	        self._queue.push({
	          event: 'mute',
	          action: function() {
	            self.mute(muted, id);
	          }
	        });
	
	        return self;
	      }
	
	      // If applying mute/unmute to all sounds, update the group's value.
	      if (typeof id === 'undefined') {
	        if (typeof muted === 'boolean') {
	          self._muted = muted;
	        } else {
	          return self._muted;
	        }
	      }
	
	      // If no id is passed, get all ID's to be muted.
	      var ids = self._getSoundIds(id);
	
	      for (var i=0; i<ids.length; i++) {
	        // Get the sound.
	        var sound = self._soundById(ids[i]);
	
	        if (sound) {
	          sound._muted = muted;
	
	          if (self._webAudio && sound._node) {
	            sound._node.gain.setValueAtTime(muted ? 0 : sound._volume, Howler.ctx.currentTime);
	          } else if (sound._node) {
	            sound._node.muted = Howler._muted ? true : muted;
	          }
	
	          self._emit('mute', sound._id);
	        }
	      }
	
	      return self;
	    },
	
	    /**
	     * Get/set the volume of this sound or of the Howl group. This method can optionally take 0, 1 or 2 arguments.
	     *   volume() -> Returns the group's volume value.
	     *   volume(id) -> Returns the sound id's current volume.
	     *   volume(vol) -> Sets the volume of all sounds in this Howl group.
	     *   volume(vol, id) -> Sets the volume of passed sound id.
	     * @return {Howl/Number} Returns self or current volume.
	     */
	    volume: function() {
	      var self = this;
	      var args = arguments;
	      var vol, id;
	
	      // Determine the values based on arguments.
	      if (args.length === 0) {
	        // Return the value of the groups' volume.
	        return self._volume;
	      } else if (args.length === 1) {
	        // First check if this is an ID, and if not, assume it is a new volume.
	        var ids = self._getSoundIds();
	        var index = ids.indexOf(args[0]);
	        if (index >= 0) {
	          id = parseInt(args[0], 10);
	        } else {
	          vol = parseFloat(args[0]);
	        }
	      } else if (args.length >= 2) {
	        vol = parseFloat(args[0]);
	        id = parseInt(args[1], 10);
	      }
	
	      // Update the volume or return the current volume.
	      var sound;
	      if (typeof vol !== 'undefined' && vol >= 0 && vol <= 1) {
	        // If the sound hasn't loaded, add it to the load queue to change volume when capable.
	        if (self._state !== 'loaded') {
	          self._queue.push({
	            event: 'volume',
	            action: function() {
	              self.volume.apply(self, args);
	            }
	          });
	
	          return self;
	        }
	
	        // Set the group volume.
	        if (typeof id === 'undefined') {
	          self._volume = vol;
	        }
	
	        // Update one or all volumes.
	        id = self._getSoundIds(id);
	        for (var i=0; i<id.length; i++) {
	          // Get the sound.
	          sound = self._soundById(id[i]);
	
	          if (sound) {
	            sound._volume = vol;
	
	            // Stop currently running fades.
	            if (!args[2]) {
	              self._stopFade(id[i]);
	            }
	
	            if (self._webAudio && sound._node && !sound._muted) {
	              sound._node.gain.setValueAtTime(vol, Howler.ctx.currentTime);
	            } else if (sound._node && !sound._muted) {
	              sound._node.volume = vol * Howler.volume();
	            }
	
	            self._emit('volume', sound._id);
	          }
	        }
	      } else {
	        sound = id ? self._soundById(id) : self._sounds[0];
	        return sound ? sound._volume : 0;
	      }
	
	      return self;
	    },
	
	    /**
	     * Fade a currently playing sound between two volumes (if no id is passsed, all sounds will fade).
	     * @param  {Number} from The value to fade from (0.0 to 1.0).
	     * @param  {Number} to   The volume to fade to (0.0 to 1.0).
	     * @param  {Number} len  Time in milliseconds to fade.
	     * @param  {Number} id   The sound id (omit to fade all sounds).
	     * @return {Howl}
	     */
	    fade: function(from, to, len, id) {
	      var self = this;
	      var diff = Math.abs(from - to);
	      var dir = from > to ? 'out' : 'in';
	      var steps = diff / 0.01;
	      var stepLen = len / steps;
	
	      // If the sound hasn't loaded, add it to the load queue to fade when capable.
	      if (self._state !== 'loaded') {
	        self._queue.push({
	          event: 'fade',
	          action: function() {
	            self.fade(from, to, len, id);
	          }
	        });
	
	        return self;
	      }
	
	      // Set the volume to the start position.
	      self.volume(from, id);
	
	      // Fade the volume of one or all sounds.
	      var ids = self._getSoundIds(id);
	      for (var i=0; i<ids.length; i++) {
	        // Get the sound.
	        var sound = self._soundById(ids[i]);
	
	        // Create a linear fade or fall back to timeouts with HTML5 Audio.
	        if (sound) {
	          // Stop the previous fade if no sprite is being used (otherwise, volume handles this).
	          if (!id) {
	            self._stopFade(ids[i]);
	          }
	
	          // If we are using Web Audio, let the native methods do the actual fade.
	          if (self._webAudio && !sound._muted) {
	            var currentTime = Howler.ctx.currentTime;
	            var end = currentTime + (len / 1000);
	            sound._volume = from;
	            sound._node.gain.setValueAtTime(from, currentTime);
	            sound._node.gain.linearRampToValueAtTime(to, end);
	          }
	
	          var vol = from;
	          sound._interval = setInterval(function(soundId, sound) {
	            // Update the volume amount.
	            vol += (dir === 'in' ? 0.01 : -0.01);
	
	            // Make sure the volume is in the right bounds.
	            vol = Math.max(0, vol);
	            vol = Math.min(1, vol);
	
	            // Round to within 2 decimal points.
	            vol = Math.round(vol * 100) / 100;
	
	            // Change the volume.
	            if (self._webAudio) {
	              if (typeof id === 'undefined') {
	                self._volume = vol;
	              }
	
	              sound._volume = vol;
	            } else {
	              self.volume(vol, soundId, true);
	            }
	
	            // When the fade is complete, stop it and fire event.
	            if (vol === to) {
	              clearInterval(sound._interval);
	              sound._interval = null;
	              self.volume(vol, soundId);
	              self._emit('fade', soundId);
	            }
	          }.bind(self, ids[i], sound), stepLen);
	        }
	      }
	
	      return self;
	    },
	
	    /**
	     * Internal method that stops the currently playing fade when
	     * a new fade starts, volume is changed or the sound is stopped.
	     * @param  {Number} id The sound id.
	     * @return {Howl}
	     */
	    _stopFade: function(id) {
	      var self = this;
	      var sound = self._soundById(id);
	
	      if (sound && sound._interval) {
	        if (self._webAudio) {
	          sound._node.gain.cancelScheduledValues(Howler.ctx.currentTime);
	        }
	
	        clearInterval(sound._interval);
	        sound._interval = null;
	        self._emit('fade', id);
	      }
	
	      return self;
	    },
	
	    /**
	     * Get/set the loop parameter on a sound. This method can optionally take 0, 1 or 2 arguments.
	     *   loop() -> Returns the group's loop value.
	     *   loop(id) -> Returns the sound id's loop value.
	     *   loop(loop) -> Sets the loop value for all sounds in this Howl group.
	     *   loop(loop, id) -> Sets the loop value of passed sound id.
	     * @return {Howl/Boolean} Returns self or current loop value.
	     */
	    loop: function() {
	      var self = this;
	      var args = arguments;
	      var loop, id, sound;
	
	      // Determine the values for loop and id.
	      if (args.length === 0) {
	        // Return the grou's loop value.
	        return self._loop;
	      } else if (args.length === 1) {
	        if (typeof args[0] === 'boolean') {
	          loop = args[0];
	          self._loop = loop;
	        } else {
	          // Return this sound's loop value.
	          sound = self._soundById(parseInt(args[0], 10));
	          return sound ? sound._loop : false;
	        }
	      } else if (args.length === 2) {
	        loop = args[0];
	        id = parseInt(args[1], 10);
	      }
	
	      // If no id is passed, get all ID's to be looped.
	      var ids = self._getSoundIds(id);
	      for (var i=0; i<ids.length; i++) {
	        sound = self._soundById(ids[i]);
	
	        if (sound) {
	          sound._loop = loop;
	          if (self._webAudio && sound._node && sound._node.bufferSource) {
	            sound._node.bufferSource.loop = loop;
	          }
	        }
	      }
	
	      return self;
	    },
	
	    /**
	     * Get/set the playback rate of a sound. This method can optionally take 0, 1 or 2 arguments.
	     *   rate() -> Returns the first sound node's current playback rate.
	     *   rate(id) -> Returns the sound id's current playback rate.
	     *   rate(rate) -> Sets the playback rate of all sounds in this Howl group.
	     *   rate(rate, id) -> Sets the playback rate of passed sound id.
	     * @return {Howl/Number} Returns self or the current playback rate.
	     */
	    rate: function() {
	      var self = this;
	      var args = arguments;
	      var rate, id;
	
	      // Determine the values based on arguments.
	      if (args.length === 0) {
	        // We will simply return the current rate of the first node.
	        id = self._sounds[0]._id;
	      } else if (args.length === 1) {
	        // First check if this is an ID, and if not, assume it is a new rate value.
	        var ids = self._getSoundIds();
	        var index = ids.indexOf(args[0]);
	        if (index >= 0) {
	          id = parseInt(args[0], 10);
	        } else {
	          rate = parseFloat(args[0]);
	        }
	      } else if (args.length === 2) {
	        rate = parseFloat(args[0]);
	        id = parseInt(args[1], 10);
	      }
	
	      // Update the playback rate or return the current value.
	      var sound;
	      if (typeof rate === 'number') {
	        // If the sound hasn't loaded, add it to the load queue to change playback rate when capable.
	        if (self._state !== 'loaded') {
	          self._queue.push({
	            event: 'rate',
	            action: function() {
	              self.rate.apply(self, args);
	            }
	          });
	
	          return self;
	        }
	
	        // Set the group rate.
	        if (typeof id === 'undefined') {
	          self._rate = rate;
	        }
	
	        // Update one or all volumes.
	        id = self._getSoundIds(id);
	        for (var i=0; i<id.length; i++) {
	          // Get the sound.
	          sound = self._soundById(id[i]);
	
	          if (sound) {
	            // Keep track of our position when the rate changed and update the playback
	            // start position so we can properly adjust the seek position for time elapsed.
	            sound._rateSeek = self.seek(id[i]);
	            sound._playStart = self._webAudio ? Howler.ctx.currentTime : sound._playStart;
	            sound._rate = rate;
	
	            // Change the playback rate.
	            if (self._webAudio && sound._node && sound._node.bufferSource) {
	              sound._node.bufferSource.playbackRate.value = rate;
	            } else if (sound._node) {
	              sound._node.playbackRate = rate;
	            }
	
	            // Reset the timers.
	            var seek = self.seek(id[i]);
	            var duration = ((self._sprite[sound._sprite][0] + self._sprite[sound._sprite][1]) / 1000) - seek;
	            var timeout = (duration * 1000) / Math.abs(sound._rate);
	
	            // Start a new end timer if sound is already playing.
	            if (self._endTimers[id[i]] || !sound._paused) {
	              self._clearTimer(id[i]);
	              self._endTimers[id[i]] = setTimeout(self._ended.bind(self, sound), timeout);
	            }
	
	            self._emit('rate', sound._id);
	          }
	        }
	      } else {
	        sound = self._soundById(id);
	        return sound ? sound._rate : self._rate;
	      }
	
	      return self;
	    },
	
	    /**
	     * Get/set the seek position of a sound. This method can optionally take 0, 1 or 2 arguments.
	     *   seek() -> Returns the first sound node's current seek position.
	     *   seek(id) -> Returns the sound id's current seek position.
	     *   seek(seek) -> Sets the seek position of the first sound node.
	     *   seek(seek, id) -> Sets the seek position of passed sound id.
	     * @return {Howl/Number} Returns self or the current seek position.
	     */
	    seek: function() {
	      var self = this;
	      var args = arguments;
	      var seek, id;
	
	      // Determine the values based on arguments.
	      if (args.length === 0) {
	        // We will simply return the current position of the first node.
	        id = self._sounds[0]._id;
	      } else if (args.length === 1) {
	        // First check if this is an ID, and if not, assume it is a new seek position.
	        var ids = self._getSoundIds();
	        var index = ids.indexOf(args[0]);
	        if (index >= 0) {
	          id = parseInt(args[0], 10);
	        } else {
	          id = self._sounds[0]._id;
	          seek = parseFloat(args[0]);
	        }
	      } else if (args.length === 2) {
	        seek = parseFloat(args[0]);
	        id = parseInt(args[1], 10);
	      }
	
	      // If there is no ID, bail out.
	      if (typeof id === 'undefined') {
	        return self;
	      }
	
	      // If the sound hasn't loaded, add it to the load queue to seek when capable.
	      if (self._state !== 'loaded') {
	        self._queue.push({
	          event: 'seek',
	          action: function() {
	            self.seek.apply(self, args);
	          }
	        });
	
	        return self;
	      }
	
	      // Get the sound.
	      var sound = self._soundById(id);
	
	      if (sound) {
	        if (typeof seek === 'number' && seek >= 0) {
	          // Pause the sound and update position for restarting playback.
	          var playing = self.playing(id);
	          if (playing) {
	            self.pause(id, true);
	          }
	
	          // Move the position of the track and cancel timer.
	          sound._seek = seek;
	          sound._ended = false;
	          self._clearTimer(id);
	
	          // Restart the playback if the sound was playing.
	          if (playing) {
	            self.play(id, true);
	          }
	
	          // Update the seek position for HTML5 Audio.
	          if (!self._webAudio && sound._node) {
	            sound._node.currentTime = seek;
	          }
	
	          self._emit('seek', id);
	        } else {
	          if (self._webAudio) {
	            var realTime = self.playing(id) ? Howler.ctx.currentTime - sound._playStart : 0;
	            var rateSeek = sound._rateSeek ? sound._rateSeek - sound._seek : 0;
	            return sound._seek + (rateSeek + realTime * Math.abs(sound._rate));
	          } else {
	            return sound._node.currentTime;
	          }
	        }
	      }
	
	      return self;
	    },
	
	    /**
	     * Check if a specific sound is currently playing or not (if id is provided), or check if at least one of the sounds in the group is playing or not.
	     * @param  {Number}  id The sound id to check. If none is passed, the whole sound group is checked.
	     * @return {Boolean} True if playing and false if not.
	     */
	    playing: function(id) {
	      var self = this;
	
	      // Check the passed sound ID (if any).
	      if (typeof id === 'number') {
	        var sound = self._soundById(id);
	        return sound ? !sound._paused : false;
	      }
	
	      // Otherwise, loop through all sounds and check if any are playing.
	      for (var i=0; i<self._sounds.length; i++) {
	        if (!self._sounds[i]._paused) {
	          return true;
	        }
	      }
	
	      return false;
	    },
	
	    /**
	     * Get the duration of this sound. Passing a sound id will return the sprite duration.
	     * @param  {Number} id The sound id to check. If none is passed, return full source duration.
	     * @return {Number} Audio duration in seconds.
	     */
	    duration: function(id) {
	      var self = this;
	      var duration = self._duration;
	
	      // If we pass an ID, get the sound and return the sprite length.
	      var sound = self._soundById(id);
	      if (sound) {
	        duration = self._sprite[sound._sprite][1] / 1000;
	      }
	
	      return duration;
	    },
	
	    /**
	     * Returns the current loaded state of this Howl.
	     * @return {String} 'unloaded', 'loading', 'loaded'
	     */
	    state: function() {
	      return this._state;
	    },
	
	    /**
	     * Unload and destroy the current Howl object.
	     * This will immediately stop all sound instances attached to this group.
	     */
	    unload: function() {
	      var self = this;
	
	      // Stop playing any active sounds.
	      var sounds = self._sounds;
	      for (var i=0; i<sounds.length; i++) {
	        // Stop the sound if it is currently playing.
	        if (!sounds[i]._paused) {
	          self.stop(sounds[i]._id);
	          self._emit('end', sounds[i]._id);
	        }
	
	        // Remove the source or disconnect.
	        if (!self._webAudio) {
	          // Set the source to 0-second silence to stop any downloading.
	          sounds[i]._node.src = 'data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQAAAAA=';
	
	          // Remove any event listeners.
	          sounds[i]._node.removeEventListener('error', sounds[i]._errorFn, false);
	          sounds[i]._node.removeEventListener(Howler._canPlayEvent, sounds[i]._loadFn, false);
	        }
	
	        // Empty out all of the nodes.
	        delete sounds[i]._node;
	
	        // Make sure all timers are cleared out.
	        self._clearTimer(sounds[i]._id);
	
	        // Remove the references in the global Howler object.
	        var index = Howler._howls.indexOf(self);
	        if (index >= 0) {
	          Howler._howls.splice(index, 1);
	        }
	      }
	
	      // Delete this sound from the cache (if no other Howl is using it).
	      var remCache = true;
	      for (i=0; i<Howler._howls.length; i++) {
	        if (Howler._howls[i]._src === self._src) {
	          remCache = false;
	          break;
	        }
	      }
	
	      if (cache && remCache) {
	        delete cache[self._src];
	      }
	
	      // Clear out `self`.
	      self._state = 'unloaded';
	      self._sounds = [];
	      self = null;
	
	      return null;
	    },
	
	    /**
	     * Listen to a custom event.
	     * @param  {String}   event Event name.
	     * @param  {Function} fn    Listener to call.
	     * @param  {Number}   id    (optional) Only listen to events for this sound.
	     * @param  {Number}   once  (INTERNAL) Marks event to fire only once.
	     * @return {Howl}
	     */
	    on: function(event, fn, id, once) {
	      var self = this;
	      var events = self['_on' + event];
	
	      if (typeof fn === 'function') {
	        events.push(once ? {id: id, fn: fn, once: once} : {id: id, fn: fn});
	      }
	
	      return self;
	    },
	
	    /**
	     * Remove a custom event. Call without parameters to remove all events.
	     * @param  {String}   event Event name.
	     * @param  {Function} fn    Listener to remove. Leave empty to remove all.
	     * @param  {Number}   id    (optional) Only remove events for this sound.
	     * @return {Howl}
	     */
	    off: function(event, fn, id) {
	      var self = this;
	      var events = self['_on' + event];
	      var i = 0;
	
	      if (fn) {
	        // Loop through event store and remove the passed function.
	        for (i=0; i<events.length; i++) {
	          if (fn === events[i].fn && id === events[i].id) {
	            events.splice(i, 1);
	            break;
	          }
	        }
	      } else if (event) {
	        // Clear out all events of this type.
	        self['_on' + event] = [];
	      } else {
	        // Clear out all events of every type.
	        var keys = Object.keys(self);
	        for (i=0; i<keys.length; i++) {
	          if ((keys[i].indexOf('_on') === 0) && Array.isArray(self[keys[i]])) {
	            self[keys[i]] = [];
	          }
	        }
	      }
	
	      return self;
	    },
	
	    /**
	     * Listen to a custom event and remove it once fired.
	     * @param  {String}   event Event name.
	     * @param  {Function} fn    Listener to call.
	     * @param  {Number}   id    (optional) Only listen to events for this sound.
	     * @return {Howl}
	     */
	    once: function(event, fn, id) {
	      var self = this;
	
	      // Setup the event listener.
	      self.on(event, fn, id, 1);
	
	      return self;
	    },
	
	    /**
	     * Emit all events of a specific type and pass the sound id.
	     * @param  {String} event Event name.
	     * @param  {Number} id    Sound ID.
	     * @param  {Number} msg   Message to go with event.
	     * @return {Howl}
	     */
	    _emit: function(event, id, msg) {
	      var self = this;
	      var events = self['_on' + event];
	
	      // Loop through event store and fire all functions.
	      for (var i=events.length-1; i>=0; i--) {
	        if (!events[i].id || events[i].id === id || event === 'load') {
	          setTimeout(function(fn) {
	            fn.call(this, id, msg);
	          }.bind(self, events[i].fn), 0);
	
	          // If this event was setup with `once`, remove it.
	          if (events[i].once) {
	            self.off(event, events[i].fn, events[i].id);
	          }
	        }
	      }
	
	      return self;
	    },
	
	    /**
	     * Queue of actions initiated before the sound has loaded.
	     * These will be called in sequence, with the next only firing
	     * after the previous has finished executing (even if async like play).
	     * @return {Howl}
	     */
	    _loadQueue: function() {
	      var self = this;
	
	      if (self._queue.length > 0) {
	        var task = self._queue[0];
	
	        // don't move onto the next task until this one is done
	        self.once(task.event, function() {
	          self._queue.shift();
	          self._loadQueue();
	        });
	
	        task.action();
	      }
	
	      return self;
	    },
	
	    /**
	     * Fired when playback ends at the end of the duration.
	     * @param  {Sound} sound The sound object to work with.
	     * @return {Howl}
	     */
	    _ended: function(sound) {
	      var self = this;
	      var sprite = sound._sprite;
	
	      // Should this sound loop?
	      var loop = !!(sound._loop || self._sprite[sprite][2]);
	
	      // Fire the ended event.
	      self._emit('end', sound._id);
	
	      // Restart the playback for HTML5 Audio loop.
	      if (!self._webAudio && loop) {
	        self.stop(sound._id, true).play(sound._id);
	      }
	
	      // Restart this timer if on a Web Audio loop.
	      if (self._webAudio && loop) {
	        self._emit('play', sound._id);
	        sound._seek = sound._start || 0;
	        sound._rateSeek = 0;
	        sound._playStart = Howler.ctx.currentTime;
	
	        var timeout = ((sound._stop - sound._start) * 1000) / Math.abs(sound._rate);
	        self._endTimers[sound._id] = setTimeout(self._ended.bind(self, sound), timeout);
	      }
	
	      // Mark the node as paused.
	      if (self._webAudio && !loop) {
	        sound._paused = true;
	        sound._ended = true;
	        sound._seek = sound._start || 0;
	        sound._rateSeek = 0;
	        self._clearTimer(sound._id);
	
	        // Clean up the buffer source.
	        self._cleanBuffer(sound._node);
	
	        // Attempt to auto-suspend AudioContext if no sounds are still playing.
	        Howler._autoSuspend();
	      }
	
	      // When using a sprite, end the track.
	      if (!self._webAudio && !loop) {
	        self.stop(sound._id);
	      }
	
	      return self;
	    },
	
	    /**
	     * Clear the end timer for a sound playback.
	     * @param  {Number} id The sound ID.
	     * @return {Howl}
	     */
	    _clearTimer: function(id) {
	      var self = this;
	
	      if (self._endTimers[id]) {
	        clearTimeout(self._endTimers[id]);
	        delete self._endTimers[id];
	      }
	
	      return self;
	    },
	
	    /**
	     * Return the sound identified by this ID, or return null.
	     * @param  {Number} id Sound ID
	     * @return {Object}    Sound object or null.
	     */
	    _soundById: function(id) {
	      var self = this;
	
	      // Loop through all sounds and find the one with this ID.
	      for (var i=0; i<self._sounds.length; i++) {
	        if (id === self._sounds[i]._id) {
	          return self._sounds[i];
	        }
	      }
	
	      return null;
	    },
	
	    /**
	     * Return an inactive sound from the pool or create a new one.
	     * @return {Sound} Sound playback object.
	     */
	    _inactiveSound: function() {
	      var self = this;
	
	      self._drain();
	
	      // Find the first inactive node to recycle.
	      for (var i=0; i<self._sounds.length; i++) {
	        if (self._sounds[i]._ended) {
	          return self._sounds[i].reset();
	        }
	      }
	
	      // If no inactive node was found, create a new one.
	      return new Sound(self);
	    },
	
	    /**
	     * Drain excess inactive sounds from the pool.
	     */
	    _drain: function() {
	      var self = this;
	      var limit = self._pool;
	      var cnt = 0;
	      var i = 0;
	
	      // If there are less sounds than the max pool size, we are done.
	      if (self._sounds.length < limit) {
	        return;
	      }
	
	      // Count the number of inactive sounds.
	      for (i=0; i<self._sounds.length; i++) {
	        if (self._sounds[i]._ended) {
	          cnt++;
	        }
	      }
	
	      // Remove excess inactive sounds, going in reverse order.
	      for (i=self._sounds.length - 1; i>=0; i--) {
	        if (cnt <= limit) {
	          return;
	        }
	
	        if (self._sounds[i]._ended) {
	          // Disconnect the audio source when using Web Audio.
	          if (self._webAudio && self._sounds[i]._node) {
	            self._sounds[i]._node.disconnect(0);
	          }
	
	          // Remove sounds until we have the pool size.
	          self._sounds.splice(i, 1);
	          cnt--;
	        }
	      }
	    },
	
	    /**
	     * Get all ID's from the sounds pool.
	     * @param  {Number} id Only return one ID if one is passed.
	     * @return {Array}    Array of IDs.
	     */
	    _getSoundIds: function(id) {
	      var self = this;
	
	      if (typeof id === 'undefined') {
	        var ids = [];
	        for (var i=0; i<self._sounds.length; i++) {
	          ids.push(self._sounds[i]._id);
	        }
	
	        return ids;
	      } else {
	        return [id];
	      }
	    },
	
	    /**
	     * Load the sound back into the buffer source.
	     * @param  {Sound} sound The sound object to work with.
	     * @return {Howl}
	     */
	    _refreshBuffer: function(sound) {
	      var self = this;
	
	      // Setup the buffer source for playback.
	      sound._node.bufferSource = Howler.ctx.createBufferSource();
	      sound._node.bufferSource.buffer = cache[self._src];
	
	      // Connect to the correct node.
	      if (sound._panner) {
	        sound._node.bufferSource.connect(sound._panner);
	      } else {
	        sound._node.bufferSource.connect(sound._node);
	      }
	
	      // Setup looping and playback rate.
	      sound._node.bufferSource.loop = sound._loop;
	      if (sound._loop) {
	        sound._node.bufferSource.loopStart = sound._start || 0;
	        sound._node.bufferSource.loopEnd = sound._stop;
	      }
	      sound._node.bufferSource.playbackRate.value = sound._rate;
	
	      return self;
	    },
	
	    /**
	     * Prevent memory leaks by cleaning up the buffer source after playback.
	     * @param  {Object} node Sound's audio node containing the buffer source.
	     * @return {Howl}
	     */
	    _cleanBuffer: function(node) {
	      var self = this;
	
	      if (self._scratchBuffer) {
	        node.bufferSource.onended = null;
	        node.bufferSource.disconnect(0);
	        try { node.bufferSource.buffer = self._scratchBuffer; } catch(e) {}
	      }
	      node.bufferSource = null;
	
	      return self;
	    }
	  };
	
	  /** Single Sound Methods **/
	  /***************************************************************************/
	
	  /**
	   * Setup the sound object, which each node attached to a Howl group is contained in.
	   * @param {Object} howl The Howl parent group.
	   */
	  var Sound = function(howl) {
	    this._parent = howl;
	    this.init();
	  };
	  Sound.prototype = {
	    /**
	     * Initialize a new Sound object.
	     * @return {Sound}
	     */
	    init: function() {
	      var self = this;
	      var parent = self._parent;
	
	      // Setup the default parameters.
	      self._muted = parent._muted;
	      self._loop = parent._loop;
	      self._volume = parent._volume;
	      self._muted = parent._muted;
	      self._rate = parent._rate;
	      self._seek = 0;
	      self._paused = true;
	      self._ended = true;
	      self._sprite = '__default';
	
	      // Generate a unique ID for this sound.
	      self._id = Math.round(Date.now() * Math.random());
	
	      // Add itself to the parent's pool.
	      parent._sounds.push(self);
	
	      // Create the new node.
	      self.create();
	
	      return self;
	    },
	
	    /**
	     * Create and setup a new sound object, whether HTML5 Audio or Web Audio.
	     * @return {Sound}
	     */
	    create: function() {
	      var self = this;
	      var parent = self._parent;
	      var volume = (Howler._muted || self._muted || self._parent._muted) ? 0 : self._volume;
	
	      if (parent._webAudio) {
	        // Create the gain node for controlling volume (the source will connect to this).
	        self._node = (typeof Howler.ctx.createGain === 'undefined') ? Howler.ctx.createGainNode() : Howler.ctx.createGain();
	        self._node.gain.setValueAtTime(volume, Howler.ctx.currentTime);
	        self._node.paused = true;
	        self._node.connect(Howler.masterGain);
	      } else {
	        self._node = new Audio();
	
	        // Listen for errors (http://dev.w3.org/html5/spec-author-view/spec.html#mediaerror).
	        self._errorFn = self._errorListener.bind(self);
	        self._node.addEventListener('error', self._errorFn, false);
	
	        // Listen for 'canplaythrough' event to let us know the sound is ready.
	        self._loadFn = self._loadListener.bind(self);
	        self._node.addEventListener(Howler._canPlayEvent, self._loadFn, false);
	
	        // Setup the new audio node.
	        self._node.src = parent._src;
	        self._node.preload = 'auto';
	        self._node.volume = volume * Howler.volume();
	
	        // Begin loading the source.
	        self._node.load();
	      }
	
	      return self;
	    },
	
	    /**
	     * Reset the parameters of this sound to the original state (for recycle).
	     * @return {Sound}
	     */
	    reset: function() {
	      var self = this;
	      var parent = self._parent;
	
	      // Reset all of the parameters of this sound.
	      self._muted = parent._muted;
	      self._loop = parent._loop;
	      self._volume = parent._volume;
	      self._muted = parent._muted;
	      self._rate = parent._rate;
	      self._seek = 0;
	      self._rateSeek = 0;
	      self._paused = true;
	      self._ended = true;
	      self._sprite = '__default';
	
	      // Generate a new ID so that it isn't confused with the previous sound.
	      self._id = Math.round(Date.now() * Math.random());
	
	      return self;
	    },
	
	    /**
	     * HTML5 Audio error listener callback.
	     */
	    _errorListener: function() {
	      var self = this;
	
	      if (self._node.error && self._node.error.code === 4) {
	        Howler.noAudio = true;
	      }
	
	      // Fire an error event and pass back the code.
	      self._parent._emit('loaderror', self._id, self._node.error ? self._node.error.code : 0);
	
	      // Clear the event listener.
	      self._node.removeEventListener('error', self._errorListener, false);
	    },
	
	    /**
	     * HTML5 Audio canplaythrough listener callback.
	     */
	    _loadListener: function() {
	      var self = this;
	      var parent = self._parent;
	
	      // Round up the duration to account for the lower precision in HTML5 Audio.
	      parent._duration = Math.ceil(self._node.duration * 10) / 10;
	
	      // Setup a sprite if none is defined.
	      if (Object.keys(parent._sprite).length === 0) {
	        parent._sprite = {__default: [0, parent._duration * 1000]};
	      }
	
	      if (parent._state !== 'loaded') {
	        parent._state = 'loaded';
	        parent._emit('load');
	        parent._loadQueue();
	      }
	
	      if (parent._autoplay) {
	        parent.play();
	      }
	
	      // Clear the event listener.
	      self._node.removeEventListener(Howler._canPlayEvent, self._loadFn, false);
	    }
	  };
	
	  /** Helper Methods **/
	  /***************************************************************************/
	
	  var cache = {};
	
	  /**
	   * Buffer a sound from URL, Data URI or cache and decode to audio source (Web Audio API).
	   * @param  {Howl} self
	   */
	  var loadBuffer = function(self) {
	    var url = self._src;
	
	    // Check if the buffer has already been cached and use it instead.
	    if (cache[url]) {
	      // Set the duration from the cache.
	      self._duration = cache[url].duration;
	
	      // Load the sound into this Howl.
	      loadSound(self);
	
	      return;
	    }
	
	    if (/^data:[^;]+;base64,/.test(url)) {
	      // Decode the base64 data URI without XHR, since some browsers don't support it.
	      var data = atob(url.split(',')[1]);
	      var dataView = new Uint8Array(data.length);
	      for (var i=0; i<data.length; ++i) {
	        dataView[i] = data.charCodeAt(i);
	      }
	
	      decodeAudioData(dataView.buffer, self);
	    } else {
	      // Load the buffer from the URL.
	      var xhr = new XMLHttpRequest();
	      xhr.open('GET', url, true);
	      xhr.responseType = 'arraybuffer';
	      xhr.onload = function() {
	        // Make sure we get a successful response back.
	        var code = (xhr.status + '')[0];
	        if (code !== '0' && code !== '2' && code !== '3') {
	          self._emit('loaderror', null, 'Failed loading audio file with status: ' + xhr.status + '.');
	          return;
	        }
	
	        decodeAudioData(xhr.response, self);
	      };
	      xhr.onerror = function() {
	        // If there is an error, switch to HTML5 Audio.
	        if (self._webAudio) {
	          self._html5 = true;
	          self._webAudio = false;
	          self._sounds = [];
	          delete cache[url];
	          self.load();
	        }
	      };
	      safeXhrSend(xhr);
	    }
	  };
	
	  /**
	   * Send the XHR request wrapped in a try/catch.
	   * @param  {Object} xhr XHR to send.
	   */
	  var safeXhrSend = function(xhr) {
	    try {
	      xhr.send();
	    } catch (e) {
	      xhr.onerror();
	    }
	  };
	
	  /**
	   * Decode audio data from an array buffer.
	   * @param  {ArrayBuffer} arraybuffer The audio data.
	   * @param  {Howl}        self
	   */
	  var decodeAudioData = function(arraybuffer, self) {
	    // Decode the buffer into an audio source.
	    Howler.ctx.decodeAudioData(arraybuffer, function(buffer) {
	      if (buffer && self._sounds.length > 0) {
	        cache[self._src] = buffer;
	        loadSound(self, buffer);
	      }
	    }, function() {
	      self._emit('loaderror', null, 'Decoding audio data failed.');
	    });
	  };
	
	  /**
	   * Sound is now loaded, so finish setting everything up and fire the loaded event.
	   * @param  {Howl} self
	   * @param  {Object} buffer The decoded buffer sound source.
	   */
	  var loadSound = function(self, buffer) {
	    // Set the duration.
	    if (buffer && !self._duration) {
	      self._duration = buffer.duration;
	    }
	
	    // Setup a sprite if none is defined.
	    if (Object.keys(self._sprite).length === 0) {
	      self._sprite = {__default: [0, self._duration * 1000]};
	    }
	
	    // Fire the loaded event.
	    if (self._state !== 'loaded') {
	      self._state = 'loaded';
	      self._emit('load');
	      self._loadQueue();
	    }
	
	    // Begin playback if specified.
	    if (self._autoplay) {
	      self.play();
	    }
	  };
	
	  /**
	   * Setup the audio context when available, or switch to HTML5 Audio mode.
	   */
	  var setupAudioContext = function() {
	    Howler.noAudio = false;
	
	    // Check if we are using Web Audio and setup the AudioContext if we are.
	    try {
	      if (typeof AudioContext !== 'undefined') {
	        Howler.ctx = new AudioContext();
	      } else if (typeof webkitAudioContext !== 'undefined') {
	        Howler.ctx = new webkitAudioContext();
	      } else {
	        Howler.usingWebAudio = false;
	      }
	    } catch(e) {
	      Howler.usingWebAudio = false;
	    }
	
	    if (!Howler.usingWebAudio) {
	      // No audio is available on this system if noAudio is set to true.
	      if (typeof Audio !== 'undefined') {
	        try {
	          var test = new Audio();
	
	          // Check if the canplaythrough event is available.
	          if (typeof test.oncanplaythrough === 'undefined') {
	            Howler._canPlayEvent = 'canplay';
	          }
	        } catch(e) {
	          Howler.noAudio = true;
	        }
	      } else {
	        Howler.noAudio = true;
	      }
	    }
	
	    // Test to make sure audio isn't disabled in Internet Explorer
	    try {
	      var test = new Audio();
	      if (test.muted) {
	        Howler.noAudio = true;
	      }
	    } catch (e) {}
	
	    // Check if a webview is being used on iOS8 or earlier (rather than the browser).
	    // If it is, disable Web Audio as it causes crashing.
	    var iOS = (/iP(hone|od|ad)/.test(Howler._navigator && Howler._navigator.platform));
	    var appVersion = Howler._navigator && Howler._navigator.appVersion.match(/OS (\d+)_(\d+)_?(\d+)?/);
	    var version = appVersion ? parseInt(appVersion[1], 10) : null;
	    if (iOS && version && version < 9) {
	      var safari = /safari/.test(Howler._navigator && Howler._navigator.userAgent.toLowerCase());
	      if (Howler._navigator && Howler._navigator.standalone && !safari || Howler._navigator && !Howler._navigator.standalone && !safari) {
	        Howler.usingWebAudio = false;
	      }
	    }
	
	    // Create and expose the master GainNode when using Web Audio (useful for plugins or advanced usage).
	    if (Howler.usingWebAudio) {
	      Howler.masterGain = (typeof Howler.ctx.createGain === 'undefined') ? Howler.ctx.createGainNode() : Howler.ctx.createGain();
	      Howler.masterGain.gain.value = 1;
	      Howler.masterGain.connect(Howler.ctx.destination);
	    }
	
	    // Re-run the setup on Howler.
	    Howler._setup();
	  };
	
	  // Add support for AMD (Asynchronous Module Definition) libraries such as require.js.
	  if (true) {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {
	      return {
	        Howler: Howler,
	        Howl: Howl
	      };
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  }
	
	  // Add support for CommonJS libraries such as browserify.
	  if (true) {
	    exports.Howler = Howler;
	    exports.Howl = Howl;
	  }
	
	  // Define globally in case AMD is not available or unused.
	  if (typeof window !== 'undefined') {
	    window.HowlerGlobal = HowlerGlobal;
	    window.Howler = Howler;
	    window.Howl = Howl;
	    window.Sound = Sound;
	  } else if (typeof global !== 'undefined') { // Add to global in Node.js (for testing, etc).
	    global.HowlerGlobal = HowlerGlobal;
	    global.Howler = Howler;
	    global.Howl = Howl;
	    global.Sound = Sound;
	  }
	})();
	
	
	/*!
	 *  Spatial Plugin - Adds support for stereo and 3D audio where Web Audio is supported.
	 *  
	 *  howler.js v2.0.0
	 *  howlerjs.com
	 *
	 *  (c) 2013-2016, James Simpson of GoldFire Studios
	 *  goldfirestudios.com
	 *
	 *  MIT License
	 */
	
	(function() {
	
	  'use strict';
	
	  // Setup default properties.
	  HowlerGlobal.prototype._pos = [0, 0, 0];
	  HowlerGlobal.prototype._orientation = [0, 0, -1, 0, 1, 0];
	  
	  /** Global Methods **/
	  /***************************************************************************/
	
	  /**
	   * Helper method to update the stereo panning position of all current Howls.
	   * Future Howls will not use this value unless explicitely set.
	   * @param  {Number} pan A value of -1.0 is all the way left and 1.0 is all the way right.
	   * @return {Howler/Number}     Self or current stereo panning value.
	   */
	  HowlerGlobal.prototype.stereo = function(pan) {
	    var self = this;
	
	    // Stop right here if not using Web Audio.
	    if (!self.ctx || !self.ctx.listener) {
	      return self;
	    }
	
	    // Loop through all Howls and update their stereo panning.
	    for (var i=self._howls.length-1; i>=0; i--) {
	      self._howls[i].stereo(pan);
	    }
	
	    return self;
	  };
	
	  /**
	   * Get/set the position of the listener in 3D cartesian space. Sounds using
	   * 3D position will be relative to the listener's position.
	   * @param  {Number} x The x-position of the listener.
	   * @param  {Number} y The y-position of the listener.
	   * @param  {Number} z The z-position of the listener.
	   * @return {Howler/Array}   Self or current listener position.
	   */
	  HowlerGlobal.prototype.pos = function(x, y, z) {
	    var self = this;
	
	    // Stop right here if not using Web Audio.
	    if (!self.ctx || !self.ctx.listener) {
	      return self;
	    }
	
	    // Set the defaults for optional 'y' & 'z'.
	    y = (typeof y !== 'number') ? self._pos[1] : y;
	    z = (typeof z !== 'number') ? self._pos[2] : z;
	
	    if (typeof x === 'number') {
	      self._pos = [x, y, z];
	      self.ctx.listener.setPosition(self._pos[0], self._pos[1], self._pos[2]);
	    } else {
	      return self._pos;
	    }
	
	    return self;
	  };
	
	  /**
	   * Get/set the direction the listener is pointing in the 3D cartesian space.
	   * A front and up vector must be provided. The front is the direction the
	   * face of the listener is pointing, and up is the direction the top of the
	   * listener is pointing. Thus, these values are expected to be at right angles
	   * from each other.
	   * @param  {Number} x   The x-orientation of the listener.
	   * @param  {Number} y   The y-orientation of the listener.
	   * @param  {Number} z   The z-orientation of the listener.
	   * @param  {Number} xUp The x-orientation of the top of the listener.
	   * @param  {Number} yUp The y-orientation of the top of the listener.
	   * @param  {Number} zUp The z-orientation of the top of the listener.
	   * @return {Howler/Array}     Returns self or the current orientation vectors.
	   */
	  HowlerGlobal.prototype.orientation = function(x, y, z, xUp, yUp, zUp) {
	    var self = this;
	
	    // Stop right here if not using Web Audio.
	    if (!self.ctx || !self.ctx.listener) {
	      return self;
	    }
	
	    // Set the defaults for optional 'y' & 'z'.
	    var or = self._orientation;
	    y = (typeof y !== 'number') ? or[1] : y;
	    z = (typeof z !== 'number') ? or[2] : z;
	    xUp = (typeof xUp !== 'number') ? or[3] : xUp;
	    yUp = (typeof yUp !== 'number') ? or[4] : yUp;
	    zUp = (typeof zUp !== 'number') ? or[5] : zUp;
	
	    if (typeof x === 'number') {
	      self._orientation = [x, y, z, xUp, yUp, zUp];
	      self.ctx.listener.setOrientation(x, y, z, xUp, yUp, zUp);
	    } else {
	      return or;
	    }
	
	    return self;
	  };
	
	  /** Group Methods **/
	  /***************************************************************************/
	
	  /**
	   * Add new properties to the core init.
	   * @param  {Function} _super Core init method.
	   * @return {Howl}
	   */
	  Howl.prototype.init = (function(_super) {
	    return function(o) {
	      var self = this;
	
	      // Setup user-defined default properties.
	      self._orientation = o.orientation || [1, 0, 0];
	      self._stereo = o.stereo || null;
	      self._pos = o.pos || null;
	      self._pannerAttr = {
	        coneInnerAngle: typeof o.coneInnerAngle !== 'undefined' ? o.coneInnerAngle : 360,
	        coneOuterAngle: typeof o.coneOuterAngle !== 'undefined' ? o.coneOuterAngle : 360,
	        coneOuterGain: typeof o.coneOuterGain !== 'undefined' ? o.coneOuterGain : 0,
	        distanceModel: typeof o.distanceModel !== 'undefined' ? o.distanceModel : 'inverse',
	        maxDistance: typeof o.maxDistance !== 'undefined' ? o.maxDistance : 10000,
	        panningModel: typeof o.panningModel !== 'undefined' ? o.panningModel : 'HRTF',
	        refDistance: typeof o.refDistance !== 'undefined' ? o.refDistance : 1,
	        rolloffFactor: typeof o.rolloffFactor !== 'undefined' ? o.rolloffFactor : 1
	      };
	
	      // Setup event listeners.
	      self._onstereo = o.onstereo ? [{fn: o.onstereo}] : [];
	      self._onpos = o.onpos ? [{fn: o.onpos}] : [];
	      self._onorientation = o.onorientation ? [{fn: o.onorientation}] : [];
	
	      // Complete initilization with howler.js core's init function.
	      return _super.call(this, o);
	    };
	  })(Howl.prototype.init);
	
	  /**
	   * Get/set the stereo panning of the audio source for this sound or all in the group.
	   * @param  {Number} pan  A value of -1.0 is all the way left and 1.0 is all the way right.
	   * @param  {Number} id (optional) The sound ID. If none is passed, all in group will be updated.
	   * @return {Howl/Number}    Returns self or the current stereo panning value.
	   */
	  Howl.prototype.stereo = function(pan, id) {
	    var self = this;
	
	    // Stop right here if not using Web Audio.
	    if (!self._webAudio) {
	      return self;
	    }
	
	    // If the sound hasn't loaded, add it to the load queue to change stereo pan when capable.
	    if (self._state !== 'loaded') {
	      self._queue.push({
	        event: 'stereo',
	        action: function() {
	          self.stereo(pan, id);
	        }
	      });
	
	      return self;
	    }
	
	    // Check for PannerStereoNode support and fallback to PannerNode if it doesn't exist.
	    var pannerType = (typeof Howler.ctx.createStereoPanner === 'undefined') ? 'spatial' : 'stereo';
	
	    // Setup the group's stereo panning if no ID is passed.
	    if (typeof id === 'undefined') {
	      // Return the group's stereo panning if no parameters are passed.
	      if (typeof pan === 'number') {
	        self._stereo = pan;
	        self._pos = [pan, 0, 0];
	      } else {
	        return self._stereo;
	      }
	    }
	
	    // Change the streo panning of one or all sounds in group.
	    var ids = self._getSoundIds(id);
	    for (var i=0; i<ids.length; i++) {
	      // Get the sound.
	      var sound = self._soundById(ids[i]);
	
	      if (sound) {
	        if (typeof pan === 'number') {
	          sound._stereo = pan;
	          sound._pos = [pan, 0, 0];
	
	          if (sound._node) {
	            // If we are falling back, make sure the panningModel is equalpower.
	            sound._pannerAttr.panningModel = 'equalpower';
	
	            // Check if there is a panner setup and create a new one if not.
	            if (!sound._panner || !sound._panner.pan) {
	              setupPanner(sound, pannerType);
	            }
	
	            if (pannerType === 'spatial') {
	              sound._panner.setPosition(pan, 0, 0);
	            } else {
	              sound._panner.pan.value = pan;
	            }
	          }
	
	          self._emit('stereo', sound._id);
	        } else {
	          return sound._stereo;
	        }
	      }
	    }
	
	    return self;
	  };
	
	  /**
	   * Get/set the 3D spatial position of the audio source for this sound or
	   * all in the group. The most common usage is to set the 'x' position for
	   * left/right panning. Setting any value higher than 1.0 will begin to
	   * decrease the volume of the sound as it moves further away.
	   * @param  {Number} x  The x-position of the audio from -1000.0 to 1000.0.
	   * @param  {Number} y  The y-position of the audio from -1000.0 to 1000.0.
	   * @param  {Number} z  The z-position of the audio from -1000.0 to 1000.0.
	   * @param  {Number} id (optional) The sound ID. If none is passed, all in group will be updated.
	   * @return {Howl/Array}    Returns self or the current 3D spatial position: [x, y, z].
	   */
	  Howl.prototype.pos = function(x, y, z, id) {
	    var self = this;
	
	    // Stop right here if not using Web Audio.
	    if (!self._webAudio) {
	      return self;
	    }
	
	    // If the sound hasn't loaded, add it to the load queue to change position when capable.
	    if (self._state !== 'loaded') {
	      self._queue.push({
	        event: 'pos',
	        action: function() {
	          self.pos(x, y, z, id);
	        }
	      });
	
	      return self;
	    }
	
	    // Set the defaults for optional 'y' & 'z'.
	    y = (typeof y !== 'number') ? 0 : y;
	    z = (typeof z !== 'number') ? -0.5 : z;
	
	    // Setup the group's spatial position if no ID is passed.
	    if (typeof id === 'undefined') {
	      // Return the group's spatial position if no parameters are passed.
	      if (typeof x === 'number') {
	        self._pos = [x, y, z];
	      } else {
	        return self._pos;
	      }
	    }
	
	    // Change the spatial position of one or all sounds in group.
	    var ids = self._getSoundIds(id);
	    for (var i=0; i<ids.length; i++) {
	      // Get the sound.
	      var sound = self._soundById(ids[i]);
	
	      if (sound) {
	        if (typeof x === 'number') {
	          sound._pos = [x, y, z];
	
	          if (sound._node) {
	            // Check if there is a panner setup and create a new one if not.
	            if (!sound._panner || sound._panner.pan) {
	              setupPanner(sound, 'spatial');
	            }
	
	            sound._panner.setPosition(x, y, z);
	          }
	
	          self._emit('pos', sound._id);
	        } else {
	          return sound._pos;
	        }
	      }
	    }
	
	    return self;
	  };
	
	  /**
	   * Get/set the direction the audio source is pointing in the 3D cartesian coordinate
	   * space. Depending on how direction the sound is, based on the `cone` attributes,
	   * a sound pointing away from the listener can be quiet or silent.
	   * @param  {Number} x  The x-orientation of the source.
	   * @param  {Number} y  The y-orientation of the source.
	   * @param  {Number} z  The z-orientation of the source.
	   * @param  {Number} id (optional) The sound ID. If none is passed, all in group will be updated.
	   * @return {Howl/Array}    Returns self or the current 3D spatial orientation: [x, y, z].
	   */
	  Howl.prototype.orientation = function(x, y, z, id) {
	    var self = this;
	
	    // Stop right here if not using Web Audio.
	    if (!self._webAudio) {
	      return self;
	    }
	
	    // If the sound hasn't loaded, add it to the load queue to change orientation when capable.
	    if (self._state !== 'loaded') {
	      self._queue.push({
	        event: 'orientation',
	        action: function() {
	          self.orientation(x, y, z, id);
	        }
	      });
	
	      return self;
	    }
	
	    // Set the defaults for optional 'y' & 'z'.
	    y = (typeof y !== 'number') ? self._orientation[1] : y;
	    z = (typeof z !== 'number') ? self._orientation[2] : z;
	
	    // Setup the group's spatial orientation if no ID is passed.
	    if (typeof id === 'undefined') {
	      // Return the group's spatial orientation if no parameters are passed.
	      if (typeof x === 'number') {
	        self._orientation = [x, y, z];
	      } else {
	        return self._orientation;
	      }
	    }
	
	    // Change the spatial orientation of one or all sounds in group.
	    var ids = self._getSoundIds(id);
	    for (var i=0; i<ids.length; i++) {
	      // Get the sound.
	      var sound = self._soundById(ids[i]);
	
	      if (sound) {
	        if (typeof x === 'number') {
	          sound._orientation = [x, y, z];
	
	          if (sound._node) {
	            // Check if there is a panner setup and create a new one if not.
	            if (!sound._panner) {
	              // Make sure we have a position to setup the node with.
	              if (!sound._pos) {
	                sound._pos = self._pos || [0, 0, -0.5];
	              }
	
	              setupPanner(sound, 'spatial');
	            }
	
	            sound._panner.setOrientation(x, y, z);
	          }
	
	          self._emit('orientation', sound._id);
	        } else {
	          return sound._orientation;
	        }
	      }
	    }
	
	    return self;
	  };
	
	  /**
	   * Get/set the panner node's attributes for a sound or group of sounds.
	   * This method can optionall take 0, 1 or 2 arguments.
	   *   pannerAttr() -> Returns the group's values.
	   *   pannerAttr(id) -> Returns the sound id's values.
	   *   pannerAttr(o) -> Set's the values of all sounds in this Howl group.
	   *   pannerAttr(o, id) -> Set's the values of passed sound id.
	   *
	   *   Attributes:
	   *     coneInnerAngle - (360 by default) There will be no volume reduction inside this angle.
	   *     coneOuterAngle - (360 by default) The volume will be reduced to a constant value of
	   *                      `coneOuterGain` outside this angle.
	   *     coneOuterGain - (0 by default) The amount of volume reduction outside of `coneOuterAngle`.
	   *     distanceModel - ('inverse' by default) Determines algorithm to use to reduce volume as audio moves
	   *                      away from listener. Can be `linear`, `inverse` or `exponential`.
	   *     maxDistance - (10000 by default) Volume won't reduce between source/listener beyond this distance.
	   *     panningModel - ('HRTF' by default) Determines which spatialization algorithm is used to position audio.
	   *                     Can be `HRTF` or `equalpower`.
	   *     refDistance - (1 by default) A reference distance for reducing volume as the source
	   *                    moves away from the listener.
	   *     rolloffFactor - (1 by default) How quickly the volume reduces as source moves from listener.
	   * 
	   * @return {Howl/Object} Returns self or current panner attributes.
	   */
	  Howl.prototype.pannerAttr = function() {
	    var self = this;
	    var args = arguments;
	    var o, id, sound;
	
	    // Stop right here if not using Web Audio.
	    if (!self._webAudio) {
	      return self;
	    }
	
	    // Determine the values based on arguments.
	    if (args.length === 0) {
	      // Return the group's panner attribute values.
	      return self._pannerAttr;
	    } else if (args.length === 1) {
	      if (typeof args[0] === 'object') {
	        o = args[0];
	
	        // Set the grou's panner attribute values.
	        if (typeof id === 'undefined') {
	          self._pannerAttr = {
	            coneInnerAngle: typeof o.coneInnerAngle !== 'undefined' ? o.coneInnerAngle : self._coneInnerAngle,
	            coneOuterAngle: typeof o.coneOuterAngle !== 'undefined' ? o.coneOuterAngle : self._coneOuterAngle,
	            coneOuterGain: typeof o.coneOuterGain !== 'undefined' ? o.coneOuterGain : self._coneOuterGain,
	            distanceModel: typeof o.distanceModel !== 'undefined' ? o.distanceModel : self._distanceModel,
	            maxDistance: typeof o.maxDistance !== 'undefined' ? o.maxDistance : self._maxDistance,
	            panningModel: typeof o.panningModel !== 'undefined' ? o.panningModel : self._panningModel,
	            refDistance: typeof o.refDistance !== 'undefined' ? o.refDistance : self._refDistance,
	            rolloffFactor: typeof o.rolloffFactor !== 'undefined' ? o.rolloffFactor : self._rolloffFactor
	          };
	        }
	      } else {
	        // Return this sound's panner attribute values.
	        sound = self._soundById(parseInt(args[0], 10));
	        return sound ? sound._pannerAttr : self._pannerAttr;
	      }
	    } else if (args.length === 2) {
	      o = args[0];
	      id = parseInt(args[1], 10);
	    }
	
	    // Update the values of the specified sounds.
	    var ids = self._getSoundIds(id);
	    for (var i=0; i<ids.length; i++) {
	      sound = self._soundById(ids[i]);
	
	      if (sound) {
	        // Merge the new values into the sound.
	        var pa = sound._pannerAttr;
	        pa = {
	          coneInnerAngle: typeof o.coneInnerAngle !== 'undefined' ? o.coneInnerAngle : pa.coneInnerAngle,
	          coneOuterAngle: typeof o.coneOuterAngle !== 'undefined' ? o.coneOuterAngle : pa.coneOuterAngle,
	          coneOuterGain: typeof o.coneOuterGain !== 'undefined' ? o.coneOuterGain : pa.coneOuterGain,
	          distanceModel: typeof o.distanceModel !== 'undefined' ? o.distanceModel : pa.distanceModel,
	          maxDistance: typeof o.maxDistance !== 'undefined' ? o.maxDistance : pa.maxDistance,
	          panningModel: typeof o.panningModel !== 'undefined' ? o.panningModel : pa.panningModel,
	          refDistance: typeof o.refDistance !== 'undefined' ? o.refDistance : pa.refDistance,
	          rolloffFactor: typeof o.rolloffFactor !== 'undefined' ? o.rolloffFactor : pa.rolloffFactor
	        };
	
	        // Update the panner values or create a new panner if none exists.
	        var panner = sound._panner;
	        if (panner) {
	          panner.coneInnerAngle = pa.coneInnerAngle;
	          panner.coneOuterAngle = pa.coneOuterAngle;
	          panner.coneOuterGain = pa.coneOuterGain;
	          panner.distanceModel = pa.distanceModel;
	          panner.maxDistance = pa.maxDistance;
	          panner.panningModel = pa.panningModel;
	          panner.refDistance = pa.refDistance;
	          panner.rolloffFactor = pa.rolloffFactor;
	        } else {
	          // Make sure we have a position to setup the node with.
	          if (!sound._pos) {
	            sound._pos = self._pos || [0, 0, -0.5];
	          }
	
	          // Create a new panner node.
	          setupPanner(sound, 'spatial');
	        }
	      }
	    }
	
	    return self;
	  };
	
	  /** Single Sound Methods **/
	  /***************************************************************************/
	
	  /**
	   * Add new properties to the core Sound init.
	   * @param  {Function} _super Core Sound init method.
	   * @return {Sound}
	   */
	  Sound.prototype.init = (function(_super) {
	    return function() {
	      var self = this;
	      var parent = self._parent;
	
	      // Setup user-defined default properties.
	      self._orientation = parent._orientation;
	      self._stereo = parent._stereo;
	      self._pos = parent._pos;
	      self._pannerAttr = parent._pannerAttr;
	
	      // Complete initilization with howler.js core Sound's init function.
	      _super.call(this);
	
	      // If a stereo or position was specified, set it up.
	      if (self._stereo) {
	        parent.stereo(self._stereo);
	      } else if (self._pos) {
	        parent.pos(self._pos[0], self._pos[1], self._pos[2], self._id);
	      }
	    };
	  })(Sound.prototype.init);
	
	  /**
	   * Override the Sound.reset method to clean up properties from the spatial plugin.
	   * @param  {Function} _super Sound reset method.
	   * @return {Sound}
	   */
	  Sound.prototype.reset = (function(_super) {
	    return function() {
	      var self = this;
	      var parent = self._parent;
	
	      // Reset all spatial plugin properties on this sound.
	      self._orientation = parent._orientation;
	      self._pos = parent._pos;
	      self._pannerAttr = parent._pannerAttr;
	
	      // Complete resetting of the sound.
	      return _super.call(this);
	    };
	  })(Sound.prototype.reset);
	
	  /** Helper Methods **/
	  /***************************************************************************/
	
	  /**
	   * Create a new panner node and save it on the sound.
	   * @param  {Sound} sound Specific sound to setup panning on.
	   * @param {String} type Type of panner to create: 'stereo' or 'spatial'.
	   */
	  var setupPanner = function(sound, type) {
	    type = type || 'spatial';
	
	    // Create the new panner node.
	    if (type === 'spatial') {
	      sound._panner = Howler.ctx.createPanner();
	      sound._panner.coneInnerAngle = sound._pannerAttr.coneInnerAngle;
	      sound._panner.coneOuterAngle = sound._pannerAttr.coneOuterAngle;
	      sound._panner.coneOuterGain = sound._pannerAttr.coneOuterGain;
	      sound._panner.distanceModel = sound._pannerAttr.distanceModel;
	      sound._panner.maxDistance = sound._pannerAttr.maxDistance;
	      sound._panner.panningModel = sound._pannerAttr.panningModel;
	      sound._panner.refDistance = sound._pannerAttr.refDistance;
	      sound._panner.rolloffFactor = sound._pannerAttr.rolloffFactor;
	      sound._panner.setPosition(sound._pos[0], sound._pos[1], sound._pos[2]);
	      sound._panner.setOrientation(sound._orientation[0], sound._orientation[1], sound._orientation[2]);
	    } else {
	      sound._panner = Howler.ctx.createStereoPanner();
	      sound._panner.pan.value = sound._stereo;
	    }
	
	    sound._panner.connect(sound._node);
	
	    // Update the connections.
	    if (!sound._paused) {
	      sound._parent.pause(sound._id, true).play(sound._id);
	    }
	  };
	})();
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 3 */
/***/ function(module, exports) {

	
	
	
		
		var events = {},
			idRegistry = 9100;
		
		
		function Subscribe(event, func){
			if(!events.hasOwnProperty(event)){
				events[event] = [];
			}
			
			var eventID = ++idRegistry;
			
			events[event].push({
				
				id : eventID,
				handler : func
							   
				});
			
			return eventID;
	
		}
		
		function Publish(){
	        
	        
	        
	        var event = arguments[0],
	            data = arguments[1],
	            realOne = arguments[2];
			
	        
	        
				if(!events.hasOwnProperty(event)){
					return false;
				}
				
			var subs = events[event];
	
			for(var i = 0, j = subs.length; i<j; i++){
				
				subs[i].handler(event, data);
				
			}
			
		}
		
		function Unsubscribe(id){
			
			for(var event in events){
				if(events.hasOwnProperty(event)){
					for(var i = 0, j = events[event].length; i<j; i++){
						if(events[event][i].id === id){
							events[event].splice(i, 1);
							return id;
						}
					}
				}
			}
			
		}
	
	
	
	module.exports = {
	    
	    subscribe : Subscribe,
	    publish : Publish,
	    unsubscribe : Unsubscribe
	    
	};

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	var ResourceLoader = __webpack_require__(1),
	    Algorithms = __webpack_require__(5),
	    mainCanvas = document.getElementById('bgCanvas'),
	    PubSub = __webpack_require__(3),
	    centerX = mainCanvas.width / 2,
	    centerY = mainCanvas.height / 2;
	
	
	        inheritFrom(Display, Physics);
	        inheritFrom(Physics, Spacecraft);
	        inheritFrom(Display, Background);
	        //make custom classes inherit display class
	        inheritFrom(Physics, Missile);
	        inheritFrom(Display, Shield);
	        inheritFrom(Spacecraft, Ship);
	        inheritFrom(Display, Explosion);
	        inheritFrom(Spacecraft, Enemy);
	        inheritFrom(Physics, Rock);
	        inheritFrom(Spacecraft, Mothership);
	        inheritFrom(Physics, Perk);   
	    
	
	
	    //inheriter function
	    function inheritFrom(parent, child){
	        var copyOfParent = Object.create(parent.prototype);
	        copyOfParent.constructor = child;
	        child.prototype = copyOfParent;
	    }
	
	    //custom classes
		function Display(){
	       
			this.canvasWidth = 0;
			this.canvasHeight = 0;
			this.centerX = 0;
			this.centerY = 0;
			this.height = 0;
			this.width = 0;
			this.x = 0;
			this.y = 0;
			this.color = "#00FF00";
			this.alpha = 1;
	        this.alive = false;  
	        this.context = undefined;
	        this.type = "display";
	       
		}
	        //temp proto method....
	    Display.prototype.reset = function(){
				this.x = 0;
				this.y = 0;
				this.angle = 0;
				this.velX = 0;
				this.velY = 0;
				this.alive = false;
				this.colliding = false;
			};
	    
	    Display.prototype.setCanvas = function(canvas){
				this.context = canvas.getContext('2d');
				this.canvasWidth = canvas.width;
				this.canvasHeight = canvas.height;
			};
	    
	    Display.prototype.init = function(width, height){
				this.width = width || 20;
				this.height = height || 20;
				this.centerX = width/2;
				this.centerY = height/2;
				this.alive = false;
			};
	
	    function Physics(){
	        
	            Display.call(this);
	        
	        this.velX = 0;
	        this.velY = 0;
	        this.acelX = 0;
	        this.acelY = 0;
	        this.colliding = false;
	        this.speed = 0; 
	        this.thrust = 0;
	        this.angle = 0;
	    }
	    
	    Physics.prototype.spawn = function(x, y, angle, speed){
	        
	        this.x = x || centerX;
	        this.y = y || centerY;
	        this.colliding = false;
	        this.alive = true;
	        this.angle = angle || this.angle;
	        this.speed = speed || this.speed;
	        this.velX = Math.cos(this.angle)*this.speed;
	        this.velY = Math.sin(this.angle)*this.speed;
	        
	    };
	    
	    Physics.prototype.destroy = function(){
	        this.alive = false; 
	    };
	    
	    //spaceCraft function constructor 
	    function Spacecraft(){
	            
	           Physics.call(this);
	        
	        this.autoSpawn = false;
	        this.thrustAccel = 0.03;
	        this.alphaSpeed = 0.03;
	        this.shieldActive = false;
	        this.shieldDisabled = false;
			this.maxVelocity = 4;
	        this.missilesSpeed = 2.5;
			this.easeValue = 0.03;
			this.jumping = false;
	        
	    }
			
	    Spacecraft.prototype.init = function(width, height){
	        
	            Display.prototype.init.call(this, width, height);
	        
	        var shield = new Shield();
	            shield.setCanvas(mainCanvas);
	            shield.init(80,80);
			var missilePool = new Pool(10);
				missilePool.init('missile');
	            
	        var explosion = new Explosion(15);
	            explosion.setCanvas(mainCanvas);
	            
	            
	        this.explosion = explosion;
	        this.shield = shield;
	        this.missiles = missilePool;
	        
	    };    
		
	    Spacecraft.prototype.follow = function(object){
	        
				if(!object.alive || this.jumping){
					return;
				}	
				var dx, dy, distance, newVelX, newVelY, futureVel, direction;
				dx = object.x - this.x;
				dy = object.y - this.y;
				distance = Math.sqrt(dx*dx+dy*dy);
				direction = Math.atan2(dy, dx);
				this.angle = direction;
				
				if(distance>=140){
				newVelX = this.velX+Math.cos(this.angle)*this.thrustAccel;
				newVelY = this.velY+Math.sin(this.angle)*this.thrustAccel;	
				futureVel = Math.sqrt(newVelX*newVelX + newVelY*newVelY);	
						if(futureVel>1.5){
					newVelX = this.velX;
					newVelY = this.velY;
					}else{
					this.velX = newVelX;
					this.velY = newVelY;
					}
				}	
	    };
	    
	    Spacecraft.prototype.attack = function(object){
				if(Math.random() >= 0.005 || !this.alive || !object.alive){
					return;
				}
				this.shoot();
	    };
	    
	    Spacecraft.prototype.spawn = function(x, y, angle, speed){
	        
	            Physics.prototype.spawn.call(this, x, y, angle, speed);
	            this.missiles.hideItems();
	            //this.shield.reset();
				this.jumping = false;
	        
	    };
	    
	    Spacecraft.prototype.destroy = function(){
	        this.colliding = true;  
	        ResourceLoader.assets.explosionSound.play();
	    };
	
		Spacecraft.prototype.jump = function(){
			
			//if spacecraft is not jumping, have it face to the right and no Y velocity.
			if(!this.jumping){
				this.velY = this.angle = 0;
				this.velX = 1;
				this.jumping = true;
			}
			
		};
	
	    Spacecraft.prototype.draw = function(){
	        
	        //draws spacecraft launched missiles
	        for(var i=0; i<this.missiles.pool.length; i++){
	            var currentMissile = this.missiles.pool[i];   
	            if(currentMissile.alive){
	                currentMissile.draw();   
	            }
	        }
	        
	        if(this.colliding){	
	                //if spacecraft is colliding, create an explosion
	            this.explosion.create(this.x+this.centerX, this.y+this.centerY);
	            this.explosion.draw();
	                //once the explosion is not running, kill off spacecraft
	            if(!this.explosion.running){
	                this.alive = false;
	                this.colliding = false;
	                if(this.autoSpawn){
	                 this.spawn();   
	                }
	            }
	                //return while colliding
	            return;
	                    
	        }
	            //if shield is active draw it.
	        if(this.shield.active){
	                this.shield.x = this.x-this.shield.centerX+this.centerX;
	                this.shield.y = this.y-this.shield.centerY+this.centerY;
	                this.shield.draw();
	        }
			
			//if spacecraft is jumping, ease the spacecraft out.
			if(this.jumping && this.velX < 10){
				
				this.velX += this.velX*this.easeValue;
				
			}
			
			
	        
	    };
	    
	    Spacecraft.prototype.shoot = function(){
	        
	        //if instance is not alive, is colliding or not moving, it will NOT shoot
	        if(!this.alive || this.colliding || this.velX == 0){
	                return;
	        }
	
	        this.missiles.get(this.x+10, this.y+10, "missile", this.angle, this.missilesSpeed);
			
	    };
	    
	    //class for the rocks floating
	    function Rock(){
	        
	            Physics.call(this);
	        
	        this.size;
	        this.spriteAnimation = new SpriteAnimation();
	        this.spriteAnimation.setCanvas(mainCanvas);
	        this.explosion = new Explosion(7);
	        this.explosion.setCanvas(mainCanvas);
	        this.type = 'rock';
	    
	    }
	    
	    Rock.prototype.init = function(size){
	        
	          var spriteAnimationInfo,
	              largeRockSpeed = 0.5,
	              mediumRockSpeed = 1,
	              smallRockSpeed = 1.2,
	              randomAngle;
	        
	          this.sprite = ResourceLoader.assets.meteorSprite;
	            
	            size = size || "large";
	    
	            switch(size){
	                case "large":
	                    
	                    spriteAnimationInfo = {width:56,height:55, offsetX: 0, offsetY: 0, numCol:2, numRow:9,fps:60,speed:8,loop:false,from:0,to:17};
	                    this.spriteAnimation.init(spriteAnimationInfo);
	                    randomAngle = Math.random()*(Math.PI*2);
	                    Display.prototype.init.call(this, spriteAnimationInfo.width, spriteAnimationInfo.height);
	                    Physics.prototype.spawn.call(this, 0, 0, randomAngle, largeRockSpeed);
	                    this.alive = false;
	                    this.size = "large";
	                    this.type = "largeRock";
	                    
	                    break;
	                    
	                case "medium":
	                    
	                    spriteAnimationInfo = {width:44,height:44, numCol:3, numRow:6,fps:60,offsetX: 130, offsetY : 0, speed:12,loop:true,from:0,to:17};   
	                    this.spriteAnimation.init(spriteAnimationInfo);
	                    randomAngle = Math.random()*(Math.PI*2);
	                    Display.prototype.init.call(this, spriteAnimationInfo.width, spriteAnimationInfo.height);
	                    Physics.prototype.spawn.call(this, 0, 0, randomAngle, mediumRockSpeed);
	                    this.alive = false;
	                    this.size = "medium";
	                    this.type = "mediumRock";
	                    
	                    break;
	                    
	                case "small":
	                    
	                    spriteAnimationInfo = {width:33,height:33, numCol:3,offsetX: 290, offsetY: 0, numRow:6,fps:60,speed:15,loop:true,from:0,to:17};
	                    this.spriteAnimation.init(spriteAnimationInfo);
	                    randomAngle = Math.random()*(Math.PI*2);
	                    Display.prototype.init.call(this, spriteAnimationInfo.width, spriteAnimationInfo.height);
	                    Physics.prototype.spawn.call(this, 0, 0, randomAngle, smallRockSpeed);
	                    this.alive = false;
	                    this.size = "small";
	                    this.type = "smallRock";
	                    
	                    break;
	            }
	            
	    };
	    
	    Rock.prototype.draw = function(){
	            
				if(this.colliding){ 
	            //when object is colliding, creates and draws explosion
				this.explosion.create(this.x+this.centerX, this.y+this.centerY);
				this.explosion.draw();
	                this.destroy();
	
				     if(!this.explosion.running){
				     //once explosion is over, kills off object
	                    this.colliding = false;
	                    this.alive = false;
	                    }
	                // if the explosion is still running return to drawing the explosion
				     return;
				}
	            
	            this.x += this.velX;
	            this.y += this.velY;
	            
	            this.spriteAnimation.play(this.x, this.y, this.sprite);    
	            
	        };
	    
	    Rock.prototype.destroy = function(){
	        
	            if(this.colliding){
	                return;
	            }
	        
	            ResourceLoader.assets.meteorExplosionSound.play();
	            this.colliding = true;
	            
	            PubSub.publish('meteor_explosion', this);
	        
	    };    
	    
		function Background(){
	        
	            Display.call(this);
	        
	        this.velX = 0;
	        this.velY = 0;
			this.progressBarWidth = 400;
			this.progressBarHeight = 40;
		}
	    
	    Background.prototype.draw = function(){
	            this.x += this.velX;
				this.y += this.velY;
	            
	            this.context.drawImage(ResourceLoader.assets.backgroundSprite, 0,0,this.canvasWidth,this.canvasHeight,this.x-this.canvasWidth, this.y,this.canvasWidth,this.canvasHeight);	
	            this.context.drawImage(ResourceLoader.assets.backgroundSprite, 0,0,this.canvasWidth,this.canvasHeight,this.x,this.y,this.canvasWidth,this.canvasHeight);
				
				if(this.x>this.canvasWidth){
					this.x = 0;
				}	
	    };
	    
		function Ship(){
	        
	                Spacecraft.call(this);
	        
	            var shipSpriteInfo = {width:21,height:22, numCol:1, numRow:2,fps:60,speed:30,loop:false,from:0,to:0};
	        
	            this.thrust = false;
	            this.autoSpawn = true;
	            this.thrustAccel = 0.04;
	            this.missilesSpeed = 3.2;
	            this.spriteAnimation = new SpriteAnimation();
	            this.spriteAnimation.setCanvas(mainCanvas);
	            this.spriteAnimation.init(shipSpriteInfo); 
	            this.type = "humanShip";
	        
		}
	    
	    Ship.prototype.draw = function(){
	        
	           Spacecraft.prototype.draw.call(this);
	        
	        if(this.colliding){
	            return;   
	        }
	        
	                this.context.save();
	                this.alpha += this.alphaSpeed;
	                this.alpha = (this.alpha >= 1)? 1: this.alpha;
	                this.context.globalAlpha = this.alpha;
	                this.context.translate(this.x+10, this.y+10);	
	                this.context.rotate(this.angle);
	                this.x += this.velX;
	                this.y += this.velY;
	                if(this.thrust){
	                    this.spriteAnimation.startFrame = 1;
	                    this.spriteAnimation.finalFrame = 1;
	                    this.spriteAnimation.play(-this.centerX, -this.centerY, ResourceLoader.assets.playerSpriteSheet);
	                }else{
	                    //this.context.drawImage(shipSprite, 0, 0, this.width, this.height, -10,-10, this.width, this.height);
	                    this.spriteAnimation.startFrame = 0;
	                    this.spriteAnimation.finalFrame = 0;
	                    this.spriteAnimation.play(-this.centerX, -this.centerY, ResourceLoader.assets.playerSpriteSheet);
	                }
	                this.context.restore();
	    };
		
		Ship.prototype.shoot = function(){
			Spacecraft.prototype.shoot.call(this);
			ResourceLoader.assets.playerShootSound.play();
		};
	    
	    function Perk(){
	        
	            Physics.call(this);
	        
	        this.spriteAnimation = new SpriteAnimation(); 
	        this.spriteAnimation.setCanvas(mainCanvas);
	    
	        this.type = 'perk';    
	    }
	
	    Perk.prototype.draw = function(){
	        
	        if(!this.alive){
	            return;
	        }
	        
	        this.x += this.velX;
	        this.y += this.velY;
	        
	        this.spriteAnimation.play(this.x, this.y, ResourceLoader.assets.perkSprite);
	        
	    };
	
	    Perk.prototype.init = function(perk){
	            
	            var spriteInfo; 
	                
	            
	            switch(perk){
	                    
	                case "shield":
	                        spriteInfo = {width:18,height:19, numCol:1, numRow:2,fps:60,speed:1,loop:false,from:0,to:0};
	                        this.spriteAnimation.init(spriteInfo);
	                        Display.prototype.init.call(this, spriteInfo.width, spriteInfo.height);
	                        this.type = "shield";
	                    break;
	                    
	                case "life":
	                        spriteInfo = {width:18,height:19, numCol:1, numRow:2,fps:60,speed:1,loop:false,from:1,to:1};
	                        this.spriteAnimation.init(spriteInfo);
	                        Display.prototype.init.call(this, spriteInfo.width, spriteInfo.height);
	                        this.type = "life";
	                    break;
	            }
	    }; 
		
		Perk.prototype.destroy = function(){
			Physics.prototype.destroy.call(this);
			ResourceLoader.assets.perkSound.play();
		};        
	    //missle constructor
	    
		function Missile(){
	        
	            Physics.call(this);
	        
			this.speed = 3;
			this.life = 0;
			this.maxLife = 100;
	        this.type = "missile";
	
		}
	    
	    Missile.prototype.spawn = function(x, y, angle, speed){
	        Physics.prototype.spawn.call(this, x, y, angle, speed);  
	        this.life = 0;
	    };
	    
	    Missile.prototype.draw = function(){
	        
	        this.life++;
				if(this.life>=this.maxLife){
					this.life = 0;
					this.alive = false;
				}
				this.x += this.velX;
				this.y += this.velY;
				this.context.fillStyle = this.color;
				this.context.fillRect(this.x, this.y, this.width, this.height);
	    
	    };
	    
		function Enemy(){
	        
	            Spacecraft.call(this);
	        
			this.thrustAccel = 0.03;
	        this.type = "enemy";
	        
			
	        var spriteRandomIndex = Math.floor(Math.random()*4);
	        this.spriteAnimation = new SpriteAnimation();
	        this.spriteAnimation.setCanvas(mainCanvas);
	        var enemySpriteInfo = {width:23,height:21, numCol:1, numRow:4,fps:60,speed:30,loop:false,from:spriteRandomIndex,to:spriteRandomIndex};
	        this.spriteAnimation.init(enemySpriteInfo);
	    
		}
	    
	    Enemy.prototype.draw = function(){
	        
	                Spacecraft.prototype.draw.call(this);
	            
	            if(this.colliding || !this.alive){
	                return;   
	            }
	        
	                this.x += this.velX;
	                this.y += this.velY;
	                this.context.save();
	                this.context.translate(this.x+this.centerX, this.y+this.centerY);
	                this.context.rotate(this.angle);
	                this.spriteAnimation.play(-this.centerX, -this.centerX, ResourceLoader.assets.enemySpriteSheet);
	                this.context.restore();  
	                
	
	    };
	        
	    //mothership constructor
	    function Mothership(){
	        
	             Spacecraft.call(this);
	        
	        
	        this.hasReleasedShips = false;
	        this.spriteAnimation = new SpriteAnimation();
	        this.spriteAnimation.setCanvas(mainCanvas);
	        this.type = undefined;
	        this.missilesSpeed = 3;
	        this.alpha = 0;
	        this.alphaSpeed = 0.02;
	        this.numShips = 0;
	        this.type = "mothership";
	    
	    }
	    
	    Mothership.prototype.init = function(shipType){
	        
	            switch(shipType){
	                    
	                case "human":
	                    
	                 var spriteSheetInfo = {width:51,height:46, numCol:1, numRow:2,fps:60,speed:30,loop:false,from:0,to:0};
	                 var spriteIndex = Math.floor(Math.random()*spriteSheetInfo.to);
	                 spriteSheetInfo.from = spriteSheetInfo.to = spriteIndex;
	                 this.spriteAnimation.init(spriteSheetInfo);
	                 this.type = "human";
	                 this.width = spriteSheetInfo.width;
	                 this.height = spriteSheetInfo.height;
	                 this.centerX = this.width / 2;
	                 this.centerY = this.height / 2;
	                    Spacecraft.prototype.init.call(this, this.width, this.height);
	                    break;
	                    
	                case "alien":
	                    
	                var spriteSheetInfo = {width:51,height:46, numCol:4, numRow:2,fps:60,speed:30,loop:false,from:0,to:4};
	                var spriteIndex = Math.floor(Math.random()*spriteSheetInfo.to);
	                spriteSheetInfo.from = spriteSheetInfo.to = spriteIndex;
	                this.spriteAnimation.init(spriteSheetInfo);
	                this.type = "alien";
	                this.width = spriteSheetInfo.width;
	                this.height = spriteSheetInfo.height;
	                this.centerX = this.width / 2;
	                this.centerY = this.height / 2;
	                    Spacecraft.prototype.init.call(this, this.width, this.height);
	                    
	                    break;     
	            }
	            
	        };
	    
	    Mothership.prototype.setRelease = function(shipsPool, numShips, time){
	            
	            if(this.hasReleasedShips){
	                return;   
	            }
	            
	            //assigns number of ships to release
	            this.numShips = numShips;
	            this.shipsPool = shipsPool;
	            
	            //checks if time to release ships was passed in
	            time = (typeof time != "number")? 5000: time;
			
				var self = this;
			
				this.interval = window.setTimeout(function(){
					//release ships after the time has passed
					Mothership.prototype.releaseShips.call(self);
	                
				}, time);   
			
	        };
	    
	    Mothership.prototype.releaseShips = function(){
	       
	        console.log('ship release function has been called');
	            
	            this.hasReleasedShips = true;
	            this.shield.active = false;
	            
	
	            for(var i=0; i<this.numShips; i++){
	                    
	                var positionX = this.x + this.shipsPool.pool[i].width*i;
	                var positionY = this.y + this.shipsPool.pool[i].height*i;
	                this.shipsPool.get(positionX, positionY, 'enemy');
	                this.shipsPool.pool[i].shield.active = false;
	                        
	            } 
	                    
	            
	        };
	    
	    Mothership.prototype.destroy = function(){
			Spacecraft.prototype.destroy.call(this);
			window.clearTimeout(this.interval);
		};
	
	    Mothership.prototype.spawn = function(x, y, angle, speed){
	            
	            Spacecraft.prototype.spawn.call(this, x, y, angle, speed);
	            this.hasReleasedShips = false;
	            this.alpha = 0;
	            
	        };
	    
	    Mothership.prototype.draw = function(){
	            
	            Spacecraft.prototype.draw.call(this);
	        
	            if(this.colliding || !this.alive){
	                console.log('ships dead wont draw it');
	                return;
	                
	            }
	            this.x += this.velX;
	            this.y += this.velY;
	        
	        
	            this.context.save();
	            this.context.translate(this.x+this.centerX, this.y+this.centerY);
	            this.context.rotate(this.angle);
	            if(this.hasReleasedShips){
	                this.alpha -= this.alphaSpeed;   
	                this.alpha = (this.alpha <= 0)? 0: this.alpha; 
	                this.alive = (this.alpha <= 0)? false : true;
	            }else{
	            this.alpha += this.alphaSpeed;
	            this.alpha = (this.alpha >= 1)? 1: this.alpha;
	            }
	            this.context.globalAlpha = this.alpha;
	            this.spriteAnimation.play(-this.centerX, -this.centerY, ResourceLoader.assets.MothershipSpriteSheet);
	            this.context.restore();
	            
	            if(this.alpha <= 0){
	                this.alive = false;
	            } 
	        };
	    
	    // explosion constructor
		function Explosion(numParticles){
	        
	            Display.call(this);
	        
			this.running = false;
			this.particles = [];
			this.deadParticleCounter = 0;
			this.size = numParticles;
	        
			for(var i = 0; i<numParticles; i++){
				this.particles.push({x:0,y:0,alive:false,maxLife:0,velX:0,velY:0, width:2, height:2, life:0});
			}
				
		}
	    
	    Explosion.prototype.create = function(x, y){
	        if(this.running){
					return;
				}
				
				for(var i=0;i<this.size;i++){
					var currentParticle = this.particles[i];
					currentParticle.x = x;
					currentParticle.y = y;
					currentParticle.maxLife = Math.random()*45+15;
					currentParticle.velX = Math.random()*4-2.8;
					currentParticle.velY = Math.random()*4-2.8;
					currentParticle.alive = true;
					currentParticle.life = 0;
				}
				this.running = true;
				this.deadParticleCounter = 0;
	    };
	
	    Explosion.prototype.draw = function(){
	        
	        if(!this.running){
					return;
				}
				
				this.context.fillStyle = '#00FF00';
				for(var i=0; i<this.size; i++){
					var currentParticle = this.particles[i];
					if(currentParticle.alive){
					currentParticle.x += currentParticle.velX;
					currentParticle.y += currentParticle.velY;
					currentParticle.life++;
					this.context.fillRect(currentParticle.x, currentParticle.y, currentParticle.width, currentParticle.height);
	                        if(currentParticle.life >= currentParticle.maxLife){
	                        currentParticle.alive = false;
	                        currentParticle.life = 0;
	                        this.deadParticleCounter++;
	                    }
					}
					
				}
	//change the state from running to false by checking if there are any particles alive left
				if(this.deadParticleCounter>=this.size){
					this.running = false;
				}
	        
	    };
	    
	    //Shield constructor
		function Shield(){
	        
	            Display.call(this);
	        
			this.radius = 40;
			this.maxRadius = 45;
	        this.life = 100;
	        this.disabled = false;
	        this.color = '#0000FF';
	        this.type = 'shield';
	        var shieldState = false;
	    
	        Object.defineProperty(this, "active", {
	            get: function(){
	                
	                return shieldState;
	                
	            },
	            set: function(value){
	                
	                shieldState = (this.disabled)? false: value;
	                this.alive = shieldState;
	                
	            },
	            configurable: true,
	            enumerable: true
	        });
	        
	        
		}
	    
	    Shield.prototype.reduceLife = function(amount){
	        amount = (amount === undefined)? 50: amount;
	        this.life -= amount;
	    };
	    
	    Shield.prototype.draw = function(){
	        
	            if(!this.active){
	                console.log('shield is disabled');
	                return;
	            }
	            if(this.life <= 0){
	                this.life = 0;
	                this.disabled = true;
	                this.active = false;
	                    return;
	            }
				this.context.strokeStyle = this.color;
	            this.context.lineWidth = 1;
				this.context.beginPath(); 
				this.context.arc(this.x+this.centerX, this.y+this.centerY, this.radius, 0, Math.PI*2, true);
				this.context.closePath();
				this.context.stroke(); 
				this.radius += .25;
				this.radius = (this.radius>this.maxRadius)? 40: this.radius;
	        
	    };
	    
	    Shield.prototype.reset = function(){
	            this.life = 100;
	            this.disabled = false;
	    };
	    
	    //meteor pool
		function Pool(maxSize){
	        
			var pool = [];
	        
			this.pool = pool;
	        this.size = maxSize;
	        
		}
	    
	    Pool.prototype.init = function(type){
	            
	            switch(type){
	                case "missile":
	                    
	                  for(var i=0; i<this.size; i++){
						var missile = new Missile();
						missile.setCanvas(mainCanvas);
						missile.init(2,2);
						this.pool[i] = missile;
					}  
	                    break;
	                    
	                case "enemy":
	                   for(var j=0; j<this.size; j++){
	                    var randomX = Math.floor(Math.random()*mainCanvas.width);
	                    var randomY = Math.floor(Math.random()*mainCanvas.height);
	                    
	                    var enemy = new Enemy();
	                    enemy.setCanvas(mainCanvas);
	                    enemy.init(23, 21);
	                    enemy.x = randomX;
	                    enemy.y = randomY;
	
	                    this.pool[j] = enemy;
	                       
	                } 
	                    break;
	                    
	                case "perks":
	                    this.size = Math.floor(this.size / 2);
	
	                    for(var k=0; k<this.size; k++){
	                        var life = new Perk();
	                        life.setCanvas(mainCanvas);
	                        life.init("life");
	                        this.pool.push(life); 
	                    }
	
	                    for(var h=0; h<this.size; h++){
	                        var shield = new Perk();
	                        shield.setCanvas(mainCanvas);
	                        shield.init("shield");
	                        this.pool.push(shield);
	                    }
	                    
	                    this.size *= 2;
	                    
	                    break;
	                    
	                case "rocks":
	                    
	                    var numMediumRocks = this.size*2;
	                    var numSmallRocks = numMediumRocks*2;
	
	                        for(var l=0; l<this.size; l++){
	                            var meteor = new Rock();
	                            meteor.setCanvas(mainCanvas);
	                            meteor.init("large");
	                            meteor.type = "largeRock";
	                            this.pool.push(meteor);
	                        }
	                        for(var m=0; m<numMediumRocks; m++){
	                            var meteorMedium = new Rock();
	                            meteorMedium.setCanvas(mainCanvas);
	                            meteorMedium.init("medium");
	                            meteorMedium.type = "mediumRock";
	                            this.pool.push(meteorMedium);
	                        }
	                        for(var n=0; n<numSmallRocks; n++){
	                            var meteorSmall = new Rock();
	                            meteorSmall.setCanvas(mainCanvas);
	                            meteorSmall.init("small");
	                            meteorSmall.type = "smallRock";
	                            this.pool.push(meteorSmall);
	                        }
	                    
	                    this.size += (numMediumRocks+numSmallRocks);
	                    
	                    break;
	            }
	            
	    };
	    
	    Pool.prototype.get = function(x, y, type, angle, speed){
	        
	            type = type || "missile";
	        
	            /* code from before mixing both pools meteor and regular 
				if(!this.pool[size-1].alive){
					this.pool[size-1].spawn(x,y, angle, speed);
					this.pool.unshift(pool.pop());
				}
	            */
	            var i = 0;
	
	                while(i<this.size){
	                    if(this.pool[i].type === type && !this.pool[i].alive){
	                        this.pool[i].spawn(x, y, angle, speed);
	                        break;
	                    }
	                    i++;     
	                }
	        
	    };
	
	    Pool.prototype.isCollidingWith = function(args){
	            
	            var length = this.pool.length;
	            var argsLength = arguments.length;
	            
	            for(var i = 0; i<length; i++){
	                
	                var currentItem = this.pool[i];
	                
	                if(currentItem.alive){
	                
	                for(var h = 0; h<argsLength; h++){
	                    //each argument represents the objects being passed in to this method.
	                    var currentArgument = arguments[h];
						
						//if one of the arguments to check for collision is a pool of objects, iterate over each item.
						if(Array.isArray(currentArgument)){
							for(var j = 0, len = currentArgument.length; j < len; j++){
								var currentPoolItem = currentArgument[j];
								checkCollision(currentItem, currentPoolItem);
							}
						}else{
								checkCollision(currentItem, currentArgument);
						   }
	                }
	            }
	                
	        }
				//function in charge of testing for collision and executing what to do when there is a collision, it also makes a call to the recordCollision function which handles the recording of collisions for points and score.
				function checkCollision(item1, item2){
					
						if(Algorithms.hitTest(item1, item2)){
								if(item2 instanceof Shield){
									if(!(item1 instanceof Rock)){
											item1.destroy();
											item2.reduceLife(10);
											//recordCollision(item1.type);
	                                        PubSub.publish('collision', item1.type);
										}
									}else if(item1 instanceof Perk){
										item1.destroy();
										//recordCollision(item1.type);
	                                    PubSub.publish('collision', item1.type);
									}else{
										item2.destroy();
										item1.destroy();
										//recordCollision(item2.type);
	                                    PubSub.publish('collision', item2.type);
	                                    PubSub.publish('collision', item1.type);
										//recordCollision(item1.type);
									}
							}
	
				}
	    };
	    
	    Pool.prototype.hideItems  = function(){
	            var length = this.pool.length;
	            for(var i=0; i<length; i++){
	                this.pool[i].alive = false; 
	            }
	    };
	
	    function SpriteAnimation(){
			 
	        this.width;
	        this.height;
	        this.x;
	        this.y;
			this.offsetX = 0;
			this.offsetY = 0;
	        this.context;
	        this.canvasHeight;
	        this.canvasWidth;
	        this.speed;
	        this.numCol;
	        this.numRow;
	        this.currentFrame;
	        this.finalFrame;
	        this.startFrame;
	        this.totalFrames;
	        this.appFPS;
			 //spritesheet animations loops by default
	        this.loop = true;
			    //private members 
	     	this._frames = [];
	        this._frameIncrement;
	        this._frameIndex;
	
			 
		 }
		
	     SpriteAnimation.prototype.setCanvas = function(canvas){
	            this.context = canvas.getContext('2d');
	            this.canvasHeight = canvas.height;
	            this.canvasWidth = canvas.width;
	      };
		
	     SpriteAnimation.prototype.init = function(spriteObject){
	            
	            //sets up sprite properties from the spritesheet info object being passed in.
	            this.width = spriteObject.width || 32;
	            this.height = spriteObject.height || 32;
	            this.numCol = spriteObject.numCol || 1;
	            this.numRow = spriteObject.numRow || 1;
	            this.startFrame = spriteObject.from || 0;
	            this.finalFrame = spriteObject.to || 0;
	            this.speed = spriteObject.speed || 15;
			 	this.offsetX = spriteObject.offsetX || 0;
			 	this.offsetY = spriteObject.offsetY || 0;
	            this.totalFrames = spriteObject.numCol * spriteObject.numRow - 1;
	            this.loop = spriteObject.loop || true;
	            this.appFPS = spriteObject.fps;
	            
	            //creates the decimal of increment for each second
	            this._frameIncrement = this.speed/spriteObject.fps;
	            this._frameIndex = this.startFrame;        
	            
	            //creates a variable holding the length of the array holding the frames
	            var totalFramesLength = spriteObject.numCol * spriteObject.numRow;
	
	            for(var i = 0; i < totalFramesLength; i++){
	                var frame = {};
						frame.regX = this.offsetX;
						frame.regY = this.offsetY;
	            
	                frame.regX += (i % this.numCol)*this.width;
	                frame.regY += (i % this.numRow)*this.height;
	                
	                //pushes the objects with the regX and regY for each frame into a frame array.
	                this._frames.push(frame);
	                
	            }
	              
	        };
	        //use this method to locate or move the sprite sheet to a cordinate
	     SpriteAnimation.prototype.play = function(x, y, sprite){
	            this.x = x || 0;
	            this.y = y || 0;
	
	            //no animation will be playeed if the starting frame is equal to the final frame.
	            if(this.startFrame === this.finalFrame){
					
		//surrounds the sprite into a white block for debugging purposes, you can remove this in your final app
	                //this.context.strokeStyle = '#FFFFFF';
	                //this.context.strokeRect(this.x, this.y, this.width, this.height);
	               
	                this.currentFrame = this._frames[this.startFrame];
	                this.context.drawImage(sprite, this.currentFrame.regX, this.currentFrame.regY, this.width, this.height, this.x, this.y, this.width, this.height);
	                
	            }else{
	                //increments the frameIndex by a decimal, this will be floored because it is used to find an item in the frame array.
	                this._frameIndex += this._frameIncrement;
	                
	                if(this._frameIndex >= this.finalFrame + 1){
	                    this._frameIndex = (this.loop)? this.startFrame: this.finalFrame;
	                }
	                //floors the current index to a whole number so to find an object in the frame array
	                this.currentFrame = this._frames[Math.floor(this._frameIndex)];
	                //surrounds the sprite into a white block for debugging purposes, you can remove this in your final app
	                //this.context.strokeStyle = '#FFFFFF';
	                //this.context.strokeRect(this.x, this.y, this.width, this.height);
	                //draws the section of the image given the regX and regY as well as the width and height
	                this.context.drawImage(sprite, this.currentFrame.regX, this.currentFrame.regY, this.width, this.height, this.x, this.y, this.width, this.height); 
	            } 
	        };
	        //use this method to change the fps speed of your sprite sheet animation
	     SpriteAnimation.prototype.setSpeed = function(speed){
	            //reason why a method for this is needed is because there is  math to be done when speed is changed.
	          this.speed = speed || this.speed;
	            this._frameIncrement = this.speed / this.appFPS;
	            this._frameIndex = this.startFrame;   
	        }; 
		
	     SpriteAnimation.prototype.getFrame = function(frameIndex){
	            this._frameIndex = (frameIndex == undefined)? 0: frameIndex;
	            return this._frames[this._frameIndex];
	        };
	    
	module.exports = {
	    
	    Display : Display,
	    Phyiscs : Physics,
	    Spacecraft : Spacecraft,
	    Rock : Rock,
	    Background : Background,
	    Ship : Ship,
	    Perk : Perk,
	    Missile : Missile,
	    Enemy : Enemy,
	    Mothership : Mothership,
	    Explosion : Explosion,
	    Shield : Shield,
	    Pool : Pool,
	    SpriteAnimation : SpriteAnimation
	    
	};

/***/ },
/* 5 */
/***/ function(module, exports) {

	//checks if an object has left the canvas bouding box
	function checkBoundary(object){
	
			if(object.x >= object.canvasWidth){
				object.x = 0;
			}else if(object.x <= -object.width){
				object.x = object.canvasWidth-object.width;
			}else if(object.y >= object.canvasHeight+object.height){
				object.y = 0;
			}else if(object.y <= -object.height){
				object.y = object.canvasHeight-object.height;
			}	
		}
		
		//collision detection.
	function hitTest(object1, object2){
	   		var left1 = object1.x;
	   		var left2 = object2.x;
	   		var right1 = object1.x + object1.width;
	   		var right2 = object2.x + object2.width;
	   		var top1 = object1.y;
	   		var top2 = object2.y;
	   		var bottom1 = object1.y + object1.height;
	   		var bottom2 = object2.y + object2.height;
	
	   		if (bottom1 < top2) return(false);
	   		if (top1 > bottom2) return(false);
	   		if (right1 < left2) return(false);
	   		if (left1 > right2) return(false);
	        if (!object1.alive || object1.colliding || object2.colliding || !object2.alive) return(false);
	        
	        if (object1.type == "humanShip" && object1.velX == 0) return(false);
	        if (object2.type == "humanShip" && object2.velX == 0) return(false);
	        
	        if(object2.hasOwnProperty('shield')){
	            if(object2.shield.active){
	                return (false);
	            }
	        }
	        if(object1.hasOwnProperty('shield')){
	            if(object1.shield.active){
	                return (false);
	            }
	        }
	        
	
	        //otherwise return true 
	   		return(true);
	
		}
	
	
	module.exports = {
	    
	    checkBoundary : checkBoundary,
	    hitTest : hitTest
	    
	};

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	var PubSub = __webpack_require__(3),
	
		//state dictionary given property names for each state. 
	    state = {
	        loading: 0,
	        storyLine : 1,
		    titleScreen : 2,
	        gamePlay : 3,
	        levelTransition : 4,
	        beatGame : 5,
	        gameOver : 6,
	        credits : 7,
	        howToPlay : 8,
	        onPause : 9,
	        shipJump : 10,
	        setUpLevel: 11,
	
	        current : -1 
	    };
	
	function init(){
	    
	    if(this.hasInitialized) return this;
	     
	    this.hasInitialized = true;
	    this.pages = document.getElementsByClassName('appPage');
	    this.interface = document.getElementById('interfaceWrapper');
	    this.counters = document.getElementsByClassName('counter');
	    this.subId = PubSub.subscribe('statechange', handleStateChange.bind(this));
	    //Adds mousedown event listener to the div containing all the app pages
		this.interface.addEventListener('mousedown', handleClick);
	    
	    return this;
	    
	}
	
	function handleClick(event){
	    
	    var button = event.target,
	        from = button.getAttribute('data-from'),
	        to = button.getAttribute('data-to');
	    
		//if the element that triggered event has data-to and from attributes, trigger event.
	    if(from && to){
	         PubSub.publish('statechange', {from: state[from], to: state[to]});   
	    }
	    
	}
	
	function updateCounters(counter, value){
	    
		//if the counter exists update its value.
		if(this.counters[counter]){
	
			 this.counters[counter].innerHTML = value;
			
		}
	   
	    
	    return this;
	    
	}
	
	function show(pageName){
		
	    //if the page exists show it. 
	    if(this.pages[pageName]){
	        
	        this.pages[pageName].setAttribute('style', 'display: block;');
	        
	    }
	    
	    return this;
	    
	}
	
	function hide(pageName){
	    
		//if the page is defined, hide it. 
	    if(this.pages[pageName]){
	        
	        this.pages[pageName].setAttribute('style', 'display: none;');
	        
	    }
	    
	    return this;
	    
	}
	
	function hideAll(){
	    
	    var self = this;
		
	 	//delegates the forEach array method to iterate and hide each page.
	    [].forEach.call(this.pages, function(curretPage, index){
	       
			//calls the module hide method with the current context.
	        hide.call(self, index);
	        
	    });
	    
	    return self;
	    
	}
	
	
	function handleStateChange(event, data){
	    
		//hides away current state page and shows new state page.
	    hide.call(this, data.from);
	    show.call(this, data.to);
	    
	}
	
	module.exports = {
	    
	    init : init,
	    show : show,
	    hide : hide,
	    hideAll : hideAll,
	    hasInitialized : false,
	    updateCounter : updateCounters
	    
	    
	};

/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	var ResourceLoader = __webpack_require__(1),
	    keyboardControl = __webpack_require__(8),
	    Constructors = __webpack_require__(4),
	    PubSub = __webpack_require__(3),
	    UIController = __webpack_require__(6),
	    Algorithms = __webpack_require__(5),
	    mainCanvas = document.getElementById('bgCanvas'),
	    mainContext = mainCanvas.getContext('2d')
	    mouse = {x: 200, y:200},
	    centerX = mainCanvas.width / 2,
	    centerY = mainCanvas.height / 2,
	    FRAME_RATE = 1000/60,
	    
	    state = {
	        INIT : -1,
	        LOADING: 0,
	        STORY_LINE : 1,
		    TITLE_SCREEN : 2,
	        GAME_PLAY : 3,
	        LEVEL_TRANSITION : 4,
	        BEAT_GAME : 5,
	        GAME_OVER : 6,
	        CREDITS : 7,
	        HOW_TO_PLAY : 8,
	        PAUSED : 9,
	        SHIP_JUMP : 10,
	        SET_UP_LEVEL: 11,
	
	        CURRENT : -1 
	    },
	    
	    stateHandlers = {},
	    
	    loopOn = false;  
	
	    var totalEnemies = 8,
	        totalRocks = 10,
	        levelRocks = 5,
	        levelEnemies = 8,
	        levelPerks = 4,
	        enemiesKilled = 0
	        currentScore = 0,
	        shipLives = 4,
	        rocksDestroyed = 0,
	        currentLevel = 0,
	        lastLevel = 1;
	
		//TEMP: player instance and enemies
	    var playerShip,
		    alienMothership,
	        humanMothership,
		    background;
	
	     //pools holding enemies and rocks
	    var enemyShipsPool,
	        humanShipsPool,
	        perksPool,
	        meteorPool;   
	
	function init(){
	        
	        var self = this;
	    
	        attachStateHandlers();
	    
	        playerShip = new Constructors.Ship();
		    alienMothership = new Constructors.Mothership();
	        humanMothership = new Constructors.Mothership();
		    background = new Constructors.Background();
	
	     //pools holding enemies and rocks
	        enemyShipsPool = new Constructors.Pool(totalEnemies);
	        humanShipsPool = new Constructors.Pool(10);
	        perksPool = new Constructors.Pool(10);
	        meteorPool = new Constructors.Pool(totalRocks);   
	
	        background.setCanvas(mainCanvas);
			background.init(1000, 480);
			background.velX = 1;
	        
	        perksPool.init("perks");
	        meteorPool.init("rocks");
	        enemyShipsPool.init('enemy');
	        
	        alienMothership.setCanvas(mainCanvas);
	        alienMothership.init('alien');
	
	        playerShip.setCanvas(mainCanvas);
	        playerShip.init(23, 23);
	        playerShip.spawn(centerX, centerY);
	        
	        window.addEventListener('mousemove', onMouseMove, false);
	        
	        //add game control for desktop based on keyboard events
	        keyboardControl.init(playerShip);
	    
	        
	        //sign up for subscriptions
	        var subID1 = PubSub.subscribe('statechange', handleStateChange.bind(self));
	        var subID2 = PubSub.subscribe('meteor_explosion', handleMeteorExplosion.bind(self));
	        var subID3 = PubSub.subscribe('collision', recordCollision.bind(self));
	    
		window.alienMothership = alienMothership;
		window.playerShip = playerShip;
	    
	}
	
	
	function onMouseMove(e){
	    
	    
	    
	    
	}
	
	
	//function in charged of setting up the enemies and rocks in the new level given the current level
	function handleSetUpLevel(){
	    
	        
	        
	        console.log('Set Up Level function CALLED');
	        
	        //sets up random location for rocks and mothership
	            var randomX, randomY;
	        
	        //increases level by 1
	        currentLevel += 1;
	        
	        //checks if game is over
	        if(currentLevel > lastLevel){
	            userBeatGame = true;
	            PubSub.publish('statechange', {from: state.CURRENT, to: state.BEAT_GAME});
	            return;
	        }
	           
	        if(currentLevel == lastLevel){
	            ResourceLoader.assets.lastLevelSound.play();
	        }else{
	            //begins normal soundtrack 
			   ResourceLoader.assets.soundTrack.play();
	        }
			
	        //resets enemy killed and rocks destroyed counter and ship lives
	        enemiesKilled = 0;
	        rocksDestroyed = 0;
	    
	        if(currentLevel == 1){
	            shipLives = 4;
	        }
	        //sets up number of rocks and enemies that will be displayed
	        levelEnemies = currentLevel+1;
	        levelRocks = currentLevel+2;
	        
	        //checks to see if the level rocks and enemies exceed total in pool.
	        levelEnemies = (levelEnemies>=totalEnemies)? totalEnemies : levelEnemies;
	        levelRocks = (levelRocks>=totalRocks)? totalRocks : levelRocks;
	        
	        //centers ship and hide all of its missiles
	        playerShip.spawn(centerX, centerY);
	        
	        //kill off any alive rocks and enemies
	        perksPool.hideItems();
	        enemyShipsPool.hideItems();
	        meteorPool.hideItems();
	        
	        //inits the rocks
	        for(var i=0; i<levelRocks; i++){
	            randomX = Math.floor(Math.random()*(mainCanvas.width-50)),
	            randomY = Math.floor(Math.random()*(mainCanvas.height-50));
	            meteorPool.get(randomX, randomY, "largeRock");
	            meteorPool.get(randomX, randomY, "smallRock");
	        }
	        
	        for(var h=0; h<levelPerks; h++){
	            randomX = Math.floor(Math.random()*(mainCanvas.width-50)),
	            randomY = Math.floor(Math.random()*(mainCanvas.height-50));
	            perksPool.get(randomX, randomY, "life");
	            perksPool.get(randomY, randomX, "shield");
	        }
	    
	        //alienMothership.init("alien");
	        alienMothership.spawn(randomX, randomY);
	        alienMothership.shield.active = true;
	        alienMothership.setRelease(enemyShipsPool, levelEnemies, 8000);
	        
	        //updateCounter('level');
	        //updateCounter('life');
	        //updateCounter('score');
	    
	        UIController.updateCounter('level', currentLevel);
	        UIController.updateCounter('lives', shipLives);
	        UIController.updateCounter('score', currentScore);
	        
	        PubSub.publish('statechange', {from: state.SET_UP_LEVEL, to: state.GAME_PLAY});
	    
	}
	
	function attachStateHandlers(){
	    
	    stateHandlers[state.LOADING] = handleLoading;
	    stateHandlers[state.STORY_LINE] = handleStoryLine;
	    stateHandlers[state.TITLE_SCREEN] = handleTitleScreen;
	    stateHandlers[state.SET_UP_LEVEL] = handleSetUpLevel;
	    stateHandlers[state.GAME_PLAY] = handleGamePlay;
	    stateHandlers[state.SHIP_JUMP] = handleShipJump;
	    stateHandlers[state.LEVEL_TRANSITION] = handleLevelTransition;
	    stateHandlers[state.BEAT_GAME] = handleBeatGame;
	    stateHandlers[state.GAME_OVER] = handleGameOver;
	    stateHandlers[state.CREDITS] = handleCredits;
	    stateHandlers[state.HOW_TO_PLAY] = handleHowToPlay;
	    stateHandlers[state.PAUSED] = handlePause;
	        
	}
	
	function handleLoading(){
	    //do nothing   
	}
	
	function handleStoryLine(){
	
	    if(!loopOn){
	     
	        loopOn = true;
	        gameLoop();
	        
	    }
	    
	    background.draw();
	    
	}
	
	function handleTitleScreen(){
	    
	    if(!loopOn){
	        
	        loopOn = true;
	        gameLoop();
	        
	    }
	    
	    background.draw();
	    mainContext.drawImage(ResourceLoader.assets.earthSprite, (mainCanvas.width/2-(ResourceLoader.assets.earthSprite.width/2)), 0);
	        
	        for(var i=0; i<7; i++){
	            var currentEnemy = enemyShipsPool.pool[i];
	            currentEnemy.draw();
	            currentEnemy.follow(mouse);
	            Algorithms.checkBoundary(currentEnemy);
	        }
	    
	}
	
	function handleGamePlay(){
	    
	    if(!loopOn){
	        
	        ResourceLoader.assets.soundTrack.play();
	        loopOn = true;
	        gameLoop();
	           
	    }
	    
	     background.draw();
	
	        if(alienMothership.alive){
	            alienMothership.draw();
	            Algorithms.checkBoundary(alienMothership);
	            alienMothership.follow(playerShip);
	            alienMothership.attack(playerShip);
	            alienMothership.missiles.isCollidingWith(playerShip, playerShip.shield);
	            playerShip.missiles.isCollidingWith(alienMothership, alienMothership.shield);
	        }
	
	            for(var m=0; m<perksPool.pool.length; m++){
	                    var currentPerk = perksPool.pool[m];
	                    if(currentPerk.alive){
	                        currentPerk.draw(); 
	                        
	                        if(Algorithms.hitTest(currentPerk, playerShip)){
	                            console.log('DETECTION CONFIRMED!!');
	                            console.log(currentPerk);
	                            console.log(playerShip);
	                            currentPerk.destroy();
	                            PubSub.publish('collision', currentPerk.type);
	                        }
	                    }
	                }
	        
	        for(var i = 0; i<meteorPool.pool.length; i++){
	           
	            var currentMeteor = meteorPool.pool[i];
	            
	            if(currentMeteor.alive){
	                currentMeteor.draw();
	                Algorithms.checkBoundary(currentMeteor);
	                playerShip.missiles.isCollidingWith(currentMeteor);
	            }
	        }
	        
	        meteorPool.isCollidingWith(playerShip, playerShip.shield);
	        
	        for(var h = 0; h<enemyShipsPool.pool.length; h++){
	            
	            var currentEnemy = enemyShipsPool.pool[h];
	            
	            if(currentEnemy.alive){
	                
	                currentEnemy.draw();
	                Algorithms.checkBoundary(currentEnemy);
	                currentEnemy.follow(playerShip);
	                currentEnemy.attack(playerShip);
	                currentEnemy.missiles.isCollidingWith(playerShip, playerShip.shield, meteorPool.pool);
	                playerShip.missiles.isCollidingWith(currentEnemy, currentEnemy.shield);
	                
	                if(Algorithms.hitTest(currentEnemy, playerShip)){
	                    
	                    currentEnemy.destroy();
	                    playerShip.destroy();
	                    PubSub.publish('collision', currentEnemy.type);
	                    PubSub.publish('collision', playerShip.type);
	                    
	                }
	                
	            }
	            
	        }
	    
	        //check frames
			
	        if(playerShip.alive){
				keyboardControl.update();
	            Algorithms.checkBoundary(playerShip);
	            playerShip.draw();
	        }
	        
	        
	        if(shipLives <= 0 && !playerShip.colliding && state.CURRENT == state.GAME_PLAY){
	            
	                    if(currentLevel == lastLevel){
							ResourceLoader.assets.lastLevelSound.stop();
						}else{
							ResourceLoader.assets.soundTrack.stop(); 
						}
	                
	                PubSub.publish('statechange', {from: state.GAME_PLAY, to: state.GAME_OVER});
	            
	                currentLevel = 0;
	            
	        }else if(levelEnemies <= 0 && !playerShip.colliding && playerShip.alive && state.CURRENT == state.GAME_PLAY){
	            
	                    if(currentLevel == lastLevel){
							ResourceLoader.assets.lastLevelSound.stop();
						}else{
							ResourceLoader.assets.soundTrack.stop(); 
						}
	            
	            PubSub.publish('statechange', {from: state.GAME_PLAY, to: state.SHIP_JUMP});
	
	        }
	    
	}
	
	function handleLevelTransition(){
	    
	    if(loopOn){
	     
	        loopOn = false;
	        gameLoop();
	
	    }
	
	    
	    UIController.updateCounter('reportScore', currentScore);
	    UIController.updateCounter('reportCarnage', enemiesKilled);   
	    UIController.updateCounter('reportAsteroids', rocksDestroyed);
	
	    
	}
	
	function handleMeteorExplosion(event, meteor){
	    
	    
	            switch(meteor.size){
	                case "large":
	                meteorPool.get(meteor.x, meteor.y, "mediumRock");
	                meteorPool.get(meteor.x, meteor.y, "mediumRock");
	                    break;
	                case "medium":
	                meteorPool.get(meteor.x, meteor.y, "smallRock");
	                meteorPool.get(meteor.x, meteor.y, "smallRock");
	                    break;
	                case "small":
	                    //no rocks
	                    break;     
	            } 
	    
	}
	
	function handleShipJump(){
	    
	    if(!loopOn){
	        
	        loopOn = true;
	        gameLoop();
	        
	    }
	    
	    
	    //draw background
	        background.draw();
	        
	        //drawRemaining rocks
	        for(var k=0; k<meteorPool.pool.length; k++){
	            var currentRock = meteorPool.pool[k];
	            
	            //if rock alive draw it
	            if(currentRock.alive){
	                Algorithms.checkBoundary(currentRock);
	                currentRock.draw();
	            }
	        }
	        
	        enemyShipsPool.pool.forEach(function(enemy){
	            if(enemy.alive){
	                enemy.draw();
	            }
	        });
	        
			playerShip.jump();
	        playerShip.draw();
	        
	        
	        if(playerShip.x >= 1020-playerShip.width){ 
	            
	            PubSub.publish('statechange', {from: state.SHIP_JUMP, to: state.LEVEL_TRANSITION});
	            
	        }
	    
	}
	
	function handlePause(){
	 
	    ResourceLoader.assets.soundTrack.pause();
	    ResourceLoader.assets.lastLevelSound.pause();
	    loopOn = false;
	    
	}
	
	function handleBeatGame(){
	    
	        if(loopOn){
	            
	            loopOn = false;
	            
	        }
			
	        //outputs the final score to the winner gamer :)
	        //ResourceLoader.finalLevelSound.stop();       
	        //beatGameScore.innerHTML = "Your Score: "+currentScore;
	    
	        UIController.updateCounter('beatGameScore', currentScore);
	        userBeatGame = false;
	                
	        ResourceLoader.assets.victorySound.play();
	        
	        //resets that score
	        currentScore = 0;
	        currentLevel = 0;
	       
	}
	
	function handleGameOver(){
	    
	        if(loopOn){
	         
	            loopOn = false;
	            
	        }
	        
	        //checks to see which sound to stop playing given the level the user was before dying
			ResourceLoader.assets.gameOverSound.play();
	        
	        //resets the score and level
	        currentLevel = 0;
	        currentScore = 0;
	    
	}
	
	function recordCollision(event, objectType){
	    
	        switch(objectType){
	            case "largeRock":
	                currentScore += 20;
	                UIController.updateCounter('score', currentScore);
	                rocksDestroyed++;
	                break;
	                
	            case "mediumRock":
	                currentScore += 10;
	                UIController.updateCounter('score', currentScore);
	                rocksDestroyed++;
	                break;
	                
	            case "smallRock":
	                currentScore += 5;
	                UIController.updateCounter('score', currentScore);
	                rocksDestroyed++;
	                break;
	                
	            case "humanShip":
	                shipLives--;
	                currentScore -= 50;
	                UIController.updateCounter('score', currentScore);
	                UIController.updateCounter('lives', shipLives);
	                break;
	                
	            case "enemy":
	                currentScore += 50;
	                UIController.updateCounter('score', currentScore);
	                levelEnemies--;
	                enemiesKilled++;
	                break;
	                
	            case "life":
	                shipLives++;
	                UIController.updateCounter('lives', shipLives);
	                break;
	                
	            case "shield":
	                playerShip.shield.reset();
	                break;
	            case "cash":
	                break;
	        }
	        
	}
	
	function handleCredits(){
	    
		if(loopOn){
			loopOn = false;
		}
	    
	    
	}
	
	function handleHowToPlay(){
	    
		if(loopOn){
			loopOn = false;
		}
	    
	    
	}
	
	function handleStateChange(event, data){
	    
	    state.CURRENT = data.to;
	    
	    runState(data.to);
	    
	    
	}
	
	function runState(state){
	    
	     stateHandlers[state]();
	    
	}
	    
	function gameLoop(){
	    
	    if(loopOn){
	     
			requestAnimFrame(gameLoop, FRAME_RATE);
				
			runState(state.CURRENT);
			
			console.log('game loop running');
			
			
			}
	}
	
	module.exports = {
	    
	    init : init
	    
	};

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	
	var PubSub = __webpack_require__(3);
	
	var keyboardControl = function(){
		
		//control keys
		const UP_ARROW = 38,
			LEFT_ARROW = 37,
			RIGHT_ARROW = 39,
			DOWN_ARROW = 40,
			X_KEY = 88,
			SPACE_BAR = 32,
			LETTER_P = 80,
	          
	        state = {
	            INIT : -1,
	            LOADING: 0,
	            STORY_LINE : 1,
	            TITLE_SCREEN : 2,
	            GAME_PLAY : 3,
	            LEVEL_TRANSITION : 4,
	            BEAT_GAME : 5,
	            GAME_OVER : 6,
	            CREDITS : 7,
	            HOW_TO_PLAY : 8,
	            PAUSED : 9,
	            SHIP_JUMP : 10,
	            SET_UP_LEVEL: 11,
	
	            CURRENT : -1 
	    };
		
		//array of active and deactive keys
		var keyPressList = [],
			objects = [],
			initialized = false,
			inGamePlay = false;
		
		function init(objectsToControl){
			
			//pushes the elements to be manipulated by the keyword keys
			if(!objects.length){
				for(element in arguments){
					objects.push(arguments[element]);
				}
			}
		
			document.addEventListener('keyup', onKeyUp, false);
			document.addEventListener('keydown', onKeyDown, false);
			initialized = true;
			console.log('Keyword Control Module Initialized');
	        PubSub.subscribe('statechange', handleStateChange);
			
		}
		
		function handleStateChange(event, data){
			state.CURRENT = data.to;
		}
		
		function onKeyUp(e){
	        
			if(!initialized) return(console.log('Keyword Module has not been initialized...'));
			e.preventDefault();
			keyPressList[e.keyCode] = false;
	        
	        if(keyPressList[LETTER_P] == false && state.CURRENT === state.PAUSED){
					keyPressList[LETTER_P] = true;
	                PubSub.publish('statechange', {from: state.PAUSED, to: state.GAME_PLAY});
					console.log('Letter P has been pressed');
	
				}
	        
		}
		
		function onKeyDown(e){
			if(!initialized) return(console.log('Keyword Module has not been initialized...'));
			e.preventDefault();
			keyPressList[e.keyCode] = true; 
		}
		
		function runKeys(){
	        
			var length = objects.length;
			
			for(var i = 0; i<length; i++){
				
				var object = objects[i];
				
				if(keyPressList[LEFT_ARROW]){
					object.angle -= 5*Math.PI/180;
				}else if(keyPressList[RIGHT_ARROW]){
					object.angle += 5*Math.PI/180;
				}
				if(keyPressList[UP_ARROW]){
					object.thrust = true;
					var faceX = Math.cos(object.angle);
					var faceY = Math.sin(object.angle);
					var newVelX = object.velX+faceX*object.thrustAccel;
					var newVelY = object.velY+faceY*object.thrustAccel;
	
					var futureVelocity = Math.sqrt((newVelX*newVelX)+(newVelY*newVelY));
	
					if(futureVelocity > object.maxVelocity){
						newVelX = object.velX;
						newVelY = object.velY;
					}
	
					object.velX = newVelX;
					object.velY = newVelY;	
	
				}else{
					object.thrust = false;
				}
				if(keyPressList[SPACE_BAR] == false){                
					keyPressList[SPACE_BAR] = true;
					if(!object.shield.active){
					object.shoot();
					}				
				}
				if(keyPressList[X_KEY]){
					object.shield.active = true;
	
				}else if(keyPressList[X_KEY] == false){
					object.shield.active = false;
				}
				if(keyPressList[LETTER_P] == false){
					keyPressList[LETTER_P] = true;
	                PubSub.publish('statechange', {from: state.GAME_PLAY, to: state.PAUSED});
					console.log('Letter P has been pressed');
	
				}
				
			}
			
		}
		
		function end(){
			document.removeEventListener('keyup', onKeyUp, false);
			document.removeEventListener('keydown', onKeyDown, false);
			initialized = false;
			console.log('Keyword Module Terminated');
		}
		
		return{
			init : init,
			update : runKeys,
			end : end
		}
		
	}();
	
	module.exports = keyboardControl;

/***/ }
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgOGM0YTBhMGI4YmY4NGQ0YjM0NmQiLCJ3ZWJwYWNrOi8vLy4vanMvbWFpbi5qcyIsIndlYnBhY2s6Ly8vLi9qcy9SZXNvdXJjZUxvYWRlci5qcyIsIndlYnBhY2s6Ly8vLi9+L2hvd2xlci9kaXN0L2hvd2xlci5qcyIsIndlYnBhY2s6Ly8vLi9qcy9QdWJTdWIuanMiLCJ3ZWJwYWNrOi8vLy4vanMvQ29uc3RydWN0b3JzLmpzIiwid2VicGFjazovLy8uL2pzL0FsZ29yaXRobXMuanMiLCJ3ZWJwYWNrOi8vLy4vanMvVUlDb250cm9sbGVyLmpzIiwid2VicGFjazovLy8uL2pzL0dhbWUuanMiLCJ3ZWJwYWNrOi8vLy4vanMva2V5Ym9hcmRDb250cm9sLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1QkFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7O0FDdENBOztBQUVBOzs7QUFHQTs7QUFFQTs7O0FBR0Esc0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7Ozs7QUFJVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQSx1REFBc0Q7O0FBRXREO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFD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QTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBaUIsY0FBYztBQUMvQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWMsWUFBWTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBaUIsY0FBYztBQUMvQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFjLFNBQVM7QUFDdkIsZUFBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQSxlQUFjLFNBQVM7QUFDdkIsZUFBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFjLE1BQU07QUFDcEIsY0FBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7Ozs7Ozs7Ozs7OztBQy9xRkQsaUJBQWdCO0FBQ2hCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEtBQUk7O0FBRUo7O0FBRUE7O0FBRUE7Ozs7QUFJQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsa0NBQWlDLEtBQUs7O0FBRXRDOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSw2Q0FBNEMsS0FBSztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7OztBQUlBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxHOzs7Ozs7QUN6RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0M7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSw0QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBLE87O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDhEO0FBQ0EsNkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsSztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLCtCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxxQkFBb0IsNkJBQTZCO0FBQ2pELHdEO0FBQ0E7QUFDQSx1QztBQUNBO0FBQ0E7O0FBRUEsNEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOzs7O0FBSUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLDRDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSw0Q0FBMkMsMEc7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsNENBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsdUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsb0U7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsTzs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx1TDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsbUNBQWtDOztBQUVsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RDtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0Esb0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsc0Q7QUFDQTs7QUFFQSw0QjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLDRCOzs7QUFHQTs7QUFFQTtBQUNBLHVDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFD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TTtBQUNOLCtDO0FBQ0E7O0FBRUEsNENBQTJDLDJDQUEyQzs7QUFFdEY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQSxnRTtBQUNBOzs7QUFHQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCO0FBQ0EsYzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0EscUJBQW9CLDBCQUEwQjtBQUM5Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7OztBQUdBLG1EOztBQUVBLDRDQUEyQyxrREFBa0Q7O0FBRTdGOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLGlEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOzs7QUFHQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEc7Ozs7Ozs7QUM1a0JBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0RBQStDLHdDQUF3QztBQUN2Rjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQztBQUNBOztBQUVBOztBQUVBOztBQUVBLGlCQUFnQixVQUFVOztBQUUxQjs7QUFFQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQjs7QUFFQSxLQUFJO0FBQ0o7QUFDQTtBQUNBLHlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBK0Msd0NBQXdDO0FBQ3ZGOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEVBQUM7O0FBRUQsa0MiLCJmaWxlIjoiLi9zY3JpcHRzLm1pbi5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKVxuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuXG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRleHBvcnRzOiB7fSxcbiBcdFx0XHRpZDogbW9kdWxlSWQsXG4gXHRcdFx0bG9hZGVkOiBmYWxzZVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sb2FkZWQgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogd2VicGFjay9ib290c3RyYXAgOGM0YTBhMGI4YmY4NGQ0YjM0NmRcbiAqKi8iLCJ3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIG9uV2luZG93TG9hZCwgZmFsc2UpO1xyXG5cclxuZnVuY3Rpb24gb25XaW5kb3dMb2FkKCl7XHJcbiAgICBcclxuICAgIFxyXG4gICAgY2FudmFzQXBwKCk7XHJcbiAgICBcclxufVxyXG5cclxuXHJcbmZ1bmN0aW9uIGNhbnZhc0FwcCgpe1x0XHJcblx0XHJcblx0XHR2YXIgUmVzb3VyY2VMb2FkZXIgPSByZXF1aXJlKCcuL1Jlc291cmNlTG9hZGVyLmpzJyksXHJcbiAgICAgICAgICAgIFB1YlN1YiA9IHJlcXVpcmUoJy4vUHViU3ViLmpzJyksXHJcbiAgICAgICAgICAgIENvbnNjdHJ1Y3RvcnMgPSByZXF1aXJlKCcuL0NvbnN0cnVjdG9ycycpLFxyXG4gICAgICAgICAgICBVSUNvbnRyb2xsZXIgPSByZXF1aXJlKCcuL1VJQ29udHJvbGxlcicpLFxyXG4gICAgICAgICAgICBHYW1lID0gcmVxdWlyZSgnLi9HYW1lJyk7XHJcbiAgICBcclxuXHRcdFx0Ly9zZXRzIHVwIGdhbWUgZW5naW5lXHJcblx0XHR3aW5kb3cucmVxdWVzdEFuaW1GcmFtZSA9IChmdW5jdGlvbigpe1xyXG5cdHJldHVybiAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSAgIHx8XHJcblx0XHRcdHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcclxuXHRcdFx0d2luZG93Lm1velJlcXVlc3RBbmltYXRpb25GcmFtZSAgICB8fFxyXG5cdFx0XHR3aW5kb3cub1JlcXVlc3RBbmltYXRpb25GcmFtZSAgICAgIHx8XHJcblx0XHRcdHdpbmRvdy5tc1JlcXVlc3RBbmltYXRpb25GcmFtZSAgICAgfHxcclxuXHRcdFx0ZnVuY3Rpb24oLyogZnVuY3Rpb24gKi8gY2FsbGJhY2ssIC8qIERPTUVsZW1lbnQgKi8gZWxlbWVudCl7XHJcblx0XHRcdFx0d2luZG93LnNldFRpbWVvdXQoY2FsbGJhY2ssIEZSQU1FX1JBVEUpO1xyXG5cdFx0XHR9O1xyXG4gICAgICAgIH0pKCk7XHJcblxyXG5cclxuICAgIFxyXG4gICAgdmFyIHN0YXRlID0ge1xyXG4gICAgICAgICAgICBJTklUIDogLTEsXHJcbiAgICAgICAgICAgIExPQURJTkc6IDAsXHJcbiAgICAgICAgICAgIFNUT1JZX0xJTkUgOiAxLFxyXG4gICAgICAgICAgICBUSVRMRV9TQ1JFRU4gOiAyLFxyXG4gICAgICAgICAgICBHQU1FX1BMQVkgOiAzLFxyXG4gICAgICAgICAgICBMRVZFTF9UUkFOU0lUSU9OIDogNCxcclxuICAgICAgICAgICAgQkVBVF9HQU1FIDogNSxcclxuICAgICAgICAgICAgR0FNRV9PVkVSIDogNixcclxuICAgICAgICAgICAgQ1JFRElUUyA6IDcsXHJcbiAgICAgICAgICAgIEhPV19UT19QTEFZIDogOCxcclxuICAgICAgICAgICAgUEFVU0VEIDogOSxcclxuICAgICAgICAgICAgU0hJUF9KVU1QIDogMTAsXHJcbiAgICAgICAgICAgIFNFVF9VUF9MRVZFTDogMTEsXHJcblxyXG4gICAgICAgICAgICBDVVJSRU5UIDogLTEgXHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICBcclxuICAgIHdpbmRvdy5SZXNvdXJjZUxvYWRlciA9IFJlc291cmNlTG9hZGVyO1xyXG5cdC8vYWRkaW5nIHRoZSBzdGF0ZSBvYmplY3QgdG8gdGhlIGtleWJvYXJkQ29udHJvbCBzdGF0ZSBwcm9wZXJ0eVxyXG4gICAgdmFyIHByZWxvYWRJbWFnZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdwcmVsb2FkJyk7XHJcbiAgICBcclxuICAgIHByZWxvYWRJbWFnZS5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgJ2Rpc3BsYXk6IG5vbmU7Jyk7XHJcblx0XHJcblx0Ly9mcmFtZSwgYXNzZXRzIGNvdW50ZXIgYW5kIGF1ZGlvIHN1cHBvcnRcclxuXHR2YXIgZnJhbWVSYXRlID0gbmV3IEZyYW1lUmF0ZUNvdW50ZXIoKTtcclxuXHJcblx0XHJcbiAgICB2YXIgbG9hZEJhciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdsb2FkQmFyJyk7XHJcbiAgICBcclxuXHQvL3NldCB1cCBsb2FkZXJcclxuXHR2YXIgbG9hZGVyT3B0aW9ucyA9IHtcclxuXHRcdFx0YXNzZXRzIDoge1xyXG5cdFx0XHRcdGltZ3MgOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgZWFydGhTcHJpdGUgOiBcImFzc2V0cy9zcHJpdGVzL2VhcnRoLnBuZ1wiLFxyXG4gICAgICAgICAgICAgICAgICAgIHBsYXllclNwcml0ZVNoZWV0IDogXCJhc3NldHMvc3ByaXRlcy9wbGF5ZXJTaGlwLnBuZ1wiLFxyXG4gICAgICAgICAgICAgICAgICAgIGVuZW15U3ByaXRlU2hlZXQgOiBcImFzc2V0cy9zcHJpdGVzL2VuZW15U2hpcHMucG5nXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgTW90aGVyc2hpcFNwcml0ZVNoZWV0IDogXCJhc3NldHMvc3ByaXRlcy9tb3RoZXJzaGlwcy5wbmdcIixcclxuICAgICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kU3ByaXRlIDogXCJhc3NldHMvc3ByaXRlcy9iYWNrZ3JvdW5kLnBuZ1wiLFxyXG4gICAgICAgICAgICAgICAgICAgIG1ldGVvclNwcml0ZSA6IFwiYXNzZXRzL3Nwcml0ZXMvbWV0ZW9yU3ByaXRlLnBuZ1wiLFxyXG4gICAgICAgICAgICAgICAgICAgIHBlcmtTcHJpdGUgOiBcImFzc2V0cy9zcHJpdGVzL3BlcmtzLnBuZ1wiXHJcblx0XHRcdFx0fSxcclxuICAgICAgICAgICAgICAgIHNvdW5kcyA6IHtcclxuICAgICAgICAgICAgICAgICAgICBzb3VuZFRyYWNrIDoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzcmM6IFsnYXNzZXRzL3NvdW5kcy9zb3VuZHRyYWNrLm1wMycsJ2Fzc2V0cy9zb3VuZHMvc291bmR0cmFjay53YXYnXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdm9sdW1lOiAwLjUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvb3A6IGZhbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgbGFzdExldmVsU291bmQgOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICBzcmM6IFsnYXNzZXRzL3NvdW5kcy9maW5hbExldmVsU291bmQubXAzJywnYXNzZXRzL3NvdW5kcy9maW5hbExldmVsU291bmQud2F2J10sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICB2b2x1bWU6IDEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgbWV0ZW9yRXhwbG9zaW9uU291bmQgOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNyYzogWydhc3NldHMvc291bmRzL21ldGVvckV4cGxvc2lvbi5tcDMnLCdhc3NldHMvc291bmRzL21ldGVvckV4cGxvc2lvbi53YXYnXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdm9sdW1lOiAxLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHBsYXllclNob290U291bmQgOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNyYzogWydhc3NldHMvc291bmRzL3Nob290Lm1wMycsJ2Fzc2V0cy9zb3VuZHMvc2hvb3Qud2F2J10sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZvbHVtZTogMC4zLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIGV4cGxvc2lvblNvdW5kIDoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzcmM6IFsnYXNzZXRzL3NvdW5kcy9leHBsb3Npb24ubXAzJywnYXNzZXRzL3NvdW5kcy9leHBsb3Npb24ud2F2J10sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZvbHVtZTogMC4yLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHBlcmtTb3VuZCA6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3JjOiBbJ2Fzc2V0cy9zb3VuZHMvcGVyay5tcDMnLCdhc3NldHMvc291bmRzL3Blcmsud2F2J10sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZvbHVtZTogMS4wLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHZpY3RvcnlTb3VuZCA6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3JjOiBbJ2Fzc2V0cy9zb3VuZHMvdmljdG9yeS5tcDMnLCdhc3NldHMvc291bmRzL3ZpY3Rvcnkud2F2J10sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZvbHVtZTogMS4wLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIGdhbWVPdmVyU291bmQgOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNyYzogWydhc3NldHMvc291bmRzL2dhbWVvdmVyLm1wMycsJ2Fzc2V0cy9zb3VuZHMvZ2FtZW92ZXIud2F2J10sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZvbHVtZTogMS4wLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblx0XHRcdH0sXHJcbiAgICAgICAgICAgIHVzZUhvd2wgOiB0cnVlLFxyXG4gICAgICAgIFxyXG5cdFx0XHRvbmxvYWQgOiBmdW5jdGlvbihpdGVtKXtcclxuXHRcdFx0XHRsb2FkQmFyLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCAnd2lkdGg6ICcrUmVzb3VyY2VMb2FkZXIubG9hZGVkKjEwMCsnJTsnKTtcclxuXHRcdFx0fSxcclxuICAgICAgICBcclxuXHRcdFx0ZmluYWwgOiBmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICAgICAgR2FtZS5pbml0KCk7XHJcblx0XHRcdFx0UHViU3ViLnB1Ymxpc2goJ3N0YXRlY2hhbmdlJywge2Zyb206c3RhdGUuTE9BRElORywgdG86c3RhdGUuU1RPUllfTElORX0pO1xyXG5cdFx0XHR9XHJcblx0XHR9O1xyXG4gICAgXHJcbiAgICBVSUNvbnRyb2xsZXIuaW5pdCgpO1xyXG4gICAgUmVzb3VyY2VMb2FkZXIuaW5pdChsb2FkZXJPcHRpb25zKTtcclxuICAgIFJlc291cmNlTG9hZGVyLmRvd25sb2FkQWxsKCk7XHJcbiAgICBcclxuICAgIFxyXG4gICBcclxuICAgIFxyXG4gICAgXHJcbiAgICBcclxuICAgIC8vUHViU3ViLnB1Ymxpc2goJ3N0YXRlY2hhbmdlJywge2Zyb206IHN0YXRlLkxPQURJTkcsIHRvOiBzdGF0ZS5TVE9SWV9MSU5FfSk7XHJcbiAgICBcclxuXHRcclxuXHQvL2NvdW50ZXJzXHJcblx0dmFyIHNjb3JlQ291bnRlciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzY29yZUNvdW50ZXInKTtcclxuXHR2YXIgbGV2ZWxDb3VudGVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2xldmVsQ291bnRlcicpO1xyXG5cdHZhciBsaXZlc0NvdW50ZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbGl2ZXNDb3VudGVyJyk7XHJcblx0dmFyIGZyYW1lUmF0ZUNvdW50ZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZnJhbWVSYXRlJyk7XHJcbiAgICB2YXIgcmVwb3J0RW5lbWllc0tpbGxlZCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdyZXBvcnRDYXJuYWdlJyk7XHJcbiAgICB2YXIgcmVwb3J0Um9ja3NEZXN0cm95ZWQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZXBvcnRBc3Rlcm9pZHMnKTtcclxuICAgIHZhciByZXBvcnRTY29yZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdyZXBvcnRTY29yZScpO1xyXG4gICAgdmFyIGJlYXRHYW1lU2NvcmUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYmVhdEdhbWVTY29yZScpO1xyXG5cdFxyXG5cclxuXHRcclxuXHJcbiAgICAgICAgXHJcbiAgICAvL2dhbWUgc2NvcmUgdHJhY2tlclxyXG4gICAgXHJcbiAgICBmdW5jdGlvbiByZWNvcmRDb2xsaXNpb24ob2JqZWN0VHlwZSl7XHJcbiAgICAgICAgc3dpdGNoKG9iamVjdFR5cGUpe1xyXG4gICAgICAgICAgICBjYXNlIFwibGFyZ2VSb2NrXCI6XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50U2NvcmUgKz0gMjA7XHJcbiAgICAgICAgICAgICAgICB1cGRhdGVDb3VudGVyKCdzY29yZScpO1xyXG4gICAgICAgICAgICAgICAgcm9ja3NEZXN0cm95ZWQrKztcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGNhc2UgXCJtZWRpdW1Sb2NrXCI6XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50U2NvcmUgKz0gMTA7XHJcbiAgICAgICAgICAgICAgICB1cGRhdGVDb3VudGVyKCdzY29yZScpO1xyXG4gICAgICAgICAgICAgICAgcm9ja3NEZXN0cm95ZWQrKztcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGNhc2UgXCJzbWFsbFJvY2tcIjpcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRTY29yZSArPSA1O1xyXG4gICAgICAgICAgICAgICAgdXBkYXRlQ291bnRlcignc2NvcmUnKTtcclxuICAgICAgICAgICAgICAgIHJvY2tzRGVzdHJveWVkKys7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBjYXNlIFwiaHVtYW5TaGlwXCI6XHJcbiAgICAgICAgICAgICAgICBzaGlwTGl2ZXMtLTtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRTY29yZSAtPSA1MDtcclxuICAgICAgICAgICAgICAgIHVwZGF0ZUNvdW50ZXIoJ3Njb3JlJyk7XHJcbiAgICAgICAgICAgICAgICB1cGRhdGVDb3VudGVyKCdsaWZlJyk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBjYXNlIFwiZW5lbXlcIjpcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRTY29yZSArPSA1MDtcclxuICAgICAgICAgICAgICAgIHVwZGF0ZUNvdW50ZXIoJ3Njb3JlJyk7XHJcbiAgICAgICAgICAgICAgICBsZXZlbEVuZW1pZXMtLTtcclxuICAgICAgICAgICAgICAgIGVuZW1pZXNLaWxsZWQrKztcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGNhc2UgXCJsaWZlXCI6XHJcbiAgICAgICAgICAgICAgICBzaGlwTGl2ZXMrKztcclxuICAgICAgICAgICAgICAgIHVwZGF0ZUNvdW50ZXIoJ2xpZmUnKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGNhc2UgXCJzaGllbGRcIjpcclxuICAgICAgICAgICAgICAgIHBsYXllclNoaXAuc2hpZWxkLnJlc2V0KCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcImNhc2hcIjpcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgIH1cclxuICAgIFxyXG5cdC8vaGFuZGxlcyB0aGUgbW91c2Vtb3ZlIGludGVyYWN0aW9uIGF0IHRpdGxlIHNjcmVlbi5cclxuXHRmdW5jdGlvbiBvbk1vdXNlTW92ZShldmVudCl7XHJcbiAgICAgICAgXHJcblx0XHRpZihzdGF0ZS5DVVJSRU5UICE9IHN0YXRlLlRJVExFX1NDUkVFTil7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcblx0XHRpZiAoIGV2ZW50LmxheWVyWCB8fCAgZXZlbnQubGF5ZXJYID09IDApIHsgLy8gRmlyZWZveFxyXG4gICBcdFx0XHRtb3VzZS54ID0gZXZlbnQubGF5ZXJYIDtcclxuICAgIFx0XHRtb3VzZS55ID0gZXZlbnQubGF5ZXJZO1xyXG4gIFx0XHR9IGVsc2UgaWYgKGV2ZW50Lm9mZnNldFggfHwgZXZlbnQub2Zmc2V0WCA9PSAwKSB7IC8vIE9wZXJhXHJcbiAgICBcdFx0bW91c2UueCA9IGV2ZW50Lm9mZnNldFg7XHJcbiAgICBcdFx0bW91c2UueSA9IGV2ZW50Lm9mZnNldFk7XHJcbiAgXHRcdH1cclxuXHRcdFxyXG5cdH1cclxuXHRcclxuXHQvL0NoZWNrcyBmb3IgZGV2aWNlIG9yaWVudGF0aW9uXHJcblx0ZnVuY3Rpb24gb25PcmllbnRhdGlvbkNoYW5nZShlKXtcclxuXHJcblx0XHRpZih3aW5kb3cuaW5uZXJIZWlnaHQ+PSB3aW5kb3cuaW5uZXJXaWR0aCl7XHJcblx0XHRcdHVzZXJBZ2VudC5wb3J0cmFpdCA9IHRydWU7XHJcblx0XHRcdG9yaWVudGF0aW9uTWVzc2FnZUhvbGRlci5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgJ2Rpc3BsYXk6IGJsb2NrOycpO1xyXG5cdFx0XHRjYW52YXNIb2xkZXIuc2V0QXR0cmlidXRlKCdzdHlsZScsICdkaXNwbGF5Om5vbmU7Jyk7XHJcbiAgICAgICAgICAgIGludGVyZmFjZVdyYXBwZXIuc2V0QXR0cmlidXRlKCdzdHlsZScsICdkaXNwbGF5OiBub25lOycpO1xyXG5cdFx0fWVsc2UgaWYod2luZG93LmlubmVySGVpZ2h0PD13aW5kb3cuaW5uZXJXaWR0aCl7XHJcblx0XHRcdG9yaWVudGF0aW9uTWVzc2FnZUhvbGRlci5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgJycpO1xyXG5cdFx0XHRjYW52YXNIb2xkZXIuc2V0QXR0cmlidXRlKCdzdHlsZScsICcnKTtcclxuICAgICAgICAgICAgaW50ZXJmYWNlV3JhcHBlci5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgJycpO1xyXG5cdFx0XHR1c2VyQWdlbnQucG9ydHJhaXQgPSBmYWxzZTtcclxuXHRcdH1cclxuXHRcdFxyXG5cdH1cclxuXHRcclxuXHQvL3JlbW92ZXMgdGhlIGRlZmF1bHQgYmVoYXZpb3Igb2YgcGluY2hpbmcgem9vbSBvbiBNb2JpbGVcclxuXHRmdW5jdGlvbiBvblRvdWNoTW92ZShlKXtcclxuXHRcdFxyXG5cdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cdH1cclxuXHJcblx0Ly9GcmFtUmF0ZSBDbGFzc1xyXG5cdFxyXG5cdGZ1bmN0aW9uIEZyYW1lUmF0ZUNvdW50ZXIoKSB7XHJcblxyXG4gICAgICAgIHRoaXMubGFzdEZyYW1lQ291bnQgPSAwO1xyXG4gICAgICAgIHZhciBkYXRlVGVtcCA9IG5ldyBEYXRlKCk7XHJcbiAgICAgICAgdGhpcy5mcmFtZUxhc3QgPSBkYXRlVGVtcC5nZXRUaW1lKCk7XHJcbiAgICAgICAgZGVsZXRlIGRhdGVUZW1wO1xyXG4gICAgICAgIHRoaXMuZnJhbWVDdHIgPSAwO1xyXG4gICAgfVxyXG5cclxuICAgIEZyYW1lUmF0ZUNvdW50ZXIucHJvdG90eXBlLmNvdW50RnJhbWVzPWZ1bmN0aW9uKCkge1xyXG4gICAgICAgdmFyIGRhdGVUZW1wID0gbmV3IERhdGUoKTtcclxuICAgICAgIHRoaXMuZnJhbWVDdHIrKztcclxuXHJcbiAgICAgICBpZiAoZGF0ZVRlbXAuZ2V0VGltZSgpID49dGhpcy5mcmFtZUxhc3QrMTAwMCkge1xyXG4gICAgICAgICAgLy9Db25zb2xlTG9nLmxvZyhcImZyYW1lIGV2ZW50XCIpO1xyXG4gICAgICAgICAgdGhpcy5sYXN0RnJhbWVDb3VudCA9IHRoaXMuZnJhbWVDdHI7XHJcbiAgICAgICAgICB0aGlzLmZyYW1lTGFzdCA9IGRhdGVUZW1wLmdldFRpbWUoKTtcclxuICAgICAgICAgIHRoaXMuZnJhbWVDdHIgPSAwO1xyXG4gICAgICAgfVxyXG5cclxuICAgICAgIGRlbGV0ZSBkYXRlVGVtcDtcclxuICAgIH1cclxuXHJcbn1cclxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2pzL21haW4uanNcbiAqKiBtb2R1bGUgaWQgPSAwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgSG93bCA9IHJlcXVpcmUoJ2hvd2xlcicpLkhvd2w7XHJcbnZhciBQdWJTdWIgPSByZXF1aXJlKCcuL1B1YlN1YicpO1xyXG5cclxuXHJcbnZhciBSZXNvdXJjZUxvYWRlciA9IChmdW5jdGlvbigpe1xyXG5cdFxyXG5cdHZhciB0b3RhbEFzc2V0cyA9IDAsXHJcblx0XHRsb2FkZWRBc3NldHMgPSAwLFxyXG5cdFx0YXNzZXRzRG93bmxvYWRlZCA9IGZhbHNlLFxyXG5cdFx0VXNlck9wdGlvbnMsXHJcblx0XHRwZXJjZW50YWdlTG9hZGVkLFxyXG5cdFx0YXVkaW9TdXBwb3J0LFxyXG5cdFx0YXNzZXRzID0ge307XHJcblx0XHJcblx0XHQvL2RlZmF1bHQgb3B0aW9ucyBpZiBubyBvcHRpb24gYXJndW1lbnQgaXMgcGFzc2VkIGJ5IHVzZXIuXHJcblx0XHR2YXIgZGVmYXVsdE9wdGlvbnMgPSB7XHJcblx0XHRcdFx0XHQgIG9ubG9hZDogZnVuY3Rpb24oKXsgXHJcblx0XHRcdFx0XHRcdGNvbnNvbGUubG9nKCdObyBjYWxsYmFjayB3YXMgcGFzc2VkIGluLi4nKTtcclxuXHRcdFx0XHRcdFx0fSxcclxuXHRcdFx0XHRcdCAgZmluYWwgOiBmdW5jdGlvbigpe1xyXG5cdFx0XHRcdFx0XHQgIGNvbnNvbGUubG9nKCdObyBmaW5hbCBmdW5jdGlvbiB0byBjYWxsIHdhcyBwYXNzZWQgaW4uLicpO1xyXG5cdFx0XHRcdFx0ICB9LFxyXG5cdFx0XHRcdFx0IGFzc2V0cyA6IFtdXHJcblx0XHRcdFx0XHQgfTtcclxuXHRcclxuXHQvKiBFeGFtcGxlIG9mIG9wdGlvbnM6XHJcblx0XHJcblx0e1xyXG5cdFx0YXNzZXRzIDoge1xyXG5cdFx0XHJcblx0XHRcdGltZ3MgOiB7XHJcblx0XHRcdFx0Ly9pbWcgbmFtZXMgd2l0aCBVUkxzXHJcblx0XHRcdFx0YmdfYmxhY2sgOiBcImFzc2V0cy9pbWcvYmFja2dyb3VuZC5wbmcsXHJcblx0XHRcdFx0bWV0ZW9yU3ByaXRlIDogXCJhc3NldHMvaW1nL21ldGVvci5wbmcsXHJcblx0XHRcdFx0ZW5lbWllc1Nwcml0ZSA6IFwiYXNzZXRzL2ltZy9lbmVtaWVzLnBuZyxcclxuXHRcdFx0XHRlbmVteVNoaXBTcHJpdGVzOiBcImFzc2V0cy9pbWcvZW5lbXlTaGlwcy5wbmdcclxuXHRcdFx0fSxcclxuXHRcdFx0c291bmRzIDoge1xyXG5cdFx0XHRcdC8vc291bmRzIG5hbWUgd2l0aCBVUkxzXHJcblx0XHRcdFx0c291bmR0cmFjayA6IFtcImFzc2V0cy9zb3VuZHMvcGxheWVyLm1wM1wiLCBcImFzc2V0cy9zb3VuZHMvcGxheWVyLndhdlwiXSxcclxuXHRcdFx0XHRlbmRTb3VuZCA6IFtcImFzc2V0cy9zb3VuZHMvZ2FtZW92ZXIubXAzXCIsIFwiYXNzZXRzL3NvdW5kcy9nYW1lb3Zlci53YXZcIl1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG4gICAgICAgIHVzZUhvd2wgOiBmYWxzZSxcclxuXHRcdFx0Ly9mdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCBvbiBldmVyeSBpdGVtIGxvYWRlZFxyXG5cdFx0b25sb2FkIDogdXBkYXRlTG9hZGVyRGlzcGxheWVyLFxyXG5cdFx0XHQvL2Z1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIG9uY2UgYWxsIGhhdmUgbG9hZGVkXHJcblx0XHRmaW5hbCA6IGZpbmFsRnVuY3Rpb25Ub0NhbGxcclxuXHR9XHJcblxyXG5cdCovXHJcblx0XHRcclxuXHRmdW5jdGlvbiBpbml0KG9wdGlvbnMpe1xyXG5cdFx0VXNlck9wdGlvbnMgPSBvcHRpb25zIHx8IGRlZmF1bHRPcHRpb25zO1xyXG5cdH1cclxuXHRcclxuXHRmdW5jdGlvbiBkb3dubG9hZCgpe1xyXG5cdFx0XHJcblx0XHQvL3JldHVybiBpZiBhbGwgYXNzZXRzIGhhdmUgYWxyZWFkeSBsb2FkZWQgYW5kIGluZGV4ZWQuXHJcblx0XHRpZihhc3NldHNEb3dubG9hZGVkKSByZXR1cm47XHJcbiAgICAgICAgXHJcbiAgICAgICAgUHViU3ViLnB1Ymxpc2goJ3N0YXRlY2hhbmdlJywge2Zyb206IHN0YXRlLklOSVQsIHRvOiBzdGF0ZS5MT0FESU5HfSk7XHJcblx0XHRcclxuXHRcdC8vc2V0cyB0byB0cnVlIHNvIHRoaXMgbWV0aG9kIChkb3dubG9hZEFsbCgpKSBpcyBjYWxsZWQgb25seSBvbmNlZC5cclxuXHRcdGFzc2V0c0Rvd25sb2FkZWQgPSB0cnVlO1xyXG5cdFx0Ly9jcmVhdGVzIHRoZSBzb3VuZCBhbmQgaW1hZ2UgZWxlbWVudHMgZm9yIGVhY2ggYXNzZXQgaW4gdGhlIG9wdGlvbnMgYXJndW1lbnQuXHJcblx0XHRmb3IodmFyIGl0ZW0gaW4gVXNlck9wdGlvbnMuYXNzZXRzLmltZ3Mpe1xyXG5cdFx0XHRhc3NldHNbaXRlbV0gPSBuZXcgSW1hZ2UoKTtcclxuXHRcdFx0YXNzZXRzW2l0ZW1dLnNyYyA9IFVzZXJPcHRpb25zLmFzc2V0cy5pbWdzW2l0ZW1dO1xyXG5cdFx0XHRhc3NldHNbaXRlbV0uYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIG9uTG9hZCwgZmFsc2UpO1xyXG5cdFx0XHR0b3RhbEFzc2V0cysrO1xyXG5cdFx0fVxyXG5cdFx0Ly9hcnJheXMgYXJlIHBhc3NlZCBmb3IgZWFjaCBzb3VuZCBhc3NldCBjb250YWluaW5nIHRoZSBzb3VyY2UgdG8gdGhlIHNvdW5kLlxyXG4gICAgICAgIGlmKCFVc2VyT3B0aW9ucy51c2VIb3dsKXtcclxuICAgICAgICAgICAgZm9yKHZhciBpdGVtIGluIFVzZXJPcHRpb25zLmFzc2V0cy5zb3VuZHMpe1xyXG4gICAgICAgICAgICAgICAgZm9yKHZhciBpPTAsIGo9VXNlck9wdGlvbnMuYXNzZXRzLnNvdW5kc1tpdGVtXS5sZW5ndGg7IGk8ajsgaSsrKXtcclxuICAgICAgICAgICAgICAgIHZhciBjdXJyZW50U291bmQgPSBVc2VyT3B0aW9ucy5hc3NldHMuc291bmRzW2l0ZW1dW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vYW5hbHl6ZXMgdGhlIGV4dGVuc2lvbiBhbmQgcGlja3MgdGhlIGZpcnN0IG9uZSB0aGF0IGlzIHN1cHBvcnRlZCBieSB0aGUgYnJvd3Nlci5cclxuICAgICAgICAgICAgICAgICAgICBpZihpc0F1ZGlvU3VwcG9ydChjdXJyZW50U291bmQuc2xpY2UoLTMpKSl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzc2V0c1tpdGVtXSA9IG5ldyBBdWRpbygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhc3NldHNbaXRlbV0uc3JjID0gVXNlck9wdGlvbnMuYXNzZXRzLnNvdW5kc1tpdGVtXVtpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXRzW2l0ZW1dLmFkZEV2ZW50TGlzdGVuZXIoJ2NhbnBsYXl0aHJvdWdoJywgb25Mb2FkLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvdGFsQXNzZXRzKys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgLy9jcmVhdGVzIGhvd2wgaW5zdGFuY2UgYW5kIHBhc3NlcyBpbiBob3dsIG9wdGlvbnMgZ2l2ZW4gYnkgdGhlIHVzZXIuXHJcbiAgICAgICAgICAgIGZvcih2YXIgaXRlbSBpbiBVc2VyT3B0aW9ucy5hc3NldHMuc291bmRzKXtcclxuICAgICAgICAgICAgICAgIHZhciBob3dsT3B0aW9ucyA9IFVzZXJPcHRpb25zLmFzc2V0cy5zb3VuZHNbaXRlbV07XHJcbiAgICAgICAgICAgICAgICBob3dsT3B0aW9ucy5vbmxvYWQgPSBvbkxvYWQ7XHJcbiAgICAgICAgICAgICAgICBhc3NldHNbaXRlbV0gPSBuZXcgSG93bChob3dsT3B0aW9ucyk7IFxyXG4gICAgICAgICAgICAgICAgdG90YWxBc3NldHMrKztcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cdFx0XHJcblx0fVxyXG5cdFxyXG5cdGZ1bmN0aW9uIG9uTG9hZChpdGVtKXtcclxuICAgICAgICBcclxuICAgICAgICAvL2luY3JlbWVudHMgbG9hZCBjb3VudCBhbmQgcmVtb3ZlIGxpc3RlbmVycy5cclxuXHRcdGxvYWRlZEFzc2V0cysrO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciBpdGVtTG9hZGVkO1xyXG5cclxuICAgICAgICBpZihpdGVtKXtcclxuICAgICAgICAgICAgaWYoaXRlbS50YXJnZXQudGFnTmFtZSA9PT0gXCJBVURJT1wiKXtcclxuICAgICAgICAgICAgICAgIGl0ZW1Mb2FkZWQgPSBpdGVtLnRhcmdldDtcclxuICAgICAgICAgICAgICAgIGl0ZW0udGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NhbnBsYXl0aHJvdWdoJywgb25Mb2FkLCBmYWxzZSk7XHJcbiAgICAgICAgICAgIH1lbHNlIGlmIChpdGVtLnRhcmdldC50YWdOYW1lID09PSBcIklNR1wiKXtcclxuICAgICAgICAgICAgICAgIGl0ZW1Mb2FkZWQgPSBpdGVtLnRhcmdldDtcclxuICAgICAgICAgICAgICAgIGl0ZW0udGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBvbkxvYWQsIGZhbHNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICBpdGVtTG9hZGVkID0ge25hbWU6IFwiSG93bCBzb3VuZFwiLCBzcmM6IFwiSG93bCBzb3VuZCBjaGVjayBzb3VuZFwifTsgICBcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcblx0XHQvL2NhbGN1bGF0ZXMgdGhlIGRlY2ltYWwgdmFsdWUgZnJvbSByYXRpb1xyXG5cdFx0cGVyY2VudGFnZUxvYWRlZCA9IE1hdGguZmxvb3IoKGxvYWRlZEFzc2V0cyAvIHRvdGFsQXNzZXRzKSoxMDApLzEwMDtcclxuXHRcdFxyXG5cdFx0Ly9jYWxsIHRoZSBhcHByb3ByaWF0ZSBjYWxsYmFjayBmdW5jdGlvbiBnaXZlbiB0aGUgYW1tb3VudCBvZiBhc3NldHMgbG9hZGVkLlxyXG5cdFx0aWYoVXNlck9wdGlvbnMub25sb2FkKXtcclxuXHRcdFx0VXNlck9wdGlvbnMub25sb2FkKGl0ZW1Mb2FkZWQpO1xyXG5cdFx0fVxyXG5cdFx0aWYobG9hZGVkQXNzZXRzID49IHRvdGFsQXNzZXRzICYmIFVzZXJPcHRpb25zLmZpbmFsKXtcclxuXHRcdFx0VXNlck9wdGlvbnMuZmluYWwoaXRlbUxvYWRlZCk7XHJcblx0XHR9XHJcblx0XHRcclxuXHR9XHJcblx0XHJcblx0Ly9nZXRzIHRoZSBhcHByb3ByaWF0ZSBzdXBwb3J0ZWQgYXVkaW8gZm9ybWF0LlxyXG5cdGZ1bmN0aW9uIGlzQXVkaW9TdXBwb3J0KGV4dGVuc2lvbil7XHJcblx0XHRcclxuXHRcdHZhciBhdWRpbyA9IG5ldyBBdWRpbygpO1xyXG5cdFx0dmFyIHN1cHBvcnRWYWx1ZSA9IGF1ZGlvLmNhblBsYXlUeXBlKFwiYXVkaW8vXCIrZXh0ZW5zaW9uKTtcclxuXHRcdGlmKCBzdXBwb3J0VmFsdWUgPT09IFwibWF5YmVcIiB8fCBzdXBwb3J0VmFsdWUgPT09IFwicHJvYmFibHlcIiApe1xyXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdH1lbHNle1xyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHR9XHJcblx0fVxyXG5cdFxyXG5cdHJldHVybiB7XHJcblx0XHRpbml0IDogaW5pdCxcclxuXHRcdGFzc2V0cyA6IGFzc2V0cyxcclxuXHRcdGdldCBsb2FkZWQoKXtcclxuXHRcdFx0cmV0dXJuIHBlcmNlbnRhZ2VMb2FkZWQ7XHJcblx0XHR9LFxyXG4gICAgXHRkb3dubG9hZEFsbCA6IGRvd25sb2FkXHJcblx0fVxyXG5cdFxyXG59KSgpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSZXNvdXJjZUxvYWRlcjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vanMvUmVzb3VyY2VMb2FkZXIuanNcbiAqKiBtb2R1bGUgaWQgPSAxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKiFcbiAqICBob3dsZXIuanMgdjIuMC4wXG4gKiAgaG93bGVyanMuY29tXG4gKlxuICogIChjKSAyMDEzLTIwMTYsIEphbWVzIFNpbXBzb24gb2YgR29sZEZpcmUgU3R1ZGlvc1xuICogIGdvbGRmaXJlc3R1ZGlvcy5jb21cbiAqXG4gKiAgTUlUIExpY2Vuc2VcbiAqL1xuXG4oZnVuY3Rpb24oKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8qKiBHbG9iYWwgTWV0aG9kcyAqKi9cbiAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAvKipcbiAgICogQ3JlYXRlIHRoZSBnbG9iYWwgY29udHJvbGxlci4gQWxsIGNvbnRhaW5lZCBtZXRob2RzIGFuZCBwcm9wZXJ0aWVzIGFwcGx5XG4gICAqIHRvIGFsbCBzb3VuZHMgdGhhdCBhcmUgY3VycmVudGx5IHBsYXlpbmcgb3Igd2lsbCBiZSBpbiB0aGUgZnV0dXJlLlxuICAgKi9cbiAgdmFyIEhvd2xlckdsb2JhbCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuaW5pdCgpO1xuICB9O1xuICBIb3dsZXJHbG9iYWwucHJvdG90eXBlID0ge1xuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemUgdGhlIGdsb2JhbCBIb3dsZXIgb2JqZWN0LlxuICAgICAqIEByZXR1cm4ge0hvd2xlcn1cbiAgICAgKi9cbiAgICBpbml0OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcyB8fCBIb3dsZXI7XG5cbiAgICAgIC8vIEludGVybmFsIHByb3BlcnRpZXMuXG4gICAgICBzZWxmLl9jb2RlY3MgPSB7fTtcbiAgICAgIHNlbGYuX2hvd2xzID0gW107XG4gICAgICBzZWxmLl9tdXRlZCA9IGZhbHNlO1xuICAgICAgc2VsZi5fdm9sdW1lID0gMTtcbiAgICAgIHNlbGYuX2NhblBsYXlFdmVudCA9ICdjYW5wbGF5dGhyb3VnaCc7XG4gICAgICBzZWxmLl9uYXZpZ2F0b3IgPSAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93Lm5hdmlnYXRvcikgPyB3aW5kb3cubmF2aWdhdG9yIDogbnVsbDtcblxuICAgICAgLy8gUHVibGljIHByb3BlcnRpZXMuXG4gICAgICBzZWxmLm1hc3RlckdhaW4gPSBudWxsO1xuICAgICAgc2VsZi5ub0F1ZGlvID0gZmFsc2U7XG4gICAgICBzZWxmLnVzaW5nV2ViQXVkaW8gPSB0cnVlO1xuICAgICAgc2VsZi5hdXRvU3VzcGVuZCA9IHRydWU7XG4gICAgICBzZWxmLmN0eCA9IG51bGw7XG5cbiAgICAgIC8vIFNldCB0byBmYWxzZSB0byBkaXNhYmxlIHRoZSBhdXRvIGlPUyBlbmFibGVyLlxuICAgICAgc2VsZi5tb2JpbGVBdXRvRW5hYmxlID0gdHJ1ZTtcblxuICAgICAgLy8gU2V0dXAgdGhlIHZhcmlvdXMgc3RhdGUgdmFsdWVzIGZvciBnbG9iYWwgdHJhY2tpbmcuXG4gICAgICBzZWxmLl9zZXR1cCgpO1xuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0L3NldCB0aGUgZ2xvYmFsIHZvbHVtZSBmb3IgYWxsIHNvdW5kcy5cbiAgICAgKiBAcGFyYW0gIHtGbG9hdH0gdm9sIFZvbHVtZSBmcm9tIDAuMCB0byAxLjAuXG4gICAgICogQHJldHVybiB7SG93bGVyL0Zsb2F0fSAgICAgUmV0dXJucyBzZWxmIG9yIGN1cnJlbnQgdm9sdW1lLlxuICAgICAqL1xuICAgIHZvbHVtZTogZnVuY3Rpb24odm9sKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXMgfHwgSG93bGVyO1xuICAgICAgdm9sID0gcGFyc2VGbG9hdCh2b2wpO1xuXG4gICAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGFuIEF1ZGlvQ29udGV4dCBjcmVhdGVkIHlldCwgcnVuIHRoZSBzZXR1cC5cbiAgICAgIGlmICghc2VsZi5jdHgpIHtcbiAgICAgICAgc2V0dXBBdWRpb0NvbnRleHQoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiB2b2wgIT09ICd1bmRlZmluZWQnICYmIHZvbCA+PSAwICYmIHZvbCA8PSAxKSB7XG4gICAgICAgIHNlbGYuX3ZvbHVtZSA9IHZvbDtcblxuICAgICAgICAvLyBEb24ndCB1cGRhdGUgYW55IG9mIHRoZSBub2RlcyBpZiB3ZSBhcmUgbXV0ZWQuXG4gICAgICAgIGlmIChzZWxmLl9tdXRlZCkge1xuICAgICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gV2hlbiB1c2luZyBXZWIgQXVkaW8sIHdlIGp1c3QgbmVlZCB0byBhZGp1c3QgdGhlIG1hc3RlciBnYWluLlxuICAgICAgICBpZiAoc2VsZi51c2luZ1dlYkF1ZGlvKSB7XG4gICAgICAgICAgc2VsZi5tYXN0ZXJHYWluLmdhaW4udmFsdWUgPSB2b2w7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBMb29wIHRocm91Z2ggYW5kIGNoYW5nZSB2b2x1bWUgZm9yIGFsbCBIVE1MNSBhdWRpbyBub2Rlcy5cbiAgICAgICAgZm9yICh2YXIgaT0wOyBpPHNlbGYuX2hvd2xzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKCFzZWxmLl9ob3dsc1tpXS5fd2ViQXVkaW8pIHtcbiAgICAgICAgICAgIC8vIEdldCBhbGwgb2YgdGhlIHNvdW5kcyBpbiB0aGlzIEhvd2wgZ3JvdXAuXG4gICAgICAgICAgICB2YXIgaWRzID0gc2VsZi5faG93bHNbaV0uX2dldFNvdW5kSWRzKCk7XG5cbiAgICAgICAgICAgIC8vIExvb3AgdGhyb3VnaCBhbGwgc291bmRzIGFuZCBjaGFuZ2UgdGhlIHZvbHVtZXMuXG4gICAgICAgICAgICBmb3IgKHZhciBqPTA7IGo8aWRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgIHZhciBzb3VuZCA9IHNlbGYuX2hvd2xzW2ldLl9zb3VuZEJ5SWQoaWRzW2pdKTtcblxuICAgICAgICAgICAgICBpZiAoc291bmQgJiYgc291bmQuX25vZGUpIHtcbiAgICAgICAgICAgICAgICBzb3VuZC5fbm9kZS52b2x1bWUgPSBzb3VuZC5fdm9sdW1lICogdm9sO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmLl92b2x1bWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEhhbmRsZSBtdXRpbmcgYW5kIHVubXV0aW5nIGdsb2JhbGx5LlxuICAgICAqIEBwYXJhbSAge0Jvb2xlYW59IG11dGVkIElzIG11dGVkIG9yIG5vdC5cbiAgICAgKi9cbiAgICBtdXRlOiBmdW5jdGlvbihtdXRlZCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzIHx8IEhvd2xlcjtcblxuICAgICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBhbiBBdWRpb0NvbnRleHQgY3JlYXRlZCB5ZXQsIHJ1biB0aGUgc2V0dXAuXG4gICAgICBpZiAoIXNlbGYuY3R4KSB7XG4gICAgICAgIHNldHVwQXVkaW9Db250ZXh0KCk7XG4gICAgICB9XG5cbiAgICAgIHNlbGYuX211dGVkID0gbXV0ZWQ7XG5cbiAgICAgIC8vIFdpdGggV2ViIEF1ZGlvLCB3ZSBqdXN0IG5lZWQgdG8gbXV0ZSB0aGUgbWFzdGVyIGdhaW4uXG4gICAgICBpZiAoc2VsZi51c2luZ1dlYkF1ZGlvKSB7XG4gICAgICAgIHNlbGYubWFzdGVyR2Fpbi5nYWluLnZhbHVlID0gbXV0ZWQgPyAwIDogc2VsZi5fdm9sdW1lO1xuICAgICAgfVxuXG4gICAgICAvLyBMb29wIHRocm91Z2ggYW5kIG11dGUgYWxsIEhUTUw1IEF1ZGlvIG5vZGVzLlxuICAgICAgZm9yICh2YXIgaT0wOyBpPHNlbGYuX2hvd2xzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICghc2VsZi5faG93bHNbaV0uX3dlYkF1ZGlvKSB7XG4gICAgICAgICAgLy8gR2V0IGFsbCBvZiB0aGUgc291bmRzIGluIHRoaXMgSG93bCBncm91cC5cbiAgICAgICAgICB2YXIgaWRzID0gc2VsZi5faG93bHNbaV0uX2dldFNvdW5kSWRzKCk7XG5cbiAgICAgICAgICAvLyBMb29wIHRocm91Z2ggYWxsIHNvdW5kcyBhbmQgbWFyayB0aGUgYXVkaW8gbm9kZSBhcyBtdXRlZC5cbiAgICAgICAgICBmb3IgKHZhciBqPTA7IGo8aWRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICB2YXIgc291bmQgPSBzZWxmLl9ob3dsc1tpXS5fc291bmRCeUlkKGlkc1tqXSk7XG5cbiAgICAgICAgICAgIGlmIChzb3VuZCAmJiBzb3VuZC5fbm9kZSkge1xuICAgICAgICAgICAgICBzb3VuZC5fbm9kZS5tdXRlZCA9IChtdXRlZCkgPyB0cnVlIDogc291bmQuX211dGVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVW5sb2FkIGFuZCBkZXN0cm95IGFsbCBjdXJyZW50bHkgbG9hZGVkIEhvd2wgb2JqZWN0cy5cbiAgICAgKiBAcmV0dXJuIHtIb3dsZXJ9XG4gICAgICovXG4gICAgdW5sb2FkOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcyB8fCBIb3dsZXI7XG5cbiAgICAgIGZvciAodmFyIGk9c2VsZi5faG93bHMubGVuZ3RoLTE7IGk+PTA7IGktLSkge1xuICAgICAgICBzZWxmLl9ob3dsc1tpXS51bmxvYWQoKTtcbiAgICAgIH1cblxuICAgICAgLy8gQ3JlYXRlIGEgbmV3IEF1ZGlvQ29udGV4dCB0byBtYWtlIHN1cmUgaXQgaXMgZnVsbHkgcmVzZXQuXG4gICAgICBpZiAoc2VsZi51c2luZ1dlYkF1ZGlvICYmIHR5cGVvZiBzZWxmLmN0eC5jbG9zZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgc2VsZi5jdHguY2xvc2UoKTtcbiAgICAgICAgc2VsZi5jdHggPSBudWxsO1xuICAgICAgICBzZXR1cEF1ZGlvQ29udGV4dCgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgZm9yIGNvZGVjIHN1cHBvcnQgb2Ygc3BlY2lmaWMgZXh0ZW5zaW9uLlxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gZXh0IEF1ZGlvIGZpbGUgZXh0ZW50aW9uLlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgY29kZWNzOiBmdW5jdGlvbihleHQpIHtcbiAgICAgIHJldHVybiAodGhpcyB8fCBIb3dsZXIpLl9jb2RlY3NbZXh0XTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0dXAgdmFyaW91cyBzdGF0ZSB2YWx1ZXMgZm9yIGdsb2JhbCB0cmFja2luZy5cbiAgICAgKiBAcmV0dXJuIHtIb3dsZXJ9XG4gICAgICovXG4gICAgX3NldHVwOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcyB8fCBIb3dsZXI7XG5cbiAgICAgIC8vIEtlZXBzIHRyYWNrIG9mIHRoZSBzdXNwZW5kL3Jlc3VtZSBzdGF0ZSBvZiB0aGUgQXVkaW9Db250ZXh0LlxuICAgICAgc2VsZi5zdGF0ZSA9IHNlbGYuY3R4ID8gc2VsZi5jdHguc3RhdGUgfHwgJ3J1bm5pbmcnIDogJ3J1bm5pbmcnO1xuXG4gICAgICAvLyBBdXRvbWF0aWNhbGx5IGJlZ2luIHRoZSAzMC1zZWNvbmQgc3VzcGVuZCBwcm9jZXNzXG4gICAgICBzZWxmLl9hdXRvU3VzcGVuZCgpO1xuXG4gICAgICAvLyBDaGVjayBmb3Igc3VwcG9ydGVkIGNvZGVjcy5cbiAgICAgIGlmICghc2VsZi5ub0F1ZGlvKSB7XG4gICAgICAgIHNlbGYuX3NldHVwQ29kZWNzKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBmb3IgYnJvd3NlciBzdXBwb3J0IGZvciB2YXJpb3VzIGNvZGVjcyBhbmQgY2FjaGUgdGhlIHJlc3VsdHMuXG4gICAgICogQHJldHVybiB7SG93bGVyfVxuICAgICAqL1xuICAgIF9zZXR1cENvZGVjczogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXMgfHwgSG93bGVyO1xuICAgICAgdmFyIGF1ZGlvVGVzdCA9ICh0eXBlb2YgQXVkaW8gIT09ICd1bmRlZmluZWQnKSA/IG5ldyBBdWRpbygpIDogbnVsbDtcblxuICAgICAgaWYgKCFhdWRpb1Rlc3QgfHwgdHlwZW9mIGF1ZGlvVGVzdC5jYW5QbGF5VHlwZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgIH1cblxuICAgICAgdmFyIG1wZWdUZXN0ID0gYXVkaW9UZXN0LmNhblBsYXlUeXBlKCdhdWRpby9tcGVnOycpLnJlcGxhY2UoL15ubyQvLCAnJyk7XG5cbiAgICAgIC8vIE9wZXJhIHZlcnNpb24gPDMzIGhhcyBtaXhlZCBNUDMgc3VwcG9ydCwgc28gd2UgbmVlZCB0byBjaGVjayBmb3IgYW5kIGJsb2NrIGl0LlxuICAgICAgdmFyIGNoZWNrT3BlcmEgPSBzZWxmLl9uYXZpZ2F0b3IgJiYgc2VsZi5fbmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvT1BSXFwvKFswLTZdLikvZyk7XG4gICAgICB2YXIgaXNPbGRPcGVyYSA9IChjaGVja09wZXJhICYmIHBhcnNlSW50KGNoZWNrT3BlcmFbMF0uc3BsaXQoJy8nKVsxXSwgMTApIDwgMzMpO1xuXG4gICAgICBzZWxmLl9jb2RlY3MgPSB7XG4gICAgICAgIG1wMzogISEoIWlzT2xkT3BlcmEgJiYgKG1wZWdUZXN0IHx8IGF1ZGlvVGVzdC5jYW5QbGF5VHlwZSgnYXVkaW8vbXAzOycpLnJlcGxhY2UoL15ubyQvLCAnJykpKSxcbiAgICAgICAgbXBlZzogISFtcGVnVGVzdCxcbiAgICAgICAgb3B1czogISFhdWRpb1Rlc3QuY2FuUGxheVR5cGUoJ2F1ZGlvL29nZzsgY29kZWNzPVwib3B1c1wiJykucmVwbGFjZSgvXm5vJC8sICcnKSxcbiAgICAgICAgb2dnOiAhIWF1ZGlvVGVzdC5jYW5QbGF5VHlwZSgnYXVkaW8vb2dnOyBjb2RlY3M9XCJ2b3JiaXNcIicpLnJlcGxhY2UoL15ubyQvLCAnJyksXG4gICAgICAgIG9nYTogISFhdWRpb1Rlc3QuY2FuUGxheVR5cGUoJ2F1ZGlvL29nZzsgY29kZWNzPVwidm9yYmlzXCInKS5yZXBsYWNlKC9ebm8kLywgJycpLFxuICAgICAgICB3YXY6ICEhYXVkaW9UZXN0LmNhblBsYXlUeXBlKCdhdWRpby93YXY7IGNvZGVjcz1cIjFcIicpLnJlcGxhY2UoL15ubyQvLCAnJyksXG4gICAgICAgIGFhYzogISFhdWRpb1Rlc3QuY2FuUGxheVR5cGUoJ2F1ZGlvL2FhYzsnKS5yZXBsYWNlKC9ebm8kLywgJycpLFxuICAgICAgICBjYWY6ICEhYXVkaW9UZXN0LmNhblBsYXlUeXBlKCdhdWRpby94LWNhZjsnKS5yZXBsYWNlKC9ebm8kLywgJycpLFxuICAgICAgICBtNGE6ICEhKGF1ZGlvVGVzdC5jYW5QbGF5VHlwZSgnYXVkaW8veC1tNGE7JykgfHwgYXVkaW9UZXN0LmNhblBsYXlUeXBlKCdhdWRpby9tNGE7JykgfHwgYXVkaW9UZXN0LmNhblBsYXlUeXBlKCdhdWRpby9hYWM7JykpLnJlcGxhY2UoL15ubyQvLCAnJyksXG4gICAgICAgIG1wNDogISEoYXVkaW9UZXN0LmNhblBsYXlUeXBlKCdhdWRpby94LW1wNDsnKSB8fCBhdWRpb1Rlc3QuY2FuUGxheVR5cGUoJ2F1ZGlvL21wNDsnKSB8fCBhdWRpb1Rlc3QuY2FuUGxheVR5cGUoJ2F1ZGlvL2FhYzsnKSkucmVwbGFjZSgvXm5vJC8sICcnKSxcbiAgICAgICAgd2ViYTogISFhdWRpb1Rlc3QuY2FuUGxheVR5cGUoJ2F1ZGlvL3dlYm07IGNvZGVjcz1cInZvcmJpc1wiJykucmVwbGFjZSgvXm5vJC8sICcnKSxcbiAgICAgICAgd2VibTogISFhdWRpb1Rlc3QuY2FuUGxheVR5cGUoJ2F1ZGlvL3dlYm07IGNvZGVjcz1cInZvcmJpc1wiJykucmVwbGFjZSgvXm5vJC8sICcnKSxcbiAgICAgICAgZG9sYnk6ICEhYXVkaW9UZXN0LmNhblBsYXlUeXBlKCdhdWRpby9tcDQ7IGNvZGVjcz1cImVjLTNcIicpLnJlcGxhY2UoL15ubyQvLCAnJylcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNb2JpbGUgYnJvd3NlcnMgd2lsbCBvbmx5IGFsbG93IGF1ZGlvIHRvIGJlIHBsYXllZCBhZnRlciBhIHVzZXIgaW50ZXJhY3Rpb24uXG4gICAgICogQXR0ZW1wdCB0byBhdXRvbWF0aWNhbGx5IHVubG9jayBhdWRpbyBvbiB0aGUgZmlyc3QgdXNlciBpbnRlcmFjdGlvbi5cbiAgICAgKiBDb25jZXB0IGZyb206IGh0dHA6Ly9wYXVsYmFrYXVzLmNvbS90dXRvcmlhbHMvaHRtbDUvd2ViLWF1ZGlvLW9uLWlvcy9cbiAgICAgKiBAcmV0dXJuIHtIb3dsZXJ9XG4gICAgICovXG4gICAgX2VuYWJsZU1vYmlsZUF1ZGlvOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcyB8fCBIb3dsZXI7XG5cbiAgICAgIC8vIE9ubHkgcnVuIHRoaXMgb24gbW9iaWxlIGRldmljZXMgaWYgYXVkaW8gaXNuJ3QgYWxyZWFkeSBlYW5ibGVkLlxuICAgICAgdmFyIGlzTW9iaWxlID0gL2lQaG9uZXxpUGFkfGlQb2R8QW5kcm9pZHxCbGFja0JlcnJ5fEJCMTB8U2lsa3xNb2JpL2kudGVzdChzZWxmLl9uYXZpZ2F0b3IgJiYgc2VsZi5fbmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gICAgICB2YXIgaXNUb3VjaCA9ICEhKCgnb250b3VjaGVuZCcgaW4gd2luZG93KSB8fCAoc2VsZi5fbmF2aWdhdG9yICYmIHNlbGYuX25hdmlnYXRvci5tYXhUb3VjaFBvaW50cyA+IDApIHx8IChzZWxmLl9uYXZpZ2F0b3IgJiYgc2VsZi5fbmF2aWdhdG9yLm1zTWF4VG91Y2hQb2ludHMgPiAwKSk7XG4gICAgICBpZiAoc2VsZi5fbW9iaWxlRW5hYmxlZCB8fCAhc2VsZi5jdHggfHwgKCFpc01vYmlsZSAmJiAhaXNUb3VjaCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBzZWxmLl9tb2JpbGVFbmFibGVkID0gZmFsc2U7XG5cbiAgICAgIC8vIFNvbWUgbW9iaWxlIGRldmljZXMvcGxhdGZvcm1zIGhhdmUgZGlzdG9ydGlvbiBpc3N1ZXMgd2hlbiBvcGVuaW5nL2Nsb3NpbmcgdGFicyBhbmQvb3Igd2ViIHZpZXdzLlxuICAgICAgLy8gQnVncyBpbiB0aGUgYnJvd3NlciAoZXNwZWNpYWxseSBNb2JpbGUgU2FmYXJpKSBjYW4gY2F1c2UgdGhlIHNhbXBsZVJhdGUgdG8gY2hhbmdlIGZyb20gNDQxMDAgdG8gNDgwMDAuXG4gICAgICAvLyBCeSBjYWxsaW5nIEhvd2xlci51bmxvYWQoKSwgd2UgY3JlYXRlIGEgbmV3IEF1ZGlvQ29udGV4dCB3aXRoIHRoZSBjb3JyZWN0IHNhbXBsZVJhdGUuXG4gICAgICBpZiAoIXNlbGYuX21vYmlsZVVubG9hZGVkICYmIHNlbGYuY3R4LnNhbXBsZVJhdGUgIT09IDQ0MTAwKSB7XG4gICAgICAgIHNlbGYuX21vYmlsZVVubG9hZGVkID0gdHJ1ZTtcbiAgICAgICAgc2VsZi51bmxvYWQoKTtcbiAgICAgIH1cblxuICAgICAgLy8gU2NyYXRjaCBidWZmZXIgZm9yIGVuYWJsaW5nIGlPUyB0byBkaXNwb3NlIG9mIHdlYiBhdWRpbyBidWZmZXJzIGNvcnJlY3RseSwgYXMgcGVyOlxuICAgICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8yNDExOTY4NFxuICAgICAgc2VsZi5fc2NyYXRjaEJ1ZmZlciA9IHNlbGYuY3R4LmNyZWF0ZUJ1ZmZlcigxLCAxLCAyMjA1MCk7XG5cbiAgICAgIC8vIENhbGwgdGhpcyBtZXRob2Qgb24gdG91Y2ggc3RhcnQgdG8gY3JlYXRlIGFuZCBwbGF5IGEgYnVmZmVyLFxuICAgICAgLy8gdGhlbiBjaGVjayBpZiB0aGUgYXVkaW8gYWN0dWFsbHkgcGxheWVkIHRvIGRldGVybWluZSBpZlxuICAgICAgLy8gYXVkaW8gaGFzIG5vdyBiZWVuIHVubG9ja2VkIG9uIGlPUywgQW5kcm9pZCwgZXRjLlxuICAgICAgdmFyIHVubG9jayA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBDcmVhdGUgYW4gZW1wdHkgYnVmZmVyLlxuICAgICAgICB2YXIgc291cmNlID0gc2VsZi5jdHguY3JlYXRlQnVmZmVyU291cmNlKCk7XG4gICAgICAgIHNvdXJjZS5idWZmZXIgPSBzZWxmLl9zY3JhdGNoQnVmZmVyO1xuICAgICAgICBzb3VyY2UuY29ubmVjdChzZWxmLmN0eC5kZXN0aW5hdGlvbik7XG5cbiAgICAgICAgLy8gUGxheSB0aGUgZW1wdHkgYnVmZmVyLlxuICAgICAgICBpZiAodHlwZW9mIHNvdXJjZS5zdGFydCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBzb3VyY2Uubm90ZU9uKDApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNvdXJjZS5zdGFydCgwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNldHVwIGEgdGltZW91dCB0byBjaGVjayB0aGF0IHdlIGFyZSB1bmxvY2tlZCBvbiB0aGUgbmV4dCBldmVudCBsb29wLlxuICAgICAgICBzb3VyY2Uub25lbmRlZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHNvdXJjZS5kaXNjb25uZWN0KDApO1xuXG4gICAgICAgICAgLy8gVXBkYXRlIHRoZSB1bmxvY2tlZCBzdGF0ZSBhbmQgcHJldmVudCB0aGlzIGNoZWNrIGZyb20gaGFwcGVuaW5nIGFnYWluLlxuICAgICAgICAgIHNlbGYuX21vYmlsZUVuYWJsZWQgPSB0cnVlO1xuICAgICAgICAgIHNlbGYubW9iaWxlQXV0b0VuYWJsZSA9IGZhbHNlO1xuXG4gICAgICAgICAgLy8gUmVtb3ZlIHRoZSB0b3VjaCBzdGFydCBsaXN0ZW5lci5cbiAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHVubG9jaywgdHJ1ZSk7XG4gICAgICAgIH07XG4gICAgICB9O1xuXG4gICAgICAvLyBTZXR1cCBhIHRvdWNoIHN0YXJ0IGxpc3RlbmVyIHRvIGF0dGVtcHQgYW4gdW5sb2NrIGluLlxuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB1bmxvY2ssIHRydWUpO1xuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQXV0b21hdGljYWxseSBzdXNwZW5kIHRoZSBXZWIgQXVkaW8gQXVkaW9Db250ZXh0IGFmdGVyIG5vIHNvdW5kIGhhcyBwbGF5ZWQgZm9yIDMwIHNlY29uZHMuXG4gICAgICogVGhpcyBzYXZlcyBwcm9jZXNzaW5nL2VuZXJneSBhbmQgZml4ZXMgdmFyaW91cyBicm93c2VyLXNwZWNpZmljIGJ1Z3Mgd2l0aCBhdWRpbyBnZXR0aW5nIHN0dWNrLlxuICAgICAqIEByZXR1cm4ge0hvd2xlcn1cbiAgICAgKi9cbiAgICBfYXV0b1N1c3BlbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICBpZiAoIXNlbGYuYXV0b1N1c3BlbmQgfHwgIXNlbGYuY3R4IHx8IHR5cGVvZiBzZWxmLmN0eC5zdXNwZW5kID09PSAndW5kZWZpbmVkJyB8fCAhSG93bGVyLnVzaW5nV2ViQXVkaW8pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBDaGVjayBpZiBhbnkgc291bmRzIGFyZSBwbGF5aW5nLlxuICAgICAgZm9yICh2YXIgaT0wOyBpPHNlbGYuX2hvd2xzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChzZWxmLl9ob3dsc1tpXS5fd2ViQXVkaW8pIHtcbiAgICAgICAgICBmb3IgKHZhciBqPTA7IGo8c2VsZi5faG93bHNbaV0uX3NvdW5kcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgaWYgKCFzZWxmLl9ob3dsc1tpXS5fc291bmRzW2pdLl9wYXVzZWQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChzZWxmLl9zdXNwZW5kVGltZXIpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHNlbGYuX3N1c3BlbmRUaW1lcik7XG4gICAgICB9XG5cbiAgICAgIC8vIElmIG5vIHNvdW5kIGhhcyBwbGF5ZWQgYWZ0ZXIgMzAgc2Vjb25kcywgc3VzcGVuZCB0aGUgY29udGV4dC5cbiAgICAgIHNlbGYuX3N1c3BlbmRUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghc2VsZi5hdXRvU3VzcGVuZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHNlbGYuX3N1c3BlbmRUaW1lciA9IG51bGw7XG4gICAgICAgIHNlbGYuc3RhdGUgPSAnc3VzcGVuZGluZyc7XG4gICAgICAgIHNlbGYuY3R4LnN1c3BlbmQoKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHNlbGYuc3RhdGUgPSAnc3VzcGVuZGVkJztcblxuICAgICAgICAgIGlmIChzZWxmLl9yZXN1bWVBZnRlclN1c3BlbmQpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBzZWxmLl9yZXN1bWVBZnRlclN1c3BlbmQ7XG4gICAgICAgICAgICBzZWxmLl9hdXRvUmVzdW1lKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0sIDMwMDAwKTtcblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEF1dG9tYXRpY2FsbHkgcmVzdW1lIHRoZSBXZWIgQXVkaW8gQXVkaW9Db250ZXh0IHdoZW4gYSBuZXcgc291bmQgaXMgcGxheWVkLlxuICAgICAqIEByZXR1cm4ge0hvd2xlcn1cbiAgICAgKi9cbiAgICBfYXV0b1Jlc3VtZTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgIGlmICghc2VsZi5jdHggfHwgdHlwZW9mIHNlbGYuY3R4LnJlc3VtZSA9PT0gJ3VuZGVmaW5lZCcgfHwgIUhvd2xlci51c2luZ1dlYkF1ZGlvKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHNlbGYuc3RhdGUgPT09ICdydW5uaW5nJyAmJiBzZWxmLl9zdXNwZW5kVGltZXIpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHNlbGYuX3N1c3BlbmRUaW1lcik7XG4gICAgICAgIHNlbGYuX3N1c3BlbmRUaW1lciA9IG51bGw7XG4gICAgICB9IGVsc2UgaWYgKHNlbGYuc3RhdGUgPT09ICdzdXNwZW5kZWQnKSB7XG4gICAgICAgIHNlbGYuc3RhdGUgPSAncmVzdW1pbmcnO1xuICAgICAgICBzZWxmLmN0eC5yZXN1bWUoKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHNlbGYuc3RhdGUgPSAncnVubmluZyc7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChzZWxmLl9zdXNwZW5kVGltZXIpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQoc2VsZi5fc3VzcGVuZFRpbWVyKTtcbiAgICAgICAgICBzZWxmLl9zdXNwZW5kVGltZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHNlbGYuc3RhdGUgPT09ICdzdXNwZW5kaW5nJykge1xuICAgICAgICBzZWxmLl9yZXN1bWVBZnRlclN1c3BlbmQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG4gIH07XG5cbiAgLy8gU2V0dXAgdGhlIGdsb2JhbCBhdWRpbyBjb250cm9sbGVyLlxuICB2YXIgSG93bGVyID0gbmV3IEhvd2xlckdsb2JhbCgpO1xuXG4gIC8qKiBHcm91cCBNZXRob2RzICoqL1xuICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gYXVkaW8gZ3JvdXAgY29udHJvbGxlci5cbiAgICogQHBhcmFtIHtPYmplY3R9IG8gUGFzc2VkIGluIHByb3BlcnRpZXMgZm9yIHRoaXMgZ3JvdXAuXG4gICAqL1xuICB2YXIgSG93bCA9IGZ1bmN0aW9uKG8pIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAvLyBUaHJvdyBhbiBlcnJvciBpZiBubyBzb3VyY2UgaXMgcHJvdmlkZWQuXG4gICAgaWYgKCFvLnNyYyB8fCBvLnNyYy5sZW5ndGggPT09IDApIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0FuIGFycmF5IG9mIHNvdXJjZSBmaWxlcyBtdXN0IGJlIHBhc3NlZCB3aXRoIGFueSBuZXcgSG93bC4nKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzZWxmLmluaXQobyk7XG4gIH07XG4gIEhvd2wucHJvdG90eXBlID0ge1xuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemUgYSBuZXcgSG93bCBncm91cCBvYmplY3QuXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBvIFBhc3NlZCBpbiBwcm9wZXJ0aWVzIGZvciB0aGlzIGdyb3VwLlxuICAgICAqIEByZXR1cm4ge0hvd2x9XG4gICAgICovXG4gICAgaW5pdDogZnVuY3Rpb24obykge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGFuIEF1ZGlvQ29udGV4dCBjcmVhdGVkIHlldCwgcnVuIHRoZSBzZXR1cC5cbiAgICAgIGlmICghSG93bGVyLmN0eCkge1xuICAgICAgICBzZXR1cEF1ZGlvQ29udGV4dCgpO1xuICAgICAgfVxuXG4gICAgICAvLyBTZXR1cCB1c2VyLWRlZmluZWQgZGVmYXVsdCBwcm9wZXJ0aWVzLlxuICAgICAgc2VsZi5fYXV0b3BsYXkgPSBvLmF1dG9wbGF5IHx8IGZhbHNlO1xuICAgICAgc2VsZi5fZm9ybWF0ID0gKHR5cGVvZiBvLmZvcm1hdCAhPT0gJ3N0cmluZycpID8gby5mb3JtYXQgOiBbby5mb3JtYXRdO1xuICAgICAgc2VsZi5faHRtbDUgPSBvLmh0bWw1IHx8IGZhbHNlO1xuICAgICAgc2VsZi5fbXV0ZWQgPSBvLm11dGUgfHwgZmFsc2U7XG4gICAgICBzZWxmLl9sb29wID0gby5sb29wIHx8IGZhbHNlO1xuICAgICAgc2VsZi5fcG9vbCA9IG8ucG9vbCB8fCA1O1xuICAgICAgc2VsZi5fcHJlbG9hZCA9ICh0eXBlb2Ygby5wcmVsb2FkID09PSAnYm9vbGVhbicpID8gby5wcmVsb2FkIDogdHJ1ZTtcbiAgICAgIHNlbGYuX3JhdGUgPSBvLnJhdGUgfHwgMTtcbiAgICAgIHNlbGYuX3Nwcml0ZSA9IG8uc3ByaXRlIHx8IHt9O1xuICAgICAgc2VsZi5fc3JjID0gKHR5cGVvZiBvLnNyYyAhPT0gJ3N0cmluZycpID8gby5zcmMgOiBbby5zcmNdO1xuICAgICAgc2VsZi5fdm9sdW1lID0gby52b2x1bWUgIT09IHVuZGVmaW5lZCA/IG8udm9sdW1lIDogMTtcblxuICAgICAgLy8gU2V0dXAgYWxsIG90aGVyIGRlZmF1bHQgcHJvcGVydGllcy5cbiAgICAgIHNlbGYuX2R1cmF0aW9uID0gMDtcbiAgICAgIHNlbGYuX3N0YXRlID0gJ3VubG9hZGVkJztcbiAgICAgIHNlbGYuX3NvdW5kcyA9IFtdO1xuICAgICAgc2VsZi5fZW5kVGltZXJzID0ge307XG4gICAgICBzZWxmLl9xdWV1ZSA9IFtdO1xuXG4gICAgICAvLyBTZXR1cCBldmVudCBsaXN0ZW5lcnMuXG4gICAgICBzZWxmLl9vbmVuZCA9IG8ub25lbmQgPyBbe2ZuOiBvLm9uZW5kfV0gOiBbXTtcbiAgICAgIHNlbGYuX29uZmFkZSA9IG8ub25mYWRlID8gW3tmbjogby5vbmZhZGV9XSA6IFtdO1xuICAgICAgc2VsZi5fb25sb2FkID0gby5vbmxvYWQgPyBbe2ZuOiBvLm9ubG9hZH1dIDogW107XG4gICAgICBzZWxmLl9vbmxvYWRlcnJvciA9IG8ub25sb2FkZXJyb3IgPyBbe2ZuOiBvLm9ubG9hZGVycm9yfV0gOiBbXTtcbiAgICAgIHNlbGYuX29ucGF1c2UgPSBvLm9ucGF1c2UgPyBbe2ZuOiBvLm9ucGF1c2V9XSA6IFtdO1xuICAgICAgc2VsZi5fb25wbGF5ID0gby5vbnBsYXkgPyBbe2ZuOiBvLm9ucGxheX1dIDogW107XG4gICAgICBzZWxmLl9vbnN0b3AgPSBvLm9uc3RvcCA/IFt7Zm46IG8ub25zdG9wfV0gOiBbXTtcbiAgICAgIHNlbGYuX29ubXV0ZSA9IG8ub25tdXRlID8gW3tmbjogby5vbm11dGV9XSA6IFtdO1xuICAgICAgc2VsZi5fb252b2x1bWUgPSBvLm9udm9sdW1lID8gW3tmbjogby5vbnZvbHVtZX1dIDogW107XG4gICAgICBzZWxmLl9vbnJhdGUgPSBvLm9ucmF0ZSA/IFt7Zm46IG8ub25yYXRlfV0gOiBbXTtcbiAgICAgIHNlbGYuX29uc2VlayA9IG8ub25zZWVrID8gW3tmbjogby5vbnNlZWt9XSA6IFtdO1xuXG4gICAgICAvLyBXZWIgQXVkaW8gb3IgSFRNTDUgQXVkaW8/XG4gICAgICBzZWxmLl93ZWJBdWRpbyA9IEhvd2xlci51c2luZ1dlYkF1ZGlvICYmICFzZWxmLl9odG1sNTtcblxuICAgICAgLy8gQXV0b21hdGljYWxseSB0cnkgdG8gZW5hYmxlIGF1ZGlvIG9uIGlPUy5cbiAgICAgIGlmICh0eXBlb2YgSG93bGVyLmN0eCAhPT0gJ3VuZGVmaW5lZCcgJiYgSG93bGVyLmN0eCAmJiBIb3dsZXIubW9iaWxlQXV0b0VuYWJsZSkge1xuICAgICAgICBIb3dsZXIuX2VuYWJsZU1vYmlsZUF1ZGlvKCk7XG4gICAgICB9XG5cbiAgICAgIC8vIEtlZXAgdHJhY2sgb2YgdGhpcyBIb3dsIGdyb3VwIGluIHRoZSBnbG9iYWwgY29udHJvbGxlci5cbiAgICAgIEhvd2xlci5faG93bHMucHVzaChzZWxmKTtcblxuICAgICAgLy8gTG9hZCB0aGUgc291cmNlIGZpbGUgdW5sZXNzIG90aGVyd2lzZSBzcGVjaWZpZWQuXG4gICAgICBpZiAoc2VsZi5fcHJlbG9hZCkge1xuICAgICAgICBzZWxmLmxvYWQoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIExvYWQgdGhlIGF1ZGlvIGZpbGUuXG4gICAgICogQHJldHVybiB7SG93bGVyfVxuICAgICAqL1xuICAgIGxvYWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIHVybCA9IG51bGw7XG5cbiAgICAgIC8vIElmIG5vIGF1ZGlvIGlzIGF2YWlsYWJsZSwgcXVpdCBpbW1lZGlhdGVseS5cbiAgICAgIGlmIChIb3dsZXIubm9BdWRpbykge1xuICAgICAgICBzZWxmLl9lbWl0KCdsb2FkZXJyb3InLCBudWxsLCAnTm8gYXVkaW8gc3VwcG9ydC4nKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBNYWtlIHN1cmUgb3VyIHNvdXJjZSBpcyBpbiBhbiBhcnJheS5cbiAgICAgIGlmICh0eXBlb2Ygc2VsZi5fc3JjID09PSAnc3RyaW5nJykge1xuICAgICAgICBzZWxmLl9zcmMgPSBbc2VsZi5fc3JjXTtcbiAgICAgIH1cblxuICAgICAgLy8gTG9vcCB0aHJvdWdoIHRoZSBzb3VyY2VzIGFuZCBwaWNrIHRoZSBmaXJzdCBvbmUgdGhhdCBpcyBjb21wYXRpYmxlLlxuICAgICAgZm9yICh2YXIgaT0wOyBpPHNlbGYuX3NyYy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZXh0LCBzdHI7XG5cbiAgICAgICAgaWYgKHNlbGYuX2Zvcm1hdCAmJiBzZWxmLl9mb3JtYXRbaV0pIHtcbiAgICAgICAgICAvLyBJZiBhbiBleHRlbnNpb24gd2FzIHNwZWNpZmllZCwgdXNlIHRoYXQgaW5zdGVhZC5cbiAgICAgICAgICBleHQgPSBzZWxmLl9mb3JtYXRbaV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSBzb3VyY2UgaXMgYSBzdHJpbmcuXG4gICAgICAgICAgc3RyID0gc2VsZi5fc3JjW2ldO1xuICAgICAgICAgIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgc2VsZi5fZW1pdCgnbG9hZGVycm9yJywgbnVsbCwgJ05vbi1zdHJpbmcgZm91bmQgaW4gc2VsZWN0ZWQgYXVkaW8gc291cmNlcyAtIGlnbm9yaW5nLicpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gRXh0cmFjdCB0aGUgZmlsZSBleHRlbnNpb24gZnJvbSB0aGUgVVJMIG9yIGJhc2U2NCBkYXRhIFVSSS5cbiAgICAgICAgICBleHQgPSAvXmRhdGE6YXVkaW9cXC8oW147LF0rKTsvaS5leGVjKHN0cik7XG4gICAgICAgICAgaWYgKCFleHQpIHtcbiAgICAgICAgICAgIGV4dCA9IC9cXC4oW14uXSspJC8uZXhlYyhzdHIuc3BsaXQoJz8nLCAxKVswXSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGV4dCkge1xuICAgICAgICAgICAgZXh0ID0gZXh0WzFdLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBleHRlbnNpb24gaXMgYXZhaWxhYmxlLlxuICAgICAgICBpZiAoSG93bGVyLmNvZGVjcyhleHQpKSB7XG4gICAgICAgICAgdXJsID0gc2VsZi5fc3JjW2ldO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghdXJsKSB7XG4gICAgICAgIHNlbGYuX2VtaXQoJ2xvYWRlcnJvcicsIG51bGwsICdObyBjb2RlYyBzdXBwb3J0IGZvciBzZWxlY3RlZCBhdWRpbyBzb3VyY2VzLicpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHNlbGYuX3NyYyA9IHVybDtcbiAgICAgIHNlbGYuX3N0YXRlID0gJ2xvYWRpbmcnO1xuXG4gICAgICAvLyBJZiB0aGUgaG9zdGluZyBwYWdlIGlzIEhUVFBTIGFuZCB0aGUgc291cmNlIGlzbid0LFxuICAgICAgLy8gZHJvcCBkb3duIHRvIEhUTUw1IEF1ZGlvIHRvIGF2b2lkIE1peGVkIENvbnRlbnQgZXJyb3JzLlxuICAgICAgaWYgKHdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbCA9PT0gJ2h0dHBzOicgJiYgdXJsLnNsaWNlKDAsIDUpID09PSAnaHR0cDonKSB7XG4gICAgICAgIHNlbGYuX2h0bWw1ID0gdHJ1ZTtcbiAgICAgICAgc2VsZi5fd2ViQXVkaW8gPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgLy8gQ3JlYXRlIGEgbmV3IHNvdW5kIG9iamVjdCBhbmQgYWRkIGl0IHRvIHRoZSBwb29sLlxuICAgICAgbmV3IFNvdW5kKHNlbGYpO1xuXG4gICAgICAvLyBMb2FkIGFuZCBkZWNvZGUgdGhlIGF1ZGlvIGRhdGEgZm9yIHBsYXliYWNrLlxuICAgICAgaWYgKHNlbGYuX3dlYkF1ZGlvKSB7XG4gICAgICAgIGxvYWRCdWZmZXIoc2VsZik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQbGF5IGEgc291bmQgb3IgcmVzdW1lIHByZXZpb3VzIHBsYXliYWNrLlxuICAgICAqIEBwYXJhbSAge1N0cmluZy9OdW1iZXJ9IHNwcml0ZSAgIFNwcml0ZSBuYW1lIGZvciBzcHJpdGUgcGxheWJhY2sgb3Igc291bmQgaWQgdG8gY29udGludWUgcHJldmlvdXMuXG4gICAgICogQHBhcmFtICB7Qm9vbGVhbn0gaW50ZXJuYWwgSW50ZXJuYWwgVXNlOiB0cnVlIHByZXZlbnRzIGV2ZW50IGZpcmluZy5cbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9ICAgICAgICAgIFNvdW5kIElELlxuICAgICAqL1xuICAgIHBsYXk6IGZ1bmN0aW9uKHNwcml0ZSwgaW50ZXJuYWwpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBpZCA9IG51bGw7XG5cbiAgICAgIC8vIERldGVybWluZSBpZiBhIHNwcml0ZSwgc291bmQgaWQgb3Igbm90aGluZyB3YXMgcGFzc2VkXG4gICAgICBpZiAodHlwZW9mIHNwcml0ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgaWQgPSBzcHJpdGU7XG4gICAgICAgIHNwcml0ZSA9IG51bGw7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBzcHJpdGUgPT09ICdzdHJpbmcnICYmIHNlbGYuX3N0YXRlID09PSAnbG9hZGVkJyAmJiAhc2VsZi5fc3ByaXRlW3Nwcml0ZV0pIHtcbiAgICAgICAgLy8gSWYgdGhlIHBhc3NlZCBzcHJpdGUgZG9lc24ndCBleGlzdCwgZG8gbm90aGluZy5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBzcHJpdGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIC8vIFVzZSB0aGUgZGVmYXVsdCBzb3VuZCBzcHJpdGUgKHBsYXlzIHRoZSBmdWxsIGF1ZGlvIGxlbmd0aCkuXG4gICAgICAgIHNwcml0ZSA9ICdfX2RlZmF1bHQnO1xuXG4gICAgICAgIC8vIENoZWNrIGlmIHRoZXJlIGlzIGEgc2luZ2xlIHBhdXNlZCBzb3VuZCB0aGF0IGlzbid0IGVuZGVkLlxuICAgICAgICAvLyBJZiB0aGVyZSBpcywgcGxheSB0aGF0IHNvdW5kLiBJZiBub3QsIGNvbnRpbnVlIGFzIHVzdWFsLlxuICAgICAgICB2YXIgbnVtID0gMDtcbiAgICAgICAgZm9yICh2YXIgaT0wOyBpPHNlbGYuX3NvdW5kcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChzZWxmLl9zb3VuZHNbaV0uX3BhdXNlZCAmJiAhc2VsZi5fc291bmRzW2ldLl9lbmRlZCkge1xuICAgICAgICAgICAgbnVtKys7XG4gICAgICAgICAgICBpZCA9IHNlbGYuX3NvdW5kc1tpXS5faWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG51bSA9PT0gMSkge1xuICAgICAgICAgIHNwcml0ZSA9IG51bGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIEdldCB0aGUgc2VsZWN0ZWQgbm9kZSwgb3IgZ2V0IG9uZSBmcm9tIHRoZSBwb29sLlxuICAgICAgdmFyIHNvdW5kID0gaWQgPyBzZWxmLl9zb3VuZEJ5SWQoaWQpIDogc2VsZi5faW5hY3RpdmVTb3VuZCgpO1xuXG4gICAgICAvLyBJZiB0aGUgc291bmQgZG9lc24ndCBleGlzdCwgZG8gbm90aGluZy5cbiAgICAgIGlmICghc291bmQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIC8vIFNlbGVjdCB0aGUgc3ByaXRlIGRlZmluaXRpb24uXG4gICAgICBpZiAoaWQgJiYgIXNwcml0ZSkge1xuICAgICAgICBzcHJpdGUgPSBzb3VuZC5fc3ByaXRlIHx8ICdfX2RlZmF1bHQnO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiB3ZSBoYXZlIG5vIHNwcml0ZSBhbmQgdGhlIHNvdW5kIGhhc24ndCBsb2FkZWQsIHdlIG11c3Qgd2FpdFxuICAgICAgLy8gZm9yIHRoZSBzb3VuZCB0byBsb2FkIHRvIGdldCBvdXIgYXVkaW8ncyBkdXJhdGlvbi5cbiAgICAgIGlmIChzZWxmLl9zdGF0ZSAhPT0gJ2xvYWRlZCcgJiYgIXNlbGYuX3Nwcml0ZVtzcHJpdGVdKSB7XG4gICAgICAgIHNlbGYuX3F1ZXVlLnB1c2goe1xuICAgICAgICAgIGV2ZW50OiAncGxheScsXG4gICAgICAgICAgYWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHNlbGYucGxheShzZWxmLl9zb3VuZEJ5SWQoc291bmQuX2lkKSA/IHNvdW5kLl9pZCA6IHVuZGVmaW5lZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gc291bmQuX2lkO1xuICAgICAgfVxuXG4gICAgICAvLyBEb24ndCBwbGF5IHRoZSBzb3VuZCBpZiBhbiBpZCB3YXMgcGFzc2VkIGFuZCBpdCBpcyBhbHJlYWR5IHBsYXlpbmcuXG4gICAgICBpZiAoaWQgJiYgIXNvdW5kLl9wYXVzZWQpIHtcbiAgICAgICAgLy8gVHJpZ2dlciB0aGUgcGxheSBldmVudCwgaW4gb3JkZXIgdG8ga2VlcCBpdGVyYXRpbmcgdGhyb3VnaCBxdWV1ZS5cbiAgICAgICAgaWYgKCFpbnRlcm5hbCkge1xuICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBzZWxmLl9lbWl0KCdwbGF5Jywgc291bmQuX2lkKTtcbiAgICAgICAgICB9LCAwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzb3VuZC5faWQ7XG4gICAgICB9XG5cbiAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgQXVkaW9Db250ZXh0IGlzbid0IHN1c3BlbmRlZCwgYW5kIHJlc3VtZSBpdCBpZiBpdCBpcy5cbiAgICAgIGlmIChzZWxmLl93ZWJBdWRpbykge1xuICAgICAgICBIb3dsZXIuX2F1dG9SZXN1bWUoKTtcbiAgICAgIH1cblxuICAgICAgLy8gRGV0ZXJtaW5lIGhvdyBsb25nIHRvIHBsYXkgZm9yIGFuZCB3aGVyZSB0byBzdGFydCBwbGF5aW5nLlxuICAgICAgdmFyIHNlZWsgPSBzb3VuZC5fc2VlayA+IDAgPyBzb3VuZC5fc2VlayA6IHNlbGYuX3Nwcml0ZVtzcHJpdGVdWzBdIC8gMTAwMDtcbiAgICAgIHZhciBkdXJhdGlvbiA9ICgoc2VsZi5fc3ByaXRlW3Nwcml0ZV1bMF0gKyBzZWxmLl9zcHJpdGVbc3ByaXRlXVsxXSkgLyAxMDAwKSAtIHNlZWs7XG4gICAgICB2YXIgdGltZW91dCA9IChkdXJhdGlvbiAqIDEwMDApIC8gTWF0aC5hYnMoc291bmQuX3JhdGUpO1xuXG4gICAgICAvLyBVcGRhdGUgdGhlIHBhcmFtZXRlcnMgb2YgdGhlIHNvdW5kXG4gICAgICBzb3VuZC5fcGF1c2VkID0gZmFsc2U7XG4gICAgICBzb3VuZC5fZW5kZWQgPSBmYWxzZTtcbiAgICAgIHNvdW5kLl9zcHJpdGUgPSBzcHJpdGU7XG4gICAgICBzb3VuZC5fc2VlayA9IHNlZWs7XG4gICAgICBzb3VuZC5fc3RhcnQgPSBzZWxmLl9zcHJpdGVbc3ByaXRlXVswXSAvIDEwMDA7XG4gICAgICBzb3VuZC5fc3RvcCA9IChzZWxmLl9zcHJpdGVbc3ByaXRlXVswXSArIHNlbGYuX3Nwcml0ZVtzcHJpdGVdWzFdKSAvIDEwMDA7XG4gICAgICBzb3VuZC5fbG9vcCA9ICEhKHNvdW5kLl9sb29wIHx8IHNlbGYuX3Nwcml0ZVtzcHJpdGVdWzJdKTtcblxuICAgICAgLy8gQmVnaW4gdGhlIGFjdHVhbCBwbGF5YmFjay5cbiAgICAgIHZhciBub2RlID0gc291bmQuX25vZGU7XG4gICAgICBpZiAoc2VsZi5fd2ViQXVkaW8pIHtcbiAgICAgICAgLy8gRmlyZSB0aGlzIHdoZW4gdGhlIHNvdW5kIGlzIHJlYWR5IHRvIHBsYXkgdG8gYmVnaW4gV2ViIEF1ZGlvIHBsYXliYWNrLlxuICAgICAgICB2YXIgcGxheVdlYkF1ZGlvID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgc2VsZi5fcmVmcmVzaEJ1ZmZlcihzb3VuZCk7XG5cbiAgICAgICAgICAvLyBTZXR1cCB0aGUgcGxheWJhY2sgcGFyYW1zLlxuICAgICAgICAgIHZhciB2b2wgPSAoc291bmQuX211dGVkIHx8IHNlbGYuX211dGVkKSA/IDAgOiBzb3VuZC5fdm9sdW1lO1xuICAgICAgICAgIG5vZGUuZ2Fpbi5zZXRWYWx1ZUF0VGltZSh2b2wsIEhvd2xlci5jdHguY3VycmVudFRpbWUpO1xuICAgICAgICAgIHNvdW5kLl9wbGF5U3RhcnQgPSBIb3dsZXIuY3R4LmN1cnJlbnRUaW1lO1xuXG4gICAgICAgICAgLy8gUGxheSB0aGUgc291bmQgdXNpbmcgdGhlIHN1cHBvcnRlZCBtZXRob2QuXG4gICAgICAgICAgaWYgKHR5cGVvZiBub2RlLmJ1ZmZlclNvdXJjZS5zdGFydCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHNvdW5kLl9sb29wID8gbm9kZS5idWZmZXJTb3VyY2Uubm90ZUdyYWluT24oMCwgc2VlaywgODY0MDApIDogbm9kZS5idWZmZXJTb3VyY2Uubm90ZUdyYWluT24oMCwgc2VlaywgZHVyYXRpb24pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzb3VuZC5fbG9vcCA/IG5vZGUuYnVmZmVyU291cmNlLnN0YXJ0KDAsIHNlZWssIDg2NDAwKSA6IG5vZGUuYnVmZmVyU291cmNlLnN0YXJ0KDAsIHNlZWssIGR1cmF0aW9uKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBTdGFydCBhIG5ldyB0aW1lciBpZiBub25lIGlzIHByZXNlbnQuXG4gICAgICAgICAgaWYgKHRpbWVvdXQgIT09IEluZmluaXR5KSB7XG4gICAgICAgICAgICBzZWxmLl9lbmRUaW1lcnNbc291bmQuX2lkXSA9IHNldFRpbWVvdXQoc2VsZi5fZW5kZWQuYmluZChzZWxmLCBzb3VuZCksIHRpbWVvdXQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghaW50ZXJuYWwpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHNlbGYuX2VtaXQoJ3BsYXknLCBzb3VuZC5faWQpO1xuICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChzZWxmLl9zdGF0ZSA9PT0gJ2xvYWRlZCcpIHtcbiAgICAgICAgICBwbGF5V2ViQXVkaW8oKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBXYWl0IGZvciB0aGUgYXVkaW8gdG8gbG9hZCBhbmQgdGhlbiBiZWdpbiBwbGF5YmFjay5cbiAgICAgICAgICBzZWxmLm9uY2UoJ2xvYWQnLCBwbGF5V2ViQXVkaW8sIHNvdW5kLl9pZCk7XG5cbiAgICAgICAgICAvLyBDYW5jZWwgdGhlIGVuZCB0aW1lci5cbiAgICAgICAgICBzZWxmLl9jbGVhclRpbWVyKHNvdW5kLl9pZCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEZpcmUgdGhpcyB3aGVuIHRoZSBzb3VuZCBpcyByZWFkeSB0byBwbGF5IHRvIGJlZ2luIEhUTUw1IEF1ZGlvIHBsYXliYWNrLlxuICAgICAgICB2YXIgcGxheUh0bWw1ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgbm9kZS5jdXJyZW50VGltZSA9IHNlZWs7XG4gICAgICAgICAgbm9kZS5tdXRlZCA9IHNvdW5kLl9tdXRlZCB8fCBzZWxmLl9tdXRlZCB8fCBIb3dsZXIuX211dGVkIHx8IG5vZGUubXV0ZWQ7XG4gICAgICAgICAgbm9kZS52b2x1bWUgPSBzb3VuZC5fdm9sdW1lICogSG93bGVyLnZvbHVtZSgpO1xuICAgICAgICAgIG5vZGUucGxheWJhY2tSYXRlID0gc291bmQuX3JhdGU7XG5cbiAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgbm9kZS5wbGF5KCk7XG5cbiAgICAgICAgICAgIC8vIFNldHVwIHRoZSBuZXcgZW5kIHRpbWVyLlxuICAgICAgICAgICAgaWYgKHRpbWVvdXQgIT09IEluZmluaXR5KSB7XG4gICAgICAgICAgICAgIHNlbGYuX2VuZFRpbWVyc1tzb3VuZC5faWRdID0gc2V0VGltZW91dChzZWxmLl9lbmRlZC5iaW5kKHNlbGYsIHNvdW5kKSwgdGltZW91dCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghaW50ZXJuYWwpIHtcbiAgICAgICAgICAgICAgc2VsZi5fZW1pdCgncGxheScsIHNvdW5kLl9pZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgMCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gUGxheSBpbW1lZGlhdGVseSBpZiByZWFkeSwgb3Igd2FpdCBmb3IgdGhlICdjYW5wbGF5dGhyb3VnaCdlIHZlbnQuXG4gICAgICAgIHZhciBsb2FkZWROb1JlYWR5U3RhdGUgPSAoc2VsZi5fc3RhdGUgPT09ICdsb2FkZWQnICYmICh3aW5kb3cgJiYgd2luZG93LmVqZWN0YSB8fCAhbm9kZS5yZWFkeVN0YXRlICYmIEhvd2xlci5fbmF2aWdhdG9yLmlzQ29jb29uSlMpKTtcbiAgICAgICAgaWYgKG5vZGUucmVhZHlTdGF0ZSA9PT0gNCB8fCBsb2FkZWROb1JlYWR5U3RhdGUpIHtcbiAgICAgICAgICBwbGF5SHRtbDUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgbGlzdGVuZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIEJlZ2luIHBsYXliYWNrLlxuICAgICAgICAgICAgcGxheUh0bWw1KCk7XG5cbiAgICAgICAgICAgIC8vIENsZWFyIHRoaXMgbGlzdGVuZXIuXG4gICAgICAgICAgICBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoSG93bGVyLl9jYW5QbGF5RXZlbnQsIGxpc3RlbmVyLCBmYWxzZSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoSG93bGVyLl9jYW5QbGF5RXZlbnQsIGxpc3RlbmVyLCBmYWxzZSk7XG5cbiAgICAgICAgICAvLyBDYW5jZWwgdGhlIGVuZCB0aW1lci5cbiAgICAgICAgICBzZWxmLl9jbGVhclRpbWVyKHNvdW5kLl9pZCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNvdW5kLl9pZDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUGF1c2UgcGxheWJhY2sgYW5kIHNhdmUgY3VycmVudCBwb3NpdGlvbi5cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGlkIFRoZSBzb3VuZCBJRCAoZW1wdHkgdG8gcGF1c2UgYWxsIGluIGdyb3VwKS5cbiAgICAgKiBAcmV0dXJuIHtIb3dsfVxuICAgICAqL1xuICAgIHBhdXNlOiBmdW5jdGlvbihpZCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAvLyBJZiB0aGUgc291bmQgaGFzbid0IGxvYWRlZCwgYWRkIGl0IHRvIHRoZSBsb2FkIHF1ZXVlIHRvIHBhdXNlIHdoZW4gY2FwYWJsZS5cbiAgICAgIGlmIChzZWxmLl9zdGF0ZSAhPT0gJ2xvYWRlZCcpIHtcbiAgICAgICAgc2VsZi5fcXVldWUucHVzaCh7XG4gICAgICAgICAgZXZlbnQ6ICdwYXVzZScsXG4gICAgICAgICAgYWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHNlbGYucGF1c2UoaWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICB9XG5cbiAgICAgIC8vIElmIG5vIGlkIGlzIHBhc3NlZCwgZ2V0IGFsbCBJRCdzIHRvIGJlIHBhdXNlZC5cbiAgICAgIHZhciBpZHMgPSBzZWxmLl9nZXRTb3VuZElkcyhpZCk7XG5cbiAgICAgIGZvciAodmFyIGk9MDsgaTxpZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gQ2xlYXIgdGhlIGVuZCB0aW1lci5cbiAgICAgICAgc2VsZi5fY2xlYXJUaW1lcihpZHNbaV0pO1xuXG4gICAgICAgIC8vIEdldCB0aGUgc291bmQuXG4gICAgICAgIHZhciBzb3VuZCA9IHNlbGYuX3NvdW5kQnlJZChpZHNbaV0pO1xuXG4gICAgICAgIGlmIChzb3VuZCAmJiAhc291bmQuX3BhdXNlZCkge1xuICAgICAgICAgIC8vIFJlc2V0IHRoZSBzZWVrIHBvc2l0aW9uLlxuICAgICAgICAgIHNvdW5kLl9zZWVrID0gc2VsZi5zZWVrKGlkc1tpXSk7XG4gICAgICAgICAgc291bmQuX3JhdGVTZWVrID0gMDtcbiAgICAgICAgICBzb3VuZC5fcGF1c2VkID0gdHJ1ZTtcblxuICAgICAgICAgIC8vIFN0b3AgY3VycmVudGx5IHJ1bm5pbmcgZmFkZXMuXG4gICAgICAgICAgc2VsZi5fc3RvcEZhZGUoaWRzW2ldKTtcblxuICAgICAgICAgIGlmIChzb3VuZC5fbm9kZSkge1xuICAgICAgICAgICAgaWYgKHNlbGYuX3dlYkF1ZGlvKSB7XG4gICAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSB0aGUgc291bmQgaGFzIGJlZW4gY3JlYXRlZFxuICAgICAgICAgICAgICBpZiAoIXNvdW5kLl9ub2RlLmJ1ZmZlclNvdXJjZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzb3VuZC5fbm9kZS5idWZmZXJTb3VyY2Uuc3RvcCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBzb3VuZC5fbm9kZS5idWZmZXJTb3VyY2Uubm90ZU9mZigwKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzb3VuZC5fbm9kZS5idWZmZXJTb3VyY2Uuc3RvcCgwKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vIENsZWFuIHVwIHRoZSBidWZmZXIgc291cmNlLlxuICAgICAgICAgICAgICBzZWxmLl9jbGVhbkJ1ZmZlcihzb3VuZC5fbm9kZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFpc05hTihzb3VuZC5fbm9kZS5kdXJhdGlvbikgfHwgc291bmQuX25vZGUuZHVyYXRpb24gPT09IEluZmluaXR5KSB7XG4gICAgICAgICAgICAgIHNvdW5kLl9ub2RlLnBhdXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gRmlyZSB0aGUgcGF1c2UgZXZlbnQsIHVubGVzcyBgdHJ1ZWAgaXMgcGFzc2VkIGFzIHRoZSAybmQgYXJndW1lbnQuXG4gICAgICAgICAgaWYgKCFhcmd1bWVudHNbMV0pIHtcbiAgICAgICAgICAgIHNlbGYuX2VtaXQoJ3BhdXNlJywgc291bmQuX2lkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFN0b3AgcGxheWJhY2sgYW5kIHJlc2V0IHRvIHN0YXJ0LlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gaWQgVGhlIHNvdW5kIElEIChlbXB0eSB0byBzdG9wIGFsbCBpbiBncm91cCkuXG4gICAgICogQHBhcmFtICB7Qm9vbGVhbn0gaW50ZXJuYWwgSW50ZXJuYWwgVXNlOiB0cnVlIHByZXZlbnRzIGV2ZW50IGZpcmluZy5cbiAgICAgKiBAcmV0dXJuIHtIb3dsfVxuICAgICAqL1xuICAgIHN0b3A6IGZ1bmN0aW9uKGlkLCBpbnRlcm5hbCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAvLyBJZiB0aGUgc291bmQgaGFzbid0IGxvYWRlZCwgYWRkIGl0IHRvIHRoZSBsb2FkIHF1ZXVlIHRvIHN0b3Agd2hlbiBjYXBhYmxlLlxuICAgICAgaWYgKHNlbGYuX3N0YXRlICE9PSAnbG9hZGVkJykge1xuICAgICAgICBzZWxmLl9xdWV1ZS5wdXNoKHtcbiAgICAgICAgICBldmVudDogJ3N0b3AnLFxuICAgICAgICAgIGFjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBzZWxmLnN0b3AoaWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICB9XG5cbiAgICAgIC8vIElmIG5vIGlkIGlzIHBhc3NlZCwgZ2V0IGFsbCBJRCdzIHRvIGJlIHN0b3BwZWQuXG4gICAgICB2YXIgaWRzID0gc2VsZi5fZ2V0U291bmRJZHMoaWQpO1xuXG4gICAgICBmb3IgKHZhciBpPTA7IGk8aWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIENsZWFyIHRoZSBlbmQgdGltZXIuXG4gICAgICAgIHNlbGYuX2NsZWFyVGltZXIoaWRzW2ldKTtcblxuICAgICAgICAvLyBHZXQgdGhlIHNvdW5kLlxuICAgICAgICB2YXIgc291bmQgPSBzZWxmLl9zb3VuZEJ5SWQoaWRzW2ldKTtcblxuICAgICAgICBpZiAoc291bmQgJiYgIXNvdW5kLl9wYXVzZWQpIHtcbiAgICAgICAgICAvLyBSZXNldCB0aGUgc2VlayBwb3NpdGlvbi5cbiAgICAgICAgICBzb3VuZC5fc2VlayA9IHNvdW5kLl9zdGFydCB8fCAwO1xuICAgICAgICAgIHNvdW5kLl9yYXRlU2VlayA9IDA7XG4gICAgICAgICAgc291bmQuX3BhdXNlZCA9IHRydWU7XG4gICAgICAgICAgc291bmQuX2VuZGVkID0gdHJ1ZTtcblxuICAgICAgICAgIC8vIFN0b3AgY3VycmVudGx5IHJ1bm5pbmcgZmFkZXMuXG4gICAgICAgICAgc2VsZi5fc3RvcEZhZGUoaWRzW2ldKTtcblxuICAgICAgICAgIGlmIChzb3VuZC5fbm9kZSkge1xuICAgICAgICAgICAgaWYgKHNlbGYuX3dlYkF1ZGlvKSB7XG4gICAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSB0aGUgc291bmQgaGFzIGJlZW4gY3JlYXRlZFxuICAgICAgICAgICAgICBpZiAoIXNvdW5kLl9ub2RlLmJ1ZmZlclNvdXJjZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzb3VuZC5fbm9kZS5idWZmZXJTb3VyY2Uuc3RvcCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBzb3VuZC5fbm9kZS5idWZmZXJTb3VyY2Uubm90ZU9mZigwKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzb3VuZC5fbm9kZS5idWZmZXJTb3VyY2Uuc3RvcCgwKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vIENsZWFuIHVwIHRoZSBidWZmZXIgc291cmNlLlxuICAgICAgICAgICAgICBzZWxmLl9jbGVhbkJ1ZmZlcihzb3VuZC5fbm9kZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFpc05hTihzb3VuZC5fbm9kZS5kdXJhdGlvbikgfHwgc291bmQuX25vZGUuZHVyYXRpb24gPT09IEluZmluaXR5KSB7XG4gICAgICAgICAgICAgIHNvdW5kLl9ub2RlLmN1cnJlbnRUaW1lID0gc291bmQuX3N0YXJ0IHx8IDA7XG4gICAgICAgICAgICAgIHNvdW5kLl9ub2RlLnBhdXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNvdW5kICYmICFpbnRlcm5hbCkge1xuICAgICAgICAgIHNlbGYuX2VtaXQoJ3N0b3AnLCBzb3VuZC5faWQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNdXRlL3VubXV0ZSBhIHNpbmdsZSBzb3VuZCBvciBhbGwgc291bmRzIGluIHRoaXMgSG93bCBncm91cC5cbiAgICAgKiBAcGFyYW0gIHtCb29sZWFufSBtdXRlZCBTZXQgdG8gdHJ1ZSB0byBtdXRlIGFuZCBmYWxzZSB0byB1bm11dGUuXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBpZCAgICBUaGUgc291bmQgSUQgdG8gdXBkYXRlIChvbWl0IHRvIG11dGUvdW5tdXRlIGFsbCkuXG4gICAgICogQHJldHVybiB7SG93bH1cbiAgICAgKi9cbiAgICBtdXRlOiBmdW5jdGlvbihtdXRlZCwgaWQpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgLy8gSWYgdGhlIHNvdW5kIGhhc24ndCBsb2FkZWQsIGFkZCBpdCB0byB0aGUgbG9hZCBxdWV1ZSB0byBtdXRlIHdoZW4gY2FwYWJsZS5cbiAgICAgIGlmIChzZWxmLl9zdGF0ZSAhPT0gJ2xvYWRlZCcpIHtcbiAgICAgICAgc2VsZi5fcXVldWUucHVzaCh7XG4gICAgICAgICAgZXZlbnQ6ICdtdXRlJyxcbiAgICAgICAgICBhY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc2VsZi5tdXRlKG11dGVkLCBpZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgYXBwbHlpbmcgbXV0ZS91bm11dGUgdG8gYWxsIHNvdW5kcywgdXBkYXRlIHRoZSBncm91cCdzIHZhbHVlLlxuICAgICAgaWYgKHR5cGVvZiBpZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBtdXRlZCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgc2VsZi5fbXV0ZWQgPSBtdXRlZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gc2VsZi5fbXV0ZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gSWYgbm8gaWQgaXMgcGFzc2VkLCBnZXQgYWxsIElEJ3MgdG8gYmUgbXV0ZWQuXG4gICAgICB2YXIgaWRzID0gc2VsZi5fZ2V0U291bmRJZHMoaWQpO1xuXG4gICAgICBmb3IgKHZhciBpPTA7IGk8aWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIEdldCB0aGUgc291bmQuXG4gICAgICAgIHZhciBzb3VuZCA9IHNlbGYuX3NvdW5kQnlJZChpZHNbaV0pO1xuXG4gICAgICAgIGlmIChzb3VuZCkge1xuICAgICAgICAgIHNvdW5kLl9tdXRlZCA9IG11dGVkO1xuXG4gICAgICAgICAgaWYgKHNlbGYuX3dlYkF1ZGlvICYmIHNvdW5kLl9ub2RlKSB7XG4gICAgICAgICAgICBzb3VuZC5fbm9kZS5nYWluLnNldFZhbHVlQXRUaW1lKG11dGVkID8gMCA6IHNvdW5kLl92b2x1bWUsIEhvd2xlci5jdHguY3VycmVudFRpbWUpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc291bmQuX25vZGUpIHtcbiAgICAgICAgICAgIHNvdW5kLl9ub2RlLm11dGVkID0gSG93bGVyLl9tdXRlZCA/IHRydWUgOiBtdXRlZDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzZWxmLl9lbWl0KCdtdXRlJywgc291bmQuX2lkKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0L3NldCB0aGUgdm9sdW1lIG9mIHRoaXMgc291bmQgb3Igb2YgdGhlIEhvd2wgZ3JvdXAuIFRoaXMgbWV0aG9kIGNhbiBvcHRpb25hbGx5IHRha2UgMCwgMSBvciAyIGFyZ3VtZW50cy5cbiAgICAgKiAgIHZvbHVtZSgpIC0+IFJldHVybnMgdGhlIGdyb3VwJ3Mgdm9sdW1lIHZhbHVlLlxuICAgICAqICAgdm9sdW1lKGlkKSAtPiBSZXR1cm5zIHRoZSBzb3VuZCBpZCdzIGN1cnJlbnQgdm9sdW1lLlxuICAgICAqICAgdm9sdW1lKHZvbCkgLT4gU2V0cyB0aGUgdm9sdW1lIG9mIGFsbCBzb3VuZHMgaW4gdGhpcyBIb3dsIGdyb3VwLlxuICAgICAqICAgdm9sdW1lKHZvbCwgaWQpIC0+IFNldHMgdGhlIHZvbHVtZSBvZiBwYXNzZWQgc291bmQgaWQuXG4gICAgICogQHJldHVybiB7SG93bC9OdW1iZXJ9IFJldHVybnMgc2VsZiBvciBjdXJyZW50IHZvbHVtZS5cbiAgICAgKi9cbiAgICB2b2x1bWU6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICB2YXIgdm9sLCBpZDtcblxuICAgICAgLy8gRGV0ZXJtaW5lIHRoZSB2YWx1ZXMgYmFzZWQgb24gYXJndW1lbnRzLlxuICAgICAgaWYgKGFyZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIC8vIFJldHVybiB0aGUgdmFsdWUgb2YgdGhlIGdyb3Vwcycgdm9sdW1lLlxuICAgICAgICByZXR1cm4gc2VsZi5fdm9sdW1lO1xuICAgICAgfSBlbHNlIGlmIChhcmdzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAvLyBGaXJzdCBjaGVjayBpZiB0aGlzIGlzIGFuIElELCBhbmQgaWYgbm90LCBhc3N1bWUgaXQgaXMgYSBuZXcgdm9sdW1lLlxuICAgICAgICB2YXIgaWRzID0gc2VsZi5fZ2V0U291bmRJZHMoKTtcbiAgICAgICAgdmFyIGluZGV4ID0gaWRzLmluZGV4T2YoYXJnc1swXSk7XG4gICAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgICAgaWQgPSBwYXJzZUludChhcmdzWzBdLCAxMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdm9sID0gcGFyc2VGbG9hdChhcmdzWzBdKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChhcmdzLmxlbmd0aCA+PSAyKSB7XG4gICAgICAgIHZvbCA9IHBhcnNlRmxvYXQoYXJnc1swXSk7XG4gICAgICAgIGlkID0gcGFyc2VJbnQoYXJnc1sxXSwgMTApO1xuICAgICAgfVxuXG4gICAgICAvLyBVcGRhdGUgdGhlIHZvbHVtZSBvciByZXR1cm4gdGhlIGN1cnJlbnQgdm9sdW1lLlxuICAgICAgdmFyIHNvdW5kO1xuICAgICAgaWYgKHR5cGVvZiB2b2wgIT09ICd1bmRlZmluZWQnICYmIHZvbCA+PSAwICYmIHZvbCA8PSAxKSB7XG4gICAgICAgIC8vIElmIHRoZSBzb3VuZCBoYXNuJ3QgbG9hZGVkLCBhZGQgaXQgdG8gdGhlIGxvYWQgcXVldWUgdG8gY2hhbmdlIHZvbHVtZSB3aGVuIGNhcGFibGUuXG4gICAgICAgIGlmIChzZWxmLl9zdGF0ZSAhPT0gJ2xvYWRlZCcpIHtcbiAgICAgICAgICBzZWxmLl9xdWV1ZS5wdXNoKHtcbiAgICAgICAgICAgIGV2ZW50OiAndm9sdW1lJyxcbiAgICAgICAgICAgIGFjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHNlbGYudm9sdW1lLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTZXQgdGhlIGdyb3VwIHZvbHVtZS5cbiAgICAgICAgaWYgKHR5cGVvZiBpZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBzZWxmLl92b2x1bWUgPSB2b2w7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBVcGRhdGUgb25lIG9yIGFsbCB2b2x1bWVzLlxuICAgICAgICBpZCA9IHNlbGYuX2dldFNvdW5kSWRzKGlkKTtcbiAgICAgICAgZm9yICh2YXIgaT0wOyBpPGlkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgLy8gR2V0IHRoZSBzb3VuZC5cbiAgICAgICAgICBzb3VuZCA9IHNlbGYuX3NvdW5kQnlJZChpZFtpXSk7XG5cbiAgICAgICAgICBpZiAoc291bmQpIHtcbiAgICAgICAgICAgIHNvdW5kLl92b2x1bWUgPSB2b2w7XG5cbiAgICAgICAgICAgIC8vIFN0b3AgY3VycmVudGx5IHJ1bm5pbmcgZmFkZXMuXG4gICAgICAgICAgICBpZiAoIWFyZ3NbMl0pIHtcbiAgICAgICAgICAgICAgc2VsZi5fc3RvcEZhZGUoaWRbaV0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc2VsZi5fd2ViQXVkaW8gJiYgc291bmQuX25vZGUgJiYgIXNvdW5kLl9tdXRlZCkge1xuICAgICAgICAgICAgICBzb3VuZC5fbm9kZS5nYWluLnNldFZhbHVlQXRUaW1lKHZvbCwgSG93bGVyLmN0eC5jdXJyZW50VGltZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNvdW5kLl9ub2RlICYmICFzb3VuZC5fbXV0ZWQpIHtcbiAgICAgICAgICAgICAgc291bmQuX25vZGUudm9sdW1lID0gdm9sICogSG93bGVyLnZvbHVtZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzZWxmLl9lbWl0KCd2b2x1bWUnLCBzb3VuZC5faWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc291bmQgPSBpZCA/IHNlbGYuX3NvdW5kQnlJZChpZCkgOiBzZWxmLl9zb3VuZHNbMF07XG4gICAgICAgIHJldHVybiBzb3VuZCA/IHNvdW5kLl92b2x1bWUgOiAwO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmFkZSBhIGN1cnJlbnRseSBwbGF5aW5nIHNvdW5kIGJldHdlZW4gdHdvIHZvbHVtZXMgKGlmIG5vIGlkIGlzIHBhc3NzZWQsIGFsbCBzb3VuZHMgd2lsbCBmYWRlKS5cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGZyb20gVGhlIHZhbHVlIHRvIGZhZGUgZnJvbSAoMC4wIHRvIDEuMCkuXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSB0byAgIFRoZSB2b2x1bWUgdG8gZmFkZSB0byAoMC4wIHRvIDEuMCkuXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBsZW4gIFRpbWUgaW4gbWlsbGlzZWNvbmRzIHRvIGZhZGUuXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBpZCAgIFRoZSBzb3VuZCBpZCAob21pdCB0byBmYWRlIGFsbCBzb3VuZHMpLlxuICAgICAqIEByZXR1cm4ge0hvd2x9XG4gICAgICovXG4gICAgZmFkZTogZnVuY3Rpb24oZnJvbSwgdG8sIGxlbiwgaWQpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBkaWZmID0gTWF0aC5hYnMoZnJvbSAtIHRvKTtcbiAgICAgIHZhciBkaXIgPSBmcm9tID4gdG8gPyAnb3V0JyA6ICdpbic7XG4gICAgICB2YXIgc3RlcHMgPSBkaWZmIC8gMC4wMTtcbiAgICAgIHZhciBzdGVwTGVuID0gbGVuIC8gc3RlcHM7XG5cbiAgICAgIC8vIElmIHRoZSBzb3VuZCBoYXNuJ3QgbG9hZGVkLCBhZGQgaXQgdG8gdGhlIGxvYWQgcXVldWUgdG8gZmFkZSB3aGVuIGNhcGFibGUuXG4gICAgICBpZiAoc2VsZi5fc3RhdGUgIT09ICdsb2FkZWQnKSB7XG4gICAgICAgIHNlbGYuX3F1ZXVlLnB1c2goe1xuICAgICAgICAgIGV2ZW50OiAnZmFkZScsXG4gICAgICAgICAgYWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHNlbGYuZmFkZShmcm9tLCB0bywgbGVuLCBpZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgIH1cblxuICAgICAgLy8gU2V0IHRoZSB2b2x1bWUgdG8gdGhlIHN0YXJ0IHBvc2l0aW9uLlxuICAgICAgc2VsZi52b2x1bWUoZnJvbSwgaWQpO1xuXG4gICAgICAvLyBGYWRlIHRoZSB2b2x1bWUgb2Ygb25lIG9yIGFsbCBzb3VuZHMuXG4gICAgICB2YXIgaWRzID0gc2VsZi5fZ2V0U291bmRJZHMoaWQpO1xuICAgICAgZm9yICh2YXIgaT0wOyBpPGlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAvLyBHZXQgdGhlIHNvdW5kLlxuICAgICAgICB2YXIgc291bmQgPSBzZWxmLl9zb3VuZEJ5SWQoaWRzW2ldKTtcblxuICAgICAgICAvLyBDcmVhdGUgYSBsaW5lYXIgZmFkZSBvciBmYWxsIGJhY2sgdG8gdGltZW91dHMgd2l0aCBIVE1MNSBBdWRpby5cbiAgICAgICAgaWYgKHNvdW5kKSB7XG4gICAgICAgICAgLy8gU3RvcCB0aGUgcHJldmlvdXMgZmFkZSBpZiBubyBzcHJpdGUgaXMgYmVpbmcgdXNlZCAob3RoZXJ3aXNlLCB2b2x1bWUgaGFuZGxlcyB0aGlzKS5cbiAgICAgICAgICBpZiAoIWlkKSB7XG4gICAgICAgICAgICBzZWxmLl9zdG9wRmFkZShpZHNbaV0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIElmIHdlIGFyZSB1c2luZyBXZWIgQXVkaW8sIGxldCB0aGUgbmF0aXZlIG1ldGhvZHMgZG8gdGhlIGFjdHVhbCBmYWRlLlxuICAgICAgICAgIGlmIChzZWxmLl93ZWJBdWRpbyAmJiAhc291bmQuX211dGVkKSB7XG4gICAgICAgICAgICB2YXIgY3VycmVudFRpbWUgPSBIb3dsZXIuY3R4LmN1cnJlbnRUaW1lO1xuICAgICAgICAgICAgdmFyIGVuZCA9IGN1cnJlbnRUaW1lICsgKGxlbiAvIDEwMDApO1xuICAgICAgICAgICAgc291bmQuX3ZvbHVtZSA9IGZyb207XG4gICAgICAgICAgICBzb3VuZC5fbm9kZS5nYWluLnNldFZhbHVlQXRUaW1lKGZyb20sIGN1cnJlbnRUaW1lKTtcbiAgICAgICAgICAgIHNvdW5kLl9ub2RlLmdhaW4ubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUodG8sIGVuZCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHZvbCA9IGZyb207XG4gICAgICAgICAgc291bmQuX2ludGVydmFsID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24oc291bmRJZCwgc291bmQpIHtcbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgdm9sdW1lIGFtb3VudC5cbiAgICAgICAgICAgIHZvbCArPSAoZGlyID09PSAnaW4nID8gMC4wMSA6IC0wLjAxKTtcblxuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSB2b2x1bWUgaXMgaW4gdGhlIHJpZ2h0IGJvdW5kcy5cbiAgICAgICAgICAgIHZvbCA9IE1hdGgubWF4KDAsIHZvbCk7XG4gICAgICAgICAgICB2b2wgPSBNYXRoLm1pbigxLCB2b2wpO1xuXG4gICAgICAgICAgICAvLyBSb3VuZCB0byB3aXRoaW4gMiBkZWNpbWFsIHBvaW50cy5cbiAgICAgICAgICAgIHZvbCA9IE1hdGgucm91bmQodm9sICogMTAwKSAvIDEwMDtcblxuICAgICAgICAgICAgLy8gQ2hhbmdlIHRoZSB2b2x1bWUuXG4gICAgICAgICAgICBpZiAoc2VsZi5fd2ViQXVkaW8pIHtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBpZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBzZWxmLl92b2x1bWUgPSB2b2w7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBzb3VuZC5fdm9sdW1lID0gdm9sO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc2VsZi52b2x1bWUodm9sLCBzb3VuZElkLCB0cnVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gV2hlbiB0aGUgZmFkZSBpcyBjb21wbGV0ZSwgc3RvcCBpdCBhbmQgZmlyZSBldmVudC5cbiAgICAgICAgICAgIGlmICh2b2wgPT09IHRvKSB7XG4gICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwoc291bmQuX2ludGVydmFsKTtcbiAgICAgICAgICAgICAgc291bmQuX2ludGVydmFsID0gbnVsbDtcbiAgICAgICAgICAgICAgc2VsZi52b2x1bWUodm9sLCBzb3VuZElkKTtcbiAgICAgICAgICAgICAgc2VsZi5fZW1pdCgnZmFkZScsIHNvdW5kSWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0uYmluZChzZWxmLCBpZHNbaV0sIHNvdW5kKSwgc3RlcExlbik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEludGVybmFsIG1ldGhvZCB0aGF0IHN0b3BzIHRoZSBjdXJyZW50bHkgcGxheWluZyBmYWRlIHdoZW5cbiAgICAgKiBhIG5ldyBmYWRlIHN0YXJ0cywgdm9sdW1lIGlzIGNoYW5nZWQgb3IgdGhlIHNvdW5kIGlzIHN0b3BwZWQuXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBpZCBUaGUgc291bmQgaWQuXG4gICAgICogQHJldHVybiB7SG93bH1cbiAgICAgKi9cbiAgICBfc3RvcEZhZGU6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgc291bmQgPSBzZWxmLl9zb3VuZEJ5SWQoaWQpO1xuXG4gICAgICBpZiAoc291bmQgJiYgc291bmQuX2ludGVydmFsKSB7XG4gICAgICAgIGlmIChzZWxmLl93ZWJBdWRpbykge1xuICAgICAgICAgIHNvdW5kLl9ub2RlLmdhaW4uY2FuY2VsU2NoZWR1bGVkVmFsdWVzKEhvd2xlci5jdHguY3VycmVudFRpbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgY2xlYXJJbnRlcnZhbChzb3VuZC5faW50ZXJ2YWwpO1xuICAgICAgICBzb3VuZC5faW50ZXJ2YWwgPSBudWxsO1xuICAgICAgICBzZWxmLl9lbWl0KCdmYWRlJywgaWQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0L3NldCB0aGUgbG9vcCBwYXJhbWV0ZXIgb24gYSBzb3VuZC4gVGhpcyBtZXRob2QgY2FuIG9wdGlvbmFsbHkgdGFrZSAwLCAxIG9yIDIgYXJndW1lbnRzLlxuICAgICAqICAgbG9vcCgpIC0+IFJldHVybnMgdGhlIGdyb3VwJ3MgbG9vcCB2YWx1ZS5cbiAgICAgKiAgIGxvb3AoaWQpIC0+IFJldHVybnMgdGhlIHNvdW5kIGlkJ3MgbG9vcCB2YWx1ZS5cbiAgICAgKiAgIGxvb3AobG9vcCkgLT4gU2V0cyB0aGUgbG9vcCB2YWx1ZSBmb3IgYWxsIHNvdW5kcyBpbiB0aGlzIEhvd2wgZ3JvdXAuXG4gICAgICogICBsb29wKGxvb3AsIGlkKSAtPiBTZXRzIHRoZSBsb29wIHZhbHVlIG9mIHBhc3NlZCBzb3VuZCBpZC5cbiAgICAgKiBAcmV0dXJuIHtIb3dsL0Jvb2xlYW59IFJldHVybnMgc2VsZiBvciBjdXJyZW50IGxvb3AgdmFsdWUuXG4gICAgICovXG4gICAgbG9vcDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgIHZhciBsb29wLCBpZCwgc291bmQ7XG5cbiAgICAgIC8vIERldGVybWluZSB0aGUgdmFsdWVzIGZvciBsb29wIGFuZCBpZC5cbiAgICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAvLyBSZXR1cm4gdGhlIGdyb3UncyBsb29wIHZhbHVlLlxuICAgICAgICByZXR1cm4gc2VsZi5fbG9vcDtcbiAgICAgIH0gZWxzZSBpZiAoYXJncy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBhcmdzWzBdID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICBsb29wID0gYXJnc1swXTtcbiAgICAgICAgICBzZWxmLl9sb29wID0gbG9vcDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBSZXR1cm4gdGhpcyBzb3VuZCdzIGxvb3AgdmFsdWUuXG4gICAgICAgICAgc291bmQgPSBzZWxmLl9zb3VuZEJ5SWQocGFyc2VJbnQoYXJnc1swXSwgMTApKTtcbiAgICAgICAgICByZXR1cm4gc291bmQgPyBzb3VuZC5fbG9vcCA6IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGFyZ3MubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIGxvb3AgPSBhcmdzWzBdO1xuICAgICAgICBpZCA9IHBhcnNlSW50KGFyZ3NbMV0sIDEwKTtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgbm8gaWQgaXMgcGFzc2VkLCBnZXQgYWxsIElEJ3MgdG8gYmUgbG9vcGVkLlxuICAgICAgdmFyIGlkcyA9IHNlbGYuX2dldFNvdW5kSWRzKGlkKTtcbiAgICAgIGZvciAodmFyIGk9MDsgaTxpZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc291bmQgPSBzZWxmLl9zb3VuZEJ5SWQoaWRzW2ldKTtcblxuICAgICAgICBpZiAoc291bmQpIHtcbiAgICAgICAgICBzb3VuZC5fbG9vcCA9IGxvb3A7XG4gICAgICAgICAgaWYgKHNlbGYuX3dlYkF1ZGlvICYmIHNvdW5kLl9ub2RlICYmIHNvdW5kLl9ub2RlLmJ1ZmZlclNvdXJjZSkge1xuICAgICAgICAgICAgc291bmQuX25vZGUuYnVmZmVyU291cmNlLmxvb3AgPSBsb29wO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0L3NldCB0aGUgcGxheWJhY2sgcmF0ZSBvZiBhIHNvdW5kLiBUaGlzIG1ldGhvZCBjYW4gb3B0aW9uYWxseSB0YWtlIDAsIDEgb3IgMiBhcmd1bWVudHMuXG4gICAgICogICByYXRlKCkgLT4gUmV0dXJucyB0aGUgZmlyc3Qgc291bmQgbm9kZSdzIGN1cnJlbnQgcGxheWJhY2sgcmF0ZS5cbiAgICAgKiAgIHJhdGUoaWQpIC0+IFJldHVybnMgdGhlIHNvdW5kIGlkJ3MgY3VycmVudCBwbGF5YmFjayByYXRlLlxuICAgICAqICAgcmF0ZShyYXRlKSAtPiBTZXRzIHRoZSBwbGF5YmFjayByYXRlIG9mIGFsbCBzb3VuZHMgaW4gdGhpcyBIb3dsIGdyb3VwLlxuICAgICAqICAgcmF0ZShyYXRlLCBpZCkgLT4gU2V0cyB0aGUgcGxheWJhY2sgcmF0ZSBvZiBwYXNzZWQgc291bmQgaWQuXG4gICAgICogQHJldHVybiB7SG93bC9OdW1iZXJ9IFJldHVybnMgc2VsZiBvciB0aGUgY3VycmVudCBwbGF5YmFjayByYXRlLlxuICAgICAqL1xuICAgIHJhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICB2YXIgcmF0ZSwgaWQ7XG5cbiAgICAgIC8vIERldGVybWluZSB0aGUgdmFsdWVzIGJhc2VkIG9uIGFyZ3VtZW50cy5cbiAgICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAvLyBXZSB3aWxsIHNpbXBseSByZXR1cm4gdGhlIGN1cnJlbnQgcmF0ZSBvZiB0aGUgZmlyc3Qgbm9kZS5cbiAgICAgICAgaWQgPSBzZWxmLl9zb3VuZHNbMF0uX2lkO1xuICAgICAgfSBlbHNlIGlmIChhcmdzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAvLyBGaXJzdCBjaGVjayBpZiB0aGlzIGlzIGFuIElELCBhbmQgaWYgbm90LCBhc3N1bWUgaXQgaXMgYSBuZXcgcmF0ZSB2YWx1ZS5cbiAgICAgICAgdmFyIGlkcyA9IHNlbGYuX2dldFNvdW5kSWRzKCk7XG4gICAgICAgIHZhciBpbmRleCA9IGlkcy5pbmRleE9mKGFyZ3NbMF0pO1xuICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICAgIGlkID0gcGFyc2VJbnQoYXJnc1swXSwgMTApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJhdGUgPSBwYXJzZUZsb2F0KGFyZ3NbMF0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGFyZ3MubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIHJhdGUgPSBwYXJzZUZsb2F0KGFyZ3NbMF0pO1xuICAgICAgICBpZCA9IHBhcnNlSW50KGFyZ3NbMV0sIDEwKTtcbiAgICAgIH1cblxuICAgICAgLy8gVXBkYXRlIHRoZSBwbGF5YmFjayByYXRlIG9yIHJldHVybiB0aGUgY3VycmVudCB2YWx1ZS5cbiAgICAgIHZhciBzb3VuZDtcbiAgICAgIGlmICh0eXBlb2YgcmF0ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgLy8gSWYgdGhlIHNvdW5kIGhhc24ndCBsb2FkZWQsIGFkZCBpdCB0byB0aGUgbG9hZCBxdWV1ZSB0byBjaGFuZ2UgcGxheWJhY2sgcmF0ZSB3aGVuIGNhcGFibGUuXG4gICAgICAgIGlmIChzZWxmLl9zdGF0ZSAhPT0gJ2xvYWRlZCcpIHtcbiAgICAgICAgICBzZWxmLl9xdWV1ZS5wdXNoKHtcbiAgICAgICAgICAgIGV2ZW50OiAncmF0ZScsXG4gICAgICAgICAgICBhY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICBzZWxmLnJhdGUuYXBwbHkoc2VsZiwgYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNldCB0aGUgZ3JvdXAgcmF0ZS5cbiAgICAgICAgaWYgKHR5cGVvZiBpZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBzZWxmLl9yYXRlID0gcmF0ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVwZGF0ZSBvbmUgb3IgYWxsIHZvbHVtZXMuXG4gICAgICAgIGlkID0gc2VsZi5fZ2V0U291bmRJZHMoaWQpO1xuICAgICAgICBmb3IgKHZhciBpPTA7IGk8aWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAvLyBHZXQgdGhlIHNvdW5kLlxuICAgICAgICAgIHNvdW5kID0gc2VsZi5fc291bmRCeUlkKGlkW2ldKTtcblxuICAgICAgICAgIGlmIChzb3VuZCkge1xuICAgICAgICAgICAgLy8gS2VlcCB0cmFjayBvZiBvdXIgcG9zaXRpb24gd2hlbiB0aGUgcmF0ZSBjaGFuZ2VkIGFuZCB1cGRhdGUgdGhlIHBsYXliYWNrXG4gICAgICAgICAgICAvLyBzdGFydCBwb3NpdGlvbiBzbyB3ZSBjYW4gcHJvcGVybHkgYWRqdXN0IHRoZSBzZWVrIHBvc2l0aW9uIGZvciB0aW1lIGVsYXBzZWQuXG4gICAgICAgICAgICBzb3VuZC5fcmF0ZVNlZWsgPSBzZWxmLnNlZWsoaWRbaV0pO1xuICAgICAgICAgICAgc291bmQuX3BsYXlTdGFydCA9IHNlbGYuX3dlYkF1ZGlvID8gSG93bGVyLmN0eC5jdXJyZW50VGltZSA6IHNvdW5kLl9wbGF5U3RhcnQ7XG4gICAgICAgICAgICBzb3VuZC5fcmF0ZSA9IHJhdGU7XG5cbiAgICAgICAgICAgIC8vIENoYW5nZSB0aGUgcGxheWJhY2sgcmF0ZS5cbiAgICAgICAgICAgIGlmIChzZWxmLl93ZWJBdWRpbyAmJiBzb3VuZC5fbm9kZSAmJiBzb3VuZC5fbm9kZS5idWZmZXJTb3VyY2UpIHtcbiAgICAgICAgICAgICAgc291bmQuX25vZGUuYnVmZmVyU291cmNlLnBsYXliYWNrUmF0ZS52YWx1ZSA9IHJhdGU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNvdW5kLl9ub2RlKSB7XG4gICAgICAgICAgICAgIHNvdW5kLl9ub2RlLnBsYXliYWNrUmF0ZSA9IHJhdGU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFJlc2V0IHRoZSB0aW1lcnMuXG4gICAgICAgICAgICB2YXIgc2VlayA9IHNlbGYuc2VlayhpZFtpXSk7XG4gICAgICAgICAgICB2YXIgZHVyYXRpb24gPSAoKHNlbGYuX3Nwcml0ZVtzb3VuZC5fc3ByaXRlXVswXSArIHNlbGYuX3Nwcml0ZVtzb3VuZC5fc3ByaXRlXVsxXSkgLyAxMDAwKSAtIHNlZWs7XG4gICAgICAgICAgICB2YXIgdGltZW91dCA9IChkdXJhdGlvbiAqIDEwMDApIC8gTWF0aC5hYnMoc291bmQuX3JhdGUpO1xuXG4gICAgICAgICAgICAvLyBTdGFydCBhIG5ldyBlbmQgdGltZXIgaWYgc291bmQgaXMgYWxyZWFkeSBwbGF5aW5nLlxuICAgICAgICAgICAgaWYgKHNlbGYuX2VuZFRpbWVyc1tpZFtpXV0gfHwgIXNvdW5kLl9wYXVzZWQpIHtcbiAgICAgICAgICAgICAgc2VsZi5fY2xlYXJUaW1lcihpZFtpXSk7XG4gICAgICAgICAgICAgIHNlbGYuX2VuZFRpbWVyc1tpZFtpXV0gPSBzZXRUaW1lb3V0KHNlbGYuX2VuZGVkLmJpbmQoc2VsZiwgc291bmQpLCB0aW1lb3V0KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2VsZi5fZW1pdCgncmF0ZScsIHNvdW5kLl9pZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzb3VuZCA9IHNlbGYuX3NvdW5kQnlJZChpZCk7XG4gICAgICAgIHJldHVybiBzb3VuZCA/IHNvdW5kLl9yYXRlIDogc2VsZi5fcmF0ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldC9zZXQgdGhlIHNlZWsgcG9zaXRpb24gb2YgYSBzb3VuZC4gVGhpcyBtZXRob2QgY2FuIG9wdGlvbmFsbHkgdGFrZSAwLCAxIG9yIDIgYXJndW1lbnRzLlxuICAgICAqICAgc2VlaygpIC0+IFJldHVybnMgdGhlIGZpcnN0IHNvdW5kIG5vZGUncyBjdXJyZW50IHNlZWsgcG9zaXRpb24uXG4gICAgICogICBzZWVrKGlkKSAtPiBSZXR1cm5zIHRoZSBzb3VuZCBpZCdzIGN1cnJlbnQgc2VlayBwb3NpdGlvbi5cbiAgICAgKiAgIHNlZWsoc2VlaykgLT4gU2V0cyB0aGUgc2VlayBwb3NpdGlvbiBvZiB0aGUgZmlyc3Qgc291bmQgbm9kZS5cbiAgICAgKiAgIHNlZWsoc2VlaywgaWQpIC0+IFNldHMgdGhlIHNlZWsgcG9zaXRpb24gb2YgcGFzc2VkIHNvdW5kIGlkLlxuICAgICAqIEByZXR1cm4ge0hvd2wvTnVtYmVyfSBSZXR1cm5zIHNlbGYgb3IgdGhlIGN1cnJlbnQgc2VlayBwb3NpdGlvbi5cbiAgICAgKi9cbiAgICBzZWVrOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgdmFyIHNlZWssIGlkO1xuXG4gICAgICAvLyBEZXRlcm1pbmUgdGhlIHZhbHVlcyBiYXNlZCBvbiBhcmd1bWVudHMuXG4gICAgICBpZiAoYXJncy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgLy8gV2Ugd2lsbCBzaW1wbHkgcmV0dXJuIHRoZSBjdXJyZW50IHBvc2l0aW9uIG9mIHRoZSBmaXJzdCBub2RlLlxuICAgICAgICBpZCA9IHNlbGYuX3NvdW5kc1swXS5faWQ7XG4gICAgICB9IGVsc2UgaWYgKGFyZ3MubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIC8vIEZpcnN0IGNoZWNrIGlmIHRoaXMgaXMgYW4gSUQsIGFuZCBpZiBub3QsIGFzc3VtZSBpdCBpcyBhIG5ldyBzZWVrIHBvc2l0aW9uLlxuICAgICAgICB2YXIgaWRzID0gc2VsZi5fZ2V0U291bmRJZHMoKTtcbiAgICAgICAgdmFyIGluZGV4ID0gaWRzLmluZGV4T2YoYXJnc1swXSk7XG4gICAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgICAgaWQgPSBwYXJzZUludChhcmdzWzBdLCAxMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWQgPSBzZWxmLl9zb3VuZHNbMF0uX2lkO1xuICAgICAgICAgIHNlZWsgPSBwYXJzZUZsb2F0KGFyZ3NbMF0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGFyZ3MubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIHNlZWsgPSBwYXJzZUZsb2F0KGFyZ3NbMF0pO1xuICAgICAgICBpZCA9IHBhcnNlSW50KGFyZ3NbMV0sIDEwKTtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gSUQsIGJhaWwgb3V0LlxuICAgICAgaWYgKHR5cGVvZiBpZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICB9XG5cbiAgICAgIC8vIElmIHRoZSBzb3VuZCBoYXNuJ3QgbG9hZGVkLCBhZGQgaXQgdG8gdGhlIGxvYWQgcXVldWUgdG8gc2VlayB3aGVuIGNhcGFibGUuXG4gICAgICBpZiAoc2VsZi5fc3RhdGUgIT09ICdsb2FkZWQnKSB7XG4gICAgICAgIHNlbGYuX3F1ZXVlLnB1c2goe1xuICAgICAgICAgIGV2ZW50OiAnc2VlaycsXG4gICAgICAgICAgYWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHNlbGYuc2Vlay5hcHBseShzZWxmLCBhcmdzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgfVxuXG4gICAgICAvLyBHZXQgdGhlIHNvdW5kLlxuICAgICAgdmFyIHNvdW5kID0gc2VsZi5fc291bmRCeUlkKGlkKTtcblxuICAgICAgaWYgKHNvdW5kKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2VlayA9PT0gJ251bWJlcicgJiYgc2VlayA+PSAwKSB7XG4gICAgICAgICAgLy8gUGF1c2UgdGhlIHNvdW5kIGFuZCB1cGRhdGUgcG9zaXRpb24gZm9yIHJlc3RhcnRpbmcgcGxheWJhY2suXG4gICAgICAgICAgdmFyIHBsYXlpbmcgPSBzZWxmLnBsYXlpbmcoaWQpO1xuICAgICAgICAgIGlmIChwbGF5aW5nKSB7XG4gICAgICAgICAgICBzZWxmLnBhdXNlKGlkLCB0cnVlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBNb3ZlIHRoZSBwb3NpdGlvbiBvZiB0aGUgdHJhY2sgYW5kIGNhbmNlbCB0aW1lci5cbiAgICAgICAgICBzb3VuZC5fc2VlayA9IHNlZWs7XG4gICAgICAgICAgc291bmQuX2VuZGVkID0gZmFsc2U7XG4gICAgICAgICAgc2VsZi5fY2xlYXJUaW1lcihpZCk7XG5cbiAgICAgICAgICAvLyBSZXN0YXJ0IHRoZSBwbGF5YmFjayBpZiB0aGUgc291bmQgd2FzIHBsYXlpbmcuXG4gICAgICAgICAgaWYgKHBsYXlpbmcpIHtcbiAgICAgICAgICAgIHNlbGYucGxheShpZCwgdHJ1ZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gVXBkYXRlIHRoZSBzZWVrIHBvc2l0aW9uIGZvciBIVE1MNSBBdWRpby5cbiAgICAgICAgICBpZiAoIXNlbGYuX3dlYkF1ZGlvICYmIHNvdW5kLl9ub2RlKSB7XG4gICAgICAgICAgICBzb3VuZC5fbm9kZS5jdXJyZW50VGltZSA9IHNlZWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc2VsZi5fZW1pdCgnc2VlaycsIGlkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoc2VsZi5fd2ViQXVkaW8pIHtcbiAgICAgICAgICAgIHZhciByZWFsVGltZSA9IHNlbGYucGxheWluZyhpZCkgPyBIb3dsZXIuY3R4LmN1cnJlbnRUaW1lIC0gc291bmQuX3BsYXlTdGFydCA6IDA7XG4gICAgICAgICAgICB2YXIgcmF0ZVNlZWsgPSBzb3VuZC5fcmF0ZVNlZWsgPyBzb3VuZC5fcmF0ZVNlZWsgLSBzb3VuZC5fc2VlayA6IDA7XG4gICAgICAgICAgICByZXR1cm4gc291bmQuX3NlZWsgKyAocmF0ZVNlZWsgKyByZWFsVGltZSAqIE1hdGguYWJzKHNvdW5kLl9yYXRlKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBzb3VuZC5fbm9kZS5jdXJyZW50VGltZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIGEgc3BlY2lmaWMgc291bmQgaXMgY3VycmVudGx5IHBsYXlpbmcgb3Igbm90IChpZiBpZCBpcyBwcm92aWRlZCksIG9yIGNoZWNrIGlmIGF0IGxlYXN0IG9uZSBvZiB0aGUgc291bmRzIGluIHRoZSBncm91cCBpcyBwbGF5aW5nIG9yIG5vdC5cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9ICBpZCBUaGUgc291bmQgaWQgdG8gY2hlY2suIElmIG5vbmUgaXMgcGFzc2VkLCB0aGUgd2hvbGUgc291bmQgZ3JvdXAgaXMgY2hlY2tlZC5cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIGlmIHBsYXlpbmcgYW5kIGZhbHNlIGlmIG5vdC5cbiAgICAgKi9cbiAgICBwbGF5aW5nOiBmdW5jdGlvbihpZCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAvLyBDaGVjayB0aGUgcGFzc2VkIHNvdW5kIElEIChpZiBhbnkpLlxuICAgICAgaWYgKHR5cGVvZiBpZCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgdmFyIHNvdW5kID0gc2VsZi5fc291bmRCeUlkKGlkKTtcbiAgICAgICAgcmV0dXJuIHNvdW5kID8gIXNvdW5kLl9wYXVzZWQgOiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgLy8gT3RoZXJ3aXNlLCBsb29wIHRocm91Z2ggYWxsIHNvdW5kcyBhbmQgY2hlY2sgaWYgYW55IGFyZSBwbGF5aW5nLlxuICAgICAgZm9yICh2YXIgaT0wOyBpPHNlbGYuX3NvdW5kcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoIXNlbGYuX3NvdW5kc1tpXS5fcGF1c2VkKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGR1cmF0aW9uIG9mIHRoaXMgc291bmQuIFBhc3NpbmcgYSBzb3VuZCBpZCB3aWxsIHJldHVybiB0aGUgc3ByaXRlIGR1cmF0aW9uLlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gaWQgVGhlIHNvdW5kIGlkIHRvIGNoZWNrLiBJZiBub25lIGlzIHBhc3NlZCwgcmV0dXJuIGZ1bGwgc291cmNlIGR1cmF0aW9uLlxuICAgICAqIEByZXR1cm4ge051bWJlcn0gQXVkaW8gZHVyYXRpb24gaW4gc2Vjb25kcy5cbiAgICAgKi9cbiAgICBkdXJhdGlvbjogZnVuY3Rpb24oaWQpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBkdXJhdGlvbiA9IHNlbGYuX2R1cmF0aW9uO1xuXG4gICAgICAvLyBJZiB3ZSBwYXNzIGFuIElELCBnZXQgdGhlIHNvdW5kIGFuZCByZXR1cm4gdGhlIHNwcml0ZSBsZW5ndGguXG4gICAgICB2YXIgc291bmQgPSBzZWxmLl9zb3VuZEJ5SWQoaWQpO1xuICAgICAgaWYgKHNvdW5kKSB7XG4gICAgICAgIGR1cmF0aW9uID0gc2VsZi5fc3ByaXRlW3NvdW5kLl9zcHJpdGVdWzFdIC8gMTAwMDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGR1cmF0aW9uO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IGxvYWRlZCBzdGF0ZSBvZiB0aGlzIEhvd2wuXG4gICAgICogQHJldHVybiB7U3RyaW5nfSAndW5sb2FkZWQnLCAnbG9hZGluZycsICdsb2FkZWQnXG4gICAgICovXG4gICAgc3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3N0YXRlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVbmxvYWQgYW5kIGRlc3Ryb3kgdGhlIGN1cnJlbnQgSG93bCBvYmplY3QuXG4gICAgICogVGhpcyB3aWxsIGltbWVkaWF0ZWx5IHN0b3AgYWxsIHNvdW5kIGluc3RhbmNlcyBhdHRhY2hlZCB0byB0aGlzIGdyb3VwLlxuICAgICAqL1xuICAgIHVubG9hZDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgIC8vIFN0b3AgcGxheWluZyBhbnkgYWN0aXZlIHNvdW5kcy5cbiAgICAgIHZhciBzb3VuZHMgPSBzZWxmLl9zb3VuZHM7XG4gICAgICBmb3IgKHZhciBpPTA7IGk8c291bmRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIFN0b3AgdGhlIHNvdW5kIGlmIGl0IGlzIGN1cnJlbnRseSBwbGF5aW5nLlxuICAgICAgICBpZiAoIXNvdW5kc1tpXS5fcGF1c2VkKSB7XG4gICAgICAgICAgc2VsZi5zdG9wKHNvdW5kc1tpXS5faWQpO1xuICAgICAgICAgIHNlbGYuX2VtaXQoJ2VuZCcsIHNvdW5kc1tpXS5faWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVtb3ZlIHRoZSBzb3VyY2Ugb3IgZGlzY29ubmVjdC5cbiAgICAgICAgaWYgKCFzZWxmLl93ZWJBdWRpbykge1xuICAgICAgICAgIC8vIFNldCB0aGUgc291cmNlIHRvIDAtc2Vjb25kIHNpbGVuY2UgdG8gc3RvcCBhbnkgZG93bmxvYWRpbmcuXG4gICAgICAgICAgc291bmRzW2ldLl9ub2RlLnNyYyA9ICdkYXRhOmF1ZGlvL3dhdjtiYXNlNjQsVWtsR1JpUUFBQUJYUVZaRlptMTBJQkFBQUFBQkFBRUFSS3dBQUloWUFRQUNBQkFBWkdGMFlRQUFBQUE9JztcblxuICAgICAgICAgIC8vIFJlbW92ZSBhbnkgZXZlbnQgbGlzdGVuZXJzLlxuICAgICAgICAgIHNvdW5kc1tpXS5fbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCdlcnJvcicsIHNvdW5kc1tpXS5fZXJyb3JGbiwgZmFsc2UpO1xuICAgICAgICAgIHNvdW5kc1tpXS5fbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKEhvd2xlci5fY2FuUGxheUV2ZW50LCBzb3VuZHNbaV0uX2xvYWRGbiwgZmFsc2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRW1wdHkgb3V0IGFsbCBvZiB0aGUgbm9kZXMuXG4gICAgICAgIGRlbGV0ZSBzb3VuZHNbaV0uX25vZGU7XG5cbiAgICAgICAgLy8gTWFrZSBzdXJlIGFsbCB0aW1lcnMgYXJlIGNsZWFyZWQgb3V0LlxuICAgICAgICBzZWxmLl9jbGVhclRpbWVyKHNvdW5kc1tpXS5faWQpO1xuXG4gICAgICAgIC8vIFJlbW92ZSB0aGUgcmVmZXJlbmNlcyBpbiB0aGUgZ2xvYmFsIEhvd2xlciBvYmplY3QuXG4gICAgICAgIHZhciBpbmRleCA9IEhvd2xlci5faG93bHMuaW5kZXhPZihzZWxmKTtcbiAgICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgICBIb3dsZXIuX2hvd2xzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gRGVsZXRlIHRoaXMgc291bmQgZnJvbSB0aGUgY2FjaGUgKGlmIG5vIG90aGVyIEhvd2wgaXMgdXNpbmcgaXQpLlxuICAgICAgdmFyIHJlbUNhY2hlID0gdHJ1ZTtcbiAgICAgIGZvciAoaT0wOyBpPEhvd2xlci5faG93bHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKEhvd2xlci5faG93bHNbaV0uX3NyYyA9PT0gc2VsZi5fc3JjKSB7XG4gICAgICAgICAgcmVtQ2FjaGUgPSBmYWxzZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoY2FjaGUgJiYgcmVtQ2FjaGUpIHtcbiAgICAgICAgZGVsZXRlIGNhY2hlW3NlbGYuX3NyY107XG4gICAgICB9XG5cbiAgICAgIC8vIENsZWFyIG91dCBgc2VsZmAuXG4gICAgICBzZWxmLl9zdGF0ZSA9ICd1bmxvYWRlZCc7XG4gICAgICBzZWxmLl9zb3VuZHMgPSBbXTtcbiAgICAgIHNlbGYgPSBudWxsO1xuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTGlzdGVuIHRvIGEgY3VzdG9tIGV2ZW50LlxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gICBldmVudCBFdmVudCBuYW1lLlxuICAgICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBmbiAgICBMaXN0ZW5lciB0byBjYWxsLlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gICBpZCAgICAob3B0aW9uYWwpIE9ubHkgbGlzdGVuIHRvIGV2ZW50cyBmb3IgdGhpcyBzb3VuZC5cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9ICAgb25jZSAgKElOVEVSTkFMKSBNYXJrcyBldmVudCB0byBmaXJlIG9ubHkgb25jZS5cbiAgICAgKiBAcmV0dXJuIHtIb3dsfVxuICAgICAqL1xuICAgIG9uOiBmdW5jdGlvbihldmVudCwgZm4sIGlkLCBvbmNlKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgZXZlbnRzID0gc2VsZlsnX29uJyArIGV2ZW50XTtcblxuICAgICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBldmVudHMucHVzaChvbmNlID8ge2lkOiBpZCwgZm46IGZuLCBvbmNlOiBvbmNlfSA6IHtpZDogaWQsIGZuOiBmbn0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGEgY3VzdG9tIGV2ZW50LiBDYWxsIHdpdGhvdXQgcGFyYW1ldGVycyB0byByZW1vdmUgYWxsIGV2ZW50cy5cbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9ICAgZXZlbnQgRXZlbnQgbmFtZS5cbiAgICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gZm4gICAgTGlzdGVuZXIgdG8gcmVtb3ZlLiBMZWF2ZSBlbXB0eSB0byByZW1vdmUgYWxsLlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gICBpZCAgICAob3B0aW9uYWwpIE9ubHkgcmVtb3ZlIGV2ZW50cyBmb3IgdGhpcyBzb3VuZC5cbiAgICAgKiBAcmV0dXJuIHtIb3dsfVxuICAgICAqL1xuICAgIG9mZjogZnVuY3Rpb24oZXZlbnQsIGZuLCBpZCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIGV2ZW50cyA9IHNlbGZbJ19vbicgKyBldmVudF07XG4gICAgICB2YXIgaSA9IDA7XG5cbiAgICAgIGlmIChmbikge1xuICAgICAgICAvLyBMb29wIHRocm91Z2ggZXZlbnQgc3RvcmUgYW5kIHJlbW92ZSB0aGUgcGFzc2VkIGZ1bmN0aW9uLlxuICAgICAgICBmb3IgKGk9MDsgaTxldmVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAoZm4gPT09IGV2ZW50c1tpXS5mbiAmJiBpZCA9PT0gZXZlbnRzW2ldLmlkKSB7XG4gICAgICAgICAgICBldmVudHMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGV2ZW50KSB7XG4gICAgICAgIC8vIENsZWFyIG91dCBhbGwgZXZlbnRzIG9mIHRoaXMgdHlwZS5cbiAgICAgICAgc2VsZlsnX29uJyArIGV2ZW50XSA9IFtdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQ2xlYXIgb3V0IGFsbCBldmVudHMgb2YgZXZlcnkgdHlwZS5cbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhzZWxmKTtcbiAgICAgICAgZm9yIChpPTA7IGk8a2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmICgoa2V5c1tpXS5pbmRleE9mKCdfb24nKSA9PT0gMCkgJiYgQXJyYXkuaXNBcnJheShzZWxmW2tleXNbaV1dKSkge1xuICAgICAgICAgICAgc2VsZltrZXlzW2ldXSA9IFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTGlzdGVuIHRvIGEgY3VzdG9tIGV2ZW50IGFuZCByZW1vdmUgaXQgb25jZSBmaXJlZC5cbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9ICAgZXZlbnQgRXZlbnQgbmFtZS5cbiAgICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gZm4gICAgTGlzdGVuZXIgdG8gY2FsbC5cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9ICAgaWQgICAgKG9wdGlvbmFsKSBPbmx5IGxpc3RlbiB0byBldmVudHMgZm9yIHRoaXMgc291bmQuXG4gICAgICogQHJldHVybiB7SG93bH1cbiAgICAgKi9cbiAgICBvbmNlOiBmdW5jdGlvbihldmVudCwgZm4sIGlkKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgIC8vIFNldHVwIHRoZSBldmVudCBsaXN0ZW5lci5cbiAgICAgIHNlbGYub24oZXZlbnQsIGZuLCBpZCwgMSk7XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBFbWl0IGFsbCBldmVudHMgb2YgYSBzcGVjaWZpYyB0eXBlIGFuZCBwYXNzIHRoZSBzb3VuZCBpZC5cbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IGV2ZW50IEV2ZW50IG5hbWUuXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBpZCAgICBTb3VuZCBJRC5cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IG1zZyAgIE1lc3NhZ2UgdG8gZ28gd2l0aCBldmVudC5cbiAgICAgKiBAcmV0dXJuIHtIb3dsfVxuICAgICAqL1xuICAgIF9lbWl0OiBmdW5jdGlvbihldmVudCwgaWQsIG1zZykge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIGV2ZW50cyA9IHNlbGZbJ19vbicgKyBldmVudF07XG5cbiAgICAgIC8vIExvb3AgdGhyb3VnaCBldmVudCBzdG9yZSBhbmQgZmlyZSBhbGwgZnVuY3Rpb25zLlxuICAgICAgZm9yICh2YXIgaT1ldmVudHMubGVuZ3RoLTE7IGk+PTA7IGktLSkge1xuICAgICAgICBpZiAoIWV2ZW50c1tpXS5pZCB8fCBldmVudHNbaV0uaWQgPT09IGlkIHx8IGV2ZW50ID09PSAnbG9hZCcpIHtcbiAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKGZuKSB7XG4gICAgICAgICAgICBmbi5jYWxsKHRoaXMsIGlkLCBtc2cpO1xuICAgICAgICAgIH0uYmluZChzZWxmLCBldmVudHNbaV0uZm4pLCAwKTtcblxuICAgICAgICAgIC8vIElmIHRoaXMgZXZlbnQgd2FzIHNldHVwIHdpdGggYG9uY2VgLCByZW1vdmUgaXQuXG4gICAgICAgICAgaWYgKGV2ZW50c1tpXS5vbmNlKSB7XG4gICAgICAgICAgICBzZWxmLm9mZihldmVudCwgZXZlbnRzW2ldLmZuLCBldmVudHNbaV0uaWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUXVldWUgb2YgYWN0aW9ucyBpbml0aWF0ZWQgYmVmb3JlIHRoZSBzb3VuZCBoYXMgbG9hZGVkLlxuICAgICAqIFRoZXNlIHdpbGwgYmUgY2FsbGVkIGluIHNlcXVlbmNlLCB3aXRoIHRoZSBuZXh0IG9ubHkgZmlyaW5nXG4gICAgICogYWZ0ZXIgdGhlIHByZXZpb3VzIGhhcyBmaW5pc2hlZCBleGVjdXRpbmcgKGV2ZW4gaWYgYXN5bmMgbGlrZSBwbGF5KS5cbiAgICAgKiBAcmV0dXJuIHtIb3dsfVxuICAgICAqL1xuICAgIF9sb2FkUXVldWU6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICBpZiAoc2VsZi5fcXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICB2YXIgdGFzayA9IHNlbGYuX3F1ZXVlWzBdO1xuXG4gICAgICAgIC8vIGRvbid0IG1vdmUgb250byB0aGUgbmV4dCB0YXNrIHVudGlsIHRoaXMgb25lIGlzIGRvbmVcbiAgICAgICAgc2VsZi5vbmNlKHRhc2suZXZlbnQsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHNlbGYuX3F1ZXVlLnNoaWZ0KCk7XG4gICAgICAgICAgc2VsZi5fbG9hZFF1ZXVlKCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRhc2suYWN0aW9uKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGaXJlZCB3aGVuIHBsYXliYWNrIGVuZHMgYXQgdGhlIGVuZCBvZiB0aGUgZHVyYXRpb24uXG4gICAgICogQHBhcmFtICB7U291bmR9IHNvdW5kIFRoZSBzb3VuZCBvYmplY3QgdG8gd29yayB3aXRoLlxuICAgICAqIEByZXR1cm4ge0hvd2x9XG4gICAgICovXG4gICAgX2VuZGVkOiBmdW5jdGlvbihzb3VuZCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIHNwcml0ZSA9IHNvdW5kLl9zcHJpdGU7XG5cbiAgICAgIC8vIFNob3VsZCB0aGlzIHNvdW5kIGxvb3A/XG4gICAgICB2YXIgbG9vcCA9ICEhKHNvdW5kLl9sb29wIHx8IHNlbGYuX3Nwcml0ZVtzcHJpdGVdWzJdKTtcblxuICAgICAgLy8gRmlyZSB0aGUgZW5kZWQgZXZlbnQuXG4gICAgICBzZWxmLl9lbWl0KCdlbmQnLCBzb3VuZC5faWQpO1xuXG4gICAgICAvLyBSZXN0YXJ0IHRoZSBwbGF5YmFjayBmb3IgSFRNTDUgQXVkaW8gbG9vcC5cbiAgICAgIGlmICghc2VsZi5fd2ViQXVkaW8gJiYgbG9vcCkge1xuICAgICAgICBzZWxmLnN0b3Aoc291bmQuX2lkLCB0cnVlKS5wbGF5KHNvdW5kLl9pZCk7XG4gICAgICB9XG5cbiAgICAgIC8vIFJlc3RhcnQgdGhpcyB0aW1lciBpZiBvbiBhIFdlYiBBdWRpbyBsb29wLlxuICAgICAgaWYgKHNlbGYuX3dlYkF1ZGlvICYmIGxvb3ApIHtcbiAgICAgICAgc2VsZi5fZW1pdCgncGxheScsIHNvdW5kLl9pZCk7XG4gICAgICAgIHNvdW5kLl9zZWVrID0gc291bmQuX3N0YXJ0IHx8IDA7XG4gICAgICAgIHNvdW5kLl9yYXRlU2VlayA9IDA7XG4gICAgICAgIHNvdW5kLl9wbGF5U3RhcnQgPSBIb3dsZXIuY3R4LmN1cnJlbnRUaW1lO1xuXG4gICAgICAgIHZhciB0aW1lb3V0ID0gKChzb3VuZC5fc3RvcCAtIHNvdW5kLl9zdGFydCkgKiAxMDAwKSAvIE1hdGguYWJzKHNvdW5kLl9yYXRlKTtcbiAgICAgICAgc2VsZi5fZW5kVGltZXJzW3NvdW5kLl9pZF0gPSBzZXRUaW1lb3V0KHNlbGYuX2VuZGVkLmJpbmQoc2VsZiwgc291bmQpLCB0aW1lb3V0KTtcbiAgICAgIH1cblxuICAgICAgLy8gTWFyayB0aGUgbm9kZSBhcyBwYXVzZWQuXG4gICAgICBpZiAoc2VsZi5fd2ViQXVkaW8gJiYgIWxvb3ApIHtcbiAgICAgICAgc291bmQuX3BhdXNlZCA9IHRydWU7XG4gICAgICAgIHNvdW5kLl9lbmRlZCA9IHRydWU7XG4gICAgICAgIHNvdW5kLl9zZWVrID0gc291bmQuX3N0YXJ0IHx8IDA7XG4gICAgICAgIHNvdW5kLl9yYXRlU2VlayA9IDA7XG4gICAgICAgIHNlbGYuX2NsZWFyVGltZXIoc291bmQuX2lkKTtcblxuICAgICAgICAvLyBDbGVhbiB1cCB0aGUgYnVmZmVyIHNvdXJjZS5cbiAgICAgICAgc2VsZi5fY2xlYW5CdWZmZXIoc291bmQuX25vZGUpO1xuXG4gICAgICAgIC8vIEF0dGVtcHQgdG8gYXV0by1zdXNwZW5kIEF1ZGlvQ29udGV4dCBpZiBubyBzb3VuZHMgYXJlIHN0aWxsIHBsYXlpbmcuXG4gICAgICAgIEhvd2xlci5fYXV0b1N1c3BlbmQoKTtcbiAgICAgIH1cblxuICAgICAgLy8gV2hlbiB1c2luZyBhIHNwcml0ZSwgZW5kIHRoZSB0cmFjay5cbiAgICAgIGlmICghc2VsZi5fd2ViQXVkaW8gJiYgIWxvb3ApIHtcbiAgICAgICAgc2VsZi5zdG9wKHNvdW5kLl9pZCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDbGVhciB0aGUgZW5kIHRpbWVyIGZvciBhIHNvdW5kIHBsYXliYWNrLlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gaWQgVGhlIHNvdW5kIElELlxuICAgICAqIEByZXR1cm4ge0hvd2x9XG4gICAgICovXG4gICAgX2NsZWFyVGltZXI6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgIGlmIChzZWxmLl9lbmRUaW1lcnNbaWRdKSB7XG4gICAgICAgIGNsZWFyVGltZW91dChzZWxmLl9lbmRUaW1lcnNbaWRdKTtcbiAgICAgICAgZGVsZXRlIHNlbGYuX2VuZFRpbWVyc1tpZF07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIHNvdW5kIGlkZW50aWZpZWQgYnkgdGhpcyBJRCwgb3IgcmV0dXJuIG51bGwuXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBpZCBTb3VuZCBJRFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gICAgU291bmQgb2JqZWN0IG9yIG51bGwuXG4gICAgICovXG4gICAgX3NvdW5kQnlJZDogZnVuY3Rpb24oaWQpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgLy8gTG9vcCB0aHJvdWdoIGFsbCBzb3VuZHMgYW5kIGZpbmQgdGhlIG9uZSB3aXRoIHRoaXMgSUQuXG4gICAgICBmb3IgKHZhciBpPTA7IGk8c2VsZi5fc291bmRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChpZCA9PT0gc2VsZi5fc291bmRzW2ldLl9pZCkge1xuICAgICAgICAgIHJldHVybiBzZWxmLl9zb3VuZHNbaV07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybiBhbiBpbmFjdGl2ZSBzb3VuZCBmcm9tIHRoZSBwb29sIG9yIGNyZWF0ZSBhIG5ldyBvbmUuXG4gICAgICogQHJldHVybiB7U291bmR9IFNvdW5kIHBsYXliYWNrIG9iamVjdC5cbiAgICAgKi9cbiAgICBfaW5hY3RpdmVTb3VuZDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgIHNlbGYuX2RyYWluKCk7XG5cbiAgICAgIC8vIEZpbmQgdGhlIGZpcnN0IGluYWN0aXZlIG5vZGUgdG8gcmVjeWNsZS5cbiAgICAgIGZvciAodmFyIGk9MDsgaTxzZWxmLl9zb3VuZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHNlbGYuX3NvdW5kc1tpXS5fZW5kZWQpIHtcbiAgICAgICAgICByZXR1cm4gc2VsZi5fc291bmRzW2ldLnJlc2V0KCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gSWYgbm8gaW5hY3RpdmUgbm9kZSB3YXMgZm91bmQsIGNyZWF0ZSBhIG5ldyBvbmUuXG4gICAgICByZXR1cm4gbmV3IFNvdW5kKHNlbGYpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEcmFpbiBleGNlc3MgaW5hY3RpdmUgc291bmRzIGZyb20gdGhlIHBvb2wuXG4gICAgICovXG4gICAgX2RyYWluOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBsaW1pdCA9IHNlbGYuX3Bvb2w7XG4gICAgICB2YXIgY250ID0gMDtcbiAgICAgIHZhciBpID0gMDtcblxuICAgICAgLy8gSWYgdGhlcmUgYXJlIGxlc3Mgc291bmRzIHRoYW4gdGhlIG1heCBwb29sIHNpemUsIHdlIGFyZSBkb25lLlxuICAgICAgaWYgKHNlbGYuX3NvdW5kcy5sZW5ndGggPCBsaW1pdCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIENvdW50IHRoZSBudW1iZXIgb2YgaW5hY3RpdmUgc291bmRzLlxuICAgICAgZm9yIChpPTA7IGk8c2VsZi5fc291bmRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChzZWxmLl9zb3VuZHNbaV0uX2VuZGVkKSB7XG4gICAgICAgICAgY250Kys7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gUmVtb3ZlIGV4Y2VzcyBpbmFjdGl2ZSBzb3VuZHMsIGdvaW5nIGluIHJldmVyc2Ugb3JkZXIuXG4gICAgICBmb3IgKGk9c2VsZi5fc291bmRzLmxlbmd0aCAtIDE7IGk+PTA7IGktLSkge1xuICAgICAgICBpZiAoY250IDw9IGxpbWl0KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNlbGYuX3NvdW5kc1tpXS5fZW5kZWQpIHtcbiAgICAgICAgICAvLyBEaXNjb25uZWN0IHRoZSBhdWRpbyBzb3VyY2Ugd2hlbiB1c2luZyBXZWIgQXVkaW8uXG4gICAgICAgICAgaWYgKHNlbGYuX3dlYkF1ZGlvICYmIHNlbGYuX3NvdW5kc1tpXS5fbm9kZSkge1xuICAgICAgICAgICAgc2VsZi5fc291bmRzW2ldLl9ub2RlLmRpc2Nvbm5lY3QoMCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gUmVtb3ZlIHNvdW5kcyB1bnRpbCB3ZSBoYXZlIHRoZSBwb29sIHNpemUuXG4gICAgICAgICAgc2VsZi5fc291bmRzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICBjbnQtLTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgYWxsIElEJ3MgZnJvbSB0aGUgc291bmRzIHBvb2wuXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBpZCBPbmx5IHJldHVybiBvbmUgSUQgaWYgb25lIGlzIHBhc3NlZC5cbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gICAgQXJyYXkgb2YgSURzLlxuICAgICAqL1xuICAgIF9nZXRTb3VuZElkczogZnVuY3Rpb24oaWQpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgaWYgKHR5cGVvZiBpZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdmFyIGlkcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpPTA7IGk8c2VsZi5fc291bmRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWRzLnB1c2goc2VsZi5fc291bmRzW2ldLl9pZCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaWRzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFtpZF07XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIExvYWQgdGhlIHNvdW5kIGJhY2sgaW50byB0aGUgYnVmZmVyIHNvdXJjZS5cbiAgICAgKiBAcGFyYW0gIHtTb3VuZH0gc291bmQgVGhlIHNvdW5kIG9iamVjdCB0byB3b3JrIHdpdGguXG4gICAgICogQHJldHVybiB7SG93bH1cbiAgICAgKi9cbiAgICBfcmVmcmVzaEJ1ZmZlcjogZnVuY3Rpb24oc291bmQpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgLy8gU2V0dXAgdGhlIGJ1ZmZlciBzb3VyY2UgZm9yIHBsYXliYWNrLlxuICAgICAgc291bmQuX25vZGUuYnVmZmVyU291cmNlID0gSG93bGVyLmN0eC5jcmVhdGVCdWZmZXJTb3VyY2UoKTtcbiAgICAgIHNvdW5kLl9ub2RlLmJ1ZmZlclNvdXJjZS5idWZmZXIgPSBjYWNoZVtzZWxmLl9zcmNdO1xuXG4gICAgICAvLyBDb25uZWN0IHRvIHRoZSBjb3JyZWN0IG5vZGUuXG4gICAgICBpZiAoc291bmQuX3Bhbm5lcikge1xuICAgICAgICBzb3VuZC5fbm9kZS5idWZmZXJTb3VyY2UuY29ubmVjdChzb3VuZC5fcGFubmVyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNvdW5kLl9ub2RlLmJ1ZmZlclNvdXJjZS5jb25uZWN0KHNvdW5kLl9ub2RlKTtcbiAgICAgIH1cblxuICAgICAgLy8gU2V0dXAgbG9vcGluZyBhbmQgcGxheWJhY2sgcmF0ZS5cbiAgICAgIHNvdW5kLl9ub2RlLmJ1ZmZlclNvdXJjZS5sb29wID0gc291bmQuX2xvb3A7XG4gICAgICBpZiAoc291bmQuX2xvb3ApIHtcbiAgICAgICAgc291bmQuX25vZGUuYnVmZmVyU291cmNlLmxvb3BTdGFydCA9IHNvdW5kLl9zdGFydCB8fCAwO1xuICAgICAgICBzb3VuZC5fbm9kZS5idWZmZXJTb3VyY2UubG9vcEVuZCA9IHNvdW5kLl9zdG9wO1xuICAgICAgfVxuICAgICAgc291bmQuX25vZGUuYnVmZmVyU291cmNlLnBsYXliYWNrUmF0ZS52YWx1ZSA9IHNvdW5kLl9yYXRlO1xuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUHJldmVudCBtZW1vcnkgbGVha3MgYnkgY2xlYW5pbmcgdXAgdGhlIGJ1ZmZlciBzb3VyY2UgYWZ0ZXIgcGxheWJhY2suXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBub2RlIFNvdW5kJ3MgYXVkaW8gbm9kZSBjb250YWluaW5nIHRoZSBidWZmZXIgc291cmNlLlxuICAgICAqIEByZXR1cm4ge0hvd2x9XG4gICAgICovXG4gICAgX2NsZWFuQnVmZmVyOiBmdW5jdGlvbihub2RlKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgIGlmIChzZWxmLl9zY3JhdGNoQnVmZmVyKSB7XG4gICAgICAgIG5vZGUuYnVmZmVyU291cmNlLm9uZW5kZWQgPSBudWxsO1xuICAgICAgICBub2RlLmJ1ZmZlclNvdXJjZS5kaXNjb25uZWN0KDApO1xuICAgICAgICB0cnkgeyBub2RlLmJ1ZmZlclNvdXJjZS5idWZmZXIgPSBzZWxmLl9zY3JhdGNoQnVmZmVyOyB9IGNhdGNoKGUpIHt9XG4gICAgICB9XG4gICAgICBub2RlLmJ1ZmZlclNvdXJjZSA9IG51bGw7XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cbiAgfTtcblxuICAvKiogU2luZ2xlIFNvdW5kIE1ldGhvZHMgKiovXG4gIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgLyoqXG4gICAqIFNldHVwIHRoZSBzb3VuZCBvYmplY3QsIHdoaWNoIGVhY2ggbm9kZSBhdHRhY2hlZCB0byBhIEhvd2wgZ3JvdXAgaXMgY29udGFpbmVkIGluLlxuICAgKiBAcGFyYW0ge09iamVjdH0gaG93bCBUaGUgSG93bCBwYXJlbnQgZ3JvdXAuXG4gICAqL1xuICB2YXIgU291bmQgPSBmdW5jdGlvbihob3dsKSB7XG4gICAgdGhpcy5fcGFyZW50ID0gaG93bDtcbiAgICB0aGlzLmluaXQoKTtcbiAgfTtcbiAgU291bmQucHJvdG90eXBlID0ge1xuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemUgYSBuZXcgU291bmQgb2JqZWN0LlxuICAgICAqIEByZXR1cm4ge1NvdW5kfVxuICAgICAqL1xuICAgIGluaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIHBhcmVudCA9IHNlbGYuX3BhcmVudDtcblxuICAgICAgLy8gU2V0dXAgdGhlIGRlZmF1bHQgcGFyYW1ldGVycy5cbiAgICAgIHNlbGYuX211dGVkID0gcGFyZW50Ll9tdXRlZDtcbiAgICAgIHNlbGYuX2xvb3AgPSBwYXJlbnQuX2xvb3A7XG4gICAgICBzZWxmLl92b2x1bWUgPSBwYXJlbnQuX3ZvbHVtZTtcbiAgICAgIHNlbGYuX211dGVkID0gcGFyZW50Ll9tdXRlZDtcbiAgICAgIHNlbGYuX3JhdGUgPSBwYXJlbnQuX3JhdGU7XG4gICAgICBzZWxmLl9zZWVrID0gMDtcbiAgICAgIHNlbGYuX3BhdXNlZCA9IHRydWU7XG4gICAgICBzZWxmLl9lbmRlZCA9IHRydWU7XG4gICAgICBzZWxmLl9zcHJpdGUgPSAnX19kZWZhdWx0JztcblxuICAgICAgLy8gR2VuZXJhdGUgYSB1bmlxdWUgSUQgZm9yIHRoaXMgc291bmQuXG4gICAgICBzZWxmLl9pZCA9IE1hdGgucm91bmQoRGF0ZS5ub3coKSAqIE1hdGgucmFuZG9tKCkpO1xuXG4gICAgICAvLyBBZGQgaXRzZWxmIHRvIHRoZSBwYXJlbnQncyBwb29sLlxuICAgICAgcGFyZW50Ll9zb3VuZHMucHVzaChzZWxmKTtcblxuICAgICAgLy8gQ3JlYXRlIHRoZSBuZXcgbm9kZS5cbiAgICAgIHNlbGYuY3JlYXRlKCk7XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYW5kIHNldHVwIGEgbmV3IHNvdW5kIG9iamVjdCwgd2hldGhlciBIVE1MNSBBdWRpbyBvciBXZWIgQXVkaW8uXG4gICAgICogQHJldHVybiB7U291bmR9XG4gICAgICovXG4gICAgY3JlYXRlOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBwYXJlbnQgPSBzZWxmLl9wYXJlbnQ7XG4gICAgICB2YXIgdm9sdW1lID0gKEhvd2xlci5fbXV0ZWQgfHwgc2VsZi5fbXV0ZWQgfHwgc2VsZi5fcGFyZW50Ll9tdXRlZCkgPyAwIDogc2VsZi5fdm9sdW1lO1xuXG4gICAgICBpZiAocGFyZW50Ll93ZWJBdWRpbykge1xuICAgICAgICAvLyBDcmVhdGUgdGhlIGdhaW4gbm9kZSBmb3IgY29udHJvbGxpbmcgdm9sdW1lICh0aGUgc291cmNlIHdpbGwgY29ubmVjdCB0byB0aGlzKS5cbiAgICAgICAgc2VsZi5fbm9kZSA9ICh0eXBlb2YgSG93bGVyLmN0eC5jcmVhdGVHYWluID09PSAndW5kZWZpbmVkJykgPyBIb3dsZXIuY3R4LmNyZWF0ZUdhaW5Ob2RlKCkgOiBIb3dsZXIuY3R4LmNyZWF0ZUdhaW4oKTtcbiAgICAgICAgc2VsZi5fbm9kZS5nYWluLnNldFZhbHVlQXRUaW1lKHZvbHVtZSwgSG93bGVyLmN0eC5jdXJyZW50VGltZSk7XG4gICAgICAgIHNlbGYuX25vZGUucGF1c2VkID0gdHJ1ZTtcbiAgICAgICAgc2VsZi5fbm9kZS5jb25uZWN0KEhvd2xlci5tYXN0ZXJHYWluKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbGYuX25vZGUgPSBuZXcgQXVkaW8oKTtcblxuICAgICAgICAvLyBMaXN0ZW4gZm9yIGVycm9ycyAoaHR0cDovL2Rldi53My5vcmcvaHRtbDUvc3BlYy1hdXRob3Itdmlldy9zcGVjLmh0bWwjbWVkaWFlcnJvcikuXG4gICAgICAgIHNlbGYuX2Vycm9yRm4gPSBzZWxmLl9lcnJvckxpc3RlbmVyLmJpbmQoc2VsZik7XG4gICAgICAgIHNlbGYuX25vZGUuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBzZWxmLl9lcnJvckZuLCBmYWxzZSk7XG5cbiAgICAgICAgLy8gTGlzdGVuIGZvciAnY2FucGxheXRocm91Z2gnIGV2ZW50IHRvIGxldCB1cyBrbm93IHRoZSBzb3VuZCBpcyByZWFkeS5cbiAgICAgICAgc2VsZi5fbG9hZEZuID0gc2VsZi5fbG9hZExpc3RlbmVyLmJpbmQoc2VsZik7XG4gICAgICAgIHNlbGYuX25vZGUuYWRkRXZlbnRMaXN0ZW5lcihIb3dsZXIuX2NhblBsYXlFdmVudCwgc2VsZi5fbG9hZEZuLCBmYWxzZSk7XG5cbiAgICAgICAgLy8gU2V0dXAgdGhlIG5ldyBhdWRpbyBub2RlLlxuICAgICAgICBzZWxmLl9ub2RlLnNyYyA9IHBhcmVudC5fc3JjO1xuICAgICAgICBzZWxmLl9ub2RlLnByZWxvYWQgPSAnYXV0byc7XG4gICAgICAgIHNlbGYuX25vZGUudm9sdW1lID0gdm9sdW1lICogSG93bGVyLnZvbHVtZSgpO1xuXG4gICAgICAgIC8vIEJlZ2luIGxvYWRpbmcgdGhlIHNvdXJjZS5cbiAgICAgICAgc2VsZi5fbm9kZS5sb2FkKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXNldCB0aGUgcGFyYW1ldGVycyBvZiB0aGlzIHNvdW5kIHRvIHRoZSBvcmlnaW5hbCBzdGF0ZSAoZm9yIHJlY3ljbGUpLlxuICAgICAqIEByZXR1cm4ge1NvdW5kfVxuICAgICAqL1xuICAgIHJlc2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBwYXJlbnQgPSBzZWxmLl9wYXJlbnQ7XG5cbiAgICAgIC8vIFJlc2V0IGFsbCBvZiB0aGUgcGFyYW1ldGVycyBvZiB0aGlzIHNvdW5kLlxuICAgICAgc2VsZi5fbXV0ZWQgPSBwYXJlbnQuX211dGVkO1xuICAgICAgc2VsZi5fbG9vcCA9IHBhcmVudC5fbG9vcDtcbiAgICAgIHNlbGYuX3ZvbHVtZSA9IHBhcmVudC5fdm9sdW1lO1xuICAgICAgc2VsZi5fbXV0ZWQgPSBwYXJlbnQuX211dGVkO1xuICAgICAgc2VsZi5fcmF0ZSA9IHBhcmVudC5fcmF0ZTtcbiAgICAgIHNlbGYuX3NlZWsgPSAwO1xuICAgICAgc2VsZi5fcmF0ZVNlZWsgPSAwO1xuICAgICAgc2VsZi5fcGF1c2VkID0gdHJ1ZTtcbiAgICAgIHNlbGYuX2VuZGVkID0gdHJ1ZTtcbiAgICAgIHNlbGYuX3Nwcml0ZSA9ICdfX2RlZmF1bHQnO1xuXG4gICAgICAvLyBHZW5lcmF0ZSBhIG5ldyBJRCBzbyB0aGF0IGl0IGlzbid0IGNvbmZ1c2VkIHdpdGggdGhlIHByZXZpb3VzIHNvdW5kLlxuICAgICAgc2VsZi5faWQgPSBNYXRoLnJvdW5kKERhdGUubm93KCkgKiBNYXRoLnJhbmRvbSgpKTtcblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEhUTUw1IEF1ZGlvIGVycm9yIGxpc3RlbmVyIGNhbGxiYWNrLlxuICAgICAqL1xuICAgIF9lcnJvckxpc3RlbmVyOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgaWYgKHNlbGYuX25vZGUuZXJyb3IgJiYgc2VsZi5fbm9kZS5lcnJvci5jb2RlID09PSA0KSB7XG4gICAgICAgIEhvd2xlci5ub0F1ZGlvID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gRmlyZSBhbiBlcnJvciBldmVudCBhbmQgcGFzcyBiYWNrIHRoZSBjb2RlLlxuICAgICAgc2VsZi5fcGFyZW50Ll9lbWl0KCdsb2FkZXJyb3InLCBzZWxmLl9pZCwgc2VsZi5fbm9kZS5lcnJvciA/IHNlbGYuX25vZGUuZXJyb3IuY29kZSA6IDApO1xuXG4gICAgICAvLyBDbGVhciB0aGUgZXZlbnQgbGlzdGVuZXIuXG4gICAgICBzZWxmLl9ub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgc2VsZi5fZXJyb3JMaXN0ZW5lciwgZmFsc2UpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBIVE1MNSBBdWRpbyBjYW5wbGF5dGhyb3VnaCBsaXN0ZW5lciBjYWxsYmFjay5cbiAgICAgKi9cbiAgICBfbG9hZExpc3RlbmVyOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBwYXJlbnQgPSBzZWxmLl9wYXJlbnQ7XG5cbiAgICAgIC8vIFJvdW5kIHVwIHRoZSBkdXJhdGlvbiB0byBhY2NvdW50IGZvciB0aGUgbG93ZXIgcHJlY2lzaW9uIGluIEhUTUw1IEF1ZGlvLlxuICAgICAgcGFyZW50Ll9kdXJhdGlvbiA9IE1hdGguY2VpbChzZWxmLl9ub2RlLmR1cmF0aW9uICogMTApIC8gMTA7XG5cbiAgICAgIC8vIFNldHVwIGEgc3ByaXRlIGlmIG5vbmUgaXMgZGVmaW5lZC5cbiAgICAgIGlmIChPYmplY3Qua2V5cyhwYXJlbnQuX3Nwcml0ZSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHBhcmVudC5fc3ByaXRlID0ge19fZGVmYXVsdDogWzAsIHBhcmVudC5fZHVyYXRpb24gKiAxMDAwXX07XG4gICAgICB9XG5cbiAgICAgIGlmIChwYXJlbnQuX3N0YXRlICE9PSAnbG9hZGVkJykge1xuICAgICAgICBwYXJlbnQuX3N0YXRlID0gJ2xvYWRlZCc7XG4gICAgICAgIHBhcmVudC5fZW1pdCgnbG9hZCcpO1xuICAgICAgICBwYXJlbnQuX2xvYWRRdWV1ZSgpO1xuICAgICAgfVxuXG4gICAgICBpZiAocGFyZW50Ll9hdXRvcGxheSkge1xuICAgICAgICBwYXJlbnQucGxheSgpO1xuICAgICAgfVxuXG4gICAgICAvLyBDbGVhciB0aGUgZXZlbnQgbGlzdGVuZXIuXG4gICAgICBzZWxmLl9ub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoSG93bGVyLl9jYW5QbGF5RXZlbnQsIHNlbGYuX2xvYWRGbiwgZmFsc2UpO1xuICAgIH1cbiAgfTtcblxuICAvKiogSGVscGVyIE1ldGhvZHMgKiovXG4gIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgdmFyIGNhY2hlID0ge307XG5cbiAgLyoqXG4gICAqIEJ1ZmZlciBhIHNvdW5kIGZyb20gVVJMLCBEYXRhIFVSSSBvciBjYWNoZSBhbmQgZGVjb2RlIHRvIGF1ZGlvIHNvdXJjZSAoV2ViIEF1ZGlvIEFQSSkuXG4gICAqIEBwYXJhbSAge0hvd2x9IHNlbGZcbiAgICovXG4gIHZhciBsb2FkQnVmZmVyID0gZnVuY3Rpb24oc2VsZikge1xuICAgIHZhciB1cmwgPSBzZWxmLl9zcmM7XG5cbiAgICAvLyBDaGVjayBpZiB0aGUgYnVmZmVyIGhhcyBhbHJlYWR5IGJlZW4gY2FjaGVkIGFuZCB1c2UgaXQgaW5zdGVhZC5cbiAgICBpZiAoY2FjaGVbdXJsXSkge1xuICAgICAgLy8gU2V0IHRoZSBkdXJhdGlvbiBmcm9tIHRoZSBjYWNoZS5cbiAgICAgIHNlbGYuX2R1cmF0aW9uID0gY2FjaGVbdXJsXS5kdXJhdGlvbjtcblxuICAgICAgLy8gTG9hZCB0aGUgc291bmQgaW50byB0aGlzIEhvd2wuXG4gICAgICBsb2FkU291bmQoc2VsZik7XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoL15kYXRhOlteO10rO2Jhc2U2NCwvLnRlc3QodXJsKSkge1xuICAgICAgLy8gRGVjb2RlIHRoZSBiYXNlNjQgZGF0YSBVUkkgd2l0aG91dCBYSFIsIHNpbmNlIHNvbWUgYnJvd3NlcnMgZG9uJ3Qgc3VwcG9ydCBpdC5cbiAgICAgIHZhciBkYXRhID0gYXRvYih1cmwuc3BsaXQoJywnKVsxXSk7XG4gICAgICB2YXIgZGF0YVZpZXcgPSBuZXcgVWludDhBcnJheShkYXRhLmxlbmd0aCk7XG4gICAgICBmb3IgKHZhciBpPTA7IGk8ZGF0YS5sZW5ndGg7ICsraSkge1xuICAgICAgICBkYXRhVmlld1tpXSA9IGRhdGEuY2hhckNvZGVBdChpKTtcbiAgICAgIH1cblxuICAgICAgZGVjb2RlQXVkaW9EYXRhKGRhdGFWaWV3LmJ1ZmZlciwgc2VsZik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIExvYWQgdGhlIGJ1ZmZlciBmcm9tIHRoZSBVUkwuXG4gICAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICB4aHIub3BlbignR0VUJywgdXJsLCB0cnVlKTtcbiAgICAgIHhoci5yZXNwb25zZVR5cGUgPSAnYXJyYXlidWZmZXInO1xuICAgICAgeGhyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBNYWtlIHN1cmUgd2UgZ2V0IGEgc3VjY2Vzc2Z1bCByZXNwb25zZSBiYWNrLlxuICAgICAgICB2YXIgY29kZSA9ICh4aHIuc3RhdHVzICsgJycpWzBdO1xuICAgICAgICBpZiAoY29kZSAhPT0gJzAnICYmIGNvZGUgIT09ICcyJyAmJiBjb2RlICE9PSAnMycpIHtcbiAgICAgICAgICBzZWxmLl9lbWl0KCdsb2FkZXJyb3InLCBudWxsLCAnRmFpbGVkIGxvYWRpbmcgYXVkaW8gZmlsZSB3aXRoIHN0YXR1czogJyArIHhoci5zdGF0dXMgKyAnLicpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlY29kZUF1ZGlvRGF0YSh4aHIucmVzcG9uc2UsIHNlbGYpO1xuICAgICAgfTtcbiAgICAgIHhoci5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIElmIHRoZXJlIGlzIGFuIGVycm9yLCBzd2l0Y2ggdG8gSFRNTDUgQXVkaW8uXG4gICAgICAgIGlmIChzZWxmLl93ZWJBdWRpbykge1xuICAgICAgICAgIHNlbGYuX2h0bWw1ID0gdHJ1ZTtcbiAgICAgICAgICBzZWxmLl93ZWJBdWRpbyA9IGZhbHNlO1xuICAgICAgICAgIHNlbGYuX3NvdW5kcyA9IFtdO1xuICAgICAgICAgIGRlbGV0ZSBjYWNoZVt1cmxdO1xuICAgICAgICAgIHNlbGYubG9hZCgpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgc2FmZVhoclNlbmQoeGhyKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFNlbmQgdGhlIFhIUiByZXF1ZXN0IHdyYXBwZWQgaW4gYSB0cnkvY2F0Y2guXG4gICAqIEBwYXJhbSAge09iamVjdH0geGhyIFhIUiB0byBzZW5kLlxuICAgKi9cbiAgdmFyIHNhZmVYaHJTZW5kID0gZnVuY3Rpb24oeGhyKSB7XG4gICAgdHJ5IHtcbiAgICAgIHhoci5zZW5kKCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgeGhyLm9uZXJyb3IoKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIERlY29kZSBhdWRpbyBkYXRhIGZyb20gYW4gYXJyYXkgYnVmZmVyLlxuICAgKiBAcGFyYW0gIHtBcnJheUJ1ZmZlcn0gYXJyYXlidWZmZXIgVGhlIGF1ZGlvIGRhdGEuXG4gICAqIEBwYXJhbSAge0hvd2x9ICAgICAgICBzZWxmXG4gICAqL1xuICB2YXIgZGVjb2RlQXVkaW9EYXRhID0gZnVuY3Rpb24oYXJyYXlidWZmZXIsIHNlbGYpIHtcbiAgICAvLyBEZWNvZGUgdGhlIGJ1ZmZlciBpbnRvIGFuIGF1ZGlvIHNvdXJjZS5cbiAgICBIb3dsZXIuY3R4LmRlY29kZUF1ZGlvRGF0YShhcnJheWJ1ZmZlciwgZnVuY3Rpb24oYnVmZmVyKSB7XG4gICAgICBpZiAoYnVmZmVyICYmIHNlbGYuX3NvdW5kcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNhY2hlW3NlbGYuX3NyY10gPSBidWZmZXI7XG4gICAgICAgIGxvYWRTb3VuZChzZWxmLCBidWZmZXIpO1xuICAgICAgfVxuICAgIH0sIGZ1bmN0aW9uKCkge1xuICAgICAgc2VsZi5fZW1pdCgnbG9hZGVycm9yJywgbnVsbCwgJ0RlY29kaW5nIGF1ZGlvIGRhdGEgZmFpbGVkLicpO1xuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTb3VuZCBpcyBub3cgbG9hZGVkLCBzbyBmaW5pc2ggc2V0dGluZyBldmVyeXRoaW5nIHVwIGFuZCBmaXJlIHRoZSBsb2FkZWQgZXZlbnQuXG4gICAqIEBwYXJhbSAge0hvd2x9IHNlbGZcbiAgICogQHBhcmFtICB7T2JqZWN0fSBidWZmZXIgVGhlIGRlY29kZWQgYnVmZmVyIHNvdW5kIHNvdXJjZS5cbiAgICovXG4gIHZhciBsb2FkU291bmQgPSBmdW5jdGlvbihzZWxmLCBidWZmZXIpIHtcbiAgICAvLyBTZXQgdGhlIGR1cmF0aW9uLlxuICAgIGlmIChidWZmZXIgJiYgIXNlbGYuX2R1cmF0aW9uKSB7XG4gICAgICBzZWxmLl9kdXJhdGlvbiA9IGJ1ZmZlci5kdXJhdGlvbjtcbiAgICB9XG5cbiAgICAvLyBTZXR1cCBhIHNwcml0ZSBpZiBub25lIGlzIGRlZmluZWQuXG4gICAgaWYgKE9iamVjdC5rZXlzKHNlbGYuX3Nwcml0ZSkubGVuZ3RoID09PSAwKSB7XG4gICAgICBzZWxmLl9zcHJpdGUgPSB7X19kZWZhdWx0OiBbMCwgc2VsZi5fZHVyYXRpb24gKiAxMDAwXX07XG4gICAgfVxuXG4gICAgLy8gRmlyZSB0aGUgbG9hZGVkIGV2ZW50LlxuICAgIGlmIChzZWxmLl9zdGF0ZSAhPT0gJ2xvYWRlZCcpIHtcbiAgICAgIHNlbGYuX3N0YXRlID0gJ2xvYWRlZCc7XG4gICAgICBzZWxmLl9lbWl0KCdsb2FkJyk7XG4gICAgICBzZWxmLl9sb2FkUXVldWUoKTtcbiAgICB9XG5cbiAgICAvLyBCZWdpbiBwbGF5YmFjayBpZiBzcGVjaWZpZWQuXG4gICAgaWYgKHNlbGYuX2F1dG9wbGF5KSB7XG4gICAgICBzZWxmLnBsYXkoKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldHVwIHRoZSBhdWRpbyBjb250ZXh0IHdoZW4gYXZhaWxhYmxlLCBvciBzd2l0Y2ggdG8gSFRNTDUgQXVkaW8gbW9kZS5cbiAgICovXG4gIHZhciBzZXR1cEF1ZGlvQ29udGV4dCA9IGZ1bmN0aW9uKCkge1xuICAgIEhvd2xlci5ub0F1ZGlvID0gZmFsc2U7XG5cbiAgICAvLyBDaGVjayBpZiB3ZSBhcmUgdXNpbmcgV2ViIEF1ZGlvIGFuZCBzZXR1cCB0aGUgQXVkaW9Db250ZXh0IGlmIHdlIGFyZS5cbiAgICB0cnkge1xuICAgICAgaWYgKHR5cGVvZiBBdWRpb0NvbnRleHQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIEhvd2xlci5jdHggPSBuZXcgQXVkaW9Db250ZXh0KCk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB3ZWJraXRBdWRpb0NvbnRleHQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIEhvd2xlci5jdHggPSBuZXcgd2Via2l0QXVkaW9Db250ZXh0KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBIb3dsZXIudXNpbmdXZWJBdWRpbyA9IGZhbHNlO1xuICAgICAgfVxuICAgIH0gY2F0Y2goZSkge1xuICAgICAgSG93bGVyLnVzaW5nV2ViQXVkaW8gPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoIUhvd2xlci51c2luZ1dlYkF1ZGlvKSB7XG4gICAgICAvLyBObyBhdWRpbyBpcyBhdmFpbGFibGUgb24gdGhpcyBzeXN0ZW0gaWYgbm9BdWRpbyBpcyBzZXQgdG8gdHJ1ZS5cbiAgICAgIGlmICh0eXBlb2YgQXVkaW8gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdmFyIHRlc3QgPSBuZXcgQXVkaW8oKTtcblxuICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSBjYW5wbGF5dGhyb3VnaCBldmVudCBpcyBhdmFpbGFibGUuXG4gICAgICAgICAgaWYgKHR5cGVvZiB0ZXN0Lm9uY2FucGxheXRocm91Z2ggPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBIb3dsZXIuX2NhblBsYXlFdmVudCA9ICdjYW5wbGF5JztcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgIEhvd2xlci5ub0F1ZGlvID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgSG93bGVyLm5vQXVkaW8gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRlc3QgdG8gbWFrZSBzdXJlIGF1ZGlvIGlzbid0IGRpc2FibGVkIGluIEludGVybmV0IEV4cGxvcmVyXG4gICAgdHJ5IHtcbiAgICAgIHZhciB0ZXN0ID0gbmV3IEF1ZGlvKCk7XG4gICAgICBpZiAodGVzdC5tdXRlZCkge1xuICAgICAgICBIb3dsZXIubm9BdWRpbyA9IHRydWU7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge31cblxuICAgIC8vIENoZWNrIGlmIGEgd2VidmlldyBpcyBiZWluZyB1c2VkIG9uIGlPUzggb3IgZWFybGllciAocmF0aGVyIHRoYW4gdGhlIGJyb3dzZXIpLlxuICAgIC8vIElmIGl0IGlzLCBkaXNhYmxlIFdlYiBBdWRpbyBhcyBpdCBjYXVzZXMgY3Jhc2hpbmcuXG4gICAgdmFyIGlPUyA9ICgvaVAoaG9uZXxvZHxhZCkvLnRlc3QoSG93bGVyLl9uYXZpZ2F0b3IgJiYgSG93bGVyLl9uYXZpZ2F0b3IucGxhdGZvcm0pKTtcbiAgICB2YXIgYXBwVmVyc2lvbiA9IEhvd2xlci5fbmF2aWdhdG9yICYmIEhvd2xlci5fbmF2aWdhdG9yLmFwcFZlcnNpb24ubWF0Y2goL09TIChcXGQrKV8oXFxkKylfPyhcXGQrKT8vKTtcbiAgICB2YXIgdmVyc2lvbiA9IGFwcFZlcnNpb24gPyBwYXJzZUludChhcHBWZXJzaW9uWzFdLCAxMCkgOiBudWxsO1xuICAgIGlmIChpT1MgJiYgdmVyc2lvbiAmJiB2ZXJzaW9uIDwgOSkge1xuICAgICAgdmFyIHNhZmFyaSA9IC9zYWZhcmkvLnRlc3QoSG93bGVyLl9uYXZpZ2F0b3IgJiYgSG93bGVyLl9uYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkpO1xuICAgICAgaWYgKEhvd2xlci5fbmF2aWdhdG9yICYmIEhvd2xlci5fbmF2aWdhdG9yLnN0YW5kYWxvbmUgJiYgIXNhZmFyaSB8fCBIb3dsZXIuX25hdmlnYXRvciAmJiAhSG93bGVyLl9uYXZpZ2F0b3Iuc3RhbmRhbG9uZSAmJiAhc2FmYXJpKSB7XG4gICAgICAgIEhvd2xlci51c2luZ1dlYkF1ZGlvID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ3JlYXRlIGFuZCBleHBvc2UgdGhlIG1hc3RlciBHYWluTm9kZSB3aGVuIHVzaW5nIFdlYiBBdWRpbyAodXNlZnVsIGZvciBwbHVnaW5zIG9yIGFkdmFuY2VkIHVzYWdlKS5cbiAgICBpZiAoSG93bGVyLnVzaW5nV2ViQXVkaW8pIHtcbiAgICAgIEhvd2xlci5tYXN0ZXJHYWluID0gKHR5cGVvZiBIb3dsZXIuY3R4LmNyZWF0ZUdhaW4gPT09ICd1bmRlZmluZWQnKSA/IEhvd2xlci5jdHguY3JlYXRlR2Fpbk5vZGUoKSA6IEhvd2xlci5jdHguY3JlYXRlR2FpbigpO1xuICAgICAgSG93bGVyLm1hc3RlckdhaW4uZ2Fpbi52YWx1ZSA9IDE7XG4gICAgICBIb3dsZXIubWFzdGVyR2Fpbi5jb25uZWN0KEhvd2xlci5jdHguZGVzdGluYXRpb24pO1xuICAgIH1cblxuICAgIC8vIFJlLXJ1biB0aGUgc2V0dXAgb24gSG93bGVyLlxuICAgIEhvd2xlci5fc2V0dXAoKTtcbiAgfTtcblxuICAvLyBBZGQgc3VwcG9ydCBmb3IgQU1EIChBc3luY2hyb25vdXMgTW9kdWxlIERlZmluaXRpb24pIGxpYnJhcmllcyBzdWNoIGFzIHJlcXVpcmUuanMuXG4gIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICBkZWZpbmUoW10sIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgSG93bGVyOiBIb3dsZXIsXG4gICAgICAgIEhvd2w6IEhvd2xcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cblxuICAvLyBBZGQgc3VwcG9ydCBmb3IgQ29tbW9uSlMgbGlicmFyaWVzIHN1Y2ggYXMgYnJvd3NlcmlmeS5cbiAgaWYgKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJykge1xuICAgIGV4cG9ydHMuSG93bGVyID0gSG93bGVyO1xuICAgIGV4cG9ydHMuSG93bCA9IEhvd2w7XG4gIH1cblxuICAvLyBEZWZpbmUgZ2xvYmFsbHkgaW4gY2FzZSBBTUQgaXMgbm90IGF2YWlsYWJsZSBvciB1bnVzZWQuXG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgIHdpbmRvdy5Ib3dsZXJHbG9iYWwgPSBIb3dsZXJHbG9iYWw7XG4gICAgd2luZG93Lkhvd2xlciA9IEhvd2xlcjtcbiAgICB3aW5kb3cuSG93bCA9IEhvd2w7XG4gICAgd2luZG93LlNvdW5kID0gU291bmQ7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIHsgLy8gQWRkIHRvIGdsb2JhbCBpbiBOb2RlLmpzIChmb3IgdGVzdGluZywgZXRjKS5cbiAgICBnbG9iYWwuSG93bGVyR2xvYmFsID0gSG93bGVyR2xvYmFsO1xuICAgIGdsb2JhbC5Ib3dsZXIgPSBIb3dsZXI7XG4gICAgZ2xvYmFsLkhvd2wgPSBIb3dsO1xuICAgIGdsb2JhbC5Tb3VuZCA9IFNvdW5kO1xuICB9XG59KSgpO1xuXG5cbi8qIVxuICogIFNwYXRpYWwgUGx1Z2luIC0gQWRkcyBzdXBwb3J0IGZvciBzdGVyZW8gYW5kIDNEIGF1ZGlvIHdoZXJlIFdlYiBBdWRpbyBpcyBzdXBwb3J0ZWQuXG4gKiAgXG4gKiAgaG93bGVyLmpzIHYyLjAuMFxuICogIGhvd2xlcmpzLmNvbVxuICpcbiAqICAoYykgMjAxMy0yMDE2LCBKYW1lcyBTaW1wc29uIG9mIEdvbGRGaXJlIFN0dWRpb3NcbiAqICBnb2xkZmlyZXN0dWRpb3MuY29tXG4gKlxuICogIE1JVCBMaWNlbnNlXG4gKi9cblxuKGZ1bmN0aW9uKCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICAvLyBTZXR1cCBkZWZhdWx0IHByb3BlcnRpZXMuXG4gIEhvd2xlckdsb2JhbC5wcm90b3R5cGUuX3BvcyA9IFswLCAwLCAwXTtcbiAgSG93bGVyR2xvYmFsLnByb3RvdHlwZS5fb3JpZW50YXRpb24gPSBbMCwgMCwgLTEsIDAsIDEsIDBdO1xuICBcbiAgLyoqIEdsb2JhbCBNZXRob2RzICoqL1xuICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gIC8qKlxuICAgKiBIZWxwZXIgbWV0aG9kIHRvIHVwZGF0ZSB0aGUgc3RlcmVvIHBhbm5pbmcgcG9zaXRpb24gb2YgYWxsIGN1cnJlbnQgSG93bHMuXG4gICAqIEZ1dHVyZSBIb3dscyB3aWxsIG5vdCB1c2UgdGhpcyB2YWx1ZSB1bmxlc3MgZXhwbGljaXRlbHkgc2V0LlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHBhbiBBIHZhbHVlIG9mIC0xLjAgaXMgYWxsIHRoZSB3YXkgbGVmdCBhbmQgMS4wIGlzIGFsbCB0aGUgd2F5IHJpZ2h0LlxuICAgKiBAcmV0dXJuIHtIb3dsZXIvTnVtYmVyfSAgICAgU2VsZiBvciBjdXJyZW50IHN0ZXJlbyBwYW5uaW5nIHZhbHVlLlxuICAgKi9cbiAgSG93bGVyR2xvYmFsLnByb3RvdHlwZS5zdGVyZW8gPSBmdW5jdGlvbihwYW4pIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAvLyBTdG9wIHJpZ2h0IGhlcmUgaWYgbm90IHVzaW5nIFdlYiBBdWRpby5cbiAgICBpZiAoIXNlbGYuY3R4IHx8ICFzZWxmLmN0eC5saXN0ZW5lcikge1xuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuXG4gICAgLy8gTG9vcCB0aHJvdWdoIGFsbCBIb3dscyBhbmQgdXBkYXRlIHRoZWlyIHN0ZXJlbyBwYW5uaW5nLlxuICAgIGZvciAodmFyIGk9c2VsZi5faG93bHMubGVuZ3RoLTE7IGk+PTA7IGktLSkge1xuICAgICAgc2VsZi5faG93bHNbaV0uc3RlcmVvKHBhbik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNlbGY7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldC9zZXQgdGhlIHBvc2l0aW9uIG9mIHRoZSBsaXN0ZW5lciBpbiAzRCBjYXJ0ZXNpYW4gc3BhY2UuIFNvdW5kcyB1c2luZ1xuICAgKiAzRCBwb3NpdGlvbiB3aWxsIGJlIHJlbGF0aXZlIHRvIHRoZSBsaXN0ZW5lcidzIHBvc2l0aW9uLlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHggVGhlIHgtcG9zaXRpb24gb2YgdGhlIGxpc3RlbmVyLlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHkgVGhlIHktcG9zaXRpb24gb2YgdGhlIGxpc3RlbmVyLlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHogVGhlIHotcG9zaXRpb24gb2YgdGhlIGxpc3RlbmVyLlxuICAgKiBAcmV0dXJuIHtIb3dsZXIvQXJyYXl9ICAgU2VsZiBvciBjdXJyZW50IGxpc3RlbmVyIHBvc2l0aW9uLlxuICAgKi9cbiAgSG93bGVyR2xvYmFsLnByb3RvdHlwZS5wb3MgPSBmdW5jdGlvbih4LCB5LCB6KSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgLy8gU3RvcCByaWdodCBoZXJlIGlmIG5vdCB1c2luZyBXZWIgQXVkaW8uXG4gICAgaWYgKCFzZWxmLmN0eCB8fCAhc2VsZi5jdHgubGlzdGVuZXIpIHtcbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cblxuICAgIC8vIFNldCB0aGUgZGVmYXVsdHMgZm9yIG9wdGlvbmFsICd5JyAmICd6Jy5cbiAgICB5ID0gKHR5cGVvZiB5ICE9PSAnbnVtYmVyJykgPyBzZWxmLl9wb3NbMV0gOiB5O1xuICAgIHogPSAodHlwZW9mIHogIT09ICdudW1iZXInKSA/IHNlbGYuX3Bvc1syXSA6IHo7XG5cbiAgICBpZiAodHlwZW9mIHggPT09ICdudW1iZXInKSB7XG4gICAgICBzZWxmLl9wb3MgPSBbeCwgeSwgel07XG4gICAgICBzZWxmLmN0eC5saXN0ZW5lci5zZXRQb3NpdGlvbihzZWxmLl9wb3NbMF0sIHNlbGYuX3Bvc1sxXSwgc2VsZi5fcG9zWzJdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHNlbGYuX3BvcztcbiAgICB9XG5cbiAgICByZXR1cm4gc2VsZjtcbiAgfTtcblxuICAvKipcbiAgICogR2V0L3NldCB0aGUgZGlyZWN0aW9uIHRoZSBsaXN0ZW5lciBpcyBwb2ludGluZyBpbiB0aGUgM0QgY2FydGVzaWFuIHNwYWNlLlxuICAgKiBBIGZyb250IGFuZCB1cCB2ZWN0b3IgbXVzdCBiZSBwcm92aWRlZC4gVGhlIGZyb250IGlzIHRoZSBkaXJlY3Rpb24gdGhlXG4gICAqIGZhY2Ugb2YgdGhlIGxpc3RlbmVyIGlzIHBvaW50aW5nLCBhbmQgdXAgaXMgdGhlIGRpcmVjdGlvbiB0aGUgdG9wIG9mIHRoZVxuICAgKiBsaXN0ZW5lciBpcyBwb2ludGluZy4gVGh1cywgdGhlc2UgdmFsdWVzIGFyZSBleHBlY3RlZCB0byBiZSBhdCByaWdodCBhbmdsZXNcbiAgICogZnJvbSBlYWNoIG90aGVyLlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHggICBUaGUgeC1vcmllbnRhdGlvbiBvZiB0aGUgbGlzdGVuZXIuXG4gICAqIEBwYXJhbSAge051bWJlcn0geSAgIFRoZSB5LW9yaWVudGF0aW9uIG9mIHRoZSBsaXN0ZW5lci5cbiAgICogQHBhcmFtICB7TnVtYmVyfSB6ICAgVGhlIHotb3JpZW50YXRpb24gb2YgdGhlIGxpc3RlbmVyLlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHhVcCBUaGUgeC1vcmllbnRhdGlvbiBvZiB0aGUgdG9wIG9mIHRoZSBsaXN0ZW5lci5cbiAgICogQHBhcmFtICB7TnVtYmVyfSB5VXAgVGhlIHktb3JpZW50YXRpb24gb2YgdGhlIHRvcCBvZiB0aGUgbGlzdGVuZXIuXG4gICAqIEBwYXJhbSAge051bWJlcn0gelVwIFRoZSB6LW9yaWVudGF0aW9uIG9mIHRoZSB0b3Agb2YgdGhlIGxpc3RlbmVyLlxuICAgKiBAcmV0dXJuIHtIb3dsZXIvQXJyYXl9ICAgICBSZXR1cm5zIHNlbGYgb3IgdGhlIGN1cnJlbnQgb3JpZW50YXRpb24gdmVjdG9ycy5cbiAgICovXG4gIEhvd2xlckdsb2JhbC5wcm90b3R5cGUub3JpZW50YXRpb24gPSBmdW5jdGlvbih4LCB5LCB6LCB4VXAsIHlVcCwgelVwKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgLy8gU3RvcCByaWdodCBoZXJlIGlmIG5vdCB1c2luZyBXZWIgQXVkaW8uXG4gICAgaWYgKCFzZWxmLmN0eCB8fCAhc2VsZi5jdHgubGlzdGVuZXIpIHtcbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cblxuICAgIC8vIFNldCB0aGUgZGVmYXVsdHMgZm9yIG9wdGlvbmFsICd5JyAmICd6Jy5cbiAgICB2YXIgb3IgPSBzZWxmLl9vcmllbnRhdGlvbjtcbiAgICB5ID0gKHR5cGVvZiB5ICE9PSAnbnVtYmVyJykgPyBvclsxXSA6IHk7XG4gICAgeiA9ICh0eXBlb2YgeiAhPT0gJ251bWJlcicpID8gb3JbMl0gOiB6O1xuICAgIHhVcCA9ICh0eXBlb2YgeFVwICE9PSAnbnVtYmVyJykgPyBvclszXSA6IHhVcDtcbiAgICB5VXAgPSAodHlwZW9mIHlVcCAhPT0gJ251bWJlcicpID8gb3JbNF0gOiB5VXA7XG4gICAgelVwID0gKHR5cGVvZiB6VXAgIT09ICdudW1iZXInKSA/IG9yWzVdIDogelVwO1xuXG4gICAgaWYgKHR5cGVvZiB4ID09PSAnbnVtYmVyJykge1xuICAgICAgc2VsZi5fb3JpZW50YXRpb24gPSBbeCwgeSwgeiwgeFVwLCB5VXAsIHpVcF07XG4gICAgICBzZWxmLmN0eC5saXN0ZW5lci5zZXRPcmllbnRhdGlvbih4LCB5LCB6LCB4VXAsIHlVcCwgelVwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG9yO1xuICAgIH1cblxuICAgIHJldHVybiBzZWxmO1xuICB9O1xuXG4gIC8qKiBHcm91cCBNZXRob2RzICoqL1xuICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gIC8qKlxuICAgKiBBZGQgbmV3IHByb3BlcnRpZXMgdG8gdGhlIGNvcmUgaW5pdC5cbiAgICogQHBhcmFtICB7RnVuY3Rpb259IF9zdXBlciBDb3JlIGluaXQgbWV0aG9kLlxuICAgKiBAcmV0dXJuIHtIb3dsfVxuICAgKi9cbiAgSG93bC5wcm90b3R5cGUuaW5pdCA9IChmdW5jdGlvbihfc3VwZXIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24obykge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAvLyBTZXR1cCB1c2VyLWRlZmluZWQgZGVmYXVsdCBwcm9wZXJ0aWVzLlxuICAgICAgc2VsZi5fb3JpZW50YXRpb24gPSBvLm9yaWVudGF0aW9uIHx8IFsxLCAwLCAwXTtcbiAgICAgIHNlbGYuX3N0ZXJlbyA9IG8uc3RlcmVvIHx8IG51bGw7XG4gICAgICBzZWxmLl9wb3MgPSBvLnBvcyB8fCBudWxsO1xuICAgICAgc2VsZi5fcGFubmVyQXR0ciA9IHtcbiAgICAgICAgY29uZUlubmVyQW5nbGU6IHR5cGVvZiBvLmNvbmVJbm5lckFuZ2xlICE9PSAndW5kZWZpbmVkJyA/IG8uY29uZUlubmVyQW5nbGUgOiAzNjAsXG4gICAgICAgIGNvbmVPdXRlckFuZ2xlOiB0eXBlb2Ygby5jb25lT3V0ZXJBbmdsZSAhPT0gJ3VuZGVmaW5lZCcgPyBvLmNvbmVPdXRlckFuZ2xlIDogMzYwLFxuICAgICAgICBjb25lT3V0ZXJHYWluOiB0eXBlb2Ygby5jb25lT3V0ZXJHYWluICE9PSAndW5kZWZpbmVkJyA/IG8uY29uZU91dGVyR2FpbiA6IDAsXG4gICAgICAgIGRpc3RhbmNlTW9kZWw6IHR5cGVvZiBvLmRpc3RhbmNlTW9kZWwgIT09ICd1bmRlZmluZWQnID8gby5kaXN0YW5jZU1vZGVsIDogJ2ludmVyc2UnLFxuICAgICAgICBtYXhEaXN0YW5jZTogdHlwZW9mIG8ubWF4RGlzdGFuY2UgIT09ICd1bmRlZmluZWQnID8gby5tYXhEaXN0YW5jZSA6IDEwMDAwLFxuICAgICAgICBwYW5uaW5nTW9kZWw6IHR5cGVvZiBvLnBhbm5pbmdNb2RlbCAhPT0gJ3VuZGVmaW5lZCcgPyBvLnBhbm5pbmdNb2RlbCA6ICdIUlRGJyxcbiAgICAgICAgcmVmRGlzdGFuY2U6IHR5cGVvZiBvLnJlZkRpc3RhbmNlICE9PSAndW5kZWZpbmVkJyA/IG8ucmVmRGlzdGFuY2UgOiAxLFxuICAgICAgICByb2xsb2ZmRmFjdG9yOiB0eXBlb2Ygby5yb2xsb2ZmRmFjdG9yICE9PSAndW5kZWZpbmVkJyA/IG8ucm9sbG9mZkZhY3RvciA6IDFcbiAgICAgIH07XG5cbiAgICAgIC8vIFNldHVwIGV2ZW50IGxpc3RlbmVycy5cbiAgICAgIHNlbGYuX29uc3RlcmVvID0gby5vbnN0ZXJlbyA/IFt7Zm46IG8ub25zdGVyZW99XSA6IFtdO1xuICAgICAgc2VsZi5fb25wb3MgPSBvLm9ucG9zID8gW3tmbjogby5vbnBvc31dIDogW107XG4gICAgICBzZWxmLl9vbm9yaWVudGF0aW9uID0gby5vbm9yaWVudGF0aW9uID8gW3tmbjogby5vbm9yaWVudGF0aW9ufV0gOiBbXTtcblxuICAgICAgLy8gQ29tcGxldGUgaW5pdGlsaXphdGlvbiB3aXRoIGhvd2xlci5qcyBjb3JlJ3MgaW5pdCBmdW5jdGlvbi5cbiAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBvKTtcbiAgICB9O1xuICB9KShIb3dsLnByb3RvdHlwZS5pbml0KTtcblxuICAvKipcbiAgICogR2V0L3NldCB0aGUgc3RlcmVvIHBhbm5pbmcgb2YgdGhlIGF1ZGlvIHNvdXJjZSBmb3IgdGhpcyBzb3VuZCBvciBhbGwgaW4gdGhlIGdyb3VwLlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHBhbiAgQSB2YWx1ZSBvZiAtMS4wIGlzIGFsbCB0aGUgd2F5IGxlZnQgYW5kIDEuMCBpcyBhbGwgdGhlIHdheSByaWdodC5cbiAgICogQHBhcmFtICB7TnVtYmVyfSBpZCAob3B0aW9uYWwpIFRoZSBzb3VuZCBJRC4gSWYgbm9uZSBpcyBwYXNzZWQsIGFsbCBpbiBncm91cCB3aWxsIGJlIHVwZGF0ZWQuXG4gICAqIEByZXR1cm4ge0hvd2wvTnVtYmVyfSAgICBSZXR1cm5zIHNlbGYgb3IgdGhlIGN1cnJlbnQgc3RlcmVvIHBhbm5pbmcgdmFsdWUuXG4gICAqL1xuICBIb3dsLnByb3RvdHlwZS5zdGVyZW8gPSBmdW5jdGlvbihwYW4sIGlkKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgLy8gU3RvcCByaWdodCBoZXJlIGlmIG5vdCB1c2luZyBXZWIgQXVkaW8uXG4gICAgaWYgKCFzZWxmLl93ZWJBdWRpbykge1xuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIHNvdW5kIGhhc24ndCBsb2FkZWQsIGFkZCBpdCB0byB0aGUgbG9hZCBxdWV1ZSB0byBjaGFuZ2Ugc3RlcmVvIHBhbiB3aGVuIGNhcGFibGUuXG4gICAgaWYgKHNlbGYuX3N0YXRlICE9PSAnbG9hZGVkJykge1xuICAgICAgc2VsZi5fcXVldWUucHVzaCh7XG4gICAgICAgIGV2ZW50OiAnc3RlcmVvJyxcbiAgICAgICAgYWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBzZWxmLnN0ZXJlbyhwYW4sIGlkKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGZvciBQYW5uZXJTdGVyZW9Ob2RlIHN1cHBvcnQgYW5kIGZhbGxiYWNrIHRvIFBhbm5lck5vZGUgaWYgaXQgZG9lc24ndCBleGlzdC5cbiAgICB2YXIgcGFubmVyVHlwZSA9ICh0eXBlb2YgSG93bGVyLmN0eC5jcmVhdGVTdGVyZW9QYW5uZXIgPT09ICd1bmRlZmluZWQnKSA/ICdzcGF0aWFsJyA6ICdzdGVyZW8nO1xuXG4gICAgLy8gU2V0dXAgdGhlIGdyb3VwJ3Mgc3RlcmVvIHBhbm5pbmcgaWYgbm8gSUQgaXMgcGFzc2VkLlxuICAgIGlmICh0eXBlb2YgaWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAvLyBSZXR1cm4gdGhlIGdyb3VwJ3Mgc3RlcmVvIHBhbm5pbmcgaWYgbm8gcGFyYW1ldGVycyBhcmUgcGFzc2VkLlxuICAgICAgaWYgKHR5cGVvZiBwYW4gPT09ICdudW1iZXInKSB7XG4gICAgICAgIHNlbGYuX3N0ZXJlbyA9IHBhbjtcbiAgICAgICAgc2VsZi5fcG9zID0gW3BhbiwgMCwgMF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gc2VsZi5fc3RlcmVvO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIENoYW5nZSB0aGUgc3RyZW8gcGFubmluZyBvZiBvbmUgb3IgYWxsIHNvdW5kcyBpbiBncm91cC5cbiAgICB2YXIgaWRzID0gc2VsZi5fZ2V0U291bmRJZHMoaWQpO1xuICAgIGZvciAodmFyIGk9MDsgaTxpZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIC8vIEdldCB0aGUgc291bmQuXG4gICAgICB2YXIgc291bmQgPSBzZWxmLl9zb3VuZEJ5SWQoaWRzW2ldKTtcblxuICAgICAgaWYgKHNvdW5kKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcGFuID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIHNvdW5kLl9zdGVyZW8gPSBwYW47XG4gICAgICAgICAgc291bmQuX3BvcyA9IFtwYW4sIDAsIDBdO1xuXG4gICAgICAgICAgaWYgKHNvdW5kLl9ub2RlKSB7XG4gICAgICAgICAgICAvLyBJZiB3ZSBhcmUgZmFsbGluZyBiYWNrLCBtYWtlIHN1cmUgdGhlIHBhbm5pbmdNb2RlbCBpcyBlcXVhbHBvd2VyLlxuICAgICAgICAgICAgc291bmQuX3Bhbm5lckF0dHIucGFubmluZ01vZGVsID0gJ2VxdWFscG93ZXInO1xuXG4gICAgICAgICAgICAvLyBDaGVjayBpZiB0aGVyZSBpcyBhIHBhbm5lciBzZXR1cCBhbmQgY3JlYXRlIGEgbmV3IG9uZSBpZiBub3QuXG4gICAgICAgICAgICBpZiAoIXNvdW5kLl9wYW5uZXIgfHwgIXNvdW5kLl9wYW5uZXIucGFuKSB7XG4gICAgICAgICAgICAgIHNldHVwUGFubmVyKHNvdW5kLCBwYW5uZXJUeXBlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHBhbm5lclR5cGUgPT09ICdzcGF0aWFsJykge1xuICAgICAgICAgICAgICBzb3VuZC5fcGFubmVyLnNldFBvc2l0aW9uKHBhbiwgMCwgMCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzb3VuZC5fcGFubmVyLnBhbi52YWx1ZSA9IHBhbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzZWxmLl9lbWl0KCdzdGVyZW8nLCBzb3VuZC5faWQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBzb3VuZC5fc3RlcmVvO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHNlbGY7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldC9zZXQgdGhlIDNEIHNwYXRpYWwgcG9zaXRpb24gb2YgdGhlIGF1ZGlvIHNvdXJjZSBmb3IgdGhpcyBzb3VuZCBvclxuICAgKiBhbGwgaW4gdGhlIGdyb3VwLiBUaGUgbW9zdCBjb21tb24gdXNhZ2UgaXMgdG8gc2V0IHRoZSAneCcgcG9zaXRpb24gZm9yXG4gICAqIGxlZnQvcmlnaHQgcGFubmluZy4gU2V0dGluZyBhbnkgdmFsdWUgaGlnaGVyIHRoYW4gMS4wIHdpbGwgYmVnaW4gdG9cbiAgICogZGVjcmVhc2UgdGhlIHZvbHVtZSBvZiB0aGUgc291bmQgYXMgaXQgbW92ZXMgZnVydGhlciBhd2F5LlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHggIFRoZSB4LXBvc2l0aW9uIG9mIHRoZSBhdWRpbyBmcm9tIC0xMDAwLjAgdG8gMTAwMC4wLlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHkgIFRoZSB5LXBvc2l0aW9uIG9mIHRoZSBhdWRpbyBmcm9tIC0xMDAwLjAgdG8gMTAwMC4wLlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHogIFRoZSB6LXBvc2l0aW9uIG9mIHRoZSBhdWRpbyBmcm9tIC0xMDAwLjAgdG8gMTAwMC4wLlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGlkIChvcHRpb25hbCkgVGhlIHNvdW5kIElELiBJZiBub25lIGlzIHBhc3NlZCwgYWxsIGluIGdyb3VwIHdpbGwgYmUgdXBkYXRlZC5cbiAgICogQHJldHVybiB7SG93bC9BcnJheX0gICAgUmV0dXJucyBzZWxmIG9yIHRoZSBjdXJyZW50IDNEIHNwYXRpYWwgcG9zaXRpb246IFt4LCB5LCB6XS5cbiAgICovXG4gIEhvd2wucHJvdG90eXBlLnBvcyA9IGZ1bmN0aW9uKHgsIHksIHosIGlkKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgLy8gU3RvcCByaWdodCBoZXJlIGlmIG5vdCB1c2luZyBXZWIgQXVkaW8uXG4gICAgaWYgKCFzZWxmLl93ZWJBdWRpbykge1xuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIHNvdW5kIGhhc24ndCBsb2FkZWQsIGFkZCBpdCB0byB0aGUgbG9hZCBxdWV1ZSB0byBjaGFuZ2UgcG9zaXRpb24gd2hlbiBjYXBhYmxlLlxuICAgIGlmIChzZWxmLl9zdGF0ZSAhPT0gJ2xvYWRlZCcpIHtcbiAgICAgIHNlbGYuX3F1ZXVlLnB1c2goe1xuICAgICAgICBldmVudDogJ3BvcycsXG4gICAgICAgIGFjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgc2VsZi5wb3MoeCwgeSwgeiwgaWQpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuXG4gICAgLy8gU2V0IHRoZSBkZWZhdWx0cyBmb3Igb3B0aW9uYWwgJ3knICYgJ3onLlxuICAgIHkgPSAodHlwZW9mIHkgIT09ICdudW1iZXInKSA/IDAgOiB5O1xuICAgIHogPSAodHlwZW9mIHogIT09ICdudW1iZXInKSA/IC0wLjUgOiB6O1xuXG4gICAgLy8gU2V0dXAgdGhlIGdyb3VwJ3Mgc3BhdGlhbCBwb3NpdGlvbiBpZiBubyBJRCBpcyBwYXNzZWQuXG4gICAgaWYgKHR5cGVvZiBpZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIC8vIFJldHVybiB0aGUgZ3JvdXAncyBzcGF0aWFsIHBvc2l0aW9uIGlmIG5vIHBhcmFtZXRlcnMgYXJlIHBhc3NlZC5cbiAgICAgIGlmICh0eXBlb2YgeCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgc2VsZi5fcG9zID0gW3gsIHksIHpdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuX3BvcztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDaGFuZ2UgdGhlIHNwYXRpYWwgcG9zaXRpb24gb2Ygb25lIG9yIGFsbCBzb3VuZHMgaW4gZ3JvdXAuXG4gICAgdmFyIGlkcyA9IHNlbGYuX2dldFNvdW5kSWRzKGlkKTtcbiAgICBmb3IgKHZhciBpPTA7IGk8aWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAvLyBHZXQgdGhlIHNvdW5kLlxuICAgICAgdmFyIHNvdW5kID0gc2VsZi5fc291bmRCeUlkKGlkc1tpXSk7XG5cbiAgICAgIGlmIChzb3VuZCkge1xuICAgICAgICBpZiAodHlwZW9mIHggPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgc291bmQuX3BvcyA9IFt4LCB5LCB6XTtcblxuICAgICAgICAgIGlmIChzb3VuZC5fbm9kZSkge1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlcmUgaXMgYSBwYW5uZXIgc2V0dXAgYW5kIGNyZWF0ZSBhIG5ldyBvbmUgaWYgbm90LlxuICAgICAgICAgICAgaWYgKCFzb3VuZC5fcGFubmVyIHx8IHNvdW5kLl9wYW5uZXIucGFuKSB7XG4gICAgICAgICAgICAgIHNldHVwUGFubmVyKHNvdW5kLCAnc3BhdGlhbCcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzb3VuZC5fcGFubmVyLnNldFBvc2l0aW9uKHgsIHksIHopO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHNlbGYuX2VtaXQoJ3BvcycsIHNvdW5kLl9pZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHNvdW5kLl9wb3M7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc2VsZjtcbiAgfTtcblxuICAvKipcbiAgICogR2V0L3NldCB0aGUgZGlyZWN0aW9uIHRoZSBhdWRpbyBzb3VyY2UgaXMgcG9pbnRpbmcgaW4gdGhlIDNEIGNhcnRlc2lhbiBjb29yZGluYXRlXG4gICAqIHNwYWNlLiBEZXBlbmRpbmcgb24gaG93IGRpcmVjdGlvbiB0aGUgc291bmQgaXMsIGJhc2VkIG9uIHRoZSBgY29uZWAgYXR0cmlidXRlcyxcbiAgICogYSBzb3VuZCBwb2ludGluZyBhd2F5IGZyb20gdGhlIGxpc3RlbmVyIGNhbiBiZSBxdWlldCBvciBzaWxlbnQuXG4gICAqIEBwYXJhbSAge051bWJlcn0geCAgVGhlIHgtb3JpZW50YXRpb24gb2YgdGhlIHNvdXJjZS5cbiAgICogQHBhcmFtICB7TnVtYmVyfSB5ICBUaGUgeS1vcmllbnRhdGlvbiBvZiB0aGUgc291cmNlLlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHogIFRoZSB6LW9yaWVudGF0aW9uIG9mIHRoZSBzb3VyY2UuXG4gICAqIEBwYXJhbSAge051bWJlcn0gaWQgKG9wdGlvbmFsKSBUaGUgc291bmQgSUQuIElmIG5vbmUgaXMgcGFzc2VkLCBhbGwgaW4gZ3JvdXAgd2lsbCBiZSB1cGRhdGVkLlxuICAgKiBAcmV0dXJuIHtIb3dsL0FycmF5fSAgICBSZXR1cm5zIHNlbGYgb3IgdGhlIGN1cnJlbnQgM0Qgc3BhdGlhbCBvcmllbnRhdGlvbjogW3gsIHksIHpdLlxuICAgKi9cbiAgSG93bC5wcm90b3R5cGUub3JpZW50YXRpb24gPSBmdW5jdGlvbih4LCB5LCB6LCBpZCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIC8vIFN0b3AgcmlnaHQgaGVyZSBpZiBub3QgdXNpbmcgV2ViIEF1ZGlvLlxuICAgIGlmICghc2VsZi5fd2ViQXVkaW8pIHtcbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cblxuICAgIC8vIElmIHRoZSBzb3VuZCBoYXNuJ3QgbG9hZGVkLCBhZGQgaXQgdG8gdGhlIGxvYWQgcXVldWUgdG8gY2hhbmdlIG9yaWVudGF0aW9uIHdoZW4gY2FwYWJsZS5cbiAgICBpZiAoc2VsZi5fc3RhdGUgIT09ICdsb2FkZWQnKSB7XG4gICAgICBzZWxmLl9xdWV1ZS5wdXNoKHtcbiAgICAgICAgZXZlbnQ6ICdvcmllbnRhdGlvbicsXG4gICAgICAgIGFjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgc2VsZi5vcmllbnRhdGlvbih4LCB5LCB6LCBpZCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG5cbiAgICAvLyBTZXQgdGhlIGRlZmF1bHRzIGZvciBvcHRpb25hbCAneScgJiAneicuXG4gICAgeSA9ICh0eXBlb2YgeSAhPT0gJ251bWJlcicpID8gc2VsZi5fb3JpZW50YXRpb25bMV0gOiB5O1xuICAgIHogPSAodHlwZW9mIHogIT09ICdudW1iZXInKSA/IHNlbGYuX29yaWVudGF0aW9uWzJdIDogejtcblxuICAgIC8vIFNldHVwIHRoZSBncm91cCdzIHNwYXRpYWwgb3JpZW50YXRpb24gaWYgbm8gSUQgaXMgcGFzc2VkLlxuICAgIGlmICh0eXBlb2YgaWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAvLyBSZXR1cm4gdGhlIGdyb3VwJ3Mgc3BhdGlhbCBvcmllbnRhdGlvbiBpZiBubyBwYXJhbWV0ZXJzIGFyZSBwYXNzZWQuXG4gICAgICBpZiAodHlwZW9mIHggPT09ICdudW1iZXInKSB7XG4gICAgICAgIHNlbGYuX29yaWVudGF0aW9uID0gW3gsIHksIHpdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuX29yaWVudGF0aW9uO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIENoYW5nZSB0aGUgc3BhdGlhbCBvcmllbnRhdGlvbiBvZiBvbmUgb3IgYWxsIHNvdW5kcyBpbiBncm91cC5cbiAgICB2YXIgaWRzID0gc2VsZi5fZ2V0U291bmRJZHMoaWQpO1xuICAgIGZvciAodmFyIGk9MDsgaTxpZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIC8vIEdldCB0aGUgc291bmQuXG4gICAgICB2YXIgc291bmQgPSBzZWxmLl9zb3VuZEJ5SWQoaWRzW2ldKTtcblxuICAgICAgaWYgKHNvdW5kKSB7XG4gICAgICAgIGlmICh0eXBlb2YgeCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICBzb3VuZC5fb3JpZW50YXRpb24gPSBbeCwgeSwgel07XG5cbiAgICAgICAgICBpZiAoc291bmQuX25vZGUpIHtcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZXJlIGlzIGEgcGFubmVyIHNldHVwIGFuZCBjcmVhdGUgYSBuZXcgb25lIGlmIG5vdC5cbiAgICAgICAgICAgIGlmICghc291bmQuX3Bhbm5lcikge1xuICAgICAgICAgICAgICAvLyBNYWtlIHN1cmUgd2UgaGF2ZSBhIHBvc2l0aW9uIHRvIHNldHVwIHRoZSBub2RlIHdpdGguXG4gICAgICAgICAgICAgIGlmICghc291bmQuX3Bvcykge1xuICAgICAgICAgICAgICAgIHNvdW5kLl9wb3MgPSBzZWxmLl9wb3MgfHwgWzAsIDAsIC0wLjVdO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgc2V0dXBQYW5uZXIoc291bmQsICdzcGF0aWFsJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNvdW5kLl9wYW5uZXIuc2V0T3JpZW50YXRpb24oeCwgeSwgeik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc2VsZi5fZW1pdCgnb3JpZW50YXRpb24nLCBzb3VuZC5faWQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBzb3VuZC5fb3JpZW50YXRpb247XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc2VsZjtcbiAgfTtcblxuICAvKipcbiAgICogR2V0L3NldCB0aGUgcGFubmVyIG5vZGUncyBhdHRyaWJ1dGVzIGZvciBhIHNvdW5kIG9yIGdyb3VwIG9mIHNvdW5kcy5cbiAgICogVGhpcyBtZXRob2QgY2FuIG9wdGlvbmFsbCB0YWtlIDAsIDEgb3IgMiBhcmd1bWVudHMuXG4gICAqICAgcGFubmVyQXR0cigpIC0+IFJldHVybnMgdGhlIGdyb3VwJ3MgdmFsdWVzLlxuICAgKiAgIHBhbm5lckF0dHIoaWQpIC0+IFJldHVybnMgdGhlIHNvdW5kIGlkJ3MgdmFsdWVzLlxuICAgKiAgIHBhbm5lckF0dHIobykgLT4gU2V0J3MgdGhlIHZhbHVlcyBvZiBhbGwgc291bmRzIGluIHRoaXMgSG93bCBncm91cC5cbiAgICogICBwYW5uZXJBdHRyKG8sIGlkKSAtPiBTZXQncyB0aGUgdmFsdWVzIG9mIHBhc3NlZCBzb3VuZCBpZC5cbiAgICpcbiAgICogICBBdHRyaWJ1dGVzOlxuICAgKiAgICAgY29uZUlubmVyQW5nbGUgLSAoMzYwIGJ5IGRlZmF1bHQpIFRoZXJlIHdpbGwgYmUgbm8gdm9sdW1lIHJlZHVjdGlvbiBpbnNpZGUgdGhpcyBhbmdsZS5cbiAgICogICAgIGNvbmVPdXRlckFuZ2xlIC0gKDM2MCBieSBkZWZhdWx0KSBUaGUgdm9sdW1lIHdpbGwgYmUgcmVkdWNlZCB0byBhIGNvbnN0YW50IHZhbHVlIG9mXG4gICAqICAgICAgICAgICAgICAgICAgICAgIGBjb25lT3V0ZXJHYWluYCBvdXRzaWRlIHRoaXMgYW5nbGUuXG4gICAqICAgICBjb25lT3V0ZXJHYWluIC0gKDAgYnkgZGVmYXVsdCkgVGhlIGFtb3VudCBvZiB2b2x1bWUgcmVkdWN0aW9uIG91dHNpZGUgb2YgYGNvbmVPdXRlckFuZ2xlYC5cbiAgICogICAgIGRpc3RhbmNlTW9kZWwgLSAoJ2ludmVyc2UnIGJ5IGRlZmF1bHQpIERldGVybWluZXMgYWxnb3JpdGhtIHRvIHVzZSB0byByZWR1Y2Ugdm9sdW1lIGFzIGF1ZGlvIG1vdmVzXG4gICAqICAgICAgICAgICAgICAgICAgICAgIGF3YXkgZnJvbSBsaXN0ZW5lci4gQ2FuIGJlIGBsaW5lYXJgLCBgaW52ZXJzZWAgb3IgYGV4cG9uZW50aWFsYC5cbiAgICogICAgIG1heERpc3RhbmNlIC0gKDEwMDAwIGJ5IGRlZmF1bHQpIFZvbHVtZSB3b24ndCByZWR1Y2UgYmV0d2VlbiBzb3VyY2UvbGlzdGVuZXIgYmV5b25kIHRoaXMgZGlzdGFuY2UuXG4gICAqICAgICBwYW5uaW5nTW9kZWwgLSAoJ0hSVEYnIGJ5IGRlZmF1bHQpIERldGVybWluZXMgd2hpY2ggc3BhdGlhbGl6YXRpb24gYWxnb3JpdGhtIGlzIHVzZWQgdG8gcG9zaXRpb24gYXVkaW8uXG4gICAqICAgICAgICAgICAgICAgICAgICAgQ2FuIGJlIGBIUlRGYCBvciBgZXF1YWxwb3dlcmAuXG4gICAqICAgICByZWZEaXN0YW5jZSAtICgxIGJ5IGRlZmF1bHQpIEEgcmVmZXJlbmNlIGRpc3RhbmNlIGZvciByZWR1Y2luZyB2b2x1bWUgYXMgdGhlIHNvdXJjZVxuICAgKiAgICAgICAgICAgICAgICAgICAgbW92ZXMgYXdheSBmcm9tIHRoZSBsaXN0ZW5lci5cbiAgICogICAgIHJvbGxvZmZGYWN0b3IgLSAoMSBieSBkZWZhdWx0KSBIb3cgcXVpY2tseSB0aGUgdm9sdW1lIHJlZHVjZXMgYXMgc291cmNlIG1vdmVzIGZyb20gbGlzdGVuZXIuXG4gICAqIFxuICAgKiBAcmV0dXJuIHtIb3dsL09iamVjdH0gUmV0dXJucyBzZWxmIG9yIGN1cnJlbnQgcGFubmVyIGF0dHJpYnV0ZXMuXG4gICAqL1xuICBIb3dsLnByb3RvdHlwZS5wYW5uZXJBdHRyID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgIHZhciBvLCBpZCwgc291bmQ7XG5cbiAgICAvLyBTdG9wIHJpZ2h0IGhlcmUgaWYgbm90IHVzaW5nIFdlYiBBdWRpby5cbiAgICBpZiAoIXNlbGYuX3dlYkF1ZGlvKSB7XG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG5cbiAgICAvLyBEZXRlcm1pbmUgdGhlIHZhbHVlcyBiYXNlZCBvbiBhcmd1bWVudHMuXG4gICAgaWYgKGFyZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAvLyBSZXR1cm4gdGhlIGdyb3VwJ3MgcGFubmVyIGF0dHJpYnV0ZSB2YWx1ZXMuXG4gICAgICByZXR1cm4gc2VsZi5fcGFubmVyQXR0cjtcbiAgICB9IGVsc2UgaWYgKGFyZ3MubGVuZ3RoID09PSAxKSB7XG4gICAgICBpZiAodHlwZW9mIGFyZ3NbMF0gPT09ICdvYmplY3QnKSB7XG4gICAgICAgIG8gPSBhcmdzWzBdO1xuXG4gICAgICAgIC8vIFNldCB0aGUgZ3JvdSdzIHBhbm5lciBhdHRyaWJ1dGUgdmFsdWVzLlxuICAgICAgICBpZiAodHlwZW9mIGlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHNlbGYuX3Bhbm5lckF0dHIgPSB7XG4gICAgICAgICAgICBjb25lSW5uZXJBbmdsZTogdHlwZW9mIG8uY29uZUlubmVyQW5nbGUgIT09ICd1bmRlZmluZWQnID8gby5jb25lSW5uZXJBbmdsZSA6IHNlbGYuX2NvbmVJbm5lckFuZ2xlLFxuICAgICAgICAgICAgY29uZU91dGVyQW5nbGU6IHR5cGVvZiBvLmNvbmVPdXRlckFuZ2xlICE9PSAndW5kZWZpbmVkJyA/IG8uY29uZU91dGVyQW5nbGUgOiBzZWxmLl9jb25lT3V0ZXJBbmdsZSxcbiAgICAgICAgICAgIGNvbmVPdXRlckdhaW46IHR5cGVvZiBvLmNvbmVPdXRlckdhaW4gIT09ICd1bmRlZmluZWQnID8gby5jb25lT3V0ZXJHYWluIDogc2VsZi5fY29uZU91dGVyR2FpbixcbiAgICAgICAgICAgIGRpc3RhbmNlTW9kZWw6IHR5cGVvZiBvLmRpc3RhbmNlTW9kZWwgIT09ICd1bmRlZmluZWQnID8gby5kaXN0YW5jZU1vZGVsIDogc2VsZi5fZGlzdGFuY2VNb2RlbCxcbiAgICAgICAgICAgIG1heERpc3RhbmNlOiB0eXBlb2Ygby5tYXhEaXN0YW5jZSAhPT0gJ3VuZGVmaW5lZCcgPyBvLm1heERpc3RhbmNlIDogc2VsZi5fbWF4RGlzdGFuY2UsXG4gICAgICAgICAgICBwYW5uaW5nTW9kZWw6IHR5cGVvZiBvLnBhbm5pbmdNb2RlbCAhPT0gJ3VuZGVmaW5lZCcgPyBvLnBhbm5pbmdNb2RlbCA6IHNlbGYuX3Bhbm5pbmdNb2RlbCxcbiAgICAgICAgICAgIHJlZkRpc3RhbmNlOiB0eXBlb2Ygby5yZWZEaXN0YW5jZSAhPT0gJ3VuZGVmaW5lZCcgPyBvLnJlZkRpc3RhbmNlIDogc2VsZi5fcmVmRGlzdGFuY2UsXG4gICAgICAgICAgICByb2xsb2ZmRmFjdG9yOiB0eXBlb2Ygby5yb2xsb2ZmRmFjdG9yICE9PSAndW5kZWZpbmVkJyA/IG8ucm9sbG9mZkZhY3RvciA6IHNlbGYuX3JvbGxvZmZGYWN0b3JcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBSZXR1cm4gdGhpcyBzb3VuZCdzIHBhbm5lciBhdHRyaWJ1dGUgdmFsdWVzLlxuICAgICAgICBzb3VuZCA9IHNlbGYuX3NvdW5kQnlJZChwYXJzZUludChhcmdzWzBdLCAxMCkpO1xuICAgICAgICByZXR1cm4gc291bmQgPyBzb3VuZC5fcGFubmVyQXR0ciA6IHNlbGYuX3Bhbm5lckF0dHI7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChhcmdzLmxlbmd0aCA9PT0gMikge1xuICAgICAgbyA9IGFyZ3NbMF07XG4gICAgICBpZCA9IHBhcnNlSW50KGFyZ3NbMV0sIDEwKTtcbiAgICB9XG5cbiAgICAvLyBVcGRhdGUgdGhlIHZhbHVlcyBvZiB0aGUgc3BlY2lmaWVkIHNvdW5kcy5cbiAgICB2YXIgaWRzID0gc2VsZi5fZ2V0U291bmRJZHMoaWQpO1xuICAgIGZvciAodmFyIGk9MDsgaTxpZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHNvdW5kID0gc2VsZi5fc291bmRCeUlkKGlkc1tpXSk7XG5cbiAgICAgIGlmIChzb3VuZCkge1xuICAgICAgICAvLyBNZXJnZSB0aGUgbmV3IHZhbHVlcyBpbnRvIHRoZSBzb3VuZC5cbiAgICAgICAgdmFyIHBhID0gc291bmQuX3Bhbm5lckF0dHI7XG4gICAgICAgIHBhID0ge1xuICAgICAgICAgIGNvbmVJbm5lckFuZ2xlOiB0eXBlb2Ygby5jb25lSW5uZXJBbmdsZSAhPT0gJ3VuZGVmaW5lZCcgPyBvLmNvbmVJbm5lckFuZ2xlIDogcGEuY29uZUlubmVyQW5nbGUsXG4gICAgICAgICAgY29uZU91dGVyQW5nbGU6IHR5cGVvZiBvLmNvbmVPdXRlckFuZ2xlICE9PSAndW5kZWZpbmVkJyA/IG8uY29uZU91dGVyQW5nbGUgOiBwYS5jb25lT3V0ZXJBbmdsZSxcbiAgICAgICAgICBjb25lT3V0ZXJHYWluOiB0eXBlb2Ygby5jb25lT3V0ZXJHYWluICE9PSAndW5kZWZpbmVkJyA/IG8uY29uZU91dGVyR2FpbiA6IHBhLmNvbmVPdXRlckdhaW4sXG4gICAgICAgICAgZGlzdGFuY2VNb2RlbDogdHlwZW9mIG8uZGlzdGFuY2VNb2RlbCAhPT0gJ3VuZGVmaW5lZCcgPyBvLmRpc3RhbmNlTW9kZWwgOiBwYS5kaXN0YW5jZU1vZGVsLFxuICAgICAgICAgIG1heERpc3RhbmNlOiB0eXBlb2Ygby5tYXhEaXN0YW5jZSAhPT0gJ3VuZGVmaW5lZCcgPyBvLm1heERpc3RhbmNlIDogcGEubWF4RGlzdGFuY2UsXG4gICAgICAgICAgcGFubmluZ01vZGVsOiB0eXBlb2Ygby5wYW5uaW5nTW9kZWwgIT09ICd1bmRlZmluZWQnID8gby5wYW5uaW5nTW9kZWwgOiBwYS5wYW5uaW5nTW9kZWwsXG4gICAgICAgICAgcmVmRGlzdGFuY2U6IHR5cGVvZiBvLnJlZkRpc3RhbmNlICE9PSAndW5kZWZpbmVkJyA/IG8ucmVmRGlzdGFuY2UgOiBwYS5yZWZEaXN0YW5jZSxcbiAgICAgICAgICByb2xsb2ZmRmFjdG9yOiB0eXBlb2Ygby5yb2xsb2ZmRmFjdG9yICE9PSAndW5kZWZpbmVkJyA/IG8ucm9sbG9mZkZhY3RvciA6IHBhLnJvbGxvZmZGYWN0b3JcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBVcGRhdGUgdGhlIHBhbm5lciB2YWx1ZXMgb3IgY3JlYXRlIGEgbmV3IHBhbm5lciBpZiBub25lIGV4aXN0cy5cbiAgICAgICAgdmFyIHBhbm5lciA9IHNvdW5kLl9wYW5uZXI7XG4gICAgICAgIGlmIChwYW5uZXIpIHtcbiAgICAgICAgICBwYW5uZXIuY29uZUlubmVyQW5nbGUgPSBwYS5jb25lSW5uZXJBbmdsZTtcbiAgICAgICAgICBwYW5uZXIuY29uZU91dGVyQW5nbGUgPSBwYS5jb25lT3V0ZXJBbmdsZTtcbiAgICAgICAgICBwYW5uZXIuY29uZU91dGVyR2FpbiA9IHBhLmNvbmVPdXRlckdhaW47XG4gICAgICAgICAgcGFubmVyLmRpc3RhbmNlTW9kZWwgPSBwYS5kaXN0YW5jZU1vZGVsO1xuICAgICAgICAgIHBhbm5lci5tYXhEaXN0YW5jZSA9IHBhLm1heERpc3RhbmNlO1xuICAgICAgICAgIHBhbm5lci5wYW5uaW5nTW9kZWwgPSBwYS5wYW5uaW5nTW9kZWw7XG4gICAgICAgICAgcGFubmVyLnJlZkRpc3RhbmNlID0gcGEucmVmRGlzdGFuY2U7XG4gICAgICAgICAgcGFubmVyLnJvbGxvZmZGYWN0b3IgPSBwYS5yb2xsb2ZmRmFjdG9yO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBoYXZlIGEgcG9zaXRpb24gdG8gc2V0dXAgdGhlIG5vZGUgd2l0aC5cbiAgICAgICAgICBpZiAoIXNvdW5kLl9wb3MpIHtcbiAgICAgICAgICAgIHNvdW5kLl9wb3MgPSBzZWxmLl9wb3MgfHwgWzAsIDAsIC0wLjVdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIENyZWF0ZSBhIG5ldyBwYW5uZXIgbm9kZS5cbiAgICAgICAgICBzZXR1cFBhbm5lcihzb3VuZCwgJ3NwYXRpYWwnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzZWxmO1xuICB9O1xuXG4gIC8qKiBTaW5nbGUgU291bmQgTWV0aG9kcyAqKi9cbiAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAvKipcbiAgICogQWRkIG5ldyBwcm9wZXJ0aWVzIHRvIHRoZSBjb3JlIFNvdW5kIGluaXQuXG4gICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBfc3VwZXIgQ29yZSBTb3VuZCBpbml0IG1ldGhvZC5cbiAgICogQHJldHVybiB7U291bmR9XG4gICAqL1xuICBTb3VuZC5wcm90b3R5cGUuaW5pdCA9IChmdW5jdGlvbihfc3VwZXIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgcGFyZW50ID0gc2VsZi5fcGFyZW50O1xuXG4gICAgICAvLyBTZXR1cCB1c2VyLWRlZmluZWQgZGVmYXVsdCBwcm9wZXJ0aWVzLlxuICAgICAgc2VsZi5fb3JpZW50YXRpb24gPSBwYXJlbnQuX29yaWVudGF0aW9uO1xuICAgICAgc2VsZi5fc3RlcmVvID0gcGFyZW50Ll9zdGVyZW87XG4gICAgICBzZWxmLl9wb3MgPSBwYXJlbnQuX3BvcztcbiAgICAgIHNlbGYuX3Bhbm5lckF0dHIgPSBwYXJlbnQuX3Bhbm5lckF0dHI7XG5cbiAgICAgIC8vIENvbXBsZXRlIGluaXRpbGl6YXRpb24gd2l0aCBob3dsZXIuanMgY29yZSBTb3VuZCdzIGluaXQgZnVuY3Rpb24uXG4gICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcblxuICAgICAgLy8gSWYgYSBzdGVyZW8gb3IgcG9zaXRpb24gd2FzIHNwZWNpZmllZCwgc2V0IGl0IHVwLlxuICAgICAgaWYgKHNlbGYuX3N0ZXJlbykge1xuICAgICAgICBwYXJlbnQuc3RlcmVvKHNlbGYuX3N0ZXJlbyk7XG4gICAgICB9IGVsc2UgaWYgKHNlbGYuX3Bvcykge1xuICAgICAgICBwYXJlbnQucG9zKHNlbGYuX3Bvc1swXSwgc2VsZi5fcG9zWzFdLCBzZWxmLl9wb3NbMl0sIHNlbGYuX2lkKTtcbiAgICAgIH1cbiAgICB9O1xuICB9KShTb3VuZC5wcm90b3R5cGUuaW5pdCk7XG5cbiAgLyoqXG4gICAqIE92ZXJyaWRlIHRoZSBTb3VuZC5yZXNldCBtZXRob2QgdG8gY2xlYW4gdXAgcHJvcGVydGllcyBmcm9tIHRoZSBzcGF0aWFsIHBsdWdpbi5cbiAgICogQHBhcmFtICB7RnVuY3Rpb259IF9zdXBlciBTb3VuZCByZXNldCBtZXRob2QuXG4gICAqIEByZXR1cm4ge1NvdW5kfVxuICAgKi9cbiAgU291bmQucHJvdG90eXBlLnJlc2V0ID0gKGZ1bmN0aW9uKF9zdXBlcikge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBwYXJlbnQgPSBzZWxmLl9wYXJlbnQ7XG5cbiAgICAgIC8vIFJlc2V0IGFsbCBzcGF0aWFsIHBsdWdpbiBwcm9wZXJ0aWVzIG9uIHRoaXMgc291bmQuXG4gICAgICBzZWxmLl9vcmllbnRhdGlvbiA9IHBhcmVudC5fb3JpZW50YXRpb247XG4gICAgICBzZWxmLl9wb3MgPSBwYXJlbnQuX3BvcztcbiAgICAgIHNlbGYuX3Bhbm5lckF0dHIgPSBwYXJlbnQuX3Bhbm5lckF0dHI7XG5cbiAgICAgIC8vIENvbXBsZXRlIHJlc2V0dGluZyBvZiB0aGUgc291bmQuXG4gICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgfTtcbiAgfSkoU291bmQucHJvdG90eXBlLnJlc2V0KTtcblxuICAvKiogSGVscGVyIE1ldGhvZHMgKiovXG4gIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBwYW5uZXIgbm9kZSBhbmQgc2F2ZSBpdCBvbiB0aGUgc291bmQuXG4gICAqIEBwYXJhbSAge1NvdW5kfSBzb3VuZCBTcGVjaWZpYyBzb3VuZCB0byBzZXR1cCBwYW5uaW5nIG9uLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUeXBlIG9mIHBhbm5lciB0byBjcmVhdGU6ICdzdGVyZW8nIG9yICdzcGF0aWFsJy5cbiAgICovXG4gIHZhciBzZXR1cFBhbm5lciA9IGZ1bmN0aW9uKHNvdW5kLCB0eXBlKSB7XG4gICAgdHlwZSA9IHR5cGUgfHwgJ3NwYXRpYWwnO1xuXG4gICAgLy8gQ3JlYXRlIHRoZSBuZXcgcGFubmVyIG5vZGUuXG4gICAgaWYgKHR5cGUgPT09ICdzcGF0aWFsJykge1xuICAgICAgc291bmQuX3Bhbm5lciA9IEhvd2xlci5jdHguY3JlYXRlUGFubmVyKCk7XG4gICAgICBzb3VuZC5fcGFubmVyLmNvbmVJbm5lckFuZ2xlID0gc291bmQuX3Bhbm5lckF0dHIuY29uZUlubmVyQW5nbGU7XG4gICAgICBzb3VuZC5fcGFubmVyLmNvbmVPdXRlckFuZ2xlID0gc291bmQuX3Bhbm5lckF0dHIuY29uZU91dGVyQW5nbGU7XG4gICAgICBzb3VuZC5fcGFubmVyLmNvbmVPdXRlckdhaW4gPSBzb3VuZC5fcGFubmVyQXR0ci5jb25lT3V0ZXJHYWluO1xuICAgICAgc291bmQuX3Bhbm5lci5kaXN0YW5jZU1vZGVsID0gc291bmQuX3Bhbm5lckF0dHIuZGlzdGFuY2VNb2RlbDtcbiAgICAgIHNvdW5kLl9wYW5uZXIubWF4RGlzdGFuY2UgPSBzb3VuZC5fcGFubmVyQXR0ci5tYXhEaXN0YW5jZTtcbiAgICAgIHNvdW5kLl9wYW5uZXIucGFubmluZ01vZGVsID0gc291bmQuX3Bhbm5lckF0dHIucGFubmluZ01vZGVsO1xuICAgICAgc291bmQuX3Bhbm5lci5yZWZEaXN0YW5jZSA9IHNvdW5kLl9wYW5uZXJBdHRyLnJlZkRpc3RhbmNlO1xuICAgICAgc291bmQuX3Bhbm5lci5yb2xsb2ZmRmFjdG9yID0gc291bmQuX3Bhbm5lckF0dHIucm9sbG9mZkZhY3RvcjtcbiAgICAgIHNvdW5kLl9wYW5uZXIuc2V0UG9zaXRpb24oc291bmQuX3Bvc1swXSwgc291bmQuX3Bvc1sxXSwgc291bmQuX3Bvc1syXSk7XG4gICAgICBzb3VuZC5fcGFubmVyLnNldE9yaWVudGF0aW9uKHNvdW5kLl9vcmllbnRhdGlvblswXSwgc291bmQuX29yaWVudGF0aW9uWzFdLCBzb3VuZC5fb3JpZW50YXRpb25bMl0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBzb3VuZC5fcGFubmVyID0gSG93bGVyLmN0eC5jcmVhdGVTdGVyZW9QYW5uZXIoKTtcbiAgICAgIHNvdW5kLl9wYW5uZXIucGFuLnZhbHVlID0gc291bmQuX3N0ZXJlbztcbiAgICB9XG5cbiAgICBzb3VuZC5fcGFubmVyLmNvbm5lY3Qoc291bmQuX25vZGUpO1xuXG4gICAgLy8gVXBkYXRlIHRoZSBjb25uZWN0aW9ucy5cbiAgICBpZiAoIXNvdW5kLl9wYXVzZWQpIHtcbiAgICAgIHNvdW5kLl9wYXJlbnQucGF1c2Uoc291bmQuX2lkLCB0cnVlKS5wbGF5KHNvdW5kLl9pZCk7XG4gICAgfVxuICB9O1xufSkoKTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2hvd2xlci9kaXN0L2hvd2xlci5qc1xuICoqIG1vZHVsZSBpZCA9IDJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlxyXG5cclxuXHJcblx0XHJcblx0dmFyIGV2ZW50cyA9IHt9LFxyXG5cdFx0aWRSZWdpc3RyeSA9IDkxMDA7XHJcblx0XHJcblx0XHJcblx0ZnVuY3Rpb24gU3Vic2NyaWJlKGV2ZW50LCBmdW5jKXtcclxuXHRcdGlmKCFldmVudHMuaGFzT3duUHJvcGVydHkoZXZlbnQpKXtcclxuXHRcdFx0ZXZlbnRzW2V2ZW50XSA9IFtdO1xyXG5cdFx0fVxyXG5cdFx0XHJcblx0XHR2YXIgZXZlbnRJRCA9ICsraWRSZWdpc3RyeTtcclxuXHRcdFxyXG5cdFx0ZXZlbnRzW2V2ZW50XS5wdXNoKHtcclxuXHRcdFx0XHJcblx0XHRcdGlkIDogZXZlbnRJRCxcclxuXHRcdFx0aGFuZGxlciA6IGZ1bmNcclxuXHRcdFx0XHRcdFx0ICAgXHJcblx0XHRcdH0pO1xyXG5cdFx0XHJcblx0XHRyZXR1cm4gZXZlbnRJRDtcclxuXHJcblx0fVxyXG5cdFxyXG5cdGZ1bmN0aW9uIFB1Ymxpc2goKXtcclxuICAgICAgICBcclxuICAgICAgICBcclxuICAgICAgICBcclxuICAgICAgICB2YXIgZXZlbnQgPSBhcmd1bWVudHNbMF0sXHJcbiAgICAgICAgICAgIGRhdGEgPSBhcmd1bWVudHNbMV0sXHJcbiAgICAgICAgICAgIHJlYWxPbmUgPSBhcmd1bWVudHNbMl07XHJcblx0XHRcclxuICAgICAgICBcclxuICAgICAgICBcclxuXHRcdFx0aWYoIWV2ZW50cy5oYXNPd25Qcm9wZXJ0eShldmVudCkpe1xyXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdFx0fVxyXG5cdFx0XHRcclxuXHRcdHZhciBzdWJzID0gZXZlbnRzW2V2ZW50XTtcclxuXHJcblx0XHRmb3IodmFyIGkgPSAwLCBqID0gc3Vicy5sZW5ndGg7IGk8ajsgaSsrKXtcclxuXHRcdFx0XHJcblx0XHRcdHN1YnNbaV0uaGFuZGxlcihldmVudCwgZGF0YSk7XHJcblx0XHRcdFxyXG5cdFx0fVxyXG5cdFx0XHJcblx0fVxyXG5cdFxyXG5cdGZ1bmN0aW9uIFVuc3Vic2NyaWJlKGlkKXtcclxuXHRcdFxyXG5cdFx0Zm9yKHZhciBldmVudCBpbiBldmVudHMpe1xyXG5cdFx0XHRpZihldmVudHMuaGFzT3duUHJvcGVydHkoZXZlbnQpKXtcclxuXHRcdFx0XHRmb3IodmFyIGkgPSAwLCBqID0gZXZlbnRzW2V2ZW50XS5sZW5ndGg7IGk8ajsgaSsrKXtcclxuXHRcdFx0XHRcdGlmKGV2ZW50c1tldmVudF1baV0uaWQgPT09IGlkKXtcclxuXHRcdFx0XHRcdFx0ZXZlbnRzW2V2ZW50XS5zcGxpY2UoaSwgMSk7XHJcblx0XHRcdFx0XHRcdHJldHVybiBpZDtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdFxyXG5cdH1cclxuXHJcblxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgICBcclxuICAgIHN1YnNjcmliZSA6IFN1YnNjcmliZSxcclxuICAgIHB1Ymxpc2ggOiBQdWJsaXNoLFxyXG4gICAgdW5zdWJzY3JpYmUgOiBVbnN1YnNjcmliZVxyXG4gICAgXHJcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2pzL1B1YlN1Yi5qc1xuICoqIG1vZHVsZSBpZCA9IDNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBSZXNvdXJjZUxvYWRlciA9IHJlcXVpcmUoJy4vUmVzb3VyY2VMb2FkZXInKSxcclxuICAgIEFsZ29yaXRobXMgPSByZXF1aXJlKCcuL0FsZ29yaXRobXMnKSxcclxuICAgIG1haW5DYW52YXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYmdDYW52YXMnKSxcclxuICAgIFB1YlN1YiA9IHJlcXVpcmUoJy4vUHViU3ViJyksXHJcbiAgICBjZW50ZXJYID0gbWFpbkNhbnZhcy53aWR0aCAvIDIsXHJcbiAgICBjZW50ZXJZID0gbWFpbkNhbnZhcy5oZWlnaHQgLyAyO1xyXG5cclxuXHJcbiAgICAgICAgaW5oZXJpdEZyb20oRGlzcGxheSwgUGh5c2ljcyk7XHJcbiAgICAgICAgaW5oZXJpdEZyb20oUGh5c2ljcywgU3BhY2VjcmFmdCk7XHJcbiAgICAgICAgaW5oZXJpdEZyb20oRGlzcGxheSwgQmFja2dyb3VuZCk7XHJcbiAgICAgICAgLy9tYWtlIGN1c3RvbSBjbGFzc2VzIGluaGVyaXQgZGlzcGxheSBjbGFzc1xyXG4gICAgICAgIGluaGVyaXRGcm9tKFBoeXNpY3MsIE1pc3NpbGUpO1xyXG4gICAgICAgIGluaGVyaXRGcm9tKERpc3BsYXksIFNoaWVsZCk7XHJcbiAgICAgICAgaW5oZXJpdEZyb20oU3BhY2VjcmFmdCwgU2hpcCk7XHJcbiAgICAgICAgaW5oZXJpdEZyb20oRGlzcGxheSwgRXhwbG9zaW9uKTtcclxuICAgICAgICBpbmhlcml0RnJvbShTcGFjZWNyYWZ0LCBFbmVteSk7XHJcbiAgICAgICAgaW5oZXJpdEZyb20oUGh5c2ljcywgUm9jayk7XHJcbiAgICAgICAgaW5oZXJpdEZyb20oU3BhY2VjcmFmdCwgTW90aGVyc2hpcCk7XHJcbiAgICAgICAgaW5oZXJpdEZyb20oUGh5c2ljcywgUGVyayk7ICAgXHJcbiAgICBcclxuXHJcblxyXG4gICAgLy9pbmhlcml0ZXIgZnVuY3Rpb25cclxuICAgIGZ1bmN0aW9uIGluaGVyaXRGcm9tKHBhcmVudCwgY2hpbGQpe1xyXG4gICAgICAgIHZhciBjb3B5T2ZQYXJlbnQgPSBPYmplY3QuY3JlYXRlKHBhcmVudC5wcm90b3R5cGUpO1xyXG4gICAgICAgIGNvcHlPZlBhcmVudC5jb25zdHJ1Y3RvciA9IGNoaWxkO1xyXG4gICAgICAgIGNoaWxkLnByb3RvdHlwZSA9IGNvcHlPZlBhcmVudDtcclxuICAgIH1cclxuXHJcbiAgICAvL2N1c3RvbSBjbGFzc2VzXHJcblx0ZnVuY3Rpb24gRGlzcGxheSgpe1xyXG4gICAgICAgXHJcblx0XHR0aGlzLmNhbnZhc1dpZHRoID0gMDtcclxuXHRcdHRoaXMuY2FudmFzSGVpZ2h0ID0gMDtcclxuXHRcdHRoaXMuY2VudGVyWCA9IDA7XHJcblx0XHR0aGlzLmNlbnRlclkgPSAwO1xyXG5cdFx0dGhpcy5oZWlnaHQgPSAwO1xyXG5cdFx0dGhpcy53aWR0aCA9IDA7XHJcblx0XHR0aGlzLnggPSAwO1xyXG5cdFx0dGhpcy55ID0gMDtcclxuXHRcdHRoaXMuY29sb3IgPSBcIiMwMEZGMDBcIjtcclxuXHRcdHRoaXMuYWxwaGEgPSAxO1xyXG4gICAgICAgIHRoaXMuYWxpdmUgPSBmYWxzZTsgIFxyXG4gICAgICAgIHRoaXMuY29udGV4dCA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLnR5cGUgPSBcImRpc3BsYXlcIjtcclxuICAgICAgIFxyXG5cdH1cclxuICAgICAgICAvL3RlbXAgcHJvdG8gbWV0aG9kLi4uLlxyXG4gICAgRGlzcGxheS5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbigpe1xyXG5cdFx0XHR0aGlzLnggPSAwO1xyXG5cdFx0XHR0aGlzLnkgPSAwO1xyXG5cdFx0XHR0aGlzLmFuZ2xlID0gMDtcclxuXHRcdFx0dGhpcy52ZWxYID0gMDtcclxuXHRcdFx0dGhpcy52ZWxZID0gMDtcclxuXHRcdFx0dGhpcy5hbGl2ZSA9IGZhbHNlO1xyXG5cdFx0XHR0aGlzLmNvbGxpZGluZyA9IGZhbHNlO1xyXG5cdFx0fTtcclxuICAgIFxyXG4gICAgRGlzcGxheS5wcm90b3R5cGUuc2V0Q2FudmFzID0gZnVuY3Rpb24oY2FudmFzKXtcclxuXHRcdFx0dGhpcy5jb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XHJcblx0XHRcdHRoaXMuY2FudmFzV2lkdGggPSBjYW52YXMud2lkdGg7XHJcblx0XHRcdHRoaXMuY2FudmFzSGVpZ2h0ID0gY2FudmFzLmhlaWdodDtcclxuXHRcdH07XHJcbiAgICBcclxuICAgIERpc3BsYXkucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0KXtcclxuXHRcdFx0dGhpcy53aWR0aCA9IHdpZHRoIHx8IDIwO1xyXG5cdFx0XHR0aGlzLmhlaWdodCA9IGhlaWdodCB8fCAyMDtcclxuXHRcdFx0dGhpcy5jZW50ZXJYID0gd2lkdGgvMjtcclxuXHRcdFx0dGhpcy5jZW50ZXJZID0gaGVpZ2h0LzI7XHJcblx0XHRcdHRoaXMuYWxpdmUgPSBmYWxzZTtcclxuXHRcdH07XHJcblxyXG4gICAgZnVuY3Rpb24gUGh5c2ljcygpe1xyXG4gICAgICAgIFxyXG4gICAgICAgICAgICBEaXNwbGF5LmNhbGwodGhpcyk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdGhpcy52ZWxYID0gMDtcclxuICAgICAgICB0aGlzLnZlbFkgPSAwO1xyXG4gICAgICAgIHRoaXMuYWNlbFggPSAwO1xyXG4gICAgICAgIHRoaXMuYWNlbFkgPSAwO1xyXG4gICAgICAgIHRoaXMuY29sbGlkaW5nID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5zcGVlZCA9IDA7IFxyXG4gICAgICAgIHRoaXMudGhydXN0ID0gMDtcclxuICAgICAgICB0aGlzLmFuZ2xlID0gMDtcclxuICAgIH1cclxuICAgIFxyXG4gICAgUGh5c2ljcy5wcm90b3R5cGUuc3Bhd24gPSBmdW5jdGlvbih4LCB5LCBhbmdsZSwgc3BlZWQpe1xyXG4gICAgICAgIFxyXG4gICAgICAgIHRoaXMueCA9IHggfHwgY2VudGVyWDtcclxuICAgICAgICB0aGlzLnkgPSB5IHx8IGNlbnRlclk7XHJcbiAgICAgICAgdGhpcy5jb2xsaWRpbmcgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmFsaXZlID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmFuZ2xlID0gYW5nbGUgfHwgdGhpcy5hbmdsZTtcclxuICAgICAgICB0aGlzLnNwZWVkID0gc3BlZWQgfHwgdGhpcy5zcGVlZDtcclxuICAgICAgICB0aGlzLnZlbFggPSBNYXRoLmNvcyh0aGlzLmFuZ2xlKSp0aGlzLnNwZWVkO1xyXG4gICAgICAgIHRoaXMudmVsWSA9IE1hdGguc2luKHRoaXMuYW5nbGUpKnRoaXMuc3BlZWQ7XHJcbiAgICAgICAgXHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICBQaHlzaWNzLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKXtcclxuICAgICAgICB0aGlzLmFsaXZlID0gZmFsc2U7IFxyXG4gICAgfTtcclxuICAgIFxyXG4gICAgLy9zcGFjZUNyYWZ0IGZ1bmN0aW9uIGNvbnN0cnVjdG9yIFxyXG4gICAgZnVuY3Rpb24gU3BhY2VjcmFmdCgpe1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICBQaHlzaWNzLmNhbGwodGhpcyk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdGhpcy5hdXRvU3Bhd24gPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnRocnVzdEFjY2VsID0gMC4wMztcclxuICAgICAgICB0aGlzLmFscGhhU3BlZWQgPSAwLjAzO1xyXG4gICAgICAgIHRoaXMuc2hpZWxkQWN0aXZlID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5zaGllbGREaXNhYmxlZCA9IGZhbHNlO1xyXG5cdFx0dGhpcy5tYXhWZWxvY2l0eSA9IDQ7XHJcbiAgICAgICAgdGhpcy5taXNzaWxlc1NwZWVkID0gMi41O1xyXG5cdFx0dGhpcy5lYXNlVmFsdWUgPSAwLjAzO1xyXG5cdFx0dGhpcy5qdW1waW5nID0gZmFsc2U7XHJcbiAgICAgICAgXHJcbiAgICB9XHJcblx0XHRcclxuICAgIFNwYWNlY3JhZnQucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0KXtcclxuICAgICAgICBcclxuICAgICAgICAgICAgRGlzcGxheS5wcm90b3R5cGUuaW5pdC5jYWxsKHRoaXMsIHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciBzaGllbGQgPSBuZXcgU2hpZWxkKCk7XHJcbiAgICAgICAgICAgIHNoaWVsZC5zZXRDYW52YXMobWFpbkNhbnZhcyk7XHJcbiAgICAgICAgICAgIHNoaWVsZC5pbml0KDgwLDgwKTtcclxuXHRcdHZhciBtaXNzaWxlUG9vbCA9IG5ldyBQb29sKDEwKTtcclxuXHRcdFx0bWlzc2lsZVBvb2wuaW5pdCgnbWlzc2lsZScpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICB2YXIgZXhwbG9zaW9uID0gbmV3IEV4cGxvc2lvbigxNSk7XHJcbiAgICAgICAgICAgIGV4cGxvc2lvbi5zZXRDYW52YXMobWFpbkNhbnZhcyk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBcclxuICAgICAgICB0aGlzLmV4cGxvc2lvbiA9IGV4cGxvc2lvbjtcclxuICAgICAgICB0aGlzLnNoaWVsZCA9IHNoaWVsZDtcclxuICAgICAgICB0aGlzLm1pc3NpbGVzID0gbWlzc2lsZVBvb2w7XHJcbiAgICAgICAgXHJcbiAgICB9OyAgICBcclxuXHRcclxuICAgIFNwYWNlY3JhZnQucHJvdG90eXBlLmZvbGxvdyA9IGZ1bmN0aW9uKG9iamVjdCl7XHJcbiAgICAgICAgXHJcblx0XHRcdGlmKCFvYmplY3QuYWxpdmUgfHwgdGhpcy5qdW1waW5nKXtcclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdH1cdFxyXG5cdFx0XHR2YXIgZHgsIGR5LCBkaXN0YW5jZSwgbmV3VmVsWCwgbmV3VmVsWSwgZnV0dXJlVmVsLCBkaXJlY3Rpb247XHJcblx0XHRcdGR4ID0gb2JqZWN0LnggLSB0aGlzLng7XHJcblx0XHRcdGR5ID0gb2JqZWN0LnkgLSB0aGlzLnk7XHJcblx0XHRcdGRpc3RhbmNlID0gTWF0aC5zcXJ0KGR4KmR4K2R5KmR5KTtcclxuXHRcdFx0ZGlyZWN0aW9uID0gTWF0aC5hdGFuMihkeSwgZHgpO1xyXG5cdFx0XHR0aGlzLmFuZ2xlID0gZGlyZWN0aW9uO1xyXG5cdFx0XHRcclxuXHRcdFx0aWYoZGlzdGFuY2U+PTE0MCl7XHJcblx0XHRcdG5ld1ZlbFggPSB0aGlzLnZlbFgrTWF0aC5jb3ModGhpcy5hbmdsZSkqdGhpcy50aHJ1c3RBY2NlbDtcclxuXHRcdFx0bmV3VmVsWSA9IHRoaXMudmVsWStNYXRoLnNpbih0aGlzLmFuZ2xlKSp0aGlzLnRocnVzdEFjY2VsO1x0XHJcblx0XHRcdGZ1dHVyZVZlbCA9IE1hdGguc3FydChuZXdWZWxYKm5ld1ZlbFggKyBuZXdWZWxZKm5ld1ZlbFkpO1x0XHJcblx0XHRcdFx0XHRpZihmdXR1cmVWZWw+MS41KXtcclxuXHRcdFx0XHRuZXdWZWxYID0gdGhpcy52ZWxYO1xyXG5cdFx0XHRcdG5ld1ZlbFkgPSB0aGlzLnZlbFk7XHJcblx0XHRcdFx0fWVsc2V7XHJcblx0XHRcdFx0dGhpcy52ZWxYID0gbmV3VmVsWDtcclxuXHRcdFx0XHR0aGlzLnZlbFkgPSBuZXdWZWxZO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVx0XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICBTcGFjZWNyYWZ0LnByb3RvdHlwZS5hdHRhY2sgPSBmdW5jdGlvbihvYmplY3Qpe1xyXG5cdFx0XHRpZihNYXRoLnJhbmRvbSgpID49IDAuMDA1IHx8ICF0aGlzLmFsaXZlIHx8ICFvYmplY3QuYWxpdmUpe1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fVxyXG5cdFx0XHR0aGlzLnNob290KCk7XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICBTcGFjZWNyYWZ0LnByb3RvdHlwZS5zcGF3biA9IGZ1bmN0aW9uKHgsIHksIGFuZ2xlLCBzcGVlZCl7XHJcbiAgICAgICAgXHJcbiAgICAgICAgICAgIFBoeXNpY3MucHJvdG90eXBlLnNwYXduLmNhbGwodGhpcywgeCwgeSwgYW5nbGUsIHNwZWVkKTtcclxuICAgICAgICAgICAgdGhpcy5taXNzaWxlcy5oaWRlSXRlbXMoKTtcclxuICAgICAgICAgICAgLy90aGlzLnNoaWVsZC5yZXNldCgpO1xyXG5cdFx0XHR0aGlzLmp1bXBpbmcgPSBmYWxzZTtcclxuICAgICAgICBcclxuICAgIH07XHJcbiAgICBcclxuICAgIFNwYWNlY3JhZnQucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpe1xyXG4gICAgICAgIHRoaXMuY29sbGlkaW5nID0gdHJ1ZTsgIFxyXG4gICAgICAgIFJlc291cmNlTG9hZGVyLmFzc2V0cy5leHBsb3Npb25Tb3VuZC5wbGF5KCk7XHJcbiAgICB9O1xyXG5cclxuXHRTcGFjZWNyYWZ0LnByb3RvdHlwZS5qdW1wID0gZnVuY3Rpb24oKXtcclxuXHRcdFxyXG5cdFx0Ly9pZiBzcGFjZWNyYWZ0IGlzIG5vdCBqdW1waW5nLCBoYXZlIGl0IGZhY2UgdG8gdGhlIHJpZ2h0IGFuZCBubyBZIHZlbG9jaXR5LlxyXG5cdFx0aWYoIXRoaXMuanVtcGluZyl7XHJcblx0XHRcdHRoaXMudmVsWSA9IHRoaXMuYW5nbGUgPSAwO1xyXG5cdFx0XHR0aGlzLnZlbFggPSAxO1xyXG5cdFx0XHR0aGlzLmp1bXBpbmcgPSB0cnVlO1xyXG5cdFx0fVxyXG5cdFx0XHJcblx0fTtcclxuXHJcbiAgICBTcGFjZWNyYWZ0LnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24oKXtcclxuICAgICAgICBcclxuICAgICAgICAvL2RyYXdzIHNwYWNlY3JhZnQgbGF1bmNoZWQgbWlzc2lsZXNcclxuICAgICAgICBmb3IodmFyIGk9MDsgaTx0aGlzLm1pc3NpbGVzLnBvb2wubGVuZ3RoOyBpKyspe1xyXG4gICAgICAgICAgICB2YXIgY3VycmVudE1pc3NpbGUgPSB0aGlzLm1pc3NpbGVzLnBvb2xbaV07ICAgXHJcbiAgICAgICAgICAgIGlmKGN1cnJlbnRNaXNzaWxlLmFsaXZlKXtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRNaXNzaWxlLmRyYXcoKTsgICBcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICBpZih0aGlzLmNvbGxpZGluZyl7XHRcclxuICAgICAgICAgICAgICAgIC8vaWYgc3BhY2VjcmFmdCBpcyBjb2xsaWRpbmcsIGNyZWF0ZSBhbiBleHBsb3Npb25cclxuICAgICAgICAgICAgdGhpcy5leHBsb3Npb24uY3JlYXRlKHRoaXMueCt0aGlzLmNlbnRlclgsIHRoaXMueSt0aGlzLmNlbnRlclkpO1xyXG4gICAgICAgICAgICB0aGlzLmV4cGxvc2lvbi5kcmF3KCk7XHJcbiAgICAgICAgICAgICAgICAvL29uY2UgdGhlIGV4cGxvc2lvbiBpcyBub3QgcnVubmluZywga2lsbCBvZmYgc3BhY2VjcmFmdFxyXG4gICAgICAgICAgICBpZighdGhpcy5leHBsb3Npb24ucnVubmluZyl7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFsaXZlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbGxpZGluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgaWYodGhpcy5hdXRvU3Bhd24pe1xyXG4gICAgICAgICAgICAgICAgIHRoaXMuc3Bhd24oKTsgICBcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy9yZXR1cm4gd2hpbGUgY29sbGlkaW5nXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vaWYgc2hpZWxkIGlzIGFjdGl2ZSBkcmF3IGl0LlxyXG4gICAgICAgIGlmKHRoaXMuc2hpZWxkLmFjdGl2ZSl7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNoaWVsZC54ID0gdGhpcy54LXRoaXMuc2hpZWxkLmNlbnRlclgrdGhpcy5jZW50ZXJYO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zaGllbGQueSA9IHRoaXMueS10aGlzLnNoaWVsZC5jZW50ZXJZK3RoaXMuY2VudGVyWTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2hpZWxkLmRyYXcoKTtcclxuICAgICAgICB9XHJcblx0XHRcclxuXHRcdC8vaWYgc3BhY2VjcmFmdCBpcyBqdW1waW5nLCBlYXNlIHRoZSBzcGFjZWNyYWZ0IG91dC5cclxuXHRcdGlmKHRoaXMuanVtcGluZyAmJiB0aGlzLnZlbFggPCAxMCl7XHJcblx0XHRcdFxyXG5cdFx0XHR0aGlzLnZlbFggKz0gdGhpcy52ZWxYKnRoaXMuZWFzZVZhbHVlO1xyXG5cdFx0XHRcclxuXHRcdH1cclxuXHRcdFxyXG5cdFx0XHJcbiAgICAgICAgXHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICBTcGFjZWNyYWZ0LnByb3RvdHlwZS5zaG9vdCA9IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy9pZiBpbnN0YW5jZSBpcyBub3QgYWxpdmUsIGlzIGNvbGxpZGluZyBvciBub3QgbW92aW5nLCBpdCB3aWxsIE5PVCBzaG9vdFxyXG4gICAgICAgIGlmKCF0aGlzLmFsaXZlIHx8IHRoaXMuY29sbGlkaW5nIHx8IHRoaXMudmVsWCA9PSAwKXtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMubWlzc2lsZXMuZ2V0KHRoaXMueCsxMCwgdGhpcy55KzEwLCBcIm1pc3NpbGVcIiwgdGhpcy5hbmdsZSwgdGhpcy5taXNzaWxlc1NwZWVkKTtcclxuXHRcdFxyXG4gICAgfTtcclxuICAgIFxyXG4gICAgLy9jbGFzcyBmb3IgdGhlIHJvY2tzIGZsb2F0aW5nXHJcbiAgICBmdW5jdGlvbiBSb2NrKCl7XHJcbiAgICAgICAgXHJcbiAgICAgICAgICAgIFBoeXNpY3MuY2FsbCh0aGlzKTtcclxuICAgICAgICBcclxuICAgICAgICB0aGlzLnNpemU7XHJcbiAgICAgICAgdGhpcy5zcHJpdGVBbmltYXRpb24gPSBuZXcgU3ByaXRlQW5pbWF0aW9uKCk7XHJcbiAgICAgICAgdGhpcy5zcHJpdGVBbmltYXRpb24uc2V0Q2FudmFzKG1haW5DYW52YXMpO1xyXG4gICAgICAgIHRoaXMuZXhwbG9zaW9uID0gbmV3IEV4cGxvc2lvbig3KTtcclxuICAgICAgICB0aGlzLmV4cGxvc2lvbi5zZXRDYW52YXMobWFpbkNhbnZhcyk7XHJcbiAgICAgICAgdGhpcy50eXBlID0gJ3JvY2snO1xyXG4gICAgXHJcbiAgICB9XHJcbiAgICBcclxuICAgIFJvY2sucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbihzaXplKXtcclxuICAgICAgICBcclxuICAgICAgICAgIHZhciBzcHJpdGVBbmltYXRpb25JbmZvLFxyXG4gICAgICAgICAgICAgIGxhcmdlUm9ja1NwZWVkID0gMC41LFxyXG4gICAgICAgICAgICAgIG1lZGl1bVJvY2tTcGVlZCA9IDEsXHJcbiAgICAgICAgICAgICAgc21hbGxSb2NrU3BlZWQgPSAxLjIsXHJcbiAgICAgICAgICAgICAgcmFuZG9tQW5nbGU7XHJcbiAgICAgICAgXHJcbiAgICAgICAgICB0aGlzLnNwcml0ZSA9IFJlc291cmNlTG9hZGVyLmFzc2V0cy5tZXRlb3JTcHJpdGU7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBzaXplID0gc2l6ZSB8fCBcImxhcmdlXCI7XHJcbiAgICBcclxuICAgICAgICAgICAgc3dpdGNoKHNpemUpe1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcImxhcmdlXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgc3ByaXRlQW5pbWF0aW9uSW5mbyA9IHt3aWR0aDo1NixoZWlnaHQ6NTUsIG9mZnNldFg6IDAsIG9mZnNldFk6IDAsIG51bUNvbDoyLCBudW1Sb3c6OSxmcHM6NjAsc3BlZWQ6OCxsb29wOmZhbHNlLGZyb206MCx0bzoxN307XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zcHJpdGVBbmltYXRpb24uaW5pdChzcHJpdGVBbmltYXRpb25JbmZvKTtcclxuICAgICAgICAgICAgICAgICAgICByYW5kb21BbmdsZSA9IE1hdGgucmFuZG9tKCkqKE1hdGguUEkqMik7XHJcbiAgICAgICAgICAgICAgICAgICAgRGlzcGxheS5wcm90b3R5cGUuaW5pdC5jYWxsKHRoaXMsIHNwcml0ZUFuaW1hdGlvbkluZm8ud2lkdGgsIHNwcml0ZUFuaW1hdGlvbkluZm8uaGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgICAgICBQaHlzaWNzLnByb3RvdHlwZS5zcGF3bi5jYWxsKHRoaXMsIDAsIDAsIHJhbmRvbUFuZ2xlLCBsYXJnZVJvY2tTcGVlZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hbGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2l6ZSA9IFwibGFyZ2VcIjtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnR5cGUgPSBcImxhcmdlUm9ja1wiO1xyXG4gICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgY2FzZSBcIm1lZGl1bVwiOlxyXG4gICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgIHNwcml0ZUFuaW1hdGlvbkluZm8gPSB7d2lkdGg6NDQsaGVpZ2h0OjQ0LCBudW1Db2w6MywgbnVtUm93OjYsZnBzOjYwLG9mZnNldFg6IDEzMCwgb2Zmc2V0WSA6IDAsIHNwZWVkOjEyLGxvb3A6dHJ1ZSxmcm9tOjAsdG86MTd9OyAgIFxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3ByaXRlQW5pbWF0aW9uLmluaXQoc3ByaXRlQW5pbWF0aW9uSW5mbyk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmFuZG9tQW5nbGUgPSBNYXRoLnJhbmRvbSgpKihNYXRoLlBJKjIpO1xyXG4gICAgICAgICAgICAgICAgICAgIERpc3BsYXkucHJvdG90eXBlLmluaXQuY2FsbCh0aGlzLCBzcHJpdGVBbmltYXRpb25JbmZvLndpZHRoLCBzcHJpdGVBbmltYXRpb25JbmZvLmhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICAgICAgUGh5c2ljcy5wcm90b3R5cGUuc3Bhd24uY2FsbCh0aGlzLCAwLCAwLCByYW5kb21BbmdsZSwgbWVkaXVtUm9ja1NwZWVkKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFsaXZlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zaXplID0gXCJtZWRpdW1cIjtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnR5cGUgPSBcIm1lZGl1bVJvY2tcIjtcclxuICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJzbWFsbFwiOlxyXG4gICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgIHNwcml0ZUFuaW1hdGlvbkluZm8gPSB7d2lkdGg6MzMsaGVpZ2h0OjMzLCBudW1Db2w6MyxvZmZzZXRYOiAyOTAsIG9mZnNldFk6IDAsIG51bVJvdzo2LGZwczo2MCxzcGVlZDoxNSxsb29wOnRydWUsZnJvbTowLHRvOjE3fTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNwcml0ZUFuaW1hdGlvbi5pbml0KHNwcml0ZUFuaW1hdGlvbkluZm8pO1xyXG4gICAgICAgICAgICAgICAgICAgIHJhbmRvbUFuZ2xlID0gTWF0aC5yYW5kb20oKSooTWF0aC5QSSoyKTtcclxuICAgICAgICAgICAgICAgICAgICBEaXNwbGF5LnByb3RvdHlwZS5pbml0LmNhbGwodGhpcywgc3ByaXRlQW5pbWF0aW9uSW5mby53aWR0aCwgc3ByaXRlQW5pbWF0aW9uSW5mby5oZWlnaHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIFBoeXNpY3MucHJvdG90eXBlLnNwYXduLmNhbGwodGhpcywgMCwgMCwgcmFuZG9tQW5nbGUsIHNtYWxsUm9ja1NwZWVkKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFsaXZlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zaXplID0gXCJzbWFsbFwiO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHlwZSA9IFwic21hbGxSb2NrXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICBSb2NrLnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgXHJcblx0XHRcdGlmKHRoaXMuY29sbGlkaW5nKXsgXHJcbiAgICAgICAgICAgIC8vd2hlbiBvYmplY3QgaXMgY29sbGlkaW5nLCBjcmVhdGVzIGFuZCBkcmF3cyBleHBsb3Npb25cclxuXHRcdFx0dGhpcy5leHBsb3Npb24uY3JlYXRlKHRoaXMueCt0aGlzLmNlbnRlclgsIHRoaXMueSt0aGlzLmNlbnRlclkpO1xyXG5cdFx0XHR0aGlzLmV4cGxvc2lvbi5kcmF3KCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRlc3Ryb3koKTtcclxuXHJcblx0XHRcdCAgICAgaWYoIXRoaXMuZXhwbG9zaW9uLnJ1bm5pbmcpe1xyXG5cdFx0XHQgICAgIC8vb25jZSBleHBsb3Npb24gaXMgb3Zlciwga2lsbHMgb2ZmIG9iamVjdFxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29sbGlkaW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hbGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBleHBsb3Npb24gaXMgc3RpbGwgcnVubmluZyByZXR1cm4gdG8gZHJhd2luZyB0aGUgZXhwbG9zaW9uXHJcblx0XHRcdCAgICAgcmV0dXJuO1xyXG5cdFx0XHR9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB0aGlzLnggKz0gdGhpcy52ZWxYO1xyXG4gICAgICAgICAgICB0aGlzLnkgKz0gdGhpcy52ZWxZO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgdGhpcy5zcHJpdGVBbmltYXRpb24ucGxheSh0aGlzLngsIHRoaXMueSwgdGhpcy5zcHJpdGUpOyAgICBcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgfTtcclxuICAgIFxyXG4gICAgUm9jay5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgXHJcbiAgICAgICAgICAgIGlmKHRoaXMuY29sbGlkaW5nKXtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgICAgICBSZXNvdXJjZUxvYWRlci5hc3NldHMubWV0ZW9yRXhwbG9zaW9uU291bmQucGxheSgpO1xyXG4gICAgICAgICAgICB0aGlzLmNvbGxpZGluZyA9IHRydWU7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBQdWJTdWIucHVibGlzaCgnbWV0ZW9yX2V4cGxvc2lvbicsIHRoaXMpO1xyXG4gICAgICAgIFxyXG4gICAgfTsgICAgXHJcbiAgICBcclxuXHRmdW5jdGlvbiBCYWNrZ3JvdW5kKCl7XHJcbiAgICAgICAgXHJcbiAgICAgICAgICAgIERpc3BsYXkuY2FsbCh0aGlzKTtcclxuICAgICAgICBcclxuICAgICAgICB0aGlzLnZlbFggPSAwO1xyXG4gICAgICAgIHRoaXMudmVsWSA9IDA7XHJcblx0XHR0aGlzLnByb2dyZXNzQmFyV2lkdGggPSA0MDA7XHJcblx0XHR0aGlzLnByb2dyZXNzQmFySGVpZ2h0ID0gNDA7XHJcblx0fVxyXG4gICAgXHJcbiAgICBCYWNrZ3JvdW5kLnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgdGhpcy54ICs9IHRoaXMudmVsWDtcclxuXHRcdFx0dGhpcy55ICs9IHRoaXMudmVsWTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5kcmF3SW1hZ2UoUmVzb3VyY2VMb2FkZXIuYXNzZXRzLmJhY2tncm91bmRTcHJpdGUsIDAsMCx0aGlzLmNhbnZhc1dpZHRoLHRoaXMuY2FudmFzSGVpZ2h0LHRoaXMueC10aGlzLmNhbnZhc1dpZHRoLCB0aGlzLnksdGhpcy5jYW52YXNXaWR0aCx0aGlzLmNhbnZhc0hlaWdodCk7XHRcclxuICAgICAgICAgICAgdGhpcy5jb250ZXh0LmRyYXdJbWFnZShSZXNvdXJjZUxvYWRlci5hc3NldHMuYmFja2dyb3VuZFNwcml0ZSwgMCwwLHRoaXMuY2FudmFzV2lkdGgsdGhpcy5jYW52YXNIZWlnaHQsdGhpcy54LHRoaXMueSx0aGlzLmNhbnZhc1dpZHRoLHRoaXMuY2FudmFzSGVpZ2h0KTtcclxuXHRcdFx0XHJcblx0XHRcdGlmKHRoaXMueD50aGlzLmNhbnZhc1dpZHRoKXtcclxuXHRcdFx0XHR0aGlzLnggPSAwO1xyXG5cdFx0XHR9XHRcclxuICAgIH07XHJcbiAgICBcclxuXHRmdW5jdGlvbiBTaGlwKCl7XHJcbiAgICAgICAgXHJcbiAgICAgICAgICAgICAgICBTcGFjZWNyYWZ0LmNhbGwodGhpcyk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgICAgIHZhciBzaGlwU3ByaXRlSW5mbyA9IHt3aWR0aDoyMSxoZWlnaHQ6MjIsIG51bUNvbDoxLCBudW1Sb3c6MixmcHM6NjAsc3BlZWQ6MzAsbG9vcDpmYWxzZSxmcm9tOjAsdG86MH07XHJcbiAgICAgICAgXHJcbiAgICAgICAgICAgIHRoaXMudGhydXN0ID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuYXV0b1NwYXduID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy50aHJ1c3RBY2NlbCA9IDAuMDQ7XHJcbiAgICAgICAgICAgIHRoaXMubWlzc2lsZXNTcGVlZCA9IDMuMjtcclxuICAgICAgICAgICAgdGhpcy5zcHJpdGVBbmltYXRpb24gPSBuZXcgU3ByaXRlQW5pbWF0aW9uKCk7XHJcbiAgICAgICAgICAgIHRoaXMuc3ByaXRlQW5pbWF0aW9uLnNldENhbnZhcyhtYWluQ2FudmFzKTtcclxuICAgICAgICAgICAgdGhpcy5zcHJpdGVBbmltYXRpb24uaW5pdChzaGlwU3ByaXRlSW5mbyk7IFxyXG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBcImh1bWFuU2hpcFwiO1xyXG4gICAgICAgIFxyXG5cdH1cclxuICAgIFxyXG4gICAgU2hpcC5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgXHJcbiAgICAgICAgICAgU3BhY2VjcmFmdC5wcm90b3R5cGUuZHJhdy5jYWxsKHRoaXMpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmKHRoaXMuY29sbGlkaW5nKXtcclxuICAgICAgICAgICAgcmV0dXJuOyAgIFxyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5zYXZlKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFscGhhICs9IHRoaXMuYWxwaGFTcGVlZDtcclxuICAgICAgICAgICAgICAgIHRoaXMuYWxwaGEgPSAodGhpcy5hbHBoYSA+PSAxKT8gMTogdGhpcy5hbHBoYTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5nbG9iYWxBbHBoYSA9IHRoaXMuYWxwaGE7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQudHJhbnNsYXRlKHRoaXMueCsxMCwgdGhpcy55KzEwKTtcdFxyXG4gICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LnJvdGF0ZSh0aGlzLmFuZ2xlKTtcclxuICAgICAgICAgICAgICAgIHRoaXMueCArPSB0aGlzLnZlbFg7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnkgKz0gdGhpcy52ZWxZO1xyXG4gICAgICAgICAgICAgICAgaWYodGhpcy50aHJ1c3Qpe1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3ByaXRlQW5pbWF0aW9uLnN0YXJ0RnJhbWUgPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3ByaXRlQW5pbWF0aW9uLmZpbmFsRnJhbWUgPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3ByaXRlQW5pbWF0aW9uLnBsYXkoLXRoaXMuY2VudGVyWCwgLXRoaXMuY2VudGVyWSwgUmVzb3VyY2VMb2FkZXIuYXNzZXRzLnBsYXllclNwcml0ZVNoZWV0KTtcclxuICAgICAgICAgICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICAgICAgICAgIC8vdGhpcy5jb250ZXh0LmRyYXdJbWFnZShzaGlwU3ByaXRlLCAwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgLTEwLC0xMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3ByaXRlQW5pbWF0aW9uLnN0YXJ0RnJhbWUgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3ByaXRlQW5pbWF0aW9uLmZpbmFsRnJhbWUgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3ByaXRlQW5pbWF0aW9uLnBsYXkoLXRoaXMuY2VudGVyWCwgLXRoaXMuY2VudGVyWSwgUmVzb3VyY2VMb2FkZXIuYXNzZXRzLnBsYXllclNwcml0ZVNoZWV0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5yZXN0b3JlKCk7XHJcbiAgICB9O1xyXG5cdFxyXG5cdFNoaXAucHJvdG90eXBlLnNob290ID0gZnVuY3Rpb24oKXtcclxuXHRcdFNwYWNlY3JhZnQucHJvdG90eXBlLnNob290LmNhbGwodGhpcyk7XHJcblx0XHRSZXNvdXJjZUxvYWRlci5hc3NldHMucGxheWVyU2hvb3RTb3VuZC5wbGF5KCk7XHJcblx0fTtcclxuICAgIFxyXG4gICAgZnVuY3Rpb24gUGVyaygpe1xyXG4gICAgICAgIFxyXG4gICAgICAgICAgICBQaHlzaWNzLmNhbGwodGhpcyk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdGhpcy5zcHJpdGVBbmltYXRpb24gPSBuZXcgU3ByaXRlQW5pbWF0aW9uKCk7IFxyXG4gICAgICAgIHRoaXMuc3ByaXRlQW5pbWF0aW9uLnNldENhbnZhcyhtYWluQ2FudmFzKTtcclxuICAgIFxyXG4gICAgICAgIHRoaXMudHlwZSA9ICdwZXJrJzsgICAgXHJcbiAgICB9XHJcblxyXG4gICAgUGVyay5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYoIXRoaXMuYWxpdmUpe1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHRoaXMueCArPSB0aGlzLnZlbFg7XHJcbiAgICAgICAgdGhpcy55ICs9IHRoaXMudmVsWTtcclxuICAgICAgICBcclxuICAgICAgICB0aGlzLnNwcml0ZUFuaW1hdGlvbi5wbGF5KHRoaXMueCwgdGhpcy55LCBSZXNvdXJjZUxvYWRlci5hc3NldHMucGVya1Nwcml0ZSk7XHJcbiAgICAgICAgXHJcbiAgICB9O1xyXG5cclxuICAgIFBlcmsucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbihwZXJrKXtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHZhciBzcHJpdGVJbmZvOyBcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgc3dpdGNoKHBlcmspe1xyXG4gICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgY2FzZSBcInNoaWVsZFwiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzcHJpdGVJbmZvID0ge3dpZHRoOjE4LGhlaWdodDoxOSwgbnVtQ29sOjEsIG51bVJvdzoyLGZwczo2MCxzcGVlZDoxLGxvb3A6ZmFsc2UsZnJvbTowLHRvOjB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNwcml0ZUFuaW1hdGlvbi5pbml0KHNwcml0ZUluZm8pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBEaXNwbGF5LnByb3RvdHlwZS5pbml0LmNhbGwodGhpcywgc3ByaXRlSW5mby53aWR0aCwgc3ByaXRlSW5mby5oZWlnaHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnR5cGUgPSBcInNoaWVsZFwiO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgY2FzZSBcImxpZmVcIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3ByaXRlSW5mbyA9IHt3aWR0aDoxOCxoZWlnaHQ6MTksIG51bUNvbDoxLCBudW1Sb3c6MixmcHM6NjAsc3BlZWQ6MSxsb29wOmZhbHNlLGZyb206MSx0bzoxfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zcHJpdGVBbmltYXRpb24uaW5pdChzcHJpdGVJbmZvKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgRGlzcGxheS5wcm90b3R5cGUuaW5pdC5jYWxsKHRoaXMsIHNwcml0ZUluZm8ud2lkdGgsIHNwcml0ZUluZm8uaGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50eXBlID0gXCJsaWZlXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgIH07IFxyXG5cdFxyXG5cdFBlcmsucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpe1xyXG5cdFx0UGh5c2ljcy5wcm90b3R5cGUuZGVzdHJveS5jYWxsKHRoaXMpO1xyXG5cdFx0UmVzb3VyY2VMb2FkZXIuYXNzZXRzLnBlcmtTb3VuZC5wbGF5KCk7XHJcblx0fTsgICAgICAgIFxyXG4gICAgLy9taXNzbGUgY29uc3RydWN0b3JcclxuICAgIFxyXG5cdGZ1bmN0aW9uIE1pc3NpbGUoKXtcclxuICAgICAgICBcclxuICAgICAgICAgICAgUGh5c2ljcy5jYWxsKHRoaXMpO1xyXG4gICAgICAgIFxyXG5cdFx0dGhpcy5zcGVlZCA9IDM7XHJcblx0XHR0aGlzLmxpZmUgPSAwO1xyXG5cdFx0dGhpcy5tYXhMaWZlID0gMTAwO1xyXG4gICAgICAgIHRoaXMudHlwZSA9IFwibWlzc2lsZVwiO1xyXG5cclxuXHR9XHJcbiAgICBcclxuICAgIE1pc3NpbGUucHJvdG90eXBlLnNwYXduID0gZnVuY3Rpb24oeCwgeSwgYW5nbGUsIHNwZWVkKXtcclxuICAgICAgICBQaHlzaWNzLnByb3RvdHlwZS5zcGF3bi5jYWxsKHRoaXMsIHgsIHksIGFuZ2xlLCBzcGVlZCk7ICBcclxuICAgICAgICB0aGlzLmxpZmUgPSAwO1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgTWlzc2lsZS5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdGhpcy5saWZlKys7XHJcblx0XHRcdGlmKHRoaXMubGlmZT49dGhpcy5tYXhMaWZlKXtcclxuXHRcdFx0XHR0aGlzLmxpZmUgPSAwO1xyXG5cdFx0XHRcdHRoaXMuYWxpdmUgPSBmYWxzZTtcclxuXHRcdFx0fVxyXG5cdFx0XHR0aGlzLnggKz0gdGhpcy52ZWxYO1xyXG5cdFx0XHR0aGlzLnkgKz0gdGhpcy52ZWxZO1xyXG5cdFx0XHR0aGlzLmNvbnRleHQuZmlsbFN0eWxlID0gdGhpcy5jb2xvcjtcclxuXHRcdFx0dGhpcy5jb250ZXh0LmZpbGxSZWN0KHRoaXMueCwgdGhpcy55LCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XHJcbiAgICBcclxuICAgIH07XHJcbiAgICBcclxuXHRmdW5jdGlvbiBFbmVteSgpe1xyXG4gICAgICAgIFxyXG4gICAgICAgICAgICBTcGFjZWNyYWZ0LmNhbGwodGhpcyk7XHJcbiAgICAgICAgXHJcblx0XHR0aGlzLnRocnVzdEFjY2VsID0gMC4wMztcclxuICAgICAgICB0aGlzLnR5cGUgPSBcImVuZW15XCI7XHJcbiAgICAgICAgXHJcblx0XHRcclxuICAgICAgICB2YXIgc3ByaXRlUmFuZG9tSW5kZXggPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkqNCk7XHJcbiAgICAgICAgdGhpcy5zcHJpdGVBbmltYXRpb24gPSBuZXcgU3ByaXRlQW5pbWF0aW9uKCk7XHJcbiAgICAgICAgdGhpcy5zcHJpdGVBbmltYXRpb24uc2V0Q2FudmFzKG1haW5DYW52YXMpO1xyXG4gICAgICAgIHZhciBlbmVteVNwcml0ZUluZm8gPSB7d2lkdGg6MjMsaGVpZ2h0OjIxLCBudW1Db2w6MSwgbnVtUm93OjQsZnBzOjYwLHNwZWVkOjMwLGxvb3A6ZmFsc2UsZnJvbTpzcHJpdGVSYW5kb21JbmRleCx0bzpzcHJpdGVSYW5kb21JbmRleH07XHJcbiAgICAgICAgdGhpcy5zcHJpdGVBbmltYXRpb24uaW5pdChlbmVteVNwcml0ZUluZm8pO1xyXG4gICAgXHJcblx0fVxyXG4gICAgXHJcbiAgICBFbmVteS5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgXHJcbiAgICAgICAgICAgICAgICBTcGFjZWNyYWZ0LnByb3RvdHlwZS5kcmF3LmNhbGwodGhpcyk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBpZih0aGlzLmNvbGxpZGluZyB8fCAhdGhpcy5hbGl2ZSl7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47ICAgXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICAgICAgICAgIHRoaXMueCArPSB0aGlzLnZlbFg7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnkgKz0gdGhpcy52ZWxZO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LnNhdmUoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC50cmFuc2xhdGUodGhpcy54K3RoaXMuY2VudGVyWCwgdGhpcy55K3RoaXMuY2VudGVyWSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQucm90YXRlKHRoaXMuYW5nbGUpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zcHJpdGVBbmltYXRpb24ucGxheSgtdGhpcy5jZW50ZXJYLCAtdGhpcy5jZW50ZXJYLCBSZXNvdXJjZUxvYWRlci5hc3NldHMuZW5lbXlTcHJpdGVTaGVldCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQucmVzdG9yZSgpOyAgXHJcbiAgICAgICAgICAgICAgICBcclxuXHJcbiAgICB9O1xyXG4gICAgICAgIFxyXG4gICAgLy9tb3RoZXJzaGlwIGNvbnN0cnVjdG9yXHJcbiAgICBmdW5jdGlvbiBNb3RoZXJzaGlwKCl7XHJcbiAgICAgICAgXHJcbiAgICAgICAgICAgICBTcGFjZWNyYWZ0LmNhbGwodGhpcyk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgXHJcbiAgICAgICAgdGhpcy5oYXNSZWxlYXNlZFNoaXBzID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5zcHJpdGVBbmltYXRpb24gPSBuZXcgU3ByaXRlQW5pbWF0aW9uKCk7XHJcbiAgICAgICAgdGhpcy5zcHJpdGVBbmltYXRpb24uc2V0Q2FudmFzKG1haW5DYW52YXMpO1xyXG4gICAgICAgIHRoaXMudHlwZSA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLm1pc3NpbGVzU3BlZWQgPSAzO1xyXG4gICAgICAgIHRoaXMuYWxwaGEgPSAwO1xyXG4gICAgICAgIHRoaXMuYWxwaGFTcGVlZCA9IDAuMDI7XHJcbiAgICAgICAgdGhpcy5udW1TaGlwcyA9IDA7XHJcbiAgICAgICAgdGhpcy50eXBlID0gXCJtb3RoZXJzaGlwXCI7XHJcbiAgICBcclxuICAgIH1cclxuICAgIFxyXG4gICAgTW90aGVyc2hpcC5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKHNoaXBUeXBlKXtcclxuICAgICAgICBcclxuICAgICAgICAgICAgc3dpdGNoKHNoaXBUeXBlKXtcclxuICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJodW1hblwiOlxyXG4gICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgIHZhciBzcHJpdGVTaGVldEluZm8gPSB7d2lkdGg6NTEsaGVpZ2h0OjQ2LCBudW1Db2w6MSwgbnVtUm93OjIsZnBzOjYwLHNwZWVkOjMwLGxvb3A6ZmFsc2UsZnJvbTowLHRvOjB9O1xyXG4gICAgICAgICAgICAgICAgIHZhciBzcHJpdGVJbmRleCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSpzcHJpdGVTaGVldEluZm8udG8pO1xyXG4gICAgICAgICAgICAgICAgIHNwcml0ZVNoZWV0SW5mby5mcm9tID0gc3ByaXRlU2hlZXRJbmZvLnRvID0gc3ByaXRlSW5kZXg7XHJcbiAgICAgICAgICAgICAgICAgdGhpcy5zcHJpdGVBbmltYXRpb24uaW5pdChzcHJpdGVTaGVldEluZm8pO1xyXG4gICAgICAgICAgICAgICAgIHRoaXMudHlwZSA9IFwiaHVtYW5cIjtcclxuICAgICAgICAgICAgICAgICB0aGlzLndpZHRoID0gc3ByaXRlU2hlZXRJbmZvLndpZHRoO1xyXG4gICAgICAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gc3ByaXRlU2hlZXRJbmZvLmhlaWdodDtcclxuICAgICAgICAgICAgICAgICB0aGlzLmNlbnRlclggPSB0aGlzLndpZHRoIC8gMjtcclxuICAgICAgICAgICAgICAgICB0aGlzLmNlbnRlclkgPSB0aGlzLmhlaWdodCAvIDI7XHJcbiAgICAgICAgICAgICAgICAgICAgU3BhY2VjcmFmdC5wcm90b3R5cGUuaW5pdC5jYWxsKHRoaXMsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJhbGllblwiOlxyXG4gICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgdmFyIHNwcml0ZVNoZWV0SW5mbyA9IHt3aWR0aDo1MSxoZWlnaHQ6NDYsIG51bUNvbDo0LCBudW1Sb3c6MixmcHM6NjAsc3BlZWQ6MzAsbG9vcDpmYWxzZSxmcm9tOjAsdG86NH07XHJcbiAgICAgICAgICAgICAgICB2YXIgc3ByaXRlSW5kZXggPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkqc3ByaXRlU2hlZXRJbmZvLnRvKTtcclxuICAgICAgICAgICAgICAgIHNwcml0ZVNoZWV0SW5mby5mcm9tID0gc3ByaXRlU2hlZXRJbmZvLnRvID0gc3ByaXRlSW5kZXg7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNwcml0ZUFuaW1hdGlvbi5pbml0KHNwcml0ZVNoZWV0SW5mbyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnR5cGUgPSBcImFsaWVuXCI7XHJcbiAgICAgICAgICAgICAgICB0aGlzLndpZHRoID0gc3ByaXRlU2hlZXRJbmZvLndpZHRoO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSBzcHJpdGVTaGVldEluZm8uaGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jZW50ZXJYID0gdGhpcy53aWR0aCAvIDI7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNlbnRlclkgPSB0aGlzLmhlaWdodCAvIDI7XHJcbiAgICAgICAgICAgICAgICAgICAgU3BhY2VjcmFmdC5wcm90b3R5cGUuaW5pdC5jYWxsKHRoaXMsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICBicmVhazsgICAgIFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgIH07XHJcbiAgICBcclxuICAgIE1vdGhlcnNoaXAucHJvdG90eXBlLnNldFJlbGVhc2UgPSBmdW5jdGlvbihzaGlwc1Bvb2wsIG51bVNoaXBzLCB0aW1lKXtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGlmKHRoaXMuaGFzUmVsZWFzZWRTaGlwcyl7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47ICAgXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIC8vYXNzaWducyBudW1iZXIgb2Ygc2hpcHMgdG8gcmVsZWFzZVxyXG4gICAgICAgICAgICB0aGlzLm51bVNoaXBzID0gbnVtU2hpcHM7XHJcbiAgICAgICAgICAgIHRoaXMuc2hpcHNQb29sID0gc2hpcHNQb29sO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgLy9jaGVja3MgaWYgdGltZSB0byByZWxlYXNlIHNoaXBzIHdhcyBwYXNzZWQgaW5cclxuICAgICAgICAgICAgdGltZSA9ICh0eXBlb2YgdGltZSAhPSBcIm51bWJlclwiKT8gNTAwMDogdGltZTtcclxuXHRcdFxyXG5cdFx0XHR2YXIgc2VsZiA9IHRoaXM7XHJcblx0XHRcclxuXHRcdFx0dGhpcy5pbnRlcnZhbCA9IHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XHJcblx0XHRcdFx0Ly9yZWxlYXNlIHNoaXBzIGFmdGVyIHRoZSB0aW1lIGhhcyBwYXNzZWRcclxuXHRcdFx0XHRNb3RoZXJzaGlwLnByb3RvdHlwZS5yZWxlYXNlU2hpcHMuY2FsbChzZWxmKTtcclxuICAgICAgICAgICAgICAgIFxyXG5cdFx0XHR9LCB0aW1lKTsgICBcclxuXHRcdFxyXG4gICAgICAgIH07XHJcbiAgICBcclxuICAgIE1vdGhlcnNoaXAucHJvdG90eXBlLnJlbGVhc2VTaGlwcyA9IGZ1bmN0aW9uKCl7XHJcbiAgICAgICBcclxuICAgICAgICBjb25zb2xlLmxvZygnc2hpcCByZWxlYXNlIGZ1bmN0aW9uIGhhcyBiZWVuIGNhbGxlZCcpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgdGhpcy5oYXNSZWxlYXNlZFNoaXBzID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5zaGllbGQuYWN0aXZlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIFxyXG5cclxuICAgICAgICAgICAgZm9yKHZhciBpPTA7IGk8dGhpcy5udW1TaGlwczsgaSsrKXtcclxuICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIHZhciBwb3NpdGlvblggPSB0aGlzLnggKyB0aGlzLnNoaXBzUG9vbC5wb29sW2ldLndpZHRoKmk7XHJcbiAgICAgICAgICAgICAgICB2YXIgcG9zaXRpb25ZID0gdGhpcy55ICsgdGhpcy5zaGlwc1Bvb2wucG9vbFtpXS5oZWlnaHQqaTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2hpcHNQb29sLmdldChwb3NpdGlvblgsIHBvc2l0aW9uWSwgJ2VuZW15Jyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNoaXBzUG9vbC5wb29sW2ldLnNoaWVsZC5hY3RpdmUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIH0gXHJcbiAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgIH07XHJcbiAgICBcclxuICAgIE1vdGhlcnNoaXAucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpe1xyXG5cdFx0U3BhY2VjcmFmdC5wcm90b3R5cGUuZGVzdHJveS5jYWxsKHRoaXMpO1xyXG5cdFx0d2luZG93LmNsZWFyVGltZW91dCh0aGlzLmludGVydmFsKTtcclxuXHR9O1xyXG5cclxuICAgIE1vdGhlcnNoaXAucHJvdG90eXBlLnNwYXduID0gZnVuY3Rpb24oeCwgeSwgYW5nbGUsIHNwZWVkKXtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIFNwYWNlY3JhZnQucHJvdG90eXBlLnNwYXduLmNhbGwodGhpcywgeCwgeSwgYW5nbGUsIHNwZWVkKTtcclxuICAgICAgICAgICAgdGhpcy5oYXNSZWxlYXNlZFNoaXBzID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuYWxwaGEgPSAwO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICB9O1xyXG4gICAgXHJcbiAgICBNb3RoZXJzaGlwLnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIFNwYWNlY3JhZnQucHJvdG90eXBlLmRyYXcuY2FsbCh0aGlzKTtcclxuICAgICAgICBcclxuICAgICAgICAgICAgaWYodGhpcy5jb2xsaWRpbmcgfHwgIXRoaXMuYWxpdmUpe1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ3NoaXBzIGRlYWQgd29udCBkcmF3IGl0Jyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnggKz0gdGhpcy52ZWxYO1xyXG4gICAgICAgICAgICB0aGlzLnkgKz0gdGhpcy52ZWxZO1xyXG4gICAgICAgIFxyXG4gICAgICAgIFxyXG4gICAgICAgICAgICB0aGlzLmNvbnRleHQuc2F2ZSgpO1xyXG4gICAgICAgICAgICB0aGlzLmNvbnRleHQudHJhbnNsYXRlKHRoaXMueCt0aGlzLmNlbnRlclgsIHRoaXMueSt0aGlzLmNlbnRlclkpO1xyXG4gICAgICAgICAgICB0aGlzLmNvbnRleHQucm90YXRlKHRoaXMuYW5nbGUpO1xyXG4gICAgICAgICAgICBpZih0aGlzLmhhc1JlbGVhc2VkU2hpcHMpe1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hbHBoYSAtPSB0aGlzLmFscGhhU3BlZWQ7ICAgXHJcbiAgICAgICAgICAgICAgICB0aGlzLmFscGhhID0gKHRoaXMuYWxwaGEgPD0gMCk/IDA6IHRoaXMuYWxwaGE7IFxyXG4gICAgICAgICAgICAgICAgdGhpcy5hbGl2ZSA9ICh0aGlzLmFscGhhIDw9IDApPyBmYWxzZSA6IHRydWU7XHJcbiAgICAgICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICB0aGlzLmFscGhhICs9IHRoaXMuYWxwaGFTcGVlZDtcclxuICAgICAgICAgICAgdGhpcy5hbHBoYSA9ICh0aGlzLmFscGhhID49IDEpPyAxOiB0aGlzLmFscGhhO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5nbG9iYWxBbHBoYSA9IHRoaXMuYWxwaGE7XHJcbiAgICAgICAgICAgIHRoaXMuc3ByaXRlQW5pbWF0aW9uLnBsYXkoLXRoaXMuY2VudGVyWCwgLXRoaXMuY2VudGVyWSwgUmVzb3VyY2VMb2FkZXIuYXNzZXRzLk1vdGhlcnNoaXBTcHJpdGVTaGVldCk7XHJcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5yZXN0b3JlKCk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBpZih0aGlzLmFscGhhIDw9IDApe1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hbGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9IFxyXG4gICAgICAgIH07XHJcbiAgICBcclxuICAgIC8vIGV4cGxvc2lvbiBjb25zdHJ1Y3RvclxyXG5cdGZ1bmN0aW9uIEV4cGxvc2lvbihudW1QYXJ0aWNsZXMpe1xyXG4gICAgICAgIFxyXG4gICAgICAgICAgICBEaXNwbGF5LmNhbGwodGhpcyk7XHJcbiAgICAgICAgXHJcblx0XHR0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcclxuXHRcdHRoaXMucGFydGljbGVzID0gW107XHJcblx0XHR0aGlzLmRlYWRQYXJ0aWNsZUNvdW50ZXIgPSAwO1xyXG5cdFx0dGhpcy5zaXplID0gbnVtUGFydGljbGVzO1xyXG4gICAgICAgIFxyXG5cdFx0Zm9yKHZhciBpID0gMDsgaTxudW1QYXJ0aWNsZXM7IGkrKyl7XHJcblx0XHRcdHRoaXMucGFydGljbGVzLnB1c2goe3g6MCx5OjAsYWxpdmU6ZmFsc2UsbWF4TGlmZTowLHZlbFg6MCx2ZWxZOjAsIHdpZHRoOjIsIGhlaWdodDoyLCBsaWZlOjB9KTtcclxuXHRcdH1cclxuXHRcdFx0XHJcblx0fVxyXG4gICAgXHJcbiAgICBFeHBsb3Npb24ucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uKHgsIHkpe1xyXG4gICAgICAgIGlmKHRoaXMucnVubmluZyl7XHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR9XHJcblx0XHRcdFxyXG5cdFx0XHRmb3IodmFyIGk9MDtpPHRoaXMuc2l6ZTtpKyspe1xyXG5cdFx0XHRcdHZhciBjdXJyZW50UGFydGljbGUgPSB0aGlzLnBhcnRpY2xlc1tpXTtcclxuXHRcdFx0XHRjdXJyZW50UGFydGljbGUueCA9IHg7XHJcblx0XHRcdFx0Y3VycmVudFBhcnRpY2xlLnkgPSB5O1xyXG5cdFx0XHRcdGN1cnJlbnRQYXJ0aWNsZS5tYXhMaWZlID0gTWF0aC5yYW5kb20oKSo0NSsxNTtcclxuXHRcdFx0XHRjdXJyZW50UGFydGljbGUudmVsWCA9IE1hdGgucmFuZG9tKCkqNC0yLjg7XHJcblx0XHRcdFx0Y3VycmVudFBhcnRpY2xlLnZlbFkgPSBNYXRoLnJhbmRvbSgpKjQtMi44O1xyXG5cdFx0XHRcdGN1cnJlbnRQYXJ0aWNsZS5hbGl2ZSA9IHRydWU7XHJcblx0XHRcdFx0Y3VycmVudFBhcnRpY2xlLmxpZmUgPSAwO1xyXG5cdFx0XHR9XHJcblx0XHRcdHRoaXMucnVubmluZyA9IHRydWU7XHJcblx0XHRcdHRoaXMuZGVhZFBhcnRpY2xlQ291bnRlciA9IDA7XHJcbiAgICB9O1xyXG5cclxuICAgIEV4cGxvc2lvbi5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYoIXRoaXMucnVubmluZyl7XHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR9XHJcblx0XHRcdFxyXG5cdFx0XHR0aGlzLmNvbnRleHQuZmlsbFN0eWxlID0gJyMwMEZGMDAnO1xyXG5cdFx0XHRmb3IodmFyIGk9MDsgaTx0aGlzLnNpemU7IGkrKyl7XHJcblx0XHRcdFx0dmFyIGN1cnJlbnRQYXJ0aWNsZSA9IHRoaXMucGFydGljbGVzW2ldO1xyXG5cdFx0XHRcdGlmKGN1cnJlbnRQYXJ0aWNsZS5hbGl2ZSl7XHJcblx0XHRcdFx0Y3VycmVudFBhcnRpY2xlLnggKz0gY3VycmVudFBhcnRpY2xlLnZlbFg7XHJcblx0XHRcdFx0Y3VycmVudFBhcnRpY2xlLnkgKz0gY3VycmVudFBhcnRpY2xlLnZlbFk7XHJcblx0XHRcdFx0Y3VycmVudFBhcnRpY2xlLmxpZmUrKztcclxuXHRcdFx0XHR0aGlzLmNvbnRleHQuZmlsbFJlY3QoY3VycmVudFBhcnRpY2xlLngsIGN1cnJlbnRQYXJ0aWNsZS55LCBjdXJyZW50UGFydGljbGUud2lkdGgsIGN1cnJlbnRQYXJ0aWNsZS5oZWlnaHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihjdXJyZW50UGFydGljbGUubGlmZSA+PSBjdXJyZW50UGFydGljbGUubWF4TGlmZSl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQYXJ0aWNsZS5hbGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50UGFydGljbGUubGlmZSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGVhZFBhcnRpY2xlQ291bnRlcisrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0XHJcblx0XHRcdH1cclxuLy9jaGFuZ2UgdGhlIHN0YXRlIGZyb20gcnVubmluZyB0byBmYWxzZSBieSBjaGVja2luZyBpZiB0aGVyZSBhcmUgYW55IHBhcnRpY2xlcyBhbGl2ZSBsZWZ0XHJcblx0XHRcdGlmKHRoaXMuZGVhZFBhcnRpY2xlQ291bnRlcj49dGhpcy5zaXplKXtcclxuXHRcdFx0XHR0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcclxuXHRcdFx0fVxyXG4gICAgICAgIFxyXG4gICAgfTtcclxuICAgIFxyXG4gICAgLy9TaGllbGQgY29uc3RydWN0b3JcclxuXHRmdW5jdGlvbiBTaGllbGQoKXtcclxuICAgICAgICBcclxuICAgICAgICAgICAgRGlzcGxheS5jYWxsKHRoaXMpO1xyXG4gICAgICAgIFxyXG5cdFx0dGhpcy5yYWRpdXMgPSA0MDtcclxuXHRcdHRoaXMubWF4UmFkaXVzID0gNDU7XHJcbiAgICAgICAgdGhpcy5saWZlID0gMTAwO1xyXG4gICAgICAgIHRoaXMuZGlzYWJsZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmNvbG9yID0gJyMwMDAwRkYnO1xyXG4gICAgICAgIHRoaXMudHlwZSA9ICdzaGllbGQnO1xyXG4gICAgICAgIHZhciBzaGllbGRTdGF0ZSA9IGZhbHNlO1xyXG4gICAgXHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiYWN0aXZlXCIsIHtcclxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc2hpZWxkU3RhdGU7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSl7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIHNoaWVsZFN0YXRlID0gKHRoaXMuZGlzYWJsZWQpPyBmYWxzZTogdmFsdWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFsaXZlID0gc2hpZWxkU3RhdGU7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgXHJcblx0fVxyXG4gICAgXHJcbiAgICBTaGllbGQucHJvdG90eXBlLnJlZHVjZUxpZmUgPSBmdW5jdGlvbihhbW91bnQpe1xyXG4gICAgICAgIGFtb3VudCA9IChhbW91bnQgPT09IHVuZGVmaW5lZCk/IDUwOiBhbW91bnQ7XHJcbiAgICAgICAgdGhpcy5saWZlIC09IGFtb3VudDtcclxuICAgIH07XHJcbiAgICBcclxuICAgIFNoaWVsZC5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgXHJcbiAgICAgICAgICAgIGlmKCF0aGlzLmFjdGl2ZSl7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnc2hpZWxkIGlzIGRpc2FibGVkJyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYodGhpcy5saWZlIDw9IDApe1xyXG4gICAgICAgICAgICAgICAgdGhpcy5saWZlID0gMDtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGlzYWJsZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHRcdFx0dGhpcy5jb250ZXh0LnN0cm9rZVN0eWxlID0gdGhpcy5jb2xvcjtcclxuICAgICAgICAgICAgdGhpcy5jb250ZXh0LmxpbmVXaWR0aCA9IDE7XHJcblx0XHRcdHRoaXMuY29udGV4dC5iZWdpblBhdGgoKTsgXHJcblx0XHRcdHRoaXMuY29udGV4dC5hcmModGhpcy54K3RoaXMuY2VudGVyWCwgdGhpcy55K3RoaXMuY2VudGVyWSwgdGhpcy5yYWRpdXMsIDAsIE1hdGguUEkqMiwgdHJ1ZSk7XHJcblx0XHRcdHRoaXMuY29udGV4dC5jbG9zZVBhdGgoKTtcclxuXHRcdFx0dGhpcy5jb250ZXh0LnN0cm9rZSgpOyBcclxuXHRcdFx0dGhpcy5yYWRpdXMgKz0gLjI1O1xyXG5cdFx0XHR0aGlzLnJhZGl1cyA9ICh0aGlzLnJhZGl1cz50aGlzLm1heFJhZGl1cyk/IDQwOiB0aGlzLnJhZGl1cztcclxuICAgICAgICBcclxuICAgIH07XHJcbiAgICBcclxuICAgIFNoaWVsZC5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICB0aGlzLmxpZmUgPSAxMDA7XHJcbiAgICAgICAgICAgIHRoaXMuZGlzYWJsZWQgPSBmYWxzZTtcclxuICAgIH07XHJcbiAgICBcclxuICAgIC8vbWV0ZW9yIHBvb2xcclxuXHRmdW5jdGlvbiBQb29sKG1heFNpemUpe1xyXG4gICAgICAgIFxyXG5cdFx0dmFyIHBvb2wgPSBbXTtcclxuICAgICAgICBcclxuXHRcdHRoaXMucG9vbCA9IHBvb2w7XHJcbiAgICAgICAgdGhpcy5zaXplID0gbWF4U2l6ZTtcclxuICAgICAgICBcclxuXHR9XHJcbiAgICBcclxuICAgIFBvb2wucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbih0eXBlKXtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHN3aXRjaCh0eXBlKXtcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJtaXNzaWxlXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgIGZvcih2YXIgaT0wOyBpPHRoaXMuc2l6ZTsgaSsrKXtcclxuXHRcdFx0XHRcdHZhciBtaXNzaWxlID0gbmV3IE1pc3NpbGUoKTtcclxuXHRcdFx0XHRcdG1pc3NpbGUuc2V0Q2FudmFzKG1haW5DYW52YXMpO1xyXG5cdFx0XHRcdFx0bWlzc2lsZS5pbml0KDIsMik7XHJcblx0XHRcdFx0XHR0aGlzLnBvb2xbaV0gPSBtaXNzaWxlO1xyXG5cdFx0XHRcdH0gIFxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgY2FzZSBcImVuZW15XCI6XHJcbiAgICAgICAgICAgICAgICAgICBmb3IodmFyIGo9MDsgajx0aGlzLnNpemU7IGorKyl7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJhbmRvbVggPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkqbWFpbkNhbnZhcy53aWR0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJhbmRvbVkgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkqbWFpbkNhbnZhcy5oZWlnaHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlbmVteSA9IG5ldyBFbmVteSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGVuZW15LnNldENhbnZhcyhtYWluQ2FudmFzKTtcclxuICAgICAgICAgICAgICAgICAgICBlbmVteS5pbml0KDIzLCAyMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZW5lbXkueCA9IHJhbmRvbVg7XHJcbiAgICAgICAgICAgICAgICAgICAgZW5lbXkueSA9IHJhbmRvbVk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucG9vbFtqXSA9IGVuZW15O1xyXG4gICAgICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgfSBcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJwZXJrc1wiOlxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2l6ZSA9IE1hdGguZmxvb3IodGhpcy5zaXplIC8gMik7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZvcih2YXIgaz0wOyBrPHRoaXMuc2l6ZTsgaysrKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxpZmUgPSBuZXcgUGVyaygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsaWZlLnNldENhbnZhcyhtYWluQ2FudmFzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGlmZS5pbml0KFwibGlmZVwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wb29sLnB1c2gobGlmZSk7IFxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBoPTA7IGg8dGhpcy5zaXplOyBoKyspe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2hpZWxkID0gbmV3IFBlcmsoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2hpZWxkLnNldENhbnZhcyhtYWluQ2FudmFzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2hpZWxkLmluaXQoXCJzaGllbGRcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucG9vbC5wdXNoKHNoaWVsZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2l6ZSAqPSAyO1xyXG4gICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgY2FzZSBcInJvY2tzXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG51bU1lZGl1bVJvY2tzID0gdGhpcy5zaXplKjI7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG51bVNtYWxsUm9ja3MgPSBudW1NZWRpdW1Sb2NrcyoyO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBsPTA7IGw8dGhpcy5zaXplOyBsKyspe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1ldGVvciA9IG5ldyBSb2NrKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRlb3Iuc2V0Q2FudmFzKG1haW5DYW52YXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0ZW9yLmluaXQoXCJsYXJnZVwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGVvci50eXBlID0gXCJsYXJnZVJvY2tcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucG9vbC5wdXNoKG1ldGVvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBtPTA7IG08bnVtTWVkaXVtUm9ja3M7IG0rKyl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWV0ZW9yTWVkaXVtID0gbmV3IFJvY2soKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGVvck1lZGl1bS5zZXRDYW52YXMobWFpbkNhbnZhcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRlb3JNZWRpdW0uaW5pdChcIm1lZGl1bVwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGVvck1lZGl1bS50eXBlID0gXCJtZWRpdW1Sb2NrXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBvb2wucHVzaChtZXRlb3JNZWRpdW0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcih2YXIgbj0wOyBuPG51bVNtYWxsUm9ja3M7IG4rKyl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWV0ZW9yU21hbGwgPSBuZXcgUm9jaygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0ZW9yU21hbGwuc2V0Q2FudmFzKG1haW5DYW52YXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0ZW9yU21hbGwuaW5pdChcInNtYWxsXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0ZW9yU21hbGwudHlwZSA9IFwic21hbGxSb2NrXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBvb2wucHVzaChtZXRlb3JTbWFsbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNpemUgKz0gKG51bU1lZGl1bVJvY2tzK251bVNtYWxsUm9ja3MpO1xyXG4gICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFxyXG4gICAgfTtcclxuICAgIFxyXG4gICAgUG9vbC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oeCwgeSwgdHlwZSwgYW5nbGUsIHNwZWVkKXtcclxuICAgICAgICBcclxuICAgICAgICAgICAgdHlwZSA9IHR5cGUgfHwgXCJtaXNzaWxlXCI7XHJcbiAgICAgICAgXHJcbiAgICAgICAgICAgIC8qIGNvZGUgZnJvbSBiZWZvcmUgbWl4aW5nIGJvdGggcG9vbHMgbWV0ZW9yIGFuZCByZWd1bGFyIFxyXG5cdFx0XHRpZighdGhpcy5wb29sW3NpemUtMV0uYWxpdmUpe1xyXG5cdFx0XHRcdHRoaXMucG9vbFtzaXplLTFdLnNwYXduKHgseSwgYW5nbGUsIHNwZWVkKTtcclxuXHRcdFx0XHR0aGlzLnBvb2wudW5zaGlmdChwb29sLnBvcCgpKTtcclxuXHRcdFx0fVxyXG4gICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB2YXIgaSA9IDA7XHJcblxyXG4gICAgICAgICAgICAgICAgd2hpbGUoaTx0aGlzLnNpemUpe1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKHRoaXMucG9vbFtpXS50eXBlID09PSB0eXBlICYmICF0aGlzLnBvb2xbaV0uYWxpdmUpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBvb2xbaV0uc3Bhd24oeCwgeSwgYW5nbGUsIHNwZWVkKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGkrKzsgICAgIFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgfTtcclxuXHJcbiAgICBQb29sLnByb3RvdHlwZS5pc0NvbGxpZGluZ1dpdGggPSBmdW5jdGlvbihhcmdzKXtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHZhciBsZW5ndGggPSB0aGlzLnBvb2wubGVuZ3RoO1xyXG4gICAgICAgICAgICB2YXIgYXJnc0xlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpPGxlbmd0aDsgaSsrKXtcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRJdGVtID0gdGhpcy5wb29sW2ldO1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICBpZihjdXJyZW50SXRlbS5hbGl2ZSl7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIGZvcih2YXIgaCA9IDA7IGg8YXJnc0xlbmd0aDsgaCsrKXtcclxuICAgICAgICAgICAgICAgICAgICAvL2VhY2ggYXJndW1lbnQgcmVwcmVzZW50cyB0aGUgb2JqZWN0cyBiZWluZyBwYXNzZWQgaW4gdG8gdGhpcyBtZXRob2QuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRBcmd1bWVudCA9IGFyZ3VtZW50c1toXTtcclxuXHRcdFx0XHRcdFxyXG5cdFx0XHRcdFx0Ly9pZiBvbmUgb2YgdGhlIGFyZ3VtZW50cyB0byBjaGVjayBmb3IgY29sbGlzaW9uIGlzIGEgcG9vbCBvZiBvYmplY3RzLCBpdGVyYXRlIG92ZXIgZWFjaCBpdGVtLlxyXG5cdFx0XHRcdFx0aWYoQXJyYXkuaXNBcnJheShjdXJyZW50QXJndW1lbnQpKXtcclxuXHRcdFx0XHRcdFx0Zm9yKHZhciBqID0gMCwgbGVuID0gY3VycmVudEFyZ3VtZW50Lmxlbmd0aDsgaiA8IGxlbjsgaisrKXtcclxuXHRcdFx0XHRcdFx0XHR2YXIgY3VycmVudFBvb2xJdGVtID0gY3VycmVudEFyZ3VtZW50W2pdO1xyXG5cdFx0XHRcdFx0XHRcdGNoZWNrQ29sbGlzaW9uKGN1cnJlbnRJdGVtLCBjdXJyZW50UG9vbEl0ZW0pO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9ZWxzZXtcclxuXHRcdFx0XHRcdFx0XHRjaGVja0NvbGxpc2lvbihjdXJyZW50SXRlbSwgY3VycmVudEFyZ3VtZW50KTtcclxuXHRcdFx0XHRcdCAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgfVxyXG5cdFx0XHQvL2Z1bmN0aW9uIGluIGNoYXJnZSBvZiB0ZXN0aW5nIGZvciBjb2xsaXNpb24gYW5kIGV4ZWN1dGluZyB3aGF0IHRvIGRvIHdoZW4gdGhlcmUgaXMgYSBjb2xsaXNpb24sIGl0IGFsc28gbWFrZXMgYSBjYWxsIHRvIHRoZSByZWNvcmRDb2xsaXNpb24gZnVuY3Rpb24gd2hpY2ggaGFuZGxlcyB0aGUgcmVjb3JkaW5nIG9mIGNvbGxpc2lvbnMgZm9yIHBvaW50cyBhbmQgc2NvcmUuXHJcblx0XHRcdGZ1bmN0aW9uIGNoZWNrQ29sbGlzaW9uKGl0ZW0xLCBpdGVtMil7XHJcblx0XHRcdFx0XHJcblx0XHRcdFx0XHRpZihBbGdvcml0aG1zLmhpdFRlc3QoaXRlbTEsIGl0ZW0yKSl7XHJcblx0XHRcdFx0XHRcdFx0aWYoaXRlbTIgaW5zdGFuY2VvZiBTaGllbGQpe1xyXG5cdFx0XHRcdFx0XHRcdFx0aWYoIShpdGVtMSBpbnN0YW5jZW9mIFJvY2spKXtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpdGVtMS5kZXN0cm95KCk7XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0aXRlbTIucmVkdWNlTGlmZSgxMCk7XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly9yZWNvcmRDb2xsaXNpb24oaXRlbTEudHlwZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBQdWJTdWIucHVibGlzaCgnY29sbGlzaW9uJywgaXRlbTEudHlwZSk7XHJcblx0XHRcdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRcdH1lbHNlIGlmKGl0ZW0xIGluc3RhbmNlb2YgUGVyayl7XHJcblx0XHRcdFx0XHRcdFx0XHRcdGl0ZW0xLmRlc3Ryb3koKTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0Ly9yZWNvcmRDb2xsaXNpb24oaXRlbTEudHlwZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFB1YlN1Yi5wdWJsaXNoKCdjb2xsaXNpb24nLCBpdGVtMS50eXBlKTtcclxuXHRcdFx0XHRcdFx0XHRcdH1lbHNle1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRpdGVtMi5kZXN0cm95KCk7XHJcblx0XHRcdFx0XHRcdFx0XHRcdGl0ZW0xLmRlc3Ryb3koKTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0Ly9yZWNvcmRDb2xsaXNpb24oaXRlbTIudHlwZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFB1YlN1Yi5wdWJsaXNoKCdjb2xsaXNpb24nLCBpdGVtMi50eXBlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUHViU3ViLnB1Ymxpc2goJ2NvbGxpc2lvbicsIGl0ZW0xLnR5cGUpO1xyXG5cdFx0XHRcdFx0XHRcdFx0XHQvL3JlY29yZENvbGxpc2lvbihpdGVtMS50eXBlKTtcclxuXHRcdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG4gICAgfTtcclxuICAgIFxyXG4gICAgUG9vbC5wcm90b3R5cGUuaGlkZUl0ZW1zICA9IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgIHZhciBsZW5ndGggPSB0aGlzLnBvb2wubGVuZ3RoO1xyXG4gICAgICAgICAgICBmb3IodmFyIGk9MDsgaTxsZW5ndGg7IGkrKyl7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBvb2xbaV0uYWxpdmUgPSBmYWxzZTsgXHJcbiAgICAgICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgZnVuY3Rpb24gU3ByaXRlQW5pbWF0aW9uKCl7XHJcblx0XHQgXHJcbiAgICAgICAgdGhpcy53aWR0aDtcclxuICAgICAgICB0aGlzLmhlaWdodDtcclxuICAgICAgICB0aGlzLng7XHJcbiAgICAgICAgdGhpcy55O1xyXG5cdFx0dGhpcy5vZmZzZXRYID0gMDtcclxuXHRcdHRoaXMub2Zmc2V0WSA9IDA7XHJcbiAgICAgICAgdGhpcy5jb250ZXh0O1xyXG4gICAgICAgIHRoaXMuY2FudmFzSGVpZ2h0O1xyXG4gICAgICAgIHRoaXMuY2FudmFzV2lkdGg7XHJcbiAgICAgICAgdGhpcy5zcGVlZDtcclxuICAgICAgICB0aGlzLm51bUNvbDtcclxuICAgICAgICB0aGlzLm51bVJvdztcclxuICAgICAgICB0aGlzLmN1cnJlbnRGcmFtZTtcclxuICAgICAgICB0aGlzLmZpbmFsRnJhbWU7XHJcbiAgICAgICAgdGhpcy5zdGFydEZyYW1lO1xyXG4gICAgICAgIHRoaXMudG90YWxGcmFtZXM7XHJcbiAgICAgICAgdGhpcy5hcHBGUFM7XHJcblx0XHQgLy9zcHJpdGVzaGVldCBhbmltYXRpb25zIGxvb3BzIGJ5IGRlZmF1bHRcclxuICAgICAgICB0aGlzLmxvb3AgPSB0cnVlO1xyXG5cdFx0ICAgIC8vcHJpdmF0ZSBtZW1iZXJzIFxyXG4gICAgIFx0dGhpcy5fZnJhbWVzID0gW107XHJcbiAgICAgICAgdGhpcy5fZnJhbWVJbmNyZW1lbnQ7XHJcbiAgICAgICAgdGhpcy5fZnJhbWVJbmRleDtcclxuXHJcblx0XHQgXHJcblx0IH1cclxuXHRcclxuICAgICBTcHJpdGVBbmltYXRpb24ucHJvdG90eXBlLnNldENhbnZhcyA9IGZ1bmN0aW9uKGNhbnZhcyl7XHJcbiAgICAgICAgICAgIHRoaXMuY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xyXG4gICAgICAgICAgICB0aGlzLmNhbnZhc0hlaWdodCA9IGNhbnZhcy5oZWlnaHQ7XHJcbiAgICAgICAgICAgIHRoaXMuY2FudmFzV2lkdGggPSBjYW52YXMud2lkdGg7XHJcbiAgICAgIH07XHJcblx0XHJcbiAgICAgU3ByaXRlQW5pbWF0aW9uLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24oc3ByaXRlT2JqZWN0KXtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIC8vc2V0cyB1cCBzcHJpdGUgcHJvcGVydGllcyBmcm9tIHRoZSBzcHJpdGVzaGVldCBpbmZvIG9iamVjdCBiZWluZyBwYXNzZWQgaW4uXHJcbiAgICAgICAgICAgIHRoaXMud2lkdGggPSBzcHJpdGVPYmplY3Qud2lkdGggfHwgMzI7XHJcbiAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gc3ByaXRlT2JqZWN0LmhlaWdodCB8fCAzMjtcclxuICAgICAgICAgICAgdGhpcy5udW1Db2wgPSBzcHJpdGVPYmplY3QubnVtQ29sIHx8IDE7XHJcbiAgICAgICAgICAgIHRoaXMubnVtUm93ID0gc3ByaXRlT2JqZWN0Lm51bVJvdyB8fCAxO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXJ0RnJhbWUgPSBzcHJpdGVPYmplY3QuZnJvbSB8fCAwO1xyXG4gICAgICAgICAgICB0aGlzLmZpbmFsRnJhbWUgPSBzcHJpdGVPYmplY3QudG8gfHwgMDtcclxuICAgICAgICAgICAgdGhpcy5zcGVlZCA9IHNwcml0ZU9iamVjdC5zcGVlZCB8fCAxNTtcclxuXHRcdCBcdHRoaXMub2Zmc2V0WCA9IHNwcml0ZU9iamVjdC5vZmZzZXRYIHx8IDA7XHJcblx0XHQgXHR0aGlzLm9mZnNldFkgPSBzcHJpdGVPYmplY3Qub2Zmc2V0WSB8fCAwO1xyXG4gICAgICAgICAgICB0aGlzLnRvdGFsRnJhbWVzID0gc3ByaXRlT2JqZWN0Lm51bUNvbCAqIHNwcml0ZU9iamVjdC5udW1Sb3cgLSAxO1xyXG4gICAgICAgICAgICB0aGlzLmxvb3AgPSBzcHJpdGVPYmplY3QubG9vcCB8fCB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLmFwcEZQUyA9IHNwcml0ZU9iamVjdC5mcHM7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvL2NyZWF0ZXMgdGhlIGRlY2ltYWwgb2YgaW5jcmVtZW50IGZvciBlYWNoIHNlY29uZFxyXG4gICAgICAgICAgICB0aGlzLl9mcmFtZUluY3JlbWVudCA9IHRoaXMuc3BlZWQvc3ByaXRlT2JqZWN0LmZwcztcclxuICAgICAgICAgICAgdGhpcy5fZnJhbWVJbmRleCA9IHRoaXMuc3RhcnRGcmFtZTsgICAgICAgIFxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgLy9jcmVhdGVzIGEgdmFyaWFibGUgaG9sZGluZyB0aGUgbGVuZ3RoIG9mIHRoZSBhcnJheSBob2xkaW5nIHRoZSBmcmFtZXNcclxuICAgICAgICAgICAgdmFyIHRvdGFsRnJhbWVzTGVuZ3RoID0gc3ByaXRlT2JqZWN0Lm51bUNvbCAqIHNwcml0ZU9iamVjdC5udW1Sb3c7XHJcblxyXG4gICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgdG90YWxGcmFtZXNMZW5ndGg7IGkrKyl7XHJcbiAgICAgICAgICAgICAgICB2YXIgZnJhbWUgPSB7fTtcclxuXHRcdFx0XHRcdGZyYW1lLnJlZ1ggPSB0aGlzLm9mZnNldFg7XHJcblx0XHRcdFx0XHRmcmFtZS5yZWdZID0gdGhpcy5vZmZzZXRZO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIGZyYW1lLnJlZ1ggKz0gKGkgJSB0aGlzLm51bUNvbCkqdGhpcy53aWR0aDtcclxuICAgICAgICAgICAgICAgIGZyYW1lLnJlZ1kgKz0gKGkgJSB0aGlzLm51bVJvdykqdGhpcy5oZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIC8vcHVzaGVzIHRoZSBvYmplY3RzIHdpdGggdGhlIHJlZ1ggYW5kIHJlZ1kgZm9yIGVhY2ggZnJhbWUgaW50byBhIGZyYW1lIGFycmF5LlxyXG4gICAgICAgICAgICAgICAgdGhpcy5fZnJhbWVzLnB1c2goZnJhbWUpO1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vdXNlIHRoaXMgbWV0aG9kIHRvIGxvY2F0ZSBvciBtb3ZlIHRoZSBzcHJpdGUgc2hlZXQgdG8gYSBjb3JkaW5hdGVcclxuICAgICBTcHJpdGVBbmltYXRpb24ucHJvdG90eXBlLnBsYXkgPSBmdW5jdGlvbih4LCB5LCBzcHJpdGUpe1xyXG4gICAgICAgICAgICB0aGlzLnggPSB4IHx8IDA7XHJcbiAgICAgICAgICAgIHRoaXMueSA9IHkgfHwgMDtcclxuXHJcbiAgICAgICAgICAgIC8vbm8gYW5pbWF0aW9uIHdpbGwgYmUgcGxheWVlZCBpZiB0aGUgc3RhcnRpbmcgZnJhbWUgaXMgZXF1YWwgdG8gdGhlIGZpbmFsIGZyYW1lLlxyXG4gICAgICAgICAgICBpZih0aGlzLnN0YXJ0RnJhbWUgPT09IHRoaXMuZmluYWxGcmFtZSl7XHJcblx0XHRcdFx0XHJcblx0Ly9zdXJyb3VuZHMgdGhlIHNwcml0ZSBpbnRvIGEgd2hpdGUgYmxvY2sgZm9yIGRlYnVnZ2luZyBwdXJwb3NlcywgeW91IGNhbiByZW1vdmUgdGhpcyBpbiB5b3VyIGZpbmFsIGFwcFxyXG4gICAgICAgICAgICAgICAgLy90aGlzLmNvbnRleHQuc3Ryb2tlU3R5bGUgPSAnI0ZGRkZGRic7XHJcbiAgICAgICAgICAgICAgICAvL3RoaXMuY29udGV4dC5zdHJva2VSZWN0KHRoaXMueCwgdGhpcy55LCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XHJcbiAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50RnJhbWUgPSB0aGlzLl9mcmFtZXNbdGhpcy5zdGFydEZyYW1lXTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5kcmF3SW1hZ2Uoc3ByaXRlLCB0aGlzLmN1cnJlbnRGcmFtZS5yZWdYLCB0aGlzLmN1cnJlbnRGcmFtZS5yZWdZLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgdGhpcy54LCB0aGlzLnksIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgICAgIC8vaW5jcmVtZW50cyB0aGUgZnJhbWVJbmRleCBieSBhIGRlY2ltYWwsIHRoaXMgd2lsbCBiZSBmbG9vcmVkIGJlY2F1c2UgaXQgaXMgdXNlZCB0byBmaW5kIGFuIGl0ZW0gaW4gdGhlIGZyYW1lIGFycmF5LlxyXG4gICAgICAgICAgICAgICAgdGhpcy5fZnJhbWVJbmRleCArPSB0aGlzLl9mcmFtZUluY3JlbWVudDtcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgaWYodGhpcy5fZnJhbWVJbmRleCA+PSB0aGlzLmZpbmFsRnJhbWUgKyAxKXtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9mcmFtZUluZGV4ID0gKHRoaXMubG9vcCk/IHRoaXMuc3RhcnRGcmFtZTogdGhpcy5maW5hbEZyYW1lO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy9mbG9vcnMgdGhlIGN1cnJlbnQgaW5kZXggdG8gYSB3aG9sZSBudW1iZXIgc28gdG8gZmluZCBhbiBvYmplY3QgaW4gdGhlIGZyYW1lIGFycmF5XHJcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRGcmFtZSA9IHRoaXMuX2ZyYW1lc1tNYXRoLmZsb29yKHRoaXMuX2ZyYW1lSW5kZXgpXTtcclxuICAgICAgICAgICAgICAgIC8vc3Vycm91bmRzIHRoZSBzcHJpdGUgaW50byBhIHdoaXRlIGJsb2NrIGZvciBkZWJ1Z2dpbmcgcHVycG9zZXMsIHlvdSBjYW4gcmVtb3ZlIHRoaXMgaW4geW91ciBmaW5hbCBhcHBcclxuICAgICAgICAgICAgICAgIC8vdGhpcy5jb250ZXh0LnN0cm9rZVN0eWxlID0gJyNGRkZGRkYnO1xyXG4gICAgICAgICAgICAgICAgLy90aGlzLmNvbnRleHQuc3Ryb2tlUmVjdCh0aGlzLngsIHRoaXMueSwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xyXG4gICAgICAgICAgICAgICAgLy9kcmF3cyB0aGUgc2VjdGlvbiBvZiB0aGUgaW1hZ2UgZ2l2ZW4gdGhlIHJlZ1ggYW5kIHJlZ1kgYXMgd2VsbCBhcyB0aGUgd2lkdGggYW5kIGhlaWdodFxyXG4gICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmRyYXdJbWFnZShzcHJpdGUsIHRoaXMuY3VycmVudEZyYW1lLnJlZ1gsIHRoaXMuY3VycmVudEZyYW1lLnJlZ1ksIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCB0aGlzLngsIHRoaXMueSwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpOyBcclxuICAgICAgICAgICAgfSBcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vdXNlIHRoaXMgbWV0aG9kIHRvIGNoYW5nZSB0aGUgZnBzIHNwZWVkIG9mIHlvdXIgc3ByaXRlIHNoZWV0IGFuaW1hdGlvblxyXG4gICAgIFNwcml0ZUFuaW1hdGlvbi5wcm90b3R5cGUuc2V0U3BlZWQgPSBmdW5jdGlvbihzcGVlZCl7XHJcbiAgICAgICAgICAgIC8vcmVhc29uIHdoeSBhIG1ldGhvZCBmb3IgdGhpcyBpcyBuZWVkZWQgaXMgYmVjYXVzZSB0aGVyZSBpcyAgbWF0aCB0byBiZSBkb25lIHdoZW4gc3BlZWQgaXMgY2hhbmdlZC5cclxuICAgICAgICAgIHRoaXMuc3BlZWQgPSBzcGVlZCB8fCB0aGlzLnNwZWVkO1xyXG4gICAgICAgICAgICB0aGlzLl9mcmFtZUluY3JlbWVudCA9IHRoaXMuc3BlZWQgLyB0aGlzLmFwcEZQUztcclxuICAgICAgICAgICAgdGhpcy5fZnJhbWVJbmRleCA9IHRoaXMuc3RhcnRGcmFtZTsgICBcclxuICAgICAgICB9OyBcclxuXHRcclxuICAgICBTcHJpdGVBbmltYXRpb24ucHJvdG90eXBlLmdldEZyYW1lID0gZnVuY3Rpb24oZnJhbWVJbmRleCl7XHJcbiAgICAgICAgICAgIHRoaXMuX2ZyYW1lSW5kZXggPSAoZnJhbWVJbmRleCA9PSB1bmRlZmluZWQpPyAwOiBmcmFtZUluZGV4O1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZnJhbWVzW3RoaXMuX2ZyYW1lSW5kZXhdO1xyXG4gICAgICAgIH07XHJcbiAgICBcclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgICBcclxuICAgIERpc3BsYXkgOiBEaXNwbGF5LFxyXG4gICAgUGh5aXNjcyA6IFBoeXNpY3MsXHJcbiAgICBTcGFjZWNyYWZ0IDogU3BhY2VjcmFmdCxcclxuICAgIFJvY2sgOiBSb2NrLFxyXG4gICAgQmFja2dyb3VuZCA6IEJhY2tncm91bmQsXHJcbiAgICBTaGlwIDogU2hpcCxcclxuICAgIFBlcmsgOiBQZXJrLFxyXG4gICAgTWlzc2lsZSA6IE1pc3NpbGUsXHJcbiAgICBFbmVteSA6IEVuZW15LFxyXG4gICAgTW90aGVyc2hpcCA6IE1vdGhlcnNoaXAsXHJcbiAgICBFeHBsb3Npb24gOiBFeHBsb3Npb24sXHJcbiAgICBTaGllbGQgOiBTaGllbGQsXHJcbiAgICBQb29sIDogUG9vbCxcclxuICAgIFNwcml0ZUFuaW1hdGlvbiA6IFNwcml0ZUFuaW1hdGlvblxyXG4gICAgXHJcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2pzL0NvbnN0cnVjdG9ycy5qc1xuICoqIG1vZHVsZSBpZCA9IDRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vY2hlY2tzIGlmIGFuIG9iamVjdCBoYXMgbGVmdCB0aGUgY2FudmFzIGJvdWRpbmcgYm94XHJcbmZ1bmN0aW9uIGNoZWNrQm91bmRhcnkob2JqZWN0KXtcclxuXHJcblx0XHRpZihvYmplY3QueCA+PSBvYmplY3QuY2FudmFzV2lkdGgpe1xyXG5cdFx0XHRvYmplY3QueCA9IDA7XHJcblx0XHR9ZWxzZSBpZihvYmplY3QueCA8PSAtb2JqZWN0LndpZHRoKXtcclxuXHRcdFx0b2JqZWN0LnggPSBvYmplY3QuY2FudmFzV2lkdGgtb2JqZWN0LndpZHRoO1xyXG5cdFx0fWVsc2UgaWYob2JqZWN0LnkgPj0gb2JqZWN0LmNhbnZhc0hlaWdodCtvYmplY3QuaGVpZ2h0KXtcclxuXHRcdFx0b2JqZWN0LnkgPSAwO1xyXG5cdFx0fWVsc2UgaWYob2JqZWN0LnkgPD0gLW9iamVjdC5oZWlnaHQpe1xyXG5cdFx0XHRvYmplY3QueSA9IG9iamVjdC5jYW52YXNIZWlnaHQtb2JqZWN0LmhlaWdodDtcclxuXHRcdH1cdFxyXG5cdH1cclxuXHRcclxuXHQvL2NvbGxpc2lvbiBkZXRlY3Rpb24uXHJcbmZ1bmN0aW9uIGhpdFRlc3Qob2JqZWN0MSwgb2JqZWN0Mil7XHJcbiAgIFx0XHR2YXIgbGVmdDEgPSBvYmplY3QxLng7XHJcbiAgIFx0XHR2YXIgbGVmdDIgPSBvYmplY3QyLng7XHJcbiAgIFx0XHR2YXIgcmlnaHQxID0gb2JqZWN0MS54ICsgb2JqZWN0MS53aWR0aDtcclxuICAgXHRcdHZhciByaWdodDIgPSBvYmplY3QyLnggKyBvYmplY3QyLndpZHRoO1xyXG4gICBcdFx0dmFyIHRvcDEgPSBvYmplY3QxLnk7XHJcbiAgIFx0XHR2YXIgdG9wMiA9IG9iamVjdDIueTtcclxuICAgXHRcdHZhciBib3R0b20xID0gb2JqZWN0MS55ICsgb2JqZWN0MS5oZWlnaHQ7XHJcbiAgIFx0XHR2YXIgYm90dG9tMiA9IG9iamVjdDIueSArIG9iamVjdDIuaGVpZ2h0O1xyXG5cclxuICAgXHRcdGlmIChib3R0b20xIDwgdG9wMikgcmV0dXJuKGZhbHNlKTtcclxuICAgXHRcdGlmICh0b3AxID4gYm90dG9tMikgcmV0dXJuKGZhbHNlKTtcclxuICAgXHRcdGlmIChyaWdodDEgPCBsZWZ0MikgcmV0dXJuKGZhbHNlKTtcclxuICAgXHRcdGlmIChsZWZ0MSA+IHJpZ2h0MikgcmV0dXJuKGZhbHNlKTtcclxuICAgICAgICBpZiAoIW9iamVjdDEuYWxpdmUgfHwgb2JqZWN0MS5jb2xsaWRpbmcgfHwgb2JqZWN0Mi5jb2xsaWRpbmcgfHwgIW9iamVjdDIuYWxpdmUpIHJldHVybihmYWxzZSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKG9iamVjdDEudHlwZSA9PSBcImh1bWFuU2hpcFwiICYmIG9iamVjdDEudmVsWCA9PSAwKSByZXR1cm4oZmFsc2UpO1xyXG4gICAgICAgIGlmIChvYmplY3QyLnR5cGUgPT0gXCJodW1hblNoaXBcIiAmJiBvYmplY3QyLnZlbFggPT0gMCkgcmV0dXJuKGZhbHNlKTtcclxuICAgICAgICBcclxuICAgICAgICBpZihvYmplY3QyLmhhc093blByb3BlcnR5KCdzaGllbGQnKSl7XHJcbiAgICAgICAgICAgIGlmKG9iamVjdDIuc2hpZWxkLmFjdGl2ZSl7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKGZhbHNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZihvYmplY3QxLmhhc093blByb3BlcnR5KCdzaGllbGQnKSl7XHJcbiAgICAgICAgICAgIGlmKG9iamVjdDEuc2hpZWxkLmFjdGl2ZSl7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKGZhbHNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuXHJcbiAgICAgICAgLy9vdGhlcndpc2UgcmV0dXJuIHRydWUgXHJcbiAgIFx0XHRyZXR1cm4odHJ1ZSk7XHJcblxyXG5cdH1cclxuXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgIFxyXG4gICAgY2hlY2tCb3VuZGFyeSA6IGNoZWNrQm91bmRhcnksXHJcbiAgICBoaXRUZXN0IDogaGl0VGVzdFxyXG4gICAgXHJcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2pzL0FsZ29yaXRobXMuanNcbiAqKiBtb2R1bGUgaWQgPSA1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgUHViU3ViID0gcmVxdWlyZSgnLi9QdWJTdWInKSxcclxuXHJcblx0Ly9zdGF0ZSBkaWN0aW9uYXJ5IGdpdmVuIHByb3BlcnR5IG5hbWVzIGZvciBlYWNoIHN0YXRlLiBcclxuICAgIHN0YXRlID0ge1xyXG4gICAgICAgIGxvYWRpbmc6IDAsXHJcbiAgICAgICAgc3RvcnlMaW5lIDogMSxcclxuXHQgICAgdGl0bGVTY3JlZW4gOiAyLFxyXG4gICAgICAgIGdhbWVQbGF5IDogMyxcclxuICAgICAgICBsZXZlbFRyYW5zaXRpb24gOiA0LFxyXG4gICAgICAgIGJlYXRHYW1lIDogNSxcclxuICAgICAgICBnYW1lT3ZlciA6IDYsXHJcbiAgICAgICAgY3JlZGl0cyA6IDcsXHJcbiAgICAgICAgaG93VG9QbGF5IDogOCxcclxuICAgICAgICBvblBhdXNlIDogOSxcclxuICAgICAgICBzaGlwSnVtcCA6IDEwLFxyXG4gICAgICAgIHNldFVwTGV2ZWw6IDExLFxyXG5cclxuICAgICAgICBjdXJyZW50IDogLTEgXHJcbiAgICB9O1xyXG5cclxuZnVuY3Rpb24gaW5pdCgpe1xyXG4gICAgXHJcbiAgICBpZih0aGlzLmhhc0luaXRpYWxpemVkKSByZXR1cm4gdGhpcztcclxuICAgICBcclxuICAgIHRoaXMuaGFzSW5pdGlhbGl6ZWQgPSB0cnVlO1xyXG4gICAgdGhpcy5wYWdlcyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ2FwcFBhZ2UnKTtcclxuICAgIHRoaXMuaW50ZXJmYWNlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2ludGVyZmFjZVdyYXBwZXInKTtcclxuICAgIHRoaXMuY291bnRlcnMgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdjb3VudGVyJyk7XHJcbiAgICB0aGlzLnN1YklkID0gUHViU3ViLnN1YnNjcmliZSgnc3RhdGVjaGFuZ2UnLCBoYW5kbGVTdGF0ZUNoYW5nZS5iaW5kKHRoaXMpKTtcclxuICAgIC8vQWRkcyBtb3VzZWRvd24gZXZlbnQgbGlzdGVuZXIgdG8gdGhlIGRpdiBjb250YWluaW5nIGFsbCB0aGUgYXBwIHBhZ2VzXHJcblx0dGhpcy5pbnRlcmZhY2UuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgaGFuZGxlQ2xpY2spO1xyXG4gICAgXHJcbiAgICByZXR1cm4gdGhpcztcclxuICAgIFxyXG59XHJcblxyXG5mdW5jdGlvbiBoYW5kbGVDbGljayhldmVudCl7XHJcbiAgICBcclxuICAgIHZhciBidXR0b24gPSBldmVudC50YXJnZXQsXHJcbiAgICAgICAgZnJvbSA9IGJ1dHRvbi5nZXRBdHRyaWJ1dGUoJ2RhdGEtZnJvbScpLFxyXG4gICAgICAgIHRvID0gYnV0dG9uLmdldEF0dHJpYnV0ZSgnZGF0YS10bycpO1xyXG4gICAgXHJcblx0Ly9pZiB0aGUgZWxlbWVudCB0aGF0IHRyaWdnZXJlZCBldmVudCBoYXMgZGF0YS10byBhbmQgZnJvbSBhdHRyaWJ1dGVzLCB0cmlnZ2VyIGV2ZW50LlxyXG4gICAgaWYoZnJvbSAmJiB0byl7XHJcbiAgICAgICAgIFB1YlN1Yi5wdWJsaXNoKCdzdGF0ZWNoYW5nZScsIHtmcm9tOiBzdGF0ZVtmcm9tXSwgdG86IHN0YXRlW3RvXX0pOyAgIFxyXG4gICAgfVxyXG4gICAgXHJcbn1cclxuXHJcbmZ1bmN0aW9uIHVwZGF0ZUNvdW50ZXJzKGNvdW50ZXIsIHZhbHVlKXtcclxuICAgIFxyXG5cdC8vaWYgdGhlIGNvdW50ZXIgZXhpc3RzIHVwZGF0ZSBpdHMgdmFsdWUuXHJcblx0aWYodGhpcy5jb3VudGVyc1tjb3VudGVyXSl7XHJcblxyXG5cdFx0IHRoaXMuY291bnRlcnNbY291bnRlcl0uaW5uZXJIVE1MID0gdmFsdWU7XHJcblx0XHRcclxuXHR9XHJcbiAgIFxyXG4gICAgXHJcbiAgICByZXR1cm4gdGhpcztcclxuICAgIFxyXG59XHJcblxyXG5mdW5jdGlvbiBzaG93KHBhZ2VOYW1lKXtcclxuXHRcclxuICAgIC8vaWYgdGhlIHBhZ2UgZXhpc3RzIHNob3cgaXQuIFxyXG4gICAgaWYodGhpcy5wYWdlc1twYWdlTmFtZV0pe1xyXG4gICAgICAgIFxyXG4gICAgICAgIHRoaXMucGFnZXNbcGFnZU5hbWVdLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCAnZGlzcGxheTogYmxvY2s7Jyk7XHJcbiAgICAgICAgXHJcbiAgICB9XHJcbiAgICBcclxuICAgIHJldHVybiB0aGlzO1xyXG4gICAgXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGhpZGUocGFnZU5hbWUpe1xyXG4gICAgXHJcblx0Ly9pZiB0aGUgcGFnZSBpcyBkZWZpbmVkLCBoaWRlIGl0LiBcclxuICAgIGlmKHRoaXMucGFnZXNbcGFnZU5hbWVdKXtcclxuICAgICAgICBcclxuICAgICAgICB0aGlzLnBhZ2VzW3BhZ2VOYW1lXS5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgJ2Rpc3BsYXk6IG5vbmU7Jyk7XHJcbiAgICAgICAgXHJcbiAgICB9XHJcbiAgICBcclxuICAgIHJldHVybiB0aGlzO1xyXG4gICAgXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGhpZGVBbGwoKXtcclxuICAgIFxyXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cdFxyXG4gXHQvL2RlbGVnYXRlcyB0aGUgZm9yRWFjaCBhcnJheSBtZXRob2QgdG8gaXRlcmF0ZSBhbmQgaGlkZSBlYWNoIHBhZ2UuXHJcbiAgICBbXS5mb3JFYWNoLmNhbGwodGhpcy5wYWdlcywgZnVuY3Rpb24oY3VycmV0UGFnZSwgaW5kZXgpe1xyXG4gICAgICAgXHJcblx0XHQvL2NhbGxzIHRoZSBtb2R1bGUgaGlkZSBtZXRob2Qgd2l0aCB0aGUgY3VycmVudCBjb250ZXh0LlxyXG4gICAgICAgIGhpZGUuY2FsbChzZWxmLCBpbmRleCk7XHJcbiAgICAgICAgXHJcbiAgICB9KTtcclxuICAgIFxyXG4gICAgcmV0dXJuIHNlbGY7XHJcbiAgICBcclxufVxyXG5cclxuXHJcbmZ1bmN0aW9uIGhhbmRsZVN0YXRlQ2hhbmdlKGV2ZW50LCBkYXRhKXtcclxuICAgIFxyXG5cdC8vaGlkZXMgYXdheSBjdXJyZW50IHN0YXRlIHBhZ2UgYW5kIHNob3dzIG5ldyBzdGF0ZSBwYWdlLlxyXG4gICAgaGlkZS5jYWxsKHRoaXMsIGRhdGEuZnJvbSk7XHJcbiAgICBzaG93LmNhbGwodGhpcywgZGF0YS50byk7XHJcbiAgICBcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgICBcclxuICAgIGluaXQgOiBpbml0LFxyXG4gICAgc2hvdyA6IHNob3csXHJcbiAgICBoaWRlIDogaGlkZSxcclxuICAgIGhpZGVBbGwgOiBoaWRlQWxsLFxyXG4gICAgaGFzSW5pdGlhbGl6ZWQgOiBmYWxzZSxcclxuICAgIHVwZGF0ZUNvdW50ZXIgOiB1cGRhdGVDb3VudGVyc1xyXG4gICAgXHJcbiAgICBcclxufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vanMvVUlDb250cm9sbGVyLmpzXG4gKiogbW9kdWxlIGlkID0gNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIFJlc291cmNlTG9hZGVyID0gcmVxdWlyZSgnLi9SZXNvdXJjZUxvYWRlci5qcycpLFxyXG4gICAga2V5Ym9hcmRDb250cm9sID0gcmVxdWlyZSgnLi9rZXlib2FyZENvbnRyb2wuanMnKSxcclxuICAgIENvbnN0cnVjdG9ycyA9IHJlcXVpcmUoJy4vQ29uc3RydWN0b3JzJyksXHJcbiAgICBQdWJTdWIgPSByZXF1aXJlKCcuL1B1YlN1YicpLFxyXG4gICAgVUlDb250cm9sbGVyID0gcmVxdWlyZSgnLi9VSUNvbnRyb2xsZXInKSxcclxuICAgIEFsZ29yaXRobXMgPSByZXF1aXJlKCcuL0FsZ29yaXRobXMnKSxcclxuICAgIG1haW5DYW52YXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYmdDYW52YXMnKSxcclxuICAgIG1haW5Db250ZXh0ID0gbWFpbkNhbnZhcy5nZXRDb250ZXh0KCcyZCcpXHJcbiAgICBtb3VzZSA9IHt4OiAyMDAsIHk6MjAwfSxcclxuICAgIGNlbnRlclggPSBtYWluQ2FudmFzLndpZHRoIC8gMixcclxuICAgIGNlbnRlclkgPSBtYWluQ2FudmFzLmhlaWdodCAvIDIsXHJcbiAgICBGUkFNRV9SQVRFID0gMTAwMC82MCxcclxuICAgIFxyXG4gICAgc3RhdGUgPSB7XHJcbiAgICAgICAgSU5JVCA6IC0xLFxyXG4gICAgICAgIExPQURJTkc6IDAsXHJcbiAgICAgICAgU1RPUllfTElORSA6IDEsXHJcblx0ICAgIFRJVExFX1NDUkVFTiA6IDIsXHJcbiAgICAgICAgR0FNRV9QTEFZIDogMyxcclxuICAgICAgICBMRVZFTF9UUkFOU0lUSU9OIDogNCxcclxuICAgICAgICBCRUFUX0dBTUUgOiA1LFxyXG4gICAgICAgIEdBTUVfT1ZFUiA6IDYsXHJcbiAgICAgICAgQ1JFRElUUyA6IDcsXHJcbiAgICAgICAgSE9XX1RPX1BMQVkgOiA4LFxyXG4gICAgICAgIFBBVVNFRCA6IDksXHJcbiAgICAgICAgU0hJUF9KVU1QIDogMTAsXHJcbiAgICAgICAgU0VUX1VQX0xFVkVMOiAxMSxcclxuXHJcbiAgICAgICAgQ1VSUkVOVCA6IC0xIFxyXG4gICAgfSxcclxuICAgIFxyXG4gICAgc3RhdGVIYW5kbGVycyA9IHt9LFxyXG4gICAgXHJcbiAgICBsb29wT24gPSBmYWxzZTsgIFxyXG5cclxuICAgIHZhciB0b3RhbEVuZW1pZXMgPSA4LFxyXG4gICAgICAgIHRvdGFsUm9ja3MgPSAxMCxcclxuICAgICAgICBsZXZlbFJvY2tzID0gNSxcclxuICAgICAgICBsZXZlbEVuZW1pZXMgPSA4LFxyXG4gICAgICAgIGxldmVsUGVya3MgPSA0LFxyXG4gICAgICAgIGVuZW1pZXNLaWxsZWQgPSAwXHJcbiAgICAgICAgY3VycmVudFNjb3JlID0gMCxcclxuICAgICAgICBzaGlwTGl2ZXMgPSA0LFxyXG4gICAgICAgIHJvY2tzRGVzdHJveWVkID0gMCxcclxuICAgICAgICBjdXJyZW50TGV2ZWwgPSAwLFxyXG4gICAgICAgIGxhc3RMZXZlbCA9IDE7XHJcblxyXG5cdC8vVEVNUDogcGxheWVyIGluc3RhbmNlIGFuZCBlbmVtaWVzXHJcbiAgICB2YXIgcGxheWVyU2hpcCxcclxuXHQgICAgYWxpZW5Nb3RoZXJzaGlwLFxyXG4gICAgICAgIGh1bWFuTW90aGVyc2hpcCxcclxuXHQgICAgYmFja2dyb3VuZDtcclxuXHJcbiAgICAgLy9wb29scyBob2xkaW5nIGVuZW1pZXMgYW5kIHJvY2tzXHJcbiAgICB2YXIgZW5lbXlTaGlwc1Bvb2wsXHJcbiAgICAgICAgaHVtYW5TaGlwc1Bvb2wsXHJcbiAgICAgICAgcGVya3NQb29sLFxyXG4gICAgICAgIG1ldGVvclBvb2w7ICAgXHJcblxyXG5mdW5jdGlvbiBpbml0KCl7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgXHJcbiAgICAgICAgYXR0YWNoU3RhdGVIYW5kbGVycygpO1xyXG4gICAgXHJcbiAgICAgICAgcGxheWVyU2hpcCA9IG5ldyBDb25zdHJ1Y3RvcnMuU2hpcCgpO1xyXG5cdCAgICBhbGllbk1vdGhlcnNoaXAgPSBuZXcgQ29uc3RydWN0b3JzLk1vdGhlcnNoaXAoKTtcclxuICAgICAgICBodW1hbk1vdGhlcnNoaXAgPSBuZXcgQ29uc3RydWN0b3JzLk1vdGhlcnNoaXAoKTtcclxuXHQgICAgYmFja2dyb3VuZCA9IG5ldyBDb25zdHJ1Y3RvcnMuQmFja2dyb3VuZCgpO1xyXG5cclxuICAgICAvL3Bvb2xzIGhvbGRpbmcgZW5lbWllcyBhbmQgcm9ja3NcclxuICAgICAgICBlbmVteVNoaXBzUG9vbCA9IG5ldyBDb25zdHJ1Y3RvcnMuUG9vbCh0b3RhbEVuZW1pZXMpO1xyXG4gICAgICAgIGh1bWFuU2hpcHNQb29sID0gbmV3IENvbnN0cnVjdG9ycy5Qb29sKDEwKTtcclxuICAgICAgICBwZXJrc1Bvb2wgPSBuZXcgQ29uc3RydWN0b3JzLlBvb2woMTApO1xyXG4gICAgICAgIG1ldGVvclBvb2wgPSBuZXcgQ29uc3RydWN0b3JzLlBvb2wodG90YWxSb2Nrcyk7ICAgXHJcblxyXG4gICAgICAgIGJhY2tncm91bmQuc2V0Q2FudmFzKG1haW5DYW52YXMpO1xyXG5cdFx0YmFja2dyb3VuZC5pbml0KDEwMDAsIDQ4MCk7XHJcblx0XHRiYWNrZ3JvdW5kLnZlbFggPSAxO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHBlcmtzUG9vbC5pbml0KFwicGVya3NcIik7XHJcbiAgICAgICAgbWV0ZW9yUG9vbC5pbml0KFwicm9ja3NcIik7XHJcbiAgICAgICAgZW5lbXlTaGlwc1Bvb2wuaW5pdCgnZW5lbXknKTtcclxuICAgICAgICBcclxuICAgICAgICBhbGllbk1vdGhlcnNoaXAuc2V0Q2FudmFzKG1haW5DYW52YXMpO1xyXG4gICAgICAgIGFsaWVuTW90aGVyc2hpcC5pbml0KCdhbGllbicpO1xyXG5cclxuICAgICAgICBwbGF5ZXJTaGlwLnNldENhbnZhcyhtYWluQ2FudmFzKTtcclxuICAgICAgICBwbGF5ZXJTaGlwLmluaXQoMjMsIDIzKTtcclxuICAgICAgICBwbGF5ZXJTaGlwLnNwYXduKGNlbnRlclgsIGNlbnRlclkpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBvbk1vdXNlTW92ZSwgZmFsc2UpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vYWRkIGdhbWUgY29udHJvbCBmb3IgZGVza3RvcCBiYXNlZCBvbiBrZXlib2FyZCBldmVudHNcclxuICAgICAgICBrZXlib2FyZENvbnRyb2wuaW5pdChwbGF5ZXJTaGlwKTtcclxuICAgIFxyXG4gICAgICAgIFxyXG4gICAgICAgIC8vc2lnbiB1cCBmb3Igc3Vic2NyaXB0aW9uc1xyXG4gICAgICAgIHZhciBzdWJJRDEgPSBQdWJTdWIuc3Vic2NyaWJlKCdzdGF0ZWNoYW5nZScsIGhhbmRsZVN0YXRlQ2hhbmdlLmJpbmQoc2VsZikpO1xyXG4gICAgICAgIHZhciBzdWJJRDIgPSBQdWJTdWIuc3Vic2NyaWJlKCdtZXRlb3JfZXhwbG9zaW9uJywgaGFuZGxlTWV0ZW9yRXhwbG9zaW9uLmJpbmQoc2VsZikpO1xyXG4gICAgICAgIHZhciBzdWJJRDMgPSBQdWJTdWIuc3Vic2NyaWJlKCdjb2xsaXNpb24nLCByZWNvcmRDb2xsaXNpb24uYmluZChzZWxmKSk7XHJcbiAgICBcclxuXHR3aW5kb3cuYWxpZW5Nb3RoZXJzaGlwID0gYWxpZW5Nb3RoZXJzaGlwO1xyXG5cdHdpbmRvdy5wbGF5ZXJTaGlwID0gcGxheWVyU2hpcDtcclxuICAgIFxyXG59XHJcblxyXG5cclxuZnVuY3Rpb24gb25Nb3VzZU1vdmUoZSl7XHJcbiAgICBcclxuICAgIFxyXG4gICAgXHJcbiAgICBcclxufVxyXG5cclxuXHJcbi8vZnVuY3Rpb24gaW4gY2hhcmdlZCBvZiBzZXR0aW5nIHVwIHRoZSBlbmVtaWVzIGFuZCByb2NrcyBpbiB0aGUgbmV3IGxldmVsIGdpdmVuIHRoZSBjdXJyZW50IGxldmVsXHJcbmZ1bmN0aW9uIGhhbmRsZVNldFVwTGV2ZWwoKXtcclxuICAgIFxyXG4gICAgICAgIFxyXG4gICAgICAgIFxyXG4gICAgICAgIGNvbnNvbGUubG9nKCdTZXQgVXAgTGV2ZWwgZnVuY3Rpb24gQ0FMTEVEJyk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy9zZXRzIHVwIHJhbmRvbSBsb2NhdGlvbiBmb3Igcm9ja3MgYW5kIG1vdGhlcnNoaXBcclxuICAgICAgICAgICAgdmFyIHJhbmRvbVgsIHJhbmRvbVk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy9pbmNyZWFzZXMgbGV2ZWwgYnkgMVxyXG4gICAgICAgIGN1cnJlbnRMZXZlbCArPSAxO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vY2hlY2tzIGlmIGdhbWUgaXMgb3ZlclxyXG4gICAgICAgIGlmKGN1cnJlbnRMZXZlbCA+IGxhc3RMZXZlbCl7XHJcbiAgICAgICAgICAgIHVzZXJCZWF0R2FtZSA9IHRydWU7XHJcbiAgICAgICAgICAgIFB1YlN1Yi5wdWJsaXNoKCdzdGF0ZWNoYW5nZScsIHtmcm9tOiBzdGF0ZS5DVVJSRU5ULCB0bzogc3RhdGUuQkVBVF9HQU1FfSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgICAgXHJcbiAgICAgICAgaWYoY3VycmVudExldmVsID09IGxhc3RMZXZlbCl7XHJcbiAgICAgICAgICAgIFJlc291cmNlTG9hZGVyLmFzc2V0cy5sYXN0TGV2ZWxTb3VuZC5wbGF5KCk7XHJcbiAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgIC8vYmVnaW5zIG5vcm1hbCBzb3VuZHRyYWNrIFxyXG5cdFx0ICAgUmVzb3VyY2VMb2FkZXIuYXNzZXRzLnNvdW5kVHJhY2sucGxheSgpO1xyXG4gICAgICAgIH1cclxuXHRcdFxyXG4gICAgICAgIC8vcmVzZXRzIGVuZW15IGtpbGxlZCBhbmQgcm9ja3MgZGVzdHJveWVkIGNvdW50ZXIgYW5kIHNoaXAgbGl2ZXNcclxuICAgICAgICBlbmVtaWVzS2lsbGVkID0gMDtcclxuICAgICAgICByb2Nrc0Rlc3Ryb3llZCA9IDA7XHJcbiAgICBcclxuICAgICAgICBpZihjdXJyZW50TGV2ZWwgPT0gMSl7XHJcbiAgICAgICAgICAgIHNoaXBMaXZlcyA9IDQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vc2V0cyB1cCBudW1iZXIgb2Ygcm9ja3MgYW5kIGVuZW1pZXMgdGhhdCB3aWxsIGJlIGRpc3BsYXllZFxyXG4gICAgICAgIGxldmVsRW5lbWllcyA9IGN1cnJlbnRMZXZlbCsxO1xyXG4gICAgICAgIGxldmVsUm9ja3MgPSBjdXJyZW50TGV2ZWwrMjtcclxuICAgICAgICBcclxuICAgICAgICAvL2NoZWNrcyB0byBzZWUgaWYgdGhlIGxldmVsIHJvY2tzIGFuZCBlbmVtaWVzIGV4Y2VlZCB0b3RhbCBpbiBwb29sLlxyXG4gICAgICAgIGxldmVsRW5lbWllcyA9IChsZXZlbEVuZW1pZXM+PXRvdGFsRW5lbWllcyk/IHRvdGFsRW5lbWllcyA6IGxldmVsRW5lbWllcztcclxuICAgICAgICBsZXZlbFJvY2tzID0gKGxldmVsUm9ja3M+PXRvdGFsUm9ja3MpPyB0b3RhbFJvY2tzIDogbGV2ZWxSb2NrcztcclxuICAgICAgICBcclxuICAgICAgICAvL2NlbnRlcnMgc2hpcCBhbmQgaGlkZSBhbGwgb2YgaXRzIG1pc3NpbGVzXHJcbiAgICAgICAgcGxheWVyU2hpcC5zcGF3bihjZW50ZXJYLCBjZW50ZXJZKTtcclxuICAgICAgICBcclxuICAgICAgICAvL2tpbGwgb2ZmIGFueSBhbGl2ZSByb2NrcyBhbmQgZW5lbWllc1xyXG4gICAgICAgIHBlcmtzUG9vbC5oaWRlSXRlbXMoKTtcclxuICAgICAgICBlbmVteVNoaXBzUG9vbC5oaWRlSXRlbXMoKTtcclxuICAgICAgICBtZXRlb3JQb29sLmhpZGVJdGVtcygpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vaW5pdHMgdGhlIHJvY2tzXHJcbiAgICAgICAgZm9yKHZhciBpPTA7IGk8bGV2ZWxSb2NrczsgaSsrKXtcclxuICAgICAgICAgICAgcmFuZG9tWCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSoobWFpbkNhbnZhcy53aWR0aC01MCkpLFxyXG4gICAgICAgICAgICByYW5kb21ZID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpKihtYWluQ2FudmFzLmhlaWdodC01MCkpO1xyXG4gICAgICAgICAgICBtZXRlb3JQb29sLmdldChyYW5kb21YLCByYW5kb21ZLCBcImxhcmdlUm9ja1wiKTtcclxuICAgICAgICAgICAgbWV0ZW9yUG9vbC5nZXQocmFuZG9tWCwgcmFuZG9tWSwgXCJzbWFsbFJvY2tcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIGZvcih2YXIgaD0wOyBoPGxldmVsUGVya3M7IGgrKyl7XHJcbiAgICAgICAgICAgIHJhbmRvbVggPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkqKG1haW5DYW52YXMud2lkdGgtNTApKSxcclxuICAgICAgICAgICAgcmFuZG9tWSA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSoobWFpbkNhbnZhcy5oZWlnaHQtNTApKTtcclxuICAgICAgICAgICAgcGVya3NQb29sLmdldChyYW5kb21YLCByYW5kb21ZLCBcImxpZmVcIik7XHJcbiAgICAgICAgICAgIHBlcmtzUG9vbC5nZXQocmFuZG9tWSwgcmFuZG9tWCwgXCJzaGllbGRcIik7XHJcbiAgICAgICAgfVxyXG4gICAgXHJcbiAgICAgICAgLy9hbGllbk1vdGhlcnNoaXAuaW5pdChcImFsaWVuXCIpO1xyXG4gICAgICAgIGFsaWVuTW90aGVyc2hpcC5zcGF3bihyYW5kb21YLCByYW5kb21ZKTtcclxuICAgICAgICBhbGllbk1vdGhlcnNoaXAuc2hpZWxkLmFjdGl2ZSA9IHRydWU7XHJcbiAgICAgICAgYWxpZW5Nb3RoZXJzaGlwLnNldFJlbGVhc2UoZW5lbXlTaGlwc1Bvb2wsIGxldmVsRW5lbWllcywgODAwMCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy91cGRhdGVDb3VudGVyKCdsZXZlbCcpO1xyXG4gICAgICAgIC8vdXBkYXRlQ291bnRlcignbGlmZScpO1xyXG4gICAgICAgIC8vdXBkYXRlQ291bnRlcignc2NvcmUnKTtcclxuICAgIFxyXG4gICAgICAgIFVJQ29udHJvbGxlci51cGRhdGVDb3VudGVyKCdsZXZlbCcsIGN1cnJlbnRMZXZlbCk7XHJcbiAgICAgICAgVUlDb250cm9sbGVyLnVwZGF0ZUNvdW50ZXIoJ2xpdmVzJywgc2hpcExpdmVzKTtcclxuICAgICAgICBVSUNvbnRyb2xsZXIudXBkYXRlQ291bnRlcignc2NvcmUnLCBjdXJyZW50U2NvcmUpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIFB1YlN1Yi5wdWJsaXNoKCdzdGF0ZWNoYW5nZScsIHtmcm9tOiBzdGF0ZS5TRVRfVVBfTEVWRUwsIHRvOiBzdGF0ZS5HQU1FX1BMQVl9KTtcclxuICAgIFxyXG59XHJcblxyXG5mdW5jdGlvbiBhdHRhY2hTdGF0ZUhhbmRsZXJzKCl7XHJcbiAgICBcclxuICAgIHN0YXRlSGFuZGxlcnNbc3RhdGUuTE9BRElOR10gPSBoYW5kbGVMb2FkaW5nO1xyXG4gICAgc3RhdGVIYW5kbGVyc1tzdGF0ZS5TVE9SWV9MSU5FXSA9IGhhbmRsZVN0b3J5TGluZTtcclxuICAgIHN0YXRlSGFuZGxlcnNbc3RhdGUuVElUTEVfU0NSRUVOXSA9IGhhbmRsZVRpdGxlU2NyZWVuO1xyXG4gICAgc3RhdGVIYW5kbGVyc1tzdGF0ZS5TRVRfVVBfTEVWRUxdID0gaGFuZGxlU2V0VXBMZXZlbDtcclxuICAgIHN0YXRlSGFuZGxlcnNbc3RhdGUuR0FNRV9QTEFZXSA9IGhhbmRsZUdhbWVQbGF5O1xyXG4gICAgc3RhdGVIYW5kbGVyc1tzdGF0ZS5TSElQX0pVTVBdID0gaGFuZGxlU2hpcEp1bXA7XHJcbiAgICBzdGF0ZUhhbmRsZXJzW3N0YXRlLkxFVkVMX1RSQU5TSVRJT05dID0gaGFuZGxlTGV2ZWxUcmFuc2l0aW9uO1xyXG4gICAgc3RhdGVIYW5kbGVyc1tzdGF0ZS5CRUFUX0dBTUVdID0gaGFuZGxlQmVhdEdhbWU7XHJcbiAgICBzdGF0ZUhhbmRsZXJzW3N0YXRlLkdBTUVfT1ZFUl0gPSBoYW5kbGVHYW1lT3ZlcjtcclxuICAgIHN0YXRlSGFuZGxlcnNbc3RhdGUuQ1JFRElUU10gPSBoYW5kbGVDcmVkaXRzO1xyXG4gICAgc3RhdGVIYW5kbGVyc1tzdGF0ZS5IT1dfVE9fUExBWV0gPSBoYW5kbGVIb3dUb1BsYXk7XHJcbiAgICBzdGF0ZUhhbmRsZXJzW3N0YXRlLlBBVVNFRF0gPSBoYW5kbGVQYXVzZTtcclxuICAgICAgICBcclxufVxyXG5cclxuZnVuY3Rpb24gaGFuZGxlTG9hZGluZygpe1xyXG4gICAgLy9kbyBub3RoaW5nICAgXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGhhbmRsZVN0b3J5TGluZSgpe1xyXG5cclxuICAgIGlmKCFsb29wT24pe1xyXG4gICAgIFxyXG4gICAgICAgIGxvb3BPbiA9IHRydWU7XHJcbiAgICAgICAgZ2FtZUxvb3AoKTtcclxuICAgICAgICBcclxuICAgIH1cclxuICAgIFxyXG4gICAgYmFja2dyb3VuZC5kcmF3KCk7XHJcbiAgICBcclxufVxyXG5cclxuZnVuY3Rpb24gaGFuZGxlVGl0bGVTY3JlZW4oKXtcclxuICAgIFxyXG4gICAgaWYoIWxvb3BPbil7XHJcbiAgICAgICAgXHJcbiAgICAgICAgbG9vcE9uID0gdHJ1ZTtcclxuICAgICAgICBnYW1lTG9vcCgpO1xyXG4gICAgICAgIFxyXG4gICAgfVxyXG4gICAgXHJcbiAgICBiYWNrZ3JvdW5kLmRyYXcoKTtcclxuICAgIG1haW5Db250ZXh0LmRyYXdJbWFnZShSZXNvdXJjZUxvYWRlci5hc3NldHMuZWFydGhTcHJpdGUsIChtYWluQ2FudmFzLndpZHRoLzItKFJlc291cmNlTG9hZGVyLmFzc2V0cy5lYXJ0aFNwcml0ZS53aWR0aC8yKSksIDApO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGZvcih2YXIgaT0wOyBpPDc7IGkrKyl7XHJcbiAgICAgICAgICAgIHZhciBjdXJyZW50RW5lbXkgPSBlbmVteVNoaXBzUG9vbC5wb29sW2ldO1xyXG4gICAgICAgICAgICBjdXJyZW50RW5lbXkuZHJhdygpO1xyXG4gICAgICAgICAgICBjdXJyZW50RW5lbXkuZm9sbG93KG1vdXNlKTtcclxuICAgICAgICAgICAgQWxnb3JpdGhtcy5jaGVja0JvdW5kYXJ5KGN1cnJlbnRFbmVteSk7XHJcbiAgICAgICAgfVxyXG4gICAgXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGhhbmRsZUdhbWVQbGF5KCl7XHJcbiAgICBcclxuICAgIGlmKCFsb29wT24pe1xyXG4gICAgICAgIFxyXG4gICAgICAgIFJlc291cmNlTG9hZGVyLmFzc2V0cy5zb3VuZFRyYWNrLnBsYXkoKTtcclxuICAgICAgICBsb29wT24gPSB0cnVlO1xyXG4gICAgICAgIGdhbWVMb29wKCk7XHJcbiAgICAgICAgICAgXHJcbiAgICB9XHJcbiAgICBcclxuICAgICBiYWNrZ3JvdW5kLmRyYXcoKTtcclxuXHJcbiAgICAgICAgaWYoYWxpZW5Nb3RoZXJzaGlwLmFsaXZlKXtcclxuICAgICAgICAgICAgYWxpZW5Nb3RoZXJzaGlwLmRyYXcoKTtcclxuICAgICAgICAgICAgQWxnb3JpdGhtcy5jaGVja0JvdW5kYXJ5KGFsaWVuTW90aGVyc2hpcCk7XHJcbiAgICAgICAgICAgIGFsaWVuTW90aGVyc2hpcC5mb2xsb3cocGxheWVyU2hpcCk7XHJcbiAgICAgICAgICAgIGFsaWVuTW90aGVyc2hpcC5hdHRhY2socGxheWVyU2hpcCk7XHJcbiAgICAgICAgICAgIGFsaWVuTW90aGVyc2hpcC5taXNzaWxlcy5pc0NvbGxpZGluZ1dpdGgocGxheWVyU2hpcCwgcGxheWVyU2hpcC5zaGllbGQpO1xyXG4gICAgICAgICAgICBwbGF5ZXJTaGlwLm1pc3NpbGVzLmlzQ29sbGlkaW5nV2l0aChhbGllbk1vdGhlcnNoaXAsIGFsaWVuTW90aGVyc2hpcC5zaGllbGQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGZvcih2YXIgbT0wOyBtPHBlcmtzUG9vbC5wb29sLmxlbmd0aDsgbSsrKXtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY3VycmVudFBlcmsgPSBwZXJrc1Bvb2wucG9vbFttXTtcclxuICAgICAgICAgICAgICAgICAgICBpZihjdXJyZW50UGVyay5hbGl2ZSl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQZXJrLmRyYXcoKTsgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihBbGdvcml0aG1zLmhpdFRlc3QoY3VycmVudFBlcmssIHBsYXllclNoaXApKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdERVRFQ1RJT04gQ09ORklSTUVEISEnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGN1cnJlbnRQZXJrKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKHBsYXllclNoaXApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFBlcmsuZGVzdHJveSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgUHViU3ViLnB1Ymxpc2goJ2NvbGxpc2lvbicsIGN1cnJlbnRQZXJrLnR5cGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGk8bWV0ZW9yUG9vbC5wb29sLmxlbmd0aDsgaSsrKXtcclxuICAgICAgICAgICBcclxuICAgICAgICAgICAgdmFyIGN1cnJlbnRNZXRlb3IgPSBtZXRlb3JQb29sLnBvb2xbaV07XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBpZihjdXJyZW50TWV0ZW9yLmFsaXZlKXtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRNZXRlb3IuZHJhdygpO1xyXG4gICAgICAgICAgICAgICAgQWxnb3JpdGhtcy5jaGVja0JvdW5kYXJ5KGN1cnJlbnRNZXRlb3IpO1xyXG4gICAgICAgICAgICAgICAgcGxheWVyU2hpcC5taXNzaWxlcy5pc0NvbGxpZGluZ1dpdGgoY3VycmVudE1ldGVvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgbWV0ZW9yUG9vbC5pc0NvbGxpZGluZ1dpdGgocGxheWVyU2hpcCwgcGxheWVyU2hpcC5zaGllbGQpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGZvcih2YXIgaCA9IDA7IGg8ZW5lbXlTaGlwc1Bvb2wucG9vbC5sZW5ndGg7IGgrKyl7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB2YXIgY3VycmVudEVuZW15ID0gZW5lbXlTaGlwc1Bvb2wucG9vbFtoXTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGlmKGN1cnJlbnRFbmVteS5hbGl2ZSl7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRFbmVteS5kcmF3KCk7XHJcbiAgICAgICAgICAgICAgICBBbGdvcml0aG1zLmNoZWNrQm91bmRhcnkoY3VycmVudEVuZW15KTtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRFbmVteS5mb2xsb3cocGxheWVyU2hpcCk7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50RW5lbXkuYXR0YWNrKHBsYXllclNoaXApO1xyXG4gICAgICAgICAgICAgICAgY3VycmVudEVuZW15Lm1pc3NpbGVzLmlzQ29sbGlkaW5nV2l0aChwbGF5ZXJTaGlwLCBwbGF5ZXJTaGlwLnNoaWVsZCwgbWV0ZW9yUG9vbC5wb29sKTtcclxuICAgICAgICAgICAgICAgIHBsYXllclNoaXAubWlzc2lsZXMuaXNDb2xsaWRpbmdXaXRoKGN1cnJlbnRFbmVteSwgY3VycmVudEVuZW15LnNoaWVsZCk7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIGlmKEFsZ29yaXRobXMuaGl0VGVzdChjdXJyZW50RW5lbXksIHBsYXllclNoaXApKXtcclxuICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50RW5lbXkuZGVzdHJveSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHBsYXllclNoaXAuZGVzdHJveSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIFB1YlN1Yi5wdWJsaXNoKCdjb2xsaXNpb24nLCBjdXJyZW50RW5lbXkudHlwZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgUHViU3ViLnB1Ymxpc2goJ2NvbGxpc2lvbicsIHBsYXllclNoaXAudHlwZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICB9XHJcbiAgICBcclxuICAgICAgICAvL2NoZWNrIGZyYW1lc1xyXG5cdFx0XHJcbiAgICAgICAgaWYocGxheWVyU2hpcC5hbGl2ZSl7XHJcblx0XHRcdGtleWJvYXJkQ29udHJvbC51cGRhdGUoKTtcclxuICAgICAgICAgICAgQWxnb3JpdGhtcy5jaGVja0JvdW5kYXJ5KHBsYXllclNoaXApO1xyXG4gICAgICAgICAgICBwbGF5ZXJTaGlwLmRyYXcoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYoc2hpcExpdmVzIDw9IDAgJiYgIXBsYXllclNoaXAuY29sbGlkaW5nICYmIHN0YXRlLkNVUlJFTlQgPT0gc3RhdGUuR0FNRV9QTEFZKXtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgaWYoY3VycmVudExldmVsID09IGxhc3RMZXZlbCl7XHJcblx0XHRcdFx0XHRcdFJlc291cmNlTG9hZGVyLmFzc2V0cy5sYXN0TGV2ZWxTb3VuZC5zdG9wKCk7XHJcblx0XHRcdFx0XHR9ZWxzZXtcclxuXHRcdFx0XHRcdFx0UmVzb3VyY2VMb2FkZXIuYXNzZXRzLnNvdW5kVHJhY2suc3RvcCgpOyBcclxuXHRcdFx0XHRcdH1cclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgUHViU3ViLnB1Ymxpc2goJ3N0YXRlY2hhbmdlJywge2Zyb206IHN0YXRlLkdBTUVfUExBWSwgdG86IHN0YXRlLkdBTUVfT1ZFUn0pO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRMZXZlbCA9IDA7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgIH1lbHNlIGlmKGxldmVsRW5lbWllcyA8PSAwICYmICFwbGF5ZXJTaGlwLmNvbGxpZGluZyAmJiBwbGF5ZXJTaGlwLmFsaXZlICYmIHN0YXRlLkNVUlJFTlQgPT0gc3RhdGUuR0FNRV9QTEFZKXtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgaWYoY3VycmVudExldmVsID09IGxhc3RMZXZlbCl7XHJcblx0XHRcdFx0XHRcdFJlc291cmNlTG9hZGVyLmFzc2V0cy5sYXN0TGV2ZWxTb3VuZC5zdG9wKCk7XHJcblx0XHRcdFx0XHR9ZWxzZXtcclxuXHRcdFx0XHRcdFx0UmVzb3VyY2VMb2FkZXIuYXNzZXRzLnNvdW5kVHJhY2suc3RvcCgpOyBcclxuXHRcdFx0XHRcdH1cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIFB1YlN1Yi5wdWJsaXNoKCdzdGF0ZWNoYW5nZScsIHtmcm9tOiBzdGF0ZS5HQU1FX1BMQVksIHRvOiBzdGF0ZS5TSElQX0pVTVB9KTtcclxuXHJcbiAgICAgICAgfVxyXG4gICAgXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGhhbmRsZUxldmVsVHJhbnNpdGlvbigpe1xyXG4gICAgXHJcbiAgICBpZihsb29wT24pe1xyXG4gICAgIFxyXG4gICAgICAgIGxvb3BPbiA9IGZhbHNlO1xyXG4gICAgICAgIGdhbWVMb29wKCk7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIFxyXG4gICAgVUlDb250cm9sbGVyLnVwZGF0ZUNvdW50ZXIoJ3JlcG9ydFNjb3JlJywgY3VycmVudFNjb3JlKTtcclxuICAgIFVJQ29udHJvbGxlci51cGRhdGVDb3VudGVyKCdyZXBvcnRDYXJuYWdlJywgZW5lbWllc0tpbGxlZCk7ICAgXHJcbiAgICBVSUNvbnRyb2xsZXIudXBkYXRlQ291bnRlcigncmVwb3J0QXN0ZXJvaWRzJywgcm9ja3NEZXN0cm95ZWQpO1xyXG5cclxuICAgIFxyXG59XHJcblxyXG5mdW5jdGlvbiBoYW5kbGVNZXRlb3JFeHBsb3Npb24oZXZlbnQsIG1ldGVvcil7XHJcbiAgICBcclxuICAgIFxyXG4gICAgICAgICAgICBzd2l0Y2gobWV0ZW9yLnNpemUpe1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcImxhcmdlXCI6XHJcbiAgICAgICAgICAgICAgICBtZXRlb3JQb29sLmdldChtZXRlb3IueCwgbWV0ZW9yLnksIFwibWVkaXVtUm9ja1wiKTtcclxuICAgICAgICAgICAgICAgIG1ldGVvclBvb2wuZ2V0KG1ldGVvci54LCBtZXRlb3IueSwgXCJtZWRpdW1Sb2NrXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcIm1lZGl1bVwiOlxyXG4gICAgICAgICAgICAgICAgbWV0ZW9yUG9vbC5nZXQobWV0ZW9yLngsIG1ldGVvci55LCBcInNtYWxsUm9ja1wiKTtcclxuICAgICAgICAgICAgICAgIG1ldGVvclBvb2wuZ2V0KG1ldGVvci54LCBtZXRlb3IueSwgXCJzbWFsbFJvY2tcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwic21hbGxcIjpcclxuICAgICAgICAgICAgICAgICAgICAvL25vIHJvY2tzXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7ICAgICBcclxuICAgICAgICAgICAgfSBcclxuICAgIFxyXG59XHJcblxyXG5mdW5jdGlvbiBoYW5kbGVTaGlwSnVtcCgpe1xyXG4gICAgXHJcbiAgICBpZighbG9vcE9uKXtcclxuICAgICAgICBcclxuICAgICAgICBsb29wT24gPSB0cnVlO1xyXG4gICAgICAgIGdhbWVMb29wKCk7XHJcbiAgICAgICAgXHJcbiAgICB9XHJcbiAgICBcclxuICAgIFxyXG4gICAgLy9kcmF3IGJhY2tncm91bmRcclxuICAgICAgICBiYWNrZ3JvdW5kLmRyYXcoKTtcclxuICAgICAgICBcclxuICAgICAgICAvL2RyYXdSZW1haW5pbmcgcm9ja3NcclxuICAgICAgICBmb3IodmFyIGs9MDsgazxtZXRlb3JQb29sLnBvb2wubGVuZ3RoOyBrKyspe1xyXG4gICAgICAgICAgICB2YXIgY3VycmVudFJvY2sgPSBtZXRlb3JQb29sLnBvb2xba107XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvL2lmIHJvY2sgYWxpdmUgZHJhdyBpdFxyXG4gICAgICAgICAgICBpZihjdXJyZW50Um9jay5hbGl2ZSl7XHJcbiAgICAgICAgICAgICAgICBBbGdvcml0aG1zLmNoZWNrQm91bmRhcnkoY3VycmVudFJvY2spO1xyXG4gICAgICAgICAgICAgICAgY3VycmVudFJvY2suZHJhdygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIGVuZW15U2hpcHNQb29sLnBvb2wuZm9yRWFjaChmdW5jdGlvbihlbmVteSl7XHJcbiAgICAgICAgICAgIGlmKGVuZW15LmFsaXZlKXtcclxuICAgICAgICAgICAgICAgIGVuZW15LmRyYXcoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIFxyXG5cdFx0cGxheWVyU2hpcC5qdW1wKCk7XHJcbiAgICAgICAgcGxheWVyU2hpcC5kcmF3KCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYocGxheWVyU2hpcC54ID49IDEwMjAtcGxheWVyU2hpcC53aWR0aCl7IFxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgUHViU3ViLnB1Ymxpc2goJ3N0YXRlY2hhbmdlJywge2Zyb206IHN0YXRlLlNISVBfSlVNUCwgdG86IHN0YXRlLkxFVkVMX1RSQU5TSVRJT059KTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgfVxyXG4gICAgXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGhhbmRsZVBhdXNlKCl7XHJcbiBcclxuICAgIFJlc291cmNlTG9hZGVyLmFzc2V0cy5zb3VuZFRyYWNrLnBhdXNlKCk7XHJcbiAgICBSZXNvdXJjZUxvYWRlci5hc3NldHMubGFzdExldmVsU291bmQucGF1c2UoKTtcclxuICAgIGxvb3BPbiA9IGZhbHNlO1xyXG4gICAgXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGhhbmRsZUJlYXRHYW1lKCl7XHJcbiAgICBcclxuICAgICAgICBpZihsb29wT24pe1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgbG9vcE9uID0gZmFsc2U7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgIH1cclxuXHRcdFxyXG4gICAgICAgIC8vb3V0cHV0cyB0aGUgZmluYWwgc2NvcmUgdG8gdGhlIHdpbm5lciBnYW1lciA6KVxyXG4gICAgICAgIC8vUmVzb3VyY2VMb2FkZXIuZmluYWxMZXZlbFNvdW5kLnN0b3AoKTsgICAgICAgXHJcbiAgICAgICAgLy9iZWF0R2FtZVNjb3JlLmlubmVySFRNTCA9IFwiWW91ciBTY29yZTogXCIrY3VycmVudFNjb3JlO1xyXG4gICAgXHJcbiAgICAgICAgVUlDb250cm9sbGVyLnVwZGF0ZUNvdW50ZXIoJ2JlYXRHYW1lU2NvcmUnLCBjdXJyZW50U2NvcmUpO1xyXG4gICAgICAgIHVzZXJCZWF0R2FtZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgUmVzb3VyY2VMb2FkZXIuYXNzZXRzLnZpY3RvcnlTb3VuZC5wbGF5KCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy9yZXNldHMgdGhhdCBzY29yZVxyXG4gICAgICAgIGN1cnJlbnRTY29yZSA9IDA7XHJcbiAgICAgICAgY3VycmVudExldmVsID0gMDtcclxuICAgICAgIFxyXG59XHJcblxyXG5mdW5jdGlvbiBoYW5kbGVHYW1lT3Zlcigpe1xyXG4gICAgXHJcbiAgICAgICAgaWYobG9vcE9uKXtcclxuICAgICAgICAgXHJcbiAgICAgICAgICAgIGxvb3BPbiA9IGZhbHNlO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy9jaGVja3MgdG8gc2VlIHdoaWNoIHNvdW5kIHRvIHN0b3AgcGxheWluZyBnaXZlbiB0aGUgbGV2ZWwgdGhlIHVzZXIgd2FzIGJlZm9yZSBkeWluZ1xyXG5cdFx0UmVzb3VyY2VMb2FkZXIuYXNzZXRzLmdhbWVPdmVyU291bmQucGxheSgpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vcmVzZXRzIHRoZSBzY29yZSBhbmQgbGV2ZWxcclxuICAgICAgICBjdXJyZW50TGV2ZWwgPSAwO1xyXG4gICAgICAgIGN1cnJlbnRTY29yZSA9IDA7XHJcbiAgICBcclxufVxyXG5cclxuZnVuY3Rpb24gcmVjb3JkQ29sbGlzaW9uKGV2ZW50LCBvYmplY3RUeXBlKXtcclxuICAgIFxyXG4gICAgICAgIHN3aXRjaChvYmplY3RUeXBlKXtcclxuICAgICAgICAgICAgY2FzZSBcImxhcmdlUm9ja1wiOlxyXG4gICAgICAgICAgICAgICAgY3VycmVudFNjb3JlICs9IDIwO1xyXG4gICAgICAgICAgICAgICAgVUlDb250cm9sbGVyLnVwZGF0ZUNvdW50ZXIoJ3Njb3JlJywgY3VycmVudFNjb3JlKTtcclxuICAgICAgICAgICAgICAgIHJvY2tzRGVzdHJveWVkKys7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBjYXNlIFwibWVkaXVtUm9ja1wiOlxyXG4gICAgICAgICAgICAgICAgY3VycmVudFNjb3JlICs9IDEwO1xyXG4gICAgICAgICAgICAgICAgVUlDb250cm9sbGVyLnVwZGF0ZUNvdW50ZXIoJ3Njb3JlJywgY3VycmVudFNjb3JlKTtcclxuICAgICAgICAgICAgICAgIHJvY2tzRGVzdHJveWVkKys7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBjYXNlIFwic21hbGxSb2NrXCI6XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50U2NvcmUgKz0gNTtcclxuICAgICAgICAgICAgICAgIFVJQ29udHJvbGxlci51cGRhdGVDb3VudGVyKCdzY29yZScsIGN1cnJlbnRTY29yZSk7XHJcbiAgICAgICAgICAgICAgICByb2Nrc0Rlc3Ryb3llZCsrO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgY2FzZSBcImh1bWFuU2hpcFwiOlxyXG4gICAgICAgICAgICAgICAgc2hpcExpdmVzLS07XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50U2NvcmUgLT0gNTA7XHJcbiAgICAgICAgICAgICAgICBVSUNvbnRyb2xsZXIudXBkYXRlQ291bnRlcignc2NvcmUnLCBjdXJyZW50U2NvcmUpO1xyXG4gICAgICAgICAgICAgICAgVUlDb250cm9sbGVyLnVwZGF0ZUNvdW50ZXIoJ2xpdmVzJywgc2hpcExpdmVzKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGNhc2UgXCJlbmVteVwiOlxyXG4gICAgICAgICAgICAgICAgY3VycmVudFNjb3JlICs9IDUwO1xyXG4gICAgICAgICAgICAgICAgVUlDb250cm9sbGVyLnVwZGF0ZUNvdW50ZXIoJ3Njb3JlJywgY3VycmVudFNjb3JlKTtcclxuICAgICAgICAgICAgICAgIGxldmVsRW5lbWllcy0tO1xyXG4gICAgICAgICAgICAgICAgZW5lbWllc0tpbGxlZCsrO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgY2FzZSBcImxpZmVcIjpcclxuICAgICAgICAgICAgICAgIHNoaXBMaXZlcysrO1xyXG4gICAgICAgICAgICAgICAgVUlDb250cm9sbGVyLnVwZGF0ZUNvdW50ZXIoJ2xpdmVzJywgc2hpcExpdmVzKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGNhc2UgXCJzaGllbGRcIjpcclxuICAgICAgICAgICAgICAgIHBsYXllclNoaXAuc2hpZWxkLnJlc2V0KCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcImNhc2hcIjpcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxufVxyXG5cclxuZnVuY3Rpb24gaGFuZGxlQ3JlZGl0cygpe1xyXG4gICAgXHJcblx0aWYobG9vcE9uKXtcclxuXHRcdGxvb3BPbiA9IGZhbHNlO1xyXG5cdH1cclxuICAgIFxyXG4gICAgXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGhhbmRsZUhvd1RvUGxheSgpe1xyXG4gICAgXHJcblx0aWYobG9vcE9uKXtcclxuXHRcdGxvb3BPbiA9IGZhbHNlO1xyXG5cdH1cclxuICAgIFxyXG4gICAgXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGhhbmRsZVN0YXRlQ2hhbmdlKGV2ZW50LCBkYXRhKXtcclxuICAgIFxyXG4gICAgc3RhdGUuQ1VSUkVOVCA9IGRhdGEudG87XHJcbiAgICBcclxuICAgIHJ1blN0YXRlKGRhdGEudG8pO1xyXG4gICAgXHJcbiAgICBcclxufVxyXG5cclxuZnVuY3Rpb24gcnVuU3RhdGUoc3RhdGUpe1xyXG4gICAgXHJcbiAgICAgc3RhdGVIYW5kbGVyc1tzdGF0ZV0oKTtcclxuICAgIFxyXG59XHJcbiAgICBcclxuZnVuY3Rpb24gZ2FtZUxvb3AoKXtcclxuICAgIFxyXG4gICAgaWYobG9vcE9uKXtcclxuICAgICBcclxuXHRcdHJlcXVlc3RBbmltRnJhbWUoZ2FtZUxvb3AsIEZSQU1FX1JBVEUpO1xyXG5cdFx0XHRcclxuXHRcdHJ1blN0YXRlKHN0YXRlLkNVUlJFTlQpO1xyXG5cdFx0XHJcblx0XHRjb25zb2xlLmxvZygnZ2FtZSBsb29wIHJ1bm5pbmcnKTtcclxuXHRcdFxyXG5cdFx0XHJcblx0XHR9XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG4gICAgXHJcbiAgICBpbml0IDogaW5pdFxyXG4gICAgXHJcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2pzL0dhbWUuanNcbiAqKiBtb2R1bGUgaWQgPSA3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcclxudmFyIFB1YlN1YiA9IHJlcXVpcmUoJy4vUHViU3ViLmpzJyk7XHJcblxyXG52YXIga2V5Ym9hcmRDb250cm9sID0gZnVuY3Rpb24oKXtcclxuXHRcclxuXHQvL2NvbnRyb2wga2V5c1xyXG5cdGNvbnN0IFVQX0FSUk9XID0gMzgsXHJcblx0XHRMRUZUX0FSUk9XID0gMzcsXHJcblx0XHRSSUdIVF9BUlJPVyA9IDM5LFxyXG5cdFx0RE9XTl9BUlJPVyA9IDQwLFxyXG5cdFx0WF9LRVkgPSA4OCxcclxuXHRcdFNQQUNFX0JBUiA9IDMyLFxyXG5cdFx0TEVUVEVSX1AgPSA4MCxcclxuICAgICAgICAgIFxyXG4gICAgICAgIHN0YXRlID0ge1xyXG4gICAgICAgICAgICBJTklUIDogLTEsXHJcbiAgICAgICAgICAgIExPQURJTkc6IDAsXHJcbiAgICAgICAgICAgIFNUT1JZX0xJTkUgOiAxLFxyXG4gICAgICAgICAgICBUSVRMRV9TQ1JFRU4gOiAyLFxyXG4gICAgICAgICAgICBHQU1FX1BMQVkgOiAzLFxyXG4gICAgICAgICAgICBMRVZFTF9UUkFOU0lUSU9OIDogNCxcclxuICAgICAgICAgICAgQkVBVF9HQU1FIDogNSxcclxuICAgICAgICAgICAgR0FNRV9PVkVSIDogNixcclxuICAgICAgICAgICAgQ1JFRElUUyA6IDcsXHJcbiAgICAgICAgICAgIEhPV19UT19QTEFZIDogOCxcclxuICAgICAgICAgICAgUEFVU0VEIDogOSxcclxuICAgICAgICAgICAgU0hJUF9KVU1QIDogMTAsXHJcbiAgICAgICAgICAgIFNFVF9VUF9MRVZFTDogMTEsXHJcblxyXG4gICAgICAgICAgICBDVVJSRU5UIDogLTEgXHJcbiAgICB9O1xyXG5cdFxyXG5cdC8vYXJyYXkgb2YgYWN0aXZlIGFuZCBkZWFjdGl2ZSBrZXlzXHJcblx0dmFyIGtleVByZXNzTGlzdCA9IFtdLFxyXG5cdFx0b2JqZWN0cyA9IFtdLFxyXG5cdFx0aW5pdGlhbGl6ZWQgPSBmYWxzZSxcclxuXHRcdGluR2FtZVBsYXkgPSBmYWxzZTtcclxuXHRcclxuXHRmdW5jdGlvbiBpbml0KG9iamVjdHNUb0NvbnRyb2wpe1xyXG5cdFx0XHJcblx0XHQvL3B1c2hlcyB0aGUgZWxlbWVudHMgdG8gYmUgbWFuaXB1bGF0ZWQgYnkgdGhlIGtleXdvcmQga2V5c1xyXG5cdFx0aWYoIW9iamVjdHMubGVuZ3RoKXtcclxuXHRcdFx0Zm9yKGVsZW1lbnQgaW4gYXJndW1lbnRzKXtcclxuXHRcdFx0XHRvYmplY3RzLnB1c2goYXJndW1lbnRzW2VsZW1lbnRdKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFxyXG5cdFx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5dXAnLCBvbktleVVwLCBmYWxzZSk7XHJcblx0XHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgb25LZXlEb3duLCBmYWxzZSk7XHJcblx0XHRpbml0aWFsaXplZCA9IHRydWU7XHJcblx0XHRjb25zb2xlLmxvZygnS2V5d29yZCBDb250cm9sIE1vZHVsZSBJbml0aWFsaXplZCcpO1xyXG4gICAgICAgIFB1YlN1Yi5zdWJzY3JpYmUoJ3N0YXRlY2hhbmdlJywgaGFuZGxlU3RhdGVDaGFuZ2UpO1xyXG5cdFx0XHJcblx0fVxyXG5cdFxyXG5cdGZ1bmN0aW9uIGhhbmRsZVN0YXRlQ2hhbmdlKGV2ZW50LCBkYXRhKXtcclxuXHRcdHN0YXRlLkNVUlJFTlQgPSBkYXRhLnRvO1xyXG5cdH1cclxuXHRcclxuXHRmdW5jdGlvbiBvbktleVVwKGUpe1xyXG4gICAgICAgIFxyXG5cdFx0aWYoIWluaXRpYWxpemVkKSByZXR1cm4oY29uc29sZS5sb2coJ0tleXdvcmQgTW9kdWxlIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZC4uLicpKTtcclxuXHRcdGUucHJldmVudERlZmF1bHQoKTtcclxuXHRcdGtleVByZXNzTGlzdFtlLmtleUNvZGVdID0gZmFsc2U7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYoa2V5UHJlc3NMaXN0W0xFVFRFUl9QXSA9PSBmYWxzZSAmJiBzdGF0ZS5DVVJSRU5UID09PSBzdGF0ZS5QQVVTRUQpe1xyXG5cdFx0XHRcdGtleVByZXNzTGlzdFtMRVRURVJfUF0gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgUHViU3ViLnB1Ymxpc2goJ3N0YXRlY2hhbmdlJywge2Zyb206IHN0YXRlLlBBVVNFRCwgdG86IHN0YXRlLkdBTUVfUExBWX0pO1xyXG5cdFx0XHRcdGNvbnNvbGUubG9nKCdMZXR0ZXIgUCBoYXMgYmVlbiBwcmVzc2VkJyk7XHJcblxyXG5cdFx0XHR9XHJcbiAgICAgICAgXHJcblx0fVxyXG5cdFxyXG5cdGZ1bmN0aW9uIG9uS2V5RG93bihlKXtcclxuXHRcdGlmKCFpbml0aWFsaXplZCkgcmV0dXJuKGNvbnNvbGUubG9nKCdLZXl3b3JkIE1vZHVsZSBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQuLi4nKSk7XHJcblx0XHRlLnByZXZlbnREZWZhdWx0KCk7XHJcblx0XHRrZXlQcmVzc0xpc3RbZS5rZXlDb2RlXSA9IHRydWU7IFxyXG5cdH1cclxuXHRcclxuXHRmdW5jdGlvbiBydW5LZXlzKCl7XHJcbiAgICAgICAgXHJcblx0XHR2YXIgbGVuZ3RoID0gb2JqZWN0cy5sZW5ndGg7XHJcblx0XHRcclxuXHRcdGZvcih2YXIgaSA9IDA7IGk8bGVuZ3RoOyBpKyspe1xyXG5cdFx0XHRcclxuXHRcdFx0dmFyIG9iamVjdCA9IG9iamVjdHNbaV07XHJcblx0XHRcdFxyXG5cdFx0XHRpZihrZXlQcmVzc0xpc3RbTEVGVF9BUlJPV10pe1xyXG5cdFx0XHRcdG9iamVjdC5hbmdsZSAtPSA1Kk1hdGguUEkvMTgwO1xyXG5cdFx0XHR9ZWxzZSBpZihrZXlQcmVzc0xpc3RbUklHSFRfQVJST1ddKXtcclxuXHRcdFx0XHRvYmplY3QuYW5nbGUgKz0gNSpNYXRoLlBJLzE4MDtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZihrZXlQcmVzc0xpc3RbVVBfQVJST1ddKXtcclxuXHRcdFx0XHRvYmplY3QudGhydXN0ID0gdHJ1ZTtcclxuXHRcdFx0XHR2YXIgZmFjZVggPSBNYXRoLmNvcyhvYmplY3QuYW5nbGUpO1xyXG5cdFx0XHRcdHZhciBmYWNlWSA9IE1hdGguc2luKG9iamVjdC5hbmdsZSk7XHJcblx0XHRcdFx0dmFyIG5ld1ZlbFggPSBvYmplY3QudmVsWCtmYWNlWCpvYmplY3QudGhydXN0QWNjZWw7XHJcblx0XHRcdFx0dmFyIG5ld1ZlbFkgPSBvYmplY3QudmVsWStmYWNlWSpvYmplY3QudGhydXN0QWNjZWw7XHJcblxyXG5cdFx0XHRcdHZhciBmdXR1cmVWZWxvY2l0eSA9IE1hdGguc3FydCgobmV3VmVsWCpuZXdWZWxYKSsobmV3VmVsWSpuZXdWZWxZKSk7XHJcblxyXG5cdFx0XHRcdGlmKGZ1dHVyZVZlbG9jaXR5ID4gb2JqZWN0Lm1heFZlbG9jaXR5KXtcclxuXHRcdFx0XHRcdG5ld1ZlbFggPSBvYmplY3QudmVsWDtcclxuXHRcdFx0XHRcdG5ld1ZlbFkgPSBvYmplY3QudmVsWTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdG9iamVjdC52ZWxYID0gbmV3VmVsWDtcclxuXHRcdFx0XHRvYmplY3QudmVsWSA9IG5ld1ZlbFk7XHRcclxuXHJcblx0XHRcdH1lbHNle1xyXG5cdFx0XHRcdG9iamVjdC50aHJ1c3QgPSBmYWxzZTtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZihrZXlQcmVzc0xpc3RbU1BBQ0VfQkFSXSA9PSBmYWxzZSl7ICAgICAgICAgICAgICAgIFxyXG5cdFx0XHRcdGtleVByZXNzTGlzdFtTUEFDRV9CQVJdID0gdHJ1ZTtcclxuXHRcdFx0XHRpZighb2JqZWN0LnNoaWVsZC5hY3RpdmUpe1xyXG5cdFx0XHRcdG9iamVjdC5zaG9vdCgpO1xyXG5cdFx0XHRcdH1cdFx0XHRcdFxyXG5cdFx0XHR9XHJcblx0XHRcdGlmKGtleVByZXNzTGlzdFtYX0tFWV0pe1xyXG5cdFx0XHRcdG9iamVjdC5zaGllbGQuYWN0aXZlID0gdHJ1ZTtcclxuXHJcblx0XHRcdH1lbHNlIGlmKGtleVByZXNzTGlzdFtYX0tFWV0gPT0gZmFsc2Upe1xyXG5cdFx0XHRcdG9iamVjdC5zaGllbGQuYWN0aXZlID0gZmFsc2U7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYoa2V5UHJlc3NMaXN0W0xFVFRFUl9QXSA9PSBmYWxzZSl7XHJcblx0XHRcdFx0a2V5UHJlc3NMaXN0W0xFVFRFUl9QXSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBQdWJTdWIucHVibGlzaCgnc3RhdGVjaGFuZ2UnLCB7ZnJvbTogc3RhdGUuR0FNRV9QTEFZLCB0bzogc3RhdGUuUEFVU0VEfSk7XHJcblx0XHRcdFx0Y29uc29sZS5sb2coJ0xldHRlciBQIGhhcyBiZWVuIHByZXNzZWQnKTtcclxuXHJcblx0XHRcdH1cclxuXHRcdFx0XHJcblx0XHR9XHJcblx0XHRcclxuXHR9XHJcblx0XHJcblx0ZnVuY3Rpb24gZW5kKCl7XHJcblx0XHRkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXl1cCcsIG9uS2V5VXAsIGZhbHNlKTtcclxuXHRcdGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBvbktleURvd24sIGZhbHNlKTtcclxuXHRcdGluaXRpYWxpemVkID0gZmFsc2U7XHJcblx0XHRjb25zb2xlLmxvZygnS2V5d29yZCBNb2R1bGUgVGVybWluYXRlZCcpO1xyXG5cdH1cclxuXHRcclxuXHRyZXR1cm57XHJcblx0XHRpbml0IDogaW5pdCxcclxuXHRcdHVwZGF0ZSA6IHJ1bktleXMsXHJcblx0XHRlbmQgOiBlbmRcclxuXHR9XHJcblx0XHJcbn0oKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0ga2V5Ym9hcmRDb250cm9sO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9qcy9rZXlib2FyZENvbnRyb2wuanNcbiAqKiBtb2R1bGUgaWQgPSA4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9