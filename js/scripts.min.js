/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	window.addEventListener('load', canvasApp, false);
	
	function canvasApp(){	
		
		var Display = __webpack_require__(1),
			SpriteAnimation = __webpack_require__(2),
			ResourceLoader = __webpack_require__(3),
			PubSub = __webpack_require__(5),
			keyboardControl = __webpack_require__(6);
		
		
		
				//sets up game engine
			window.requestAnimFrame = (function(){
		return  window.requestAnimationFrame   ||
				window.webkitRequestAnimationFrame ||
				window.mozRequestAnimationFrame    ||
				window.oRequestAnimationFrame      ||
				window.msRequestAnimationFrame     ||
				function(/* function */ callback, /* DOMElement */ element){
					window.setTimeout(callback, FRAME_RATE);
				};
	})();
	
		//pc normal states
		const STATE_LOADING = 1,
	    STATE_INIT = 2,
	    STATE_STORY_LINE = 3,
		STATE_TITLE_SCREEN = 4,
	    STATE_HOW_TO_PLAY = 5,
		STATE_PLAYING = 6,
	    STATE_WAITING = 7,
	    STATE_LEVEL_TRANSITION = 8,
	    STATE_NEXT_LEVEL = 9,
		STATE_USER_BEAT_GAME = 10,
		STATE_GAME_OVER = 11,
		STATE_ASPECT_RATIO = 13,
		STATE_ORIENTATION_CHANGE = 14,
		STATE_USER_AGENT = 15,
	    STATE_CREDITS = 12;
			var appState;
			var previousAppState;
		
		//userAgent info and canvas control
		var userAgent = {mobile:false,platform:"", portrait:false};
		var canvasHolder = $('#canvasHolder');
	    var preloadImage = $('#preload');
	    var interfaceWrapper = $('#interfaceWrapper');
		var orientationMessageHolder = $('#orientationMessage');
		
		//frame, assets counter and audio support
		var frameRate = new FrameRateCounter();
		var itemsToLoad = 17;
		var loadCount = 0;
		var FRAME_RATE = 1000/60;
		var loopOn = false;
		
		//set up loader
		var loaderOptions = {
				assets : {
					imgs : {
				earthSprite : "assets/sprites/earth.png",
				playerSpriteSheet : "assets/sprites/playerShip.png",
				enemySpriteSheet : "assets/sprites/enemyShips.png",
				MothershipSpriteSheet : "assets/sprites/motherships.png",
				backgroundSprite : "assets/sprites/background.png",
				meteorSprite : "assets/sprites/meteorSprite.png",
				perkSprite : "assets/sprites/perks.png"
					}
				},
				onload : function(item){
					console.log("The source of the item that has just loaded is " + item.src);
				},
				final : function(){
					initAssets();
				}
			};
	    
	    
		//mouse
		var mouse = {x:0,y:0, alive:true};
		
		//counters
		var scoreCounter = $('#scoreCounter');
		var levelCounter = $('#levelCounter');
		var livesCounter = $('#livesCounter');
		var frameRateCounter = $('#frameRate');
	    var reportEnemiesKilled = $('#reportCarnage');
	    var reportRocksDestroyed = $('#reportAsteroids');
	    var reportScore = $('#reportScore');
	    var beatGameScore = $('#beatGameScore');
		
		//title screen buttons 
		var startButton = $('#startGame');
	    var howToPlayButton = $('#howToPlay');
		var restartButton = $('#restart');
	    var storyLineButton = $('#storyLine');
	    var creditsButton = $('#creditsButton');
	    
		
		//game text div holders and controls
		var gameStartHolder = $('#gameStart');
		var gamePlayHolder = $('#gamePlay');
		var gameOverHolder = $('#gameOver');
	    var howToPlayHolder = $('#howToPlayHolder');
	    var storyLineHolder = $('#storyLineHolder');
	    var levelTransitionHolder = $('#levelTransition');
	    var creditsHolder = $('#credits');
	    var beatGameHolder = $('#beatGame');
	    
	    var nextLevelButton = $('#nextLevel');
		var howToBackButton = $('#howToBack');
	    var storyLineSkipButton = $('#skipStoryLine');
	    var shareButton = $('#shareStart');
	    var skipCredits = $('#skipCredits');
	    
		//score  & level variables
		var currentScore = 0,
		    currentLevel = 0,
	        lastLevel = 14,
	        userBeatGame = false,
	        enemyShipWorth = 10,
	        rockWorth = 5,
		    shipLives = 4;
		
		var friction = 0.005;
	    
	    inheritFrom(Display, Physics);
	    inheritFrom(Physics, Spacecraft);
	    inheritFrom(Display, Background);
	    
		//make custom classes inherit display class
	    inheritFrom(Physics, Missile);
	    inheritFrom(Display, Shield);
	    inheritFrom(Spacecraft, Ship);
	    inheritFrom(Display, Explosion);
	    inheritFrom(Spacecraft, Enemy);
	    inheritFrom(Physics, Rock);
	    inheritFrom(Spacecraft, Mothership);
	    inheritFrom(Physics, Perk);
	    
	
	    
		//sounds API
		var mySubscription = PubSub.subscribe('gamestate', handleSub);
		var secondSub = PubSub.subscribe('gamestate', handleSubTwo);
		console.log("The event key for sub one is : ", mySubscription);
		console.log("The event key for sub two is : ", secondSub); 
	    
	    
		//gets canvas and its context and creates center x and y variables
		var mainCanvas = $('#bgCanvas');
		var mainContext = mainCanvas.getContext('2d');
		var centerX;
		var centerY;
	    
		//array holding key presses
		var keyPressList = [];
	
		//TEMP: player instance and enemies
	    var playerShip = new Ship();
		var alienMothership = new Mothership();
	    var humanMothership = new Mothership();
		var background = new Background();
	
	    var gameInterface = new Interface();
	    //temp assets
	    var tempEnemy = new Enemy();
	    var tempMothership = new Mothership();
		var tempSpriteSheetAnimation = new SpriteAnimation();
	    
	    
	    var totalEnemies = 8,
	        totalRocks = 10,
	        levelRocks = 5,
	        levelEnemies = 8,
	        levelPerks = 4,
	        enemiesKilled = 0,
	        rocksDestroyed = 0;
	
	     //pools holding enemies and rocks
	    var enemyShipsPool = new Pool(totalEnemies),
	        humanShipsPool = new Pool(10),
	        perksPool = new Pool(10),
	        meteorPool = new Pool(totalRocks);
	    
	    console.log(background);
	    console.log(playerShip);
	    console.log(tempEnemy);
	    console.log(tempMothership);
	    
	
		
		appState = STATE_USER_AGENT;
		runState();
		
		function runState(){
			
		switch(appState){
				
			case STATE_USER_AGENT:
					getUserAgentInfo();
				break;
				
			case STATE_ASPECT_RATIO:
					setAspectRatio();
				break;
			case STATE_ORIENTATION_CHANGE:
					onOrientationChange();
				break;
			//normal states
			case STATE_INIT: 
				loadAssets();
				break;
			case STATE_LOADING:
				//wait for calls backs of load events
				break;
	        case STATE_STORY_LINE:
	            storyLine();
	            break;
			case STATE_TITLE_SCREEN:
				introAnimation();
				break;
	        case STATE_HOW_TO_PLAY:
	            howToPlay();
	            break;
			case STATE_PLAYING:
				drawCanvas();
				break;
	        case STATE_LEVEL_TRANSITION:
	            //the transition between one level and the other.
	            transLevelAnimation();
	            break;
	        case STATE_NEXT_LEVEL:
	            nextLevelDialog();
				break;
	        case STATE_WAITING:
	            //loop does nothing, waits for a change in state.
	            break;
			case STATE_USER_BEAT_GAME:
	            beatGame();
				break;
	        case STATE_CREDITS:
	            //sets to credits
	            break;
			case STATE_GAME_OVER:
				gameOver();
				break;
			}
		}
		
		function gameLoop(){
			if(loopOn){
				requestAnimFrame(gameLoop, FRAME_RATE);
	            //window.setTimeout(gameLoop, FRAME_RATE);
				runState();
			}
		}
		
		function getUserAgentInfo(){
			
			userAgent.platform = navigator.platform;
			
			if(userAgent.platform != "Win32" && userAgent.platform != "MacIntel"){
				userAgent.mobile = true;
				window.addEventListener('resize', onOrientationChange, false);
				if(window.innerHeight>= window.innerWidth){
					orientationMessageHolder.setAttribute('style', 'display:block;');
					canvasHolder.setAttribute('style', 'display:none;');
	                interfaceWrapper.setAttribute('style','display:none;');
					userAgent.portrait = true;
				}
			}
			appState = STATE_ASPECT_RATIO;
			runState();
		}
		
		function setAspectRatio(){
			
			//if not on mobile, set the canvas ratio to 600 by 480
			if(!userAgent.mobile){
				mainCanvas.width = 600;
				mainCanvas.height = 480;
				centerX = mainCanvas.width/2;
		        centerY = mainCanvas.height/2;
			}else{
	            centerX = mainCanvas.width/2;
		        centerY = mainCanvas.height/2;
				mainCanvas.setAttribute('style', 'width: 100%; height: 100%');
				document.addEventListener('touchmove', onTouchMove, false);
				interfaceWrapper.setAttribute('style', 'margin: auto;');
			}        
			
			loopOn = true;
			appState = STATE_INIT;
			gameLoop();
			
		}
		
		function loadAssets(){
	        
	        //change app state
			appState = STATE_LOADING;
		    
			//sounds 5 sounds
			soundTrack = new Howl({
	                    src: ['assets/sounds/soundtrack.mp3','assets/sounds/soundtrack.wav'],
	                    volume: 0.5,
	                    loop: false
	                        });
	
			
	        finalLevelSound = new Howl({
	                     src: ['assets/sounds/finalLevelSound.mp3','assets/sounds/finalLevelSound.wav'],
	                     volume: 1,
	                        });
		
	        meteorExplosionSound = new Howl({
	                                    src: ['assets/sounds/meteorExplosion.mp3','assets/sounds/meteorExplosion.wav'],
	                                    volume: 1,
	                                    });
	        playerShootSound = new Howl({
	                                    src: ['assets/sounds/shoot.mp3','assets/sounds/shoot.wav'],
	                                    volume: 0.3,
	                                    });
	        explosionSound = new Howl({
	                                    src: ['assets/sounds/explosion.mp3','assets/sounds/explosion.wav'],
	                                    volume: 0.2,
	                                    });
	        perkSound = new Howl({
	                    src: ['assets/sounds/perk.mp3','assets/sounds/perk.wav'],
	                    volume: 1.0,
	                        });
			
	        victorySound = new Howl({
	                    src: ['assets/sounds/victory.mp3','assets/sounds/victory.wav'],
	                    volume: 1.0,
	                        });
	        gameOverSound = new Howl({
	                    src: ['assets/sounds/gameover.mp3','assets/sounds/gameover.wav'],
	                    volume: 1.0,
	                        });
	        
			ResourceLoader.init(loaderOptions);
			ResourceLoader.downloadAll();
		
	        //hides preload image
	        preloadImage.setAttribute('style', 'display:none;');
	        
		}
		
		function initAssets(){
	        
	        background.setCanvas(mainCanvas);
			background.init(1000, 480);
			background.velX = 1;
	        
	        perksPool.init("perks");
	        meteorPool.init("rocks");
	        enemyShipsPool.init('enemy');
	        
	        alienMothership.setCanvas(mainCanvas);
	        alienMothership.init('alien');
	      
	        
	        
	
	        playerShip.setCanvas(mainCanvas);
	        playerShip.init(23, 23);
	        playerShip.spawn(centerX, centerY);
	        
	        window.addEventListener('mousemove', onMouseMove, false);
	        gameInterface.addButtonListeners();
	
			userAgent.mobile = false;
	        
	    
	        if(userAgent.mobile){
				//add game controls for mobile devices based on motion
				window.addEventListener('touchend', onTouchEndHandler, false);
				window.addEventListener('devicemotion', devMotionHandler, false);
				//adds listener for touch move to remove the default behavior
				window.addEventListener('touchstart', onTouchStart, false);
				
			}else{
				//add game control for desktop based on keyboard events
				keyboardControl.init(playerShip);
			}
			
	        gameInterface.display('storyLine');
			appState = STATE_STORY_LINE;
			
		}
	    
	    
	    //function in charged of playing the story line
	    function storyLine(){
	        
	        background.draw(); 
	    }
		
		function introAnimation(){
	        
	        
	        
			background.draw();
			mainContext.drawImage(ResourceLoader.assets.earthSprite, (mainCanvas.width/2-(ResourceLoader.assets.earthSprite.width/2)), 0);
	        for(var i=0; i<7; i++){
	            var currentEnemy = enemyShipsPool.pool[i];
	            currentEnemy.draw();
	            currentEnemy.follow(mouse);
	            checkBoundary(currentEnemy);
	        }
	        
	        
	        
	        
		}
	    
	    function howToPlay(){
	        
	    }
	    
	    //function in charged of setting up the enemies and rocks in the new level given the current level
	    function setUpLevel(){
	        
	        
	        
	        console.log('Set Up Level function CALLED');
	        
	        
	        //sets up random location for rocks and mothership
	            var randomX, randomY;
	        
	        //increases level by 1
	        currentLevel += 1;
	        
	        //checks if game is over
	        if(currentLevel > lastLevel){
	            userBeatGame = true;
	            return;
	        }
	           
	        if(currentLevel == lastLevel){
	            finalLevelSound.play();
	        }else{
	            //begins normal soundtrack 
			   soundTrack.play();
	        }
			
	        //resets enemy killed and rocks destroyed counter and ship lives
	        enemiesKilled = 0;
	        rocksDestroyed = 0;
	        if(currentLevel == 1){
	        shipLives = 4;
	        }
	        //sets up number of rocks and enemies that will be displayed
	        levelEnemies = currentLevel+1;
	        levelRocks = currentLevel+2;
	        
	        //checks to see if the level rocks and enemies exceed total in pool.
	        levelEnemies = (levelEnemies>=totalEnemies)? totalEnemies : levelEnemies;
	        levelRocks = (levelRocks>=totalRocks)? totalRocks : levelRocks;
	        
	        //centers ship and hide all of its missiles
	        playerShip.spawn(centerX, centerY);
	        
	        //kill off any alive rocks and enemies
	        perksPool.hideItems();
	        enemyShipsPool.hideItems();
	        meteorPool.hideItems();
	        
	        //inits the rocks
	        for(var i=0; i<levelRocks; i++){
	            randomX = Math.floor(Math.random()*(mainCanvas.width-50)),
	            randomY = Math.floor(Math.random()*(mainCanvas.height-50));
	            meteorPool.get(randomX, randomY, "largeRock");
	            meteorPool.get(randomX, randomY, "smallRock");
	        }
	        
	        for(var h=0; h<levelPerks; h++){
	            randomX = Math.floor(Math.random()*(mainCanvas.width-50)),
	            randomY = Math.floor(Math.random()*(mainCanvas.height-50));
	            perksPool.get(randomX, randomY, "life");
	            perksPool.get(randomY, randomX, "shield");
	        }
	    
	        //alienMothership.init("alien");
	        alienMothership.spawn(randomX, randomY);
	        alienMothership.shield.active = true;
	        alienMothership.setRelease(levelEnemies, 8);
	        
	        updateCounter('level');
	        updateCounter('life');
	        updateCounter('score');
	        
	    }
		
		//temp code
		
		function handleSub(event, data){
			window.alert("The game state has changed to : " + data);
		}
		
		function handleSubTwo(event, data){
			console.log("the game state has changed to : " + data);
		}
		
		
		
		
		
	
		//once the user has clicked the start button, this function draws the game
		function drawCanvas(){
	        
	        background.draw();
	
	        if(alienMothership.alive){
	        alienMothership.draw();
	        checkBoundary(alienMothership);
	        alienMothership.follow(playerShip);
	        alienMothership.attack(playerShip);
	        alienMothership.missiles.isCollidingWith(playerShip, playerShip.shield);
	        playerShip.missiles.isCollidingWith(alienMothership, alienMothership.shield);
	        }
	
	            for(var m=0; m<perksPool.pool.length; m++){
	                    var currentPerk = perksPool.pool[m];
	                    if(currentPerk.alive){
	                        currentPerk.draw(); 
	                        
	                        if(hitTest(currentPerk, playerShip)){
	                            console.log('DETECTION CONFIRMED!!');
	                            console.log(currentPerk);
	                            console.log(playerShip);
	                            currentPerk.destroy();
	                            recordCollision(currentPerk.type);
	                        }
	                    }
	                }
	        
	        for(var i = 0; i<meteorPool.pool.length; i++){
	           
	            var currentMeteor = meteorPool.pool[i];
	            
	            if(currentMeteor.alive){
	                currentMeteor.draw();
	                checkBoundary(currentMeteor);
	                playerShip.missiles.isCollidingWith(currentMeteor);
	                /*
	                enemyShipsPool.pool.forEach(function(enemy){
	                    enemy.missiles.isCollidingWith(currentMeteor);
	                });
	                */
	            }
	        }
	        
	        meteorPool.isCollidingWith(playerShip, playerShip.shield);
	        
	        for(var h = 0; h<enemyShipsPool.pool.length; h++){
	            
	            var currentEnemy = enemyShipsPool.pool[h];
	            
	            if(currentEnemy.alive){
	                currentEnemy.draw();
	                checkBoundary(currentEnemy);
	                currentEnemy.follow(playerShip);
	                currentEnemy.attack(playerShip);
	                currentEnemy.missiles.isCollidingWith(playerShip, playerShip.shield, meteorPool.pool);
	                playerShip.missiles.isCollidingWith(currentEnemy, currentEnemy.shield);
	            }
	            
	        }
	
	        //counts actual frames
			frameRate.countFrames();
	        
	        //hide debugging frame counter on final versions
			frameRateCounter.innerHTML = "Frames: "+frameRate.lastFrameCount;
	        frameRateCounter.innerHTML = "";
	        
			
	        if(playerShip.alive){
				keyboardControl.update();
	            checkBoundary(playerShip);
	            playerShip.draw();
	        }
	        
	        
	        if(shipLives <= 0 && !playerShip.colliding && appState == STATE_PLAYING){
	            
	                    if(currentLevel == lastLevel){
							finalLevelSound.stop();
						}else{
							soundTrack.stop(); 
						}
	            
	                currentLevel = 0;
	                appState = STATE_GAME_OVER;
	            
	        }else if(levelEnemies <= 0 && !playerShip.colliding && playerShip.alive && appState == STATE_PLAYING){
	            
	                    if(currentLevel == lastLevel){
							finalLevelSound.stop();
						}else{
							soundTrack.stop(); 
						}
	            
	            playerShip.angle = playerShip.velY = playerShip.velX = 0;
	            playerShip.velX = 1;
	            
	            gameInterface.hide('gamePlay');
	            updateCounter('level');
	            appState = STATE_LEVEL_TRANSITION;
	
	        }
	    
		}
	    
	    //function in charged of transition level
	    function nextLevelDialog(){
	        
	        appState = STATE_WAITING;
	        
	        reportEnemiesKilled.innerHTML = "Enemies Killed: "+enemiesKilled;
	        reportRocksDestroyed.innerHTML = "Asteroids Destroyed: "+rocksDestroyed;
	        reportScore.innerHTML = "Score: "+currentScore;
	        
	        gameInterface.hide('gamePlay');
	        gameInterface.display('nextLevel');
	        
	    }
	    
	    function transLevelAnimation(){
	        
	        //draw background
	        background.draw();
	        
	        //drawRemaining rocks
	        for(var k=0; k<meteorPool.pool.length; k++){
	            var currentRock = meteorPool.pool[k];
	            
	            //if rock alive draw it
	            if(currentRock.alive){
	            checkBoundary(currentRock);
	            currentRock.draw();
	            }
	        }
	        
	        enemyShipsPool.pool.forEach(function(enemy){
	            if(enemy.alive){
	                enemy.draw();
	            }
	        });
	        
	        playerShip.velX += playerShip.velX*playerShip.easeValue;
	        playerShip.draw();
	        
	        console.log(playerShip.velX);
	        
	        
	        if(playerShip.x >= 1020-playerShip.width){
	            appState = STATE_NEXT_LEVEL;   
	        }
	        
	    }
	    
	    function beatGame(){
	        appState = STATE_WAITING;
			
	        //outputs the final score to the winner gamer :)
	        finalLevelSound.stop();       
	        beatGameScore.innerHTML = "Your Score: "+currentScore;
	        userBeatGame = false;
	        gameInterface.hide('gamePlay');
	        gameInterface.display('beatGame'); 
	        victorySound.play();
	        
	        //resets that score
	        currentScore = 0;
	        currentLevel = 0;
	        
	    }
	
		//function in charged of ending the game
		function gameOver(){
	        
	        //changes the state to call code only once.
			appState = STATE_WAITING;
	        
	        //checks to see which sound to stop playing given the level the user was before dying
			gameOverSound.play();
	        
	        //resets the score and level
	        currentLevel = 0;
	        currentScore = 0;
	
	        //displays the appropriate interface
	        gameInterface.hide('gamePlay');
	        gameInterface.display('gameOver');
	        
		}
		
		
		//checks if an object has left the canvas bouding box
		function checkBoundary(object){
	
			if(object.x >= object.canvasWidth){
				object.x = 0;
			}else if(object.x <= -object.width){
				object.x = object.canvasWidth-object.width;
			}else if(object.y >= object.canvasHeight+object.height){
				object.y = 0;
			}else if(object.y <= -object.height){
				object.y = object.canvasHeight-object.height;
			}	
		}
		
		//collision detection.
		function hitTest(object1, object2){
	   		var left1 = object1.x;
	   		var left2 = object2.x;
	   		var right1 = object1.x + object1.width;
	   		var right2 = object2.x + object2.width;
	   		var top1 = object1.y;
	   		var top2 = object2.y;
	   		var bottom1 = object1.y + object1.height;
	   		var bottom2 = object2.y + object2.height;
	
	   		if (bottom1 < top2) return(false);
	   		if (top1 > bottom2) return(false);
	   		if (right1 < left2) return(false);
	   		if (left1 > right2) return(false);
	        if (!object1.alive || object1.colliding || object2.colliding || !object2.alive) return(false);
	        
	        if (object1.type == "humanShip" && object1.velX == 0) return(false);
	        if (object2.type == "humanShip" && object2.velX == 0) return(false);
	        
	        if(object2 instanceof Spacecraft){
	            if(object2.shield.active){
	                return (false);
	            }
	        }
	        if(object1 instanceof Spacecraft){
	            if(object1.shield.active){
	                return (false);
	            }
	        }
	        
	
	        //otherwise return true 
	   		return(true);
	
		}
	        
	    //game score tracker
	    
	    function recordCollision(objectType){
	        switch(objectType){
	            case "largeRock":
	                currentScore += 20;
	                updateCounter('score');
	                rocksDestroyed++;
	                break;
	                
	            case "mediumRock":
	                currentScore += 10;
	                updateCounter('score');
	                rocksDestroyed++;
	                break;
	                
	            case "smallRock":
	                currentScore += 5;
	                updateCounter('score');
	                rocksDestroyed++;
	                break;
	                
	            case "humanShip":
	                shipLives--;
	                currentScore -= 50;
	                updateCounter('score');
	                updateCounter('life');
	                break;
	                
	            case "enemy":
	                currentScore += 50;
	                updateCounter('score');
	                levelEnemies--;
	                enemiesKilled++;
	                break;
	                
	            case "life":
	                shipLives++;
	                updateCounter('life');
	                break;
	                
	            case "shield":
	                playerShip.shield.reset();
	                break;
	            case "cash":
	                break;
	        }
	        
	    }
	    
	    
		//updates game board, scores, level etc..
		function updateCounter(object){
			switch(object){
				case "life":
					livesCounter.innerHTML = "Lives: "+shipLives;
					break;
				case "score":
					scoreCounter.innerHTML = "Score: "+currentScore;
					break;
				case "level":
					levelCounter.innerHTML = "Level: "+currentLevel;
					break;
			}
		}
		
		//handles the mousemove interaction at title screen.
		function onMouseMove(event){
	        
			if(appState != STATE_TITLE_SCREEN){
	            return;
	        }
	        
			if ( event.layerX ||  event.layerX == 0) { // Firefox
	   			mouse.x = event.layerX ;
	    		mouse.y = event.layerY;
	  		} else if (event.offsetX || event.offsetX == 0) { // Opera
	    		mouse.x = event.offsetX;
	    		mouse.y = event.offsetY;
	  		}
			
		}
		
	
		
		//Checks for device orientation
		function onOrientationChange(e){
	
			if(window.innerHeight>= window.innerWidth){
				userAgent.portrait = true;
				orientationMessageHolder.setAttribute('style', 'display: block;');
				canvasHolder.setAttribute('style', 'display:none;');
	            interfaceWrapper.setAttribute('style', 'display: none;');
			}else if(window.innerHeight<=window.innerWidth){
				orientationMessageHolder.setAttribute('style', '');
				canvasHolder.setAttribute('style', '');
	            interfaceWrapper.setAttribute('style', '');
				userAgent.portrait = false;
			}
			
		}
		
		//removes the default behavior of pinching zoom on Mobile
		function onTouchMove(e){
			e.preventDefault();
		}
		
		//pauses the game via the pause button
		function onPauseButton(e){
			loopOn = !loopOn;
			gameLoop();
		}
		
		
		//FramRate Class
		
		function FrameRateCounter() {
	
	   this.lastFrameCount = 0;
	   var dateTemp = new Date();
	   this.frameLast = dateTemp.getTime();
	   delete dateTemp;
	   this.frameCtr = 0;
	    }
	
	    FrameRateCounter.prototype.countFrames=function() {
	       var dateTemp = new Date();
	       this.frameCtr++;
	
	       if (dateTemp.getTime() >=this.frameLast+1000) {
	          //ConsoleLog.log("frame event");
	          this.lastFrameCount = this.frameCtr;
	          this.frameLast = dateTemp.getTime();
	          this.frameCtr = 0;
	       }
	
	       delete dateTemp;
	    }
	
	
	    //inheriter function
	    function inheritFrom(parent, child){
	        var copyOfParent = Object.create(parent.prototype);
	        copyOfParent.constructor = child;
	        child.prototype = copyOfParent;
	    }
		
		//custom classes
	    function Physics(){
	        
	            Display.call(this);
	        
	        this.velX = 0;
	        this.velY = 0;
	        this.acelX = 0;
	        this.acelY = 0;
	        this.colliding = false;
	        this.speed = 0; 
	        this.thrust = 0;
	        this.angle = 0;
	    }
	    
	    Physics.prototype.spawn = function(x, y, angle, speed){
	        
	        this.x = x || centerX;
	        this.y = y || centerY;
	        this.colliding = false;
	        this.alive = true;
	        this.angle = angle || this.angle;
	        this.speed = speed || this.speed;
	        this.velX = Math.cos(this.angle)*this.speed;
	        this.velY = Math.sin(this.angle)*this.speed;
	        
	    };
	    
	    Physics.prototype.destroy = function(){
	        this.alive = false; 
	    };
	    
	    //spaceCraft function constructor 
	    function Spacecraft(){
	            
	           Physics.call(this);
	        
	        this.autoSpawn = false;
	        this.thrustAccel = 0.03;
	        this.alphaSpeed = 0.03;
	        this.shieldActive = false;
	        this.shieldDisabled = false;
			this.maxVelocity = 4;
	        this.missilesSpeed = 2.5;
	        
	    }
	    
	    Spacecraft.prototype.init = function(width, height){
	        
	            Display.prototype.init.call(this, width, height);
	        
	        var shield = new Shield();
	            shield.setCanvas(mainCanvas);
	            shield.init(80,80);
	        var missilePool = new Pool(10);
	            missilePool.init('missile');
	        var explosion = new Explosion(15);
	            explosion.setCanvas(mainCanvas);
	            
	        this.explosion = explosion;
	        this.shield = shield;
	        this.missiles = missilePool;
	        
	    };    
	    Spacecraft.prototype.follow = function(object){
	        
				if(!object.alive){
					return;
				}	
				var dx, dy, distance, newVelX, newVelY, futureVel, direction;
				dx = object.x - this.x;
				dy = object.y - this.y;
				distance = Math.sqrt(dx*dx+dy*dy);
				direction = Math.atan2(dy, dx);
				this.angle = direction;
				
				if(distance>=140){
				newVelX = this.velX+Math.cos(this.angle)*this.thrustAccel;
				newVelY = this.velY+Math.sin(this.angle)*this.thrustAccel;	
				futureVel = Math.sqrt(newVelX*newVelX + newVelY*newVelY);	
						if(futureVel>1.5){
					newVelX = this.velX;
					newVelY = this.velY;
					}else{
					this.velX = newVelX;
					this.velY = newVelY;
					}
				}	
	    };
	    
	    Spacecraft.prototype.attack = function(object){
				if(Math.random() >= 0.005 || !this.alive || !object.alive){
					return;
				}
				this.shoot();
	    };
	    
	    Spacecraft.prototype.spawn = function(x, y, angle, speed){
	        
	            Physics.prototype.spawn.call(this, x, y, angle, speed);
	            this.missiles.hideItems();
	            //this.shield.reset();
	        
	    };
	    
	    Spacecraft.prototype.destroy = function(){
	        
	        this.colliding = true;  
	        explosionSound.play();
	        
	    };
	
	    Spacecraft.prototype.draw = function(){
	        
	        //draws spacecraft launched missiles
	        for(var i=0; i<this.missiles.pool.length; i++){
	            var currentMissile = this.missiles.pool[i];   
	            if(currentMissile.alive){
	                currentMissile.draw();   
	            }
	        }
	        
	        if(this.colliding){	
	                //if spacecraft is colliding, create an explosion
	            this.explosion.create(this.x+this.centerX, this.y+this.centerY);
	            this.explosion.draw();
	                //once the explosion is not running, kill off spacecraft
	            if(!this.explosion.running){
	                this.alive = false;
	                this.colliding = false;
	                if(this.autoSpawn){
	                 this.spawn();   
	                }
	            }
	                //return while colliding
	            return;
	                    
	        }
	            //if shield is active draw it.
	        if(this.shield.active){
	                this.shield.x = this.x-this.shield.centerX+this.centerX;
	                this.shield.y = this.y-this.shield.centerY+this.centerY;
	                this.shield.draw();
	        }    
	        
	    };
	    
	    Spacecraft.prototype.shoot = function(){
	        
	        //if instance is not alive, is colliding or not moving, it will NOT shoot
	        if(!this.alive || this.colliding || this.velX == 0){
	                return;
	        }
	
	        this.missiles.get(this.x+10, this.y+10, "missile", this.angle, this.missilesSpeed);
			
	    };
	    
	    //class for the rocks floating
	    
	    function Rock(){
	        
	            Physics.call(this);
	        
	        this.size;
	        this.spriteAnimation = new SpriteAnimation();
	        this.spriteAnimation.setCanvas(mainCanvas);
	        this.explosion = new Explosion(7);
	        this.explosion.setCanvas(mainCanvas);
	        this.type = 'rock';
	    
	    }
	    
	    Rock.prototype.init = function(size){
	        
	          var spriteAnimationInfo,
	              largeRockSpeed = 0.5,
	              mediumRockSpeed = 1,
	              smallRockSpeed = 1.2,
	              randomAngle;
	        
	        
	            
	            size = size || "large";
	    
	            switch(size){
	                case "large":
	                    
	                    spriteAnimationInfo = {width:56,height:55, offsetX: 0, offsetY: 0, numCol:2, numRow:9,fps:60,speed:8,loop:false,from:0,to:17};
	                    this.spriteAnimation.init(spriteAnimationInfo);
	                    this.sprite = ResourceLoader.assets.meteorSprite;
	                    randomAngle = Math.random()*(Math.PI*2);
	                    Display.prototype.init.call(this, spriteAnimationInfo.width, spriteAnimationInfo.height);
	                    Physics.prototype.spawn.call(this, 0, 0, randomAngle, largeRockSpeed);
	                    this.alive = false;
	                    this.size = "large";
	                    this.type = "largeRock";
	                    
	                    break;
	                case "medium":
	                    
	                    spriteAnimationInfo = {width:44,height:44, numCol:3, numRow:6,fps:60,offsetX: 130, offsetY : 0, speed:12,loop:true,from:0,to:17};   
	                    this.spriteAnimation.init(spriteAnimationInfo);
	                    this.sprite = ResourceLoader.assets.meteorSprite;
	                    randomAngle = Math.random()*(Math.PI*2);
	                    Display.prototype.init.call(this, spriteAnimationInfo.width, spriteAnimationInfo.height);
	                    Physics.prototype.spawn.call(this, 0, 0, randomAngle, mediumRockSpeed);
	                    this.alive = false;
	                    this.size = "medium";
	                    this.type = "mediumRock";
	                    
	                    break;
	                case "small":
	                    
	                    spriteAnimationInfo = {width:33,height:33, numCol:3,offsetX: 290, offsetY: 0, numRow:6,fps:60,speed:15,loop:true,from:0,to:17};
	                    this.spriteAnimation.init(spriteAnimationInfo);
	                    this.sprite = ResourceLoader.assets.meteorSprite;
	                    randomAngle = Math.random()*(Math.PI*2);
	                    Display.prototype.init.call(this, spriteAnimationInfo.width, spriteAnimationInfo.height);
	                    Physics.prototype.spawn.call(this, 0, 0, randomAngle, smallRockSpeed);
	                    this.alive = false;
	                    this.size = "small";
	                    this.type = "smallRock";
	                    
	                    break;
	            }
	            
	    };
	    
	    Rock.prototype.draw = function(){
	            
				if(this.colliding){ 
	            //when object is colliding, creates and draws explosion
				this.explosion.create(this.x+this.centerX, this.y+this.centerY);
				this.explosion.draw();
	                this.destroy();
	
				     if(!this.explosion.running){
				     //once explosion is over, kills off object
	                    this.colliding = false;
	                    this.alive = false;
	                    }
	                // if the explosion is still running return to drawing the explosion
				     return;
				}
	            
	            this.x += this.velX;
	            this.y += this.velY;
	            
	            this.spriteAnimation.play(this.x, this.y, this.sprite);    
	            
	        };
	    
	    Rock.prototype.destroy = function(){
	        
	            if(this.colliding){
	                return;
	            }
	        
	            meteorExplosionSound.play();
	            this.colliding = true;
	            
	            switch(this.size){
	                case "large":
	                meteorPool.get(this.x, this.y, "mediumRock");
	                meteorPool.get(this.x, this.y, "mediumRock");
	                    break;
	                case "medium":
	                meteorPool.get(this.x, this.y, "smallRock");
	                meteorPool.get(this.x, this.y, "smallRock");
	                    break;
	                case "small":
	                    //no rocks
	                    break;     
	            }  
	    };    
	    
		function Background(){
	        
	            Display.call(this);
	        
	        this.velX = 0;
	        this.velY = 0;
			this.progressBarWidth = 400;
			this.progressBarHeight = 40;
		}
	    
	    Background.prototype.draw = function(){
	            this.x += this.velX;
				this.y += this.velY;
	            
	            this.context.drawImage(ResourceLoader.assets.backgroundSprite, 0,0,this.canvasWidth,this.canvasHeight,this.x-this.canvasWidth, this.y,this.canvasWidth,this.canvasHeight);	
	            this.context.drawImage(ResourceLoader.assets.backgroundSprite, 0,0,this.canvasWidth,this.canvasHeight,this.x,this.y,this.canvasWidth,this.canvasHeight);
				
				if(this.x>this.canvasWidth){
					this.x = 0;
				}	
	    };
	    Background.prototype.drawProgress = function(loaded, toLoad){
				this.context.fillStyle = '#000000';
				this.context.fillRect(0,0, this.canvasWidth, this.canvasHeight);
				this.context.strokeStyle = '#FFFFFF';
				this.context.strokeRect((this.canvasWidth-400)/2, this.canvasHeight/2-40, this.progressBarWidth, this.progressBarHeight);
				this.context.fillStyle = '#FFFFFF';
				this.context.fillRect((this.canvasWidth-400)/2, this.canvasHeight/2-40, (this.progressBarWidth*(loaded/toLoad)), this.progressBarHeight);
				this.context.font = '20px Ariel';
				this.context.textAlign = 'center';
				this.context.fillText('Loading...', this.canvasWidth/2, this.canvasHeight/2+40);
			};
	    Background.prototype.clear = function(){
				this.context.fillStyle = '#000000';
				this.context.fillRect(0,0,this.canvasWidth, this.canvasHeight);
			};	
	    
	    
	    
	    
	    function Interface(){
	        
	        this.addButtonListeners = function(){
	            
	            storyLineSkipButton.addEventListener('mousedown', function(){
	                gameInterface.hide('storyLine');
	                gameInterface.display('titleScreen');
	                appState = STATE_TITLE_SCREEN;
	            }, false);
	            
	            //the only exception
	            startButton.addEventListener('mousedown', function(){
	                gameInterface.hide('titleScreen');
	                gameInterface.display('gamePlay');
	                setUpLevel();
	                appState = STATE_PLAYING;
	            }, false);
	            
	            storyLineButton.addEventListener('mousedown', function(){
	                gameInterface.hide('titleScreen');
	                gameInterface.display('storyLine');
	                appState = STATE_STORY_LINE;
	            }, false);
	            howToPlayButton.addEventListener('mousedown', function(){
	                gameInterface.hide('titleScreen');
	                gameInterface.display('howToPlay');
	                appState = STATE_HOW_TO_PLAY;
	            }, false);
	            creditsButton.addEventListener('mousedown', function(){
	                gameInterface.hide('titleScreen');
	                gameInterface.display('credits');
	                appState = STATE_CREDITS;
	            }, false);
	            skipCredits.addEventListener('mousedown', function(){
	                gameInterface.hide('credits');
	                gameInterface.display('titleScreen');
	                appState = STATE_TITLE_SCREEN;
	            }, false);
	            howToBackButton.addEventListener('mousedown', function(){
	                gameInterface.hide('howToPlay');
	                gameInterface.display('titleScreen');
	                appState = STATE_TITLE_SCREEN;
	            }, false);    
	            nextLevelButton.addEventListener('mousedown', function(){
	                
	                    setUpLevel();
	                
	                if(!userBeatGame){
	                    gameInterface.hide('nextLevel');
	                    gameInterface.display('gamePlay');
	                    appState = STATE_PLAYING;
	                }else{
	                    gameInterface.hide('nextLevel');
	                    gameInterface.display('beatGame');
	                    appState = STATE_USER_BEAT_GAME;
	                }
	                
	            }, false);
	            shareButton.addEventListener('mousedown', function(){
	                userBeatGame = false;
	                currentLevel = 0;
	                window.open('https://www.facebook.com/sharer.php?u=http://www.noxtar.com/2016/06/play-earth-defender-game.html');
	                gameInterface.hide('beatGame');
	                gameInterface.display('titleScreen');
	                appState = STATE_TITLE_SCREEN;
	            }, false);
	            restartButton.addEventListener('mousedown', function(){
	                gameInterface.hide('gamePlay');
	                gameInterface.hide('gameOver');
	                gameInterface.display('titleScreen');
	                appState = STATE_TITLE_SCREEN;
	            }, false);
	        };
	        
	        this.display = function(page){
	            switch(page){
	                case "titleScreen":
	                    gameStartHolder.setAttribute('style', 'display: block;');
	                    break;
	                case "gamePlay":
	                    gamePlayHolder.setAttribute('style', 'display: block;'); 
	                    break;
	                case "storyLine":
	                    storyLineHolder.setAttribute('style', 'display: block;');
	                    break;
	                case "howToPlay":
	                    howToPlayHolder.setAttribute('style', 'display:block;');
	                    break;
	                case "nextLevel":
	                    levelTransitionHolder.setAttribute('style', 'display: block;');  
	                    break;
	                case "gameOver":
	                    gameOverHolder.setAttribute('style', 'display: block;');
	                    break;
	                case "beatGame":
	                    beatGameHolder.setAttribute('style', 'display: block;');
	                    break;
	                case "credits":
	                    creditsHolder.setAttribute('style', 'display: block;');
	                    break;
	                case "none":
	                    interfaceWrapper.setAttribute('style', '');
	                    break;        
	            } 
	        };
	        this.hide = function(page){
	            switch(page){
	                case "titleScreen":
	                    gameStartHolder.setAttribute('style', '');
	                    break;
	                case "gamePlay":
	                    gamePlayHolder.setAttribute('style', ''); 
	                    break;
	                case "storyLine":
	                    storyLineHolder.setAttribute('style', '');
	                    break;
	                case "howToPlay":
	                    howToPlayHolder.setAttribute('style', '');
	                    break;
	                case "nextLevel":
	                    levelTransitionHolder.setAttribute('style', '');  
	                    break;
	                case "gameOver":
	                    gameOverHolder.setAttribute('style', '');
	                    break;
	                case "beatGame":
	                    beatGameHolder.setAttribute('style', '');
	                    break;
	                case "credits":
	                    creditsHolder.setAttribute('style', '');
	                    break;
	                case "none":
	                    interfaceWrapper.setAttribute('style', '');
	                    break;        
	            } 
	        };
	    }
	    
	    
		
		function Ship(){
	        
	                Spacecraft.call(this);
	        
	            var shipSpriteInfo = {width:21,height:22, numCol:1, numRow:2,fps:60,speed:30,loop:false,from:0,to:0};
	        
	            this.thrust = false;
	            this.autoSpawn = true;
	            this.thrustAccel = 0.04;
	            this.missilesSpeed = 3.2;
	            this.easeValue = 0.03;
	            this.spriteAnimation = new SpriteAnimation();
	            this.spriteAnimation.setCanvas(mainCanvas);
	            this.spriteAnimation.init(shipSpriteInfo); 
	            this.type = "humanShip";
	        
		}
	    
	    Ship.prototype.draw = function(){
	        
	           Spacecraft.prototype.draw.call(this);
	        
	        if(this.colliding){
	            return;   
	        }
	        
	                this.context.save();
	                this.alpha += this.alphaSpeed;
	                this.alpha = (this.alpha >= 1)? 1: this.alpha;
	                this.context.globalAlpha = this.alpha;
	                this.context.translate(this.x+10, this.y+10);	
	                this.context.rotate(this.angle);
	                this.x += this.velX;
	                this.y += this.velY;
	                if(this.thrust){
	                    this.spriteAnimation.startFrame = 1;
	                    this.spriteAnimation.finalFrame = 1;
	                    this.spriteAnimation.play(-this.centerX, -this.centerY, ResourceLoader.assets.playerSpriteSheet);
	                }else{
	                    //this.context.drawImage(shipSprite, 0, 0, this.width, this.height, -10,-10, this.width, this.height);
	                    this.spriteAnimation.startFrame = 0;
	                    this.spriteAnimation.finalFrame = 0;
	                    this.spriteAnimation.play(-this.centerX, -this.centerY, ResourceLoader.assets.playerSpriteSheet);
	                }
	                this.context.restore();
	    };
		
		Ship.prototype.shoot = function(){
			Spacecraft.prototype.shoot.call(this);
			playerShootSound.play();
		};
	    
	    function Perk(){
	        
	            Physics.call(this);
	        
	        this.spriteAnimation = new SpriteAnimation(); 
	        this.spriteAnimation.setCanvas(mainCanvas);
	    
	        this.type = 'perk';    
	    }
	    Perk.prototype.draw = function(){
	        
	        if(!this.alive){
	            return;
	        }
	        
	        this.x += this.velX;
	        this.y += this.velY;
	        
	        this.spriteAnimation.play(this.x, this.y, ResourceLoader.assets.perkSprite);
	        
	    };
	    Perk.prototype.init = function(perk){
	            
	            var spriteInfo; 
	                
	            
	            switch(perk){
	                    
	                case "shield":
	                        spriteInfo = {width:18,height:19, numCol:1, numRow:2,fps:60,speed:1,loop:false,from:0,to:0};
	                        this.spriteAnimation.init(spriteInfo);
	                        Display.prototype.init.call(this, spriteInfo.width, spriteInfo.height);
	                        this.type = "shield";
	                    break;
	                    
	                case "life":
	                        spriteInfo = {width:18,height:19, numCol:1, numRow:2,fps:60,speed:1,loop:false,from:1,to:1};
	                        this.spriteAnimation.init(spriteInfo);
	                        Display.prototype.init.call(this, spriteInfo.width, spriteInfo.height);
	                        this.type = "life";
	                    break;
	            }
	    }; 
		
		Perk.prototype.destroy = function(){
			Physics.prototype.destroy.call(this);
			perkSound.play();
		};        
	    //missle constructor
	    
		function Missile(){
	        
	            Physics.call(this);
	        
			this.speed = 3;
			this.life = 0;
			this.maxLife = 100;
	        this.type = "missile";
	
		}
	    
	    Missile.prototype.spawn = function(x, y, angle, speed){
	        Physics.prototype.spawn.call(this, x, y, angle, speed);  
	        this.life = 0;
	    };
	    
	    Missile.prototype.draw = function(){
	        
	        this.life++;
				if(this.life>=this.maxLife){
					this.life = 0;
					this.alive = false;
				}
				this.x += this.velX;
				this.y += this.velY;
				this.context.fillStyle = this.color;
				this.context.fillRect(this.x, this.y, this.width, this.height);
	    
	    };
	    
		function Enemy(){
	        
	            Spacecraft.call(this);
	        
			this.thrustAccel = 0.03;
	        this.type = "enemy";
	        
			
	        var spriteRandomIndex = Math.floor(Math.random()*4);
	        this.spriteAnimation = new SpriteAnimation();
	        this.spriteAnimation.setCanvas(mainCanvas);
	        var enemySpriteInfo = {width:23,height:21, numCol:1, numRow:4,fps:60,speed:30,loop:false,from:spriteRandomIndex,to:spriteRandomIndex};
	        this.spriteAnimation.init(enemySpriteInfo);
	    
		}
	    
	    Enemy.prototype.draw = function(){
	        
	                Spacecraft.prototype.draw.call(this);
	            
	            if(this.colliding || !this.alive){
	                return;   
	            }
	        
	                this.x += this.velX;
	                this.y += this.velY;
	                this.context.save();
	                this.context.translate(this.x+this.centerX, this.y+this.centerY);
	                this.context.rotate(this.angle);
	                this.spriteAnimation.play(-this.centerX, -this.centerX, ResourceLoader.assets.enemySpriteSheet);
	                this.context.restore();  
	                
	
	    };
	        
	    //mothership constructor
	    function Mothership(){
	        
	             Spacecraft.call(this);
	        
	        
	        this.hasReleasedShips = false;
	        this.spriteAnimation = new SpriteAnimation();
	        this.spriteAnimation.setCanvas(mainCanvas);
	        this.type = undefined;
	        this.missilesSpeed = 3;
	        this.alpha = 0;
	        this.alphaSpeed = 0.02;
	        this.numShips = 0;
	        this.type = "mothership";
	    
	    }
	    
	    Mothership.prototype.jump = function(){
	        
	            console.log('JUMPED MOTHERSHIP!');
	            if(this.alpha == 0 && this.hasReleasedShips){
	                this.alive = false;
	            } 
	            this.alive = false;
	            this.shield.active = false;
	        
	        };
	    
	    Mothership.prototype.init = function(shipType){
	        
	            switch(shipType){
	                    
	                case "human":
	                    
	                 var spriteSheetInfo = {width:51,height:46, numCol:1, numRow:2,fps:60,speed:30,loop:false,from:0,to:0};
	                 var spriteIndex = Math.floor(Math.random()*spriteSheetInfo.to);
	                 spriteSheetInfo.from = spriteSheetInfo.to = spriteIndex;
	                 this.spriteAnimation.init(spriteSheetInfo);
	                 this.type = "human";
	                 this.width = spriteSheetInfo.width;
	                 this.height = spriteSheetInfo.height;
	                 this.centerX = this.width / 2;
	                 this.centerY = this.height / 2;
	                    Spacecraft.prototype.init.call(this, this.width, this.height);
	                    break;
	                    
	                case "alien":
	                    
	                var spriteSheetInfo = {width:51,height:46, numCol:4, numRow:2,fps:60,speed:30,loop:false,from:0,to:4};
	                var spriteIndex = Math.floor(Math.random()*spriteSheetInfo.to);
	                spriteSheetInfo.from = spriteSheetInfo.to = spriteIndex;
	                this.spriteAnimation.init(spriteSheetInfo);
	                this.type = "alien";
	                this.width = spriteSheetInfo.width;
	                this.height = spriteSheetInfo.height;
	                this.centerX = this.width / 2;
	                this.centerY = this.height / 2;
	                    Spacecraft.prototype.init.call(this, this.width, this.height);
	                    
	                    break;     
	            }
	            
	        };
	    
	    Mothership.prototype.setRelease = function(numShip, time){
	            
	            if(this.hasReleasedShips){
	              return;   
	            }
	            
	            //assigns number of ships to release
	            this.numShips = numShip;
	            
	            //checks if time to release ships was passed in
	            time = (time == undefined)? 5: time;
	
	            var countDownRunning = true;
	            var currentTime = 0;
	            var finalTime = time;
	            var self = this;
	            
	            tick();  
	            
	            function tick(){
	                
	            if(countDownRunning){
	                
	                currentTime++;
	                    if(currentTime >= finalTime){
	                        
	                        Mothership.prototype.releaseShips.call(self);
	                        countDownRunning = false;
	                        currentTime = 0;
	                        tick();
	                    }
	                window.setTimeout(tick, 1000);   
	                }    
	            }   
	             
	        };
	    
	    Mothership.prototype.releaseShips = function(){
	        
	            if(!this.alive) return;
	        
	        console.log('ship release function has been called');
	            
	            this.hasReleasedShips = true;
	            this.shield.active = false;
	            
	            switch(this.type){
	                case "alien":
	                    
	                    for(var i=0; i<this.numShips; i++){
	                    
	                    var positionX = this.x + enemyShipsPool.pool[i].width*i;
	                    var positionY = this.y + enemyShipsPool.pool[i].height*i;
	                    enemyShipsPool.get(positionX, positionY, 'enemy');
	                    enemyShipsPool.pool[i].shield.active = false;
	                        
	                        } 
	                    
	                    break;
	                case "human":
	                    
	                   for(var j=0; j<this.numShips; j++){
	
	                    enemyShipsPool.pool[j].spawn(this.x, this.y);   
	                    
	                        }  
	                    
	                    break;      
	            } 
	            
	        };
	    
	    
	    Mothership.prototype.spawn = function(x, y, angle, speed){
	            
	            Spacecraft.prototype.spawn.call(this, x, y, angle, speed);
	            this.hasReleasedShips = false;
	            this.alpha = 0;
	            
	        };
	    
	    Mothership.prototype.draw = function(){
	            
	            Spacecraft.prototype.draw.call(this);
	        
	            if(this.colliding || !this.alive){
	                console.log('ships dead wont draw it');
	                return;
	                
	            }
	            this.x += this.velX;
	            this.y += this.velY;
	        
	        
	            this.context.save();
	            this.context.translate(this.x+this.centerX, this.y+this.centerY);
	            this.context.rotate(this.angle);
	            if(this.hasReleasedShips){
	                this.alpha -= this.alphaSpeed;   
	                this.alpha = (this.alpha <= 0)? 0: this.alpha; 
	                this.alive = (this.alpha <= 0)? false : true;
	            }else{
	            this.alpha += this.alphaSpeed;
	            this.alpha = (this.alpha >= 1)? 1: this.alpha;
	            }
	            this.context.globalAlpha = this.alpha;
	            this.spriteAnimation.play(-this.centerX, -this.centerY, ResourceLoader.assets.MothershipSpriteSheet);
	            this.context.restore();
	            
	            if(this.alpha <= 0){
	                this.alive = false;
	            } 
	        };
	    
	    
	    
	    
	    // explosion constructor
		function Explosion(numParticles){
	        
	            Display.call(this);
	        
			this.running = false;
			this.particles = [];
			this.deadParticleCounter = 0;
			this.size = numParticles;
	        
			for(var i = 0; i<numParticles; i++){
				this.particles.push({x:0,y:0,alive:false,maxLife:0,velX:0,velY:0, width:2, height:2, life:0});
			}
				
		}
	    
	    Explosion.prototype.create = function(x, y){
	        if(this.running){
					return;
				}
				
				for(var i=0;i<this.size;i++){
					var currentParticle = this.particles[i];
					currentParticle.x = x;
					currentParticle.y = y;
					currentParticle.maxLife = Math.random()*45+15;
					currentParticle.velX = Math.random()*4-2.8;
					currentParticle.velY = Math.random()*4-2.8;
					currentParticle.alive = true;
					currentParticle.life = 0;
				}
				this.running = true;
				this.deadParticleCounter = 0;
	    };
	    Explosion.prototype.draw = function(){
	        
	        if(!this.running){
					return;
				}
				
				this.context.fillStyle = '#00FF00';
				for(var i=0; i<this.size; i++){
					var currentParticle = this.particles[i];
					if(currentParticle.alive){
					currentParticle.x += currentParticle.velX;
					currentParticle.y += currentParticle.velY;
					currentParticle.life++;
					this.context.fillRect(currentParticle.x, currentParticle.y, currentParticle.width, currentParticle.height);
	                        if(currentParticle.life >= currentParticle.maxLife){
	                        currentParticle.alive = false;
	                        currentParticle.life = 0;
	                        this.deadParticleCounter++;
	                    }
					}
					
				}
	//change the state from running to false by checking if there are any particles alive left
				if(this.deadParticleCounter>=this.size){
					this.running = false;
				}
	        
	    };
	    
	    //Shield constructor
		function Shield(){
	        
	            Display.call(this);
	        
			this.radius = 40;
			this.maxRadius = 45;
	        this.life = 100;
	        this.disabled = false;
	        this.color = '#0000FF';
	        this.type = 'shield';
	        var shieldState = false;
	    
	        Object.defineProperty(this, "active", {
	            get: function(){
	                
	                return shieldState;
	                
	            },
	            set: function(value){
	                
	                shieldState = (this.disabled)? false: value;
	                this.alive = shieldState;
	                
	            },
	            configurable: true,
	            enumerable: true
	        });
	        
	        
		}
	    
	    Shield.prototype.reduceLife = function(amount){
	        amount = (amount === undefined)? 50: amount;
	        this.life -= amount;
	    };
	    
	    Shield.prototype.draw = function(){
	        
	            if(!this.active){
	                console.log('shield is disabled');
	                return;
	            }
	            if(this.life <= 0){
	                this.life = 0;
	                this.disabled = true;
	                this.active = false;
	                    return;
	            }
				this.context.strokeStyle = this.color;
	            this.context.lineWidth = 1;
				this.context.beginPath(); 
				this.context.arc(this.x+this.centerX, this.y+this.centerY, this.radius, 0, Math.PI*2, true);
				this.context.closePath();
				this.context.stroke(); 
				this.radius += .25;
				this.radius = (this.radius>this.maxRadius)? 40: this.radius;
	        
	    };
	    
	    Shield.prototype.reset = function(){
	            this.life = 100;
	            this.disabled = false;
	    };
	    
	    
	    //meteor pool
		function Pool(maxSize){
	        
			var pool = [];
	        
			this.pool = pool;
	        this.size = maxSize;
	        
		}
	    
	    Pool.prototype.init = function(type){
	            
	            switch(type){
	                case "missile":
	                    
	                  for(var i=0; i<this.size; i++){
						var missile = new Missile();
						missile.setCanvas(mainCanvas);
						missile.init(2,2);
						this.pool[i] = missile;
					}  
	                    break;
	                    
	                case "enemy":
	                   for(var j=0; j<this.size; j++){
	                    var randomX = Math.floor(Math.random()*mainCanvas.width);
	                    var randomY = Math.floor(Math.random()*mainCanvas.height);
	                    
	                    var enemy = new Enemy();
	                    enemy.setCanvas(mainCanvas);
	                    enemy.init(23, 21);
	                    enemy.x = randomX;
	                    enemy.y = randomY;
	
	                    this.pool[j] = enemy;
	                       
	                } 
	                    break;
	                    
	                case "perks":
	                    this.size = Math.floor(this.size / 2);
	
	                    for(var k=0; k<this.size; k++){
	                        var life = new Perk();
	                        life.setCanvas(mainCanvas);
	                        life.init("life");
	                        this.pool.push(life); 
	                    }
	
	                    for(var h=0; h<this.size; h++){
	                        var shield = new Perk();
	                        shield.setCanvas(mainCanvas);
	                        shield.init("shield");
	                        this.pool.push(shield);
	                    }
	                    
	                    this.size *= 2;
	                    
	                    break;
	                    
	                case "rocks":
	                    
	                    var numMediumRocks = this.size*2;
	                    var numSmallRocks = numMediumRocks*2;
	
	                        for(var l=0; l<this.size; l++){
	                            var meteor = new Rock();
	                            meteor.setCanvas(mainCanvas);
	                            meteor.init("large");
	                            meteor.type = "largeRock";
	                            this.pool.push(meteor);
	                        }
	                        for(var m=0; m<numMediumRocks; m++){
	                            var meteorMedium = new Rock();
	                            meteorMedium.setCanvas(mainCanvas);
	                            meteorMedium.init("medium");
	                            meteorMedium.type = "mediumRock";
	                            this.pool.push(meteorMedium);
	                        }
	                        for(var n=0; n<numSmallRocks; n++){
	                            var meteorSmall = new Rock();
	                            meteorSmall.setCanvas(mainCanvas);
	                            meteorSmall.init("small");
	                            meteorSmall.type = "smallRock";
	                            this.pool.push(meteorSmall);
	                        }
	                    
	                    this.size += (numMediumRocks+numSmallRocks);
	                    
	                    break;
	            }
	            
	    };
	    
	    Pool.prototype.get = function(x, y, type, angle, speed){
	        
	            type = type || "missile";
	        
	            /* code from before mixing both pools meteor and regular 
				if(!this.pool[size-1].alive){
					this.pool[size-1].spawn(x,y, angle, speed);
					this.pool.unshift(pool.pop());
				}
	            */
	            var i = 0;
	
	                while(i<this.size){
	                    if(this.pool[i].type === type && !this.pool[i].alive){
	                        this.pool[i].spawn(x, y, angle, speed);
	                        break;
	                    }
	                    i++;     
	                }
	        
	    };
	
	    Pool.prototype.isCollidingWith = function(args){
	            
	            var length = this.pool.length;
	            var argsLength = arguments.length;
	            
	            for(var i = 0; i<length; i++){
	                
	                var currentItem = this.pool[i];
	                
	                if(currentItem.alive){
	                
	                for(var h = 0; h<argsLength; h++){
	                    //each argument represents the objects being passed in to this method.
	                    var currentArgument = arguments[h];
						
						//if one of the arguments to check for collision is a pool of objects, iterate over each item.
						if(Array.isArray(currentArgument)){
							for(var j = 0, len = currentArgument.length; j < len; j++){
								var currentPoolItem = currentArgument[j];
								checkCollision(currentItem, currentPoolItem);
							}
						}else{
								checkCollision(currentItem, currentArgument);
						}
	                }
	            }
	                
	        }
				//function in charge of testing for collision and executing what to do when there is a collision, it also makes a call to the recordCollision function which handles the recording of collisions for points and score.
				function checkCollision(item1, item2){
					
						if(hitTest(item1, item2)){
								if(item2 instanceof Shield){
									if(!(item1 instanceof Rock)){
											item1.destroy();
											item2.reduceLife(10);
											recordCollision(item1.type);
										}
									}else if(item1 instanceof Perk){
										item1.destroy();
										recordCollision(item1.type);
									}else{
										item2.destroy();
										item1.destroy();
										recordCollision(item2.type);
										recordCollision(item1.type);
									}
							}
	
				}
	    };
	    
	    Pool.prototype.hideItems  = function(){
	            var length = this.pool.length;
	            for(var i=0; i<length; i++){
	                this.pool[i].alive = false; 
	            }
	    };
	        
		function $(selector){
		       return document.querySelector(selector);
	    }
		
		//end of canvasApp function
	}


/***/ },
/* 1 */
/***/ function(module, exports) {

	var Display = (function(){
		
		function Display(){
	       
			this.canvasWidth = 0;
			this.canvasHeight = 0;
			this.centerX = 0;
			this.centerY = 0;
			this.height = 0;
			this.width = 0;
			this.x = 0;
			this.y = 0;
			this.color = "#00FF00";
			this.alpha = 1;
	        this.alive = false;  
	        this.context = undefined;
	        this.type = "display";
	       
		}
	        //temp proto method....
	    Display.prototype.reset = function(){
				this.x = 0;
				this.y = 0;
				this.angle = 0;
				this.velX = 0;
				this.velY = 0;
				this.alive = false;
				this.colliding = false;
			};
	    
	    Display.prototype.setCanvas = function(canvas){
				this.context = canvas.getContext('2d');
				this.canvasWidth = canvas.width;
				this.canvasHeight = canvas.height;
			};
	    
	    Display.prototype.init = function(width, height){
				this.width = width || 20;
				this.height = height || 20;
				this.centerX = width/2;
				this.centerY = height/2;
				this.alive = false;
			};
	    
	    //Physics data type
		
		return Display;
		
		
	})();
	
	module.exports = Display;

/***/ },
/* 2 */
/***/ function(module, exports) {

	var SpriteAnimation = (function(){
		 
	     function SpriteAnimation(){
			 
	        this.width;
	        this.height;
	        this.x;
	        this.y;
			this.offsetX = 0;
			this.offsetY = 0;
	        this.context;
	        this.canvasHeight;
	        this.canvasWidth;
	        this.speed;
	        this.numCol;
	        this.numRow;
	        this.currentFrame;
	        this.finalFrame;
	        this.startFrame;
	        this.totalFrames;
	        this.appFPS;
			 //spritesheet animations loops by default
	        this.loop = true;
			    //private members 
	     	this._frames = [];
	        this._frameIncrement;
	        this._frameIndex;
	
			 
		 }
		
	     SpriteAnimation.prototype.setCanvas = function(canvas){
	            this.context = canvas.getContext('2d');
	            this.canvasHeight = canvas.height;
	            this.canvasWidth = canvas.width;
	      };
		
	     SpriteAnimation.prototype.init = function(spriteObject){
	            
	            //sets up sprite properties from the spritesheet info object being passed in.
	            this.width = spriteObject.width || 32;
	            this.height = spriteObject.height || 32;
	            this.numCol = spriteObject.numCol || 1;
	            this.numRow = spriteObject.numRow || 1;
	            this.startFrame = spriteObject.from || 0;
	            this.finalFrame = spriteObject.to || 0;
	            this.speed = spriteObject.speed || 15;
			 	this.offsetX = spriteObject.offsetX || 0;
			 	this.offsetY = spriteObject.offsetY || 0;
	            this.totalFrames = spriteObject.numCol * spriteObject.numRow - 1;
	            this.loop = spriteObject.loop || true;
	            this.appFPS = spriteObject.fps;
	            
	            //creates the decimal of increment for each second
	            this._frameIncrement = this.speed/spriteObject.fps;
	            this._frameIndex = this.startFrame;        
	            
	            //creates a variable holding the length of the array holding the frames
	            var totalFramesLength = spriteObject.numCol * spriteObject.numRow;
	            
	            for(var i = 0; i < totalFramesLength; i++){
	                var frame = {};
						frame.regX = this.offsetX;
						frame.regY = this.offsetY;
	                
	                //indexes the regX and regY points of each sprite frame into the array.
	                if(i>=this.numCol){
	                    frame.regX += (i - Math.floor(i/this.numCol)*this.numCol)*this.width;
	                    frame.regY += Math.floor(i/this.numCol)*this.height;
	
	                }else{
	                    frame.regX += i * this.width;
	                    frame.regY += 0;
	                }
	                //pushes the objects with the regX and regY for each frame into a frame array.
	                this._frames.push(frame);
	                
	            }
	              
	        };
	        //use this method to locate or move the sprite sheet to a cordinate
	        SpriteAnimation.prototype.play = function(x, y, sprite){
	            this.x = x || 0;
	            this.y = y || 0;
	
	            //no animation will be playeed if the starting frame is equal to the final frame.
	            if(this.startFrame === this.finalFrame){
					
		//surrounds the sprite into a white block for debugging purposes, you can remove this in your final app
	                //this.context.strokeStyle = '#FFFFFF';
	                //this.context.strokeRect(this.x, this.y, this.width, this.height);
	               
	                this.currentFrame = this._frames[this.startFrame];
	                this.context.drawImage(sprite, this.currentFrame.regX, this.currentFrame.regY, this.width, this.height, this.x, this.y, this.width, this.height);
	                
	            }else{
	                //increments the frameIndex by a decimal, this will be floored because it is used to find an item in the frame array.
	                this._frameIndex += this._frameIncrement;
	                
	                if(this._frameIndex >= this.finalFrame + 1){
	                    this._frameIndex = (this.loop)? this.startFrame: this.finalFrame;
	                }
	                //floors the current index to a whole number so to find an object in the frame array
	                this.currentFrame = this._frames[Math.floor(this._frameIndex)];
	                //surrounds the sprite into a white block for debugging purposes, you can remove this in your final app
	                //this.context.strokeStyle = '#FFFFFF';
	                //this.context.strokeRect(this.x, this.y, this.width, this.height);
	                //draws the section of the image given the regX and regY as well as the width and height
	                this.context.drawImage(sprite, this.currentFrame.regX, this.currentFrame.regY, this.width, this.height, this.x, this.y, this.width, this.height); 
	            } 
	        };
	        //use this method to change the fps speed of your sprite sheet animation
	        SpriteAnimation.prototype.setSpeed = function(speed){
	            //reason why a method for this is needed is because there is  math to be done when speed is changed.
	          this.speed = speed || this.speed;
	            this._frameIncrement = this.speed / this.appFPS;
	            this._frameIndex = this.startFrame;   
	        }; 
		
	        SpriteAnimation.prototype.getFrame = function(frameIndex){
	            this._frameIndex = (frameIndex == undefined)? 0: frameIndex;
	            return this._frames[this._frameIndex];
	        };
	           
	    
	     return SpriteAnimation;
		
		
	 })();
	
	module.exports = SpriteAnimation;

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	var Howl = __webpack_require__(4);
	
	var ResourceLoader = (function(){
		
		var totalAssets = 0,
			loadedAssets = 0,
			assetsDownloaded = false,
			UserOptions,
			percentageLoaded,
			audioSupport,
			assets = {};
		
			//default options if no option argument is passed by user.
			var defaultOptions = {
						  onload: function(){ 
							console.log('No callback was passed in..');
							},
						  final : function(){
							  console.log('No final function to call was passed in..');
						  },
						 assets : []
						 };
		
		/* Example of options:
		
		{
			assets : {
			
				imgs : {
					//img names with URLs
					bg_black : "assets/img/background.png,
					meteorSprite : "assets/img/meteor.png,
					enemiesSprite : "assets/img/enemies.png,
					enemyShipSprites: "assets/img/enemyShips.png
				},
				sounds : {
					//sounds name with URLs
					soundtrack : ["assets/sounds/player.mp3", "assets/sounds/player.wav"],
					endSound : ["assets/sounds/gameover.mp3", "assets/sounds/gameover.wav"]
				}
			}
	        useHowl : false,
				//function that is called on every item loaded
			onload : updateLoaderDisplayer,
				//function that is called once all have loaded
			final : finalFunctionToCall
		}
	
		*/
			
		function init(options){
			UserOptions = options || defaultOptions;
		}
		
		function download(){
			
			//return if all assets have already loaded and indexed.
			if(assetsDownloaded) return;
			
			//sets to true so this method (downloadAll()) is called only onced.
			assetsDownloaded = true;
			//creates the sound and image elements for each asset in the options argument.
			for(var item in UserOptions.assets.imgs){
				assets[item] = new Image();
				assets[item].src = UserOptions.assets.imgs[item];
				assets[item].addEventListener('load', onLoad, false);
				totalAssets++;
			}
			//arrays are passed for each sound asset containing the source to the sound.
	        if(!UserOptions.useHowl){
	            for(var item in UserOptions.assets.sounds){
	                for(var i=0, j=UserOptions.assets.sounds[item].length; i<j; i++){
	                var currentSound = UserOptions.assets.sounds[item][i];
	                    //analyzes the extension and picks the first one that is supported by the browser.
	                    if(isAudioSupport(currentSound.slice(-3))){
	                        assets[item] = new Audio();
	                        assets[item].src = UserOptions.assets.sounds[item][i];
	                        assets[item].addEventListener('canplaythrough', onLoad, false);
	                        totalAssets++;
	                        break;
	                    }
	                }
	
	            }
	        }else{
	            //creates howl instance and passes in howl options given by the user.
	            for(var item in UserOptions.assets.sounds){
	                var howlOptions = UserOptions.assets.sounds[item];
	                howlOptions.onload = onLoad;
	                assets[item] = new Howl(howlOptions); 
	                totalAssets++;
	                
	            }
	        }
			
		}
		
		function onLoad(item){
	        
	        //increments load count and remove listeners.
			loadedAssets++;
	        
	        var itemLoaded;
	
	        if(item){
	            if(item.target.tagName === "AUDIO"){
	                itemLoaded = item.target;
	                item.target.removeEventListener('canplaythrough', onLoad, false);
	            }else if (item.target.tagName === "IMG"){
	                itemLoaded = item.target;
	                item.target.removeEventListener('load', onLoad, false);
	            }
	        }else{
	            itemLoaded = {name: "Howl sound", src: "Howl sound check sound"};   
	        }
	        
			//calculates the decimal value from ratio
			percentageLoaded = Math.floor((loadedAssets / totalAssets)*100)/100;
			
			//call the appropriate callback function given the ammount of assets loaded.
			if(UserOptions.onload){
				UserOptions.onload(itemLoaded);
			}
			if(loadedAssets >= totalAssets && UserOptions.final){
				UserOptions.final(itemLoaded);
			}
			
		}
		
		//gets the appropriate supported audio format.
		function isAudioSupport(extension){
			
			var audio = new Audio();
			var supportValue = audio.canPlayType("audio/"+extension);
			if( supportValue === "maybe" || supportValue === "probably" ){
				return true;
			}else{
				return false;
			}
		}
		
		return {
			init : init,
			assets : assets,
			get loaded(){
				return percentageLoaded;
			},
	    	downloadAll : download
		}
		
	})();
	
	module.exports = ResourceLoader;

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(global) {/*!
	 *  howler.js v2.0.0
	 *  howlerjs.com
	 *
	 *  (c) 2013-2016, James Simpson of GoldFire Studios
	 *  goldfirestudios.com
	 *
	 *  MIT License
	 */
	
	(function() {
	
	  'use strict';
	
	  /** Global Methods **/
	  /***************************************************************************/
	
	  /**
	   * Create the global controller. All contained methods and properties apply
	   * to all sounds that are currently playing or will be in the future.
	   */
	  var HowlerGlobal = function() {
	    this.init();
	  };
	  HowlerGlobal.prototype = {
	    /**
	     * Initialize the global Howler object.
	     * @return {Howler}
	     */
	    init: function() {
	      var self = this || Howler;
	
	      // Internal properties.
	      self._codecs = {};
	      self._howls = [];
	      self._muted = false;
	      self._volume = 1;
	      self._canPlayEvent = 'canplaythrough';
	      self._navigator = (typeof window !== 'undefined' && window.navigator) ? window.navigator : null;
	
	      // Public properties.
	      self.masterGain = null;
	      self.noAudio = false;
	      self.usingWebAudio = true;
	      self.autoSuspend = true;
	      self.ctx = null;
	
	      // Set to false to disable the auto iOS enabler.
	      self.mobileAutoEnable = true;
	
	      // Setup the various state values for global tracking.
	      self._setup();
	
	      return self;
	    },
	
	    /**
	     * Get/set the global volume for all sounds.
	     * @param  {Float} vol Volume from 0.0 to 1.0.
	     * @return {Howler/Float}     Returns self or current volume.
	     */
	    volume: function(vol) {
	      var self = this || Howler;
	      vol = parseFloat(vol);
	
	      // If we don't have an AudioContext created yet, run the setup.
	      if (!self.ctx) {
	        setupAudioContext();
	      }
	
	      if (typeof vol !== 'undefined' && vol >= 0 && vol <= 1) {
	        self._volume = vol;
	
	        // Don't update any of the nodes if we are muted.
	        if (self._muted) {
	          return self;
	        }
	
	        // When using Web Audio, we just need to adjust the master gain.
	        if (self.usingWebAudio) {
	          self.masterGain.gain.value = vol;
	        }
	
	        // Loop through and change volume for all HTML5 audio nodes.
	        for (var i=0; i<self._howls.length; i++) {
	          if (!self._howls[i]._webAudio) {
	            // Get all of the sounds in this Howl group.
	            var ids = self._howls[i]._getSoundIds();
	
	            // Loop through all sounds and change the volumes.
	            for (var j=0; j<ids.length; j++) {
	              var sound = self._howls[i]._soundById(ids[j]);
	
	              if (sound && sound._node) {
	                sound._node.volume = sound._volume * vol;
	              }
	            }
	          }
	        }
	
	        return self;
	      }
	
	      return self._volume;
	    },
	
	    /**
	     * Handle muting and unmuting globally.
	     * @param  {Boolean} muted Is muted or not.
	     */
	    mute: function(muted) {
	      var self = this || Howler;
	
	      // If we don't have an AudioContext created yet, run the setup.
	      if (!self.ctx) {
	        setupAudioContext();
	      }
	
	      self._muted = muted;
	
	      // With Web Audio, we just need to mute the master gain.
	      if (self.usingWebAudio) {
	        self.masterGain.gain.value = muted ? 0 : self._volume;
	      }
	
	      // Loop through and mute all HTML5 Audio nodes.
	      for (var i=0; i<self._howls.length; i++) {
	        if (!self._howls[i]._webAudio) {
	          // Get all of the sounds in this Howl group.
	          var ids = self._howls[i]._getSoundIds();
	
	          // Loop through all sounds and mark the audio node as muted.
	          for (var j=0; j<ids.length; j++) {
	            var sound = self._howls[i]._soundById(ids[j]);
	
	            if (sound && sound._node) {
	              sound._node.muted = (muted) ? true : sound._muted;
	            }
	          }
	        }
	      }
	
	      return self;
	    },
	
	    /**
	     * Unload and destroy all currently loaded Howl objects.
	     * @return {Howler}
	     */
	    unload: function() {
	      var self = this || Howler;
	
	      for (var i=self._howls.length-1; i>=0; i--) {
	        self._howls[i].unload();
	      }
	
	      // Create a new AudioContext to make sure it is fully reset.
	      if (self.usingWebAudio && typeof self.ctx.close !== 'undefined') {
	        self.ctx.close();
	        self.ctx = null;
	        setupAudioContext();
	      }
	
	      return self;
	    },
	
	    /**
	     * Check for codec support of specific extension.
	     * @param  {String} ext Audio file extention.
	     * @return {Boolean}
	     */
	    codecs: function(ext) {
	      return (this || Howler)._codecs[ext];
	    },
	
	    /**
	     * Setup various state values for global tracking.
	     * @return {Howler}
	     */
	    _setup: function() {
	      var self = this || Howler;
	
	      // Keeps track of the suspend/resume state of the AudioContext.
	      self.state = self.ctx ? self.ctx.state || 'running' : 'running';
	
	      // Automatically begin the 30-second suspend process
	      self._autoSuspend();
	
	      // Check for supported codecs.
	      if (!self.noAudio) {
	        self._setupCodecs();
	      }
	
	      return self;
	    },
	
	    /**
	     * Check for browser support for various codecs and cache the results.
	     * @return {Howler}
	     */
	    _setupCodecs: function() {
	      var self = this || Howler;
	      var audioTest = (typeof Audio !== 'undefined') ? new Audio() : null;
	
	      if (!audioTest || typeof audioTest.canPlayType !== 'function') {
	        return self;
	      }
	
	      var mpegTest = audioTest.canPlayType('audio/mpeg;').replace(/^no$/, '');
	
	      // Opera version <33 has mixed MP3 support, so we need to check for and block it.
	      var checkOpera = self._navigator && self._navigator.userAgent.match(/OPR\/([0-6].)/g);
	      var isOldOpera = (checkOpera && parseInt(checkOpera[0].split('/')[1], 10) < 33);
	
	      self._codecs = {
	        mp3: !!(!isOldOpera && (mpegTest || audioTest.canPlayType('audio/mp3;').replace(/^no$/, ''))),
	        mpeg: !!mpegTest,
	        opus: !!audioTest.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/, ''),
	        ogg: !!audioTest.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ''),
	        oga: !!audioTest.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ''),
	        wav: !!audioTest.canPlayType('audio/wav; codecs="1"').replace(/^no$/, ''),
	        aac: !!audioTest.canPlayType('audio/aac;').replace(/^no$/, ''),
	        caf: !!audioTest.canPlayType('audio/x-caf;').replace(/^no$/, ''),
	        m4a: !!(audioTest.canPlayType('audio/x-m4a;') || audioTest.canPlayType('audio/m4a;') || audioTest.canPlayType('audio/aac;')).replace(/^no$/, ''),
	        mp4: !!(audioTest.canPlayType('audio/x-mp4;') || audioTest.canPlayType('audio/mp4;') || audioTest.canPlayType('audio/aac;')).replace(/^no$/, ''),
	        weba: !!audioTest.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, ''),
	        webm: !!audioTest.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, ''),
	        dolby: !!audioTest.canPlayType('audio/mp4; codecs="ec-3"').replace(/^no$/, '')
	      };
	
	      return self;
	    },
	
	    /**
	     * Mobile browsers will only allow audio to be played after a user interaction.
	     * Attempt to automatically unlock audio on the first user interaction.
	     * Concept from: http://paulbakaus.com/tutorials/html5/web-audio-on-ios/
	     * @return {Howler}
	     */
	    _enableMobileAudio: function() {
	      var self = this || Howler;
	
	      // Only run this on mobile devices if audio isn't already eanbled.
	      var isMobile = /iPhone|iPad|iPod|Android|BlackBerry|BB10|Silk|Mobi/i.test(self._navigator && self._navigator.userAgent);
	      var isTouch = !!(('ontouchend' in window) || (self._navigator && self._navigator.maxTouchPoints > 0) || (self._navigator && self._navigator.msMaxTouchPoints > 0));
	      if (self._mobileEnabled || !self.ctx || (!isMobile && !isTouch)) {
	        return;
	      }
	
	      self._mobileEnabled = false;
	
	      // Some mobile devices/platforms have distortion issues when opening/closing tabs and/or web views.
	      // Bugs in the browser (especially Mobile Safari) can cause the sampleRate to change from 44100 to 48000.
	      // By calling Howler.unload(), we create a new AudioContext with the correct sampleRate.
	      if (!self._mobileUnloaded && self.ctx.sampleRate !== 44100) {
	        self._mobileUnloaded = true;
	        self.unload();
	      }
	
	      // Scratch buffer for enabling iOS to dispose of web audio buffers correctly, as per:
	      // http://stackoverflow.com/questions/24119684
	      self._scratchBuffer = self.ctx.createBuffer(1, 1, 22050);
	
	      // Call this method on touch start to create and play a buffer,
	      // then check if the audio actually played to determine if
	      // audio has now been unlocked on iOS, Android, etc.
	      var unlock = function() {
	        // Create an empty buffer.
	        var source = self.ctx.createBufferSource();
	        source.buffer = self._scratchBuffer;
	        source.connect(self.ctx.destination);
	
	        // Play the empty buffer.
	        if (typeof source.start === 'undefined') {
	          source.noteOn(0);
	        } else {
	          source.start(0);
	        }
	
	        // Setup a timeout to check that we are unlocked on the next event loop.
	        source.onended = function() {
	          source.disconnect(0);
	
	          // Update the unlocked state and prevent this check from happening again.
	          self._mobileEnabled = true;
	          self.mobileAutoEnable = false;
	
	          // Remove the touch start listener.
	          document.removeEventListener('touchend', unlock, true);
	        };
	      };
	
	      // Setup a touch start listener to attempt an unlock in.
	      document.addEventListener('touchend', unlock, true);
	
	      return self;
	    },
	
	    /**
	     * Automatically suspend the Web Audio AudioContext after no sound has played for 30 seconds.
	     * This saves processing/energy and fixes various browser-specific bugs with audio getting stuck.
	     * @return {Howler}
	     */
	    _autoSuspend: function() {
	      var self = this;
	
	      if (!self.autoSuspend || !self.ctx || typeof self.ctx.suspend === 'undefined' || !Howler.usingWebAudio) {
	        return;
	      }
	
	      // Check if any sounds are playing.
	      for (var i=0; i<self._howls.length; i++) {
	        if (self._howls[i]._webAudio) {
	          for (var j=0; j<self._howls[i]._sounds.length; j++) {
	            if (!self._howls[i]._sounds[j]._paused) {
	              return self;
	            }
	          }
	        }
	      }
	
	      if (self._suspendTimer) {
	        clearTimeout(self._suspendTimer);
	      }
	
	      // If no sound has played after 30 seconds, suspend the context.
	      self._suspendTimer = setTimeout(function() {
	        if (!self.autoSuspend) {
	          return;
	        }
	
	        self._suspendTimer = null;
	        self.state = 'suspending';
	        self.ctx.suspend().then(function() {
	          self.state = 'suspended';
	
	          if (self._resumeAfterSuspend) {
	            delete self._resumeAfterSuspend;
	            self._autoResume();
	          }
	        });
	      }, 30000);
	
	      return self;
	    },
	
	    /**
	     * Automatically resume the Web Audio AudioContext when a new sound is played.
	     * @return {Howler}
	     */
	    _autoResume: function() {
	      var self = this;
	
	      if (!self.ctx || typeof self.ctx.resume === 'undefined' || !Howler.usingWebAudio) {
	        return;
	      }
	
	      if (self.state === 'running' && self._suspendTimer) {
	        clearTimeout(self._suspendTimer);
	        self._suspendTimer = null;
	      } else if (self.state === 'suspended') {
	        self.state = 'resuming';
	        self.ctx.resume().then(function() {
	          self.state = 'running';
	        });
	
	        if (self._suspendTimer) {
	          clearTimeout(self._suspendTimer);
	          self._suspendTimer = null;
	        }
	      } else if (self.state === 'suspending') {
	        self._resumeAfterSuspend = true;
	      }
	
	      return self;
	    }
	  };
	
	  // Setup the global audio controller.
	  var Howler = new HowlerGlobal();
	
	  /** Group Methods **/
	  /***************************************************************************/
	
	  /**
	   * Create an audio group controller.
	   * @param {Object} o Passed in properties for this group.
	   */
	  var Howl = function(o) {
	    var self = this;
	
	    // Throw an error if no source is provided.
	    if (!o.src || o.src.length === 0) {
	      console.error('An array of source files must be passed with any new Howl.');
	      return;
	    }
	
	    self.init(o);
	  };
	  Howl.prototype = {
	    /**
	     * Initialize a new Howl group object.
	     * @param  {Object} o Passed in properties for this group.
	     * @return {Howl}
	     */
	    init: function(o) {
	      var self = this;
	
	      // If we don't have an AudioContext created yet, run the setup.
	      if (!Howler.ctx) {
	        setupAudioContext();
	      }
	
	      // Setup user-defined default properties.
	      self._autoplay = o.autoplay || false;
	      self._format = (typeof o.format !== 'string') ? o.format : [o.format];
	      self._html5 = o.html5 || false;
	      self._muted = o.mute || false;
	      self._loop = o.loop || false;
	      self._pool = o.pool || 5;
	      self._preload = (typeof o.preload === 'boolean') ? o.preload : true;
	      self._rate = o.rate || 1;
	      self._sprite = o.sprite || {};
	      self._src = (typeof o.src !== 'string') ? o.src : [o.src];
	      self._volume = o.volume !== undefined ? o.volume : 1;
	
	      // Setup all other default properties.
	      self._duration = 0;
	      self._state = 'unloaded';
	      self._sounds = [];
	      self._endTimers = {};
	      self._queue = [];
	
	      // Setup event listeners.
	      self._onend = o.onend ? [{fn: o.onend}] : [];
	      self._onfade = o.onfade ? [{fn: o.onfade}] : [];
	      self._onload = o.onload ? [{fn: o.onload}] : [];
	      self._onloaderror = o.onloaderror ? [{fn: o.onloaderror}] : [];
	      self._onpause = o.onpause ? [{fn: o.onpause}] : [];
	      self._onplay = o.onplay ? [{fn: o.onplay}] : [];
	      self._onstop = o.onstop ? [{fn: o.onstop}] : [];
	      self._onmute = o.onmute ? [{fn: o.onmute}] : [];
	      self._onvolume = o.onvolume ? [{fn: o.onvolume}] : [];
	      self._onrate = o.onrate ? [{fn: o.onrate}] : [];
	      self._onseek = o.onseek ? [{fn: o.onseek}] : [];
	
	      // Web Audio or HTML5 Audio?
	      self._webAudio = Howler.usingWebAudio && !self._html5;
	
	      // Automatically try to enable audio on iOS.
	      if (typeof Howler.ctx !== 'undefined' && Howler.ctx && Howler.mobileAutoEnable) {
	        Howler._enableMobileAudio();
	      }
	
	      // Keep track of this Howl group in the global controller.
	      Howler._howls.push(self);
	
	      // Load the source file unless otherwise specified.
	      if (self._preload) {
	        self.load();
	      }
	
	      return self;
	    },
	
	    /**
	     * Load the audio file.
	     * @return {Howler}
	     */
	    load: function() {
	      var self = this;
	      var url = null;
	
	      // If no audio is available, quit immediately.
	      if (Howler.noAudio) {
	        self._emit('loaderror', null, 'No audio support.');
	        return;
	      }
	
	      // Make sure our source is in an array.
	      if (typeof self._src === 'string') {
	        self._src = [self._src];
	      }
	
	      // Loop through the sources and pick the first one that is compatible.
	      for (var i=0; i<self._src.length; i++) {
	        var ext, str;
	
	        if (self._format && self._format[i]) {
	          // If an extension was specified, use that instead.
	          ext = self._format[i];
	        } else {
	          // Make sure the source is a string.
	          str = self._src[i];
	          if (typeof str !== 'string') {
	            self._emit('loaderror', null, 'Non-string found in selected audio sources - ignoring.');
	            continue;
	          }
	
	          // Extract the file extension from the URL or base64 data URI.
	          ext = /^data:audio\/([^;,]+);/i.exec(str);
	          if (!ext) {
	            ext = /\.([^.]+)$/.exec(str.split('?', 1)[0]);
	          }
	
	          if (ext) {
	            ext = ext[1].toLowerCase();
	          }
	        }
	
	        // Check if this extension is available.
	        if (Howler.codecs(ext)) {
	          url = self._src[i];
	          break;
	        }
	      }
	
	      if (!url) {
	        self._emit('loaderror', null, 'No codec support for selected audio sources.');
	        return;
	      }
	
	      self._src = url;
	      self._state = 'loading';
	
	      // If the hosting page is HTTPS and the source isn't,
	      // drop down to HTML5 Audio to avoid Mixed Content errors.
	      if (window.location.protocol === 'https:' && url.slice(0, 5) === 'http:') {
	        self._html5 = true;
	        self._webAudio = false;
	      }
	
	      // Create a new sound object and add it to the pool.
	      new Sound(self);
	
	      // Load and decode the audio data for playback.
	      if (self._webAudio) {
	        loadBuffer(self);
	      }
	
	      return self;
	    },
	
	    /**
	     * Play a sound or resume previous playback.
	     * @param  {String/Number} sprite   Sprite name for sprite playback or sound id to continue previous.
	     * @param  {Boolean} internal Internal Use: true prevents event firing.
	     * @return {Number}          Sound ID.
	     */
	    play: function(sprite, internal) {
	      var self = this;
	      var id = null;
	
	      // Determine if a sprite, sound id or nothing was passed
	      if (typeof sprite === 'number') {
	        id = sprite;
	        sprite = null;
	      } else if (typeof sprite === 'string' && self._state === 'loaded' && !self._sprite[sprite]) {
	        // If the passed sprite doesn't exist, do nothing.
	        return null;
	      } else if (typeof sprite === 'undefined') {
	        // Use the default sound sprite (plays the full audio length).
	        sprite = '__default';
	
	        // Check if there is a single paused sound that isn't ended.
	        // If there is, play that sound. If not, continue as usual.
	        var num = 0;
	        for (var i=0; i<self._sounds.length; i++) {
	          if (self._sounds[i]._paused && !self._sounds[i]._ended) {
	            num++;
	            id = self._sounds[i]._id;
	          }
	        }
	
	        if (num === 1) {
	          sprite = null;
	        } else {
	          id = null;
	        }
	      }
	
	      // Get the selected node, or get one from the pool.
	      var sound = id ? self._soundById(id) : self._inactiveSound();
	
	      // If the sound doesn't exist, do nothing.
	      if (!sound) {
	        return null;
	      }
	
	      // Select the sprite definition.
	      if (id && !sprite) {
	        sprite = sound._sprite || '__default';
	      }
	
	      // If we have no sprite and the sound hasn't loaded, we must wait
	      // for the sound to load to get our audio's duration.
	      if (self._state !== 'loaded' && !self._sprite[sprite]) {
	        self._queue.push({
	          event: 'play',
	          action: function() {
	            self.play(self._soundById(sound._id) ? sound._id : undefined);
	          }
	        });
	
	        return sound._id;
	      }
	
	      // Don't play the sound if an id was passed and it is already playing.
	      if (id && !sound._paused) {
	        // Trigger the play event, in order to keep iterating through queue.
	        if (!internal) {
	          setTimeout(function() {
	            self._emit('play', sound._id);
	          }, 0);
	        }
	
	        return sound._id;
	      }
	
	      // Make sure the AudioContext isn't suspended, and resume it if it is.
	      if (self._webAudio) {
	        Howler._autoResume();
	      }
	
	      // Determine how long to play for and where to start playing.
	      var seek = sound._seek > 0 ? sound._seek : self._sprite[sprite][0] / 1000;
	      var duration = ((self._sprite[sprite][0] + self._sprite[sprite][1]) / 1000) - seek;
	      var timeout = (duration * 1000) / Math.abs(sound._rate);
	
	      // Update the parameters of the sound
	      sound._paused = false;
	      sound._ended = false;
	      sound._sprite = sprite;
	      sound._seek = seek;
	      sound._start = self._sprite[sprite][0] / 1000;
	      sound._stop = (self._sprite[sprite][0] + self._sprite[sprite][1]) / 1000;
	      sound._loop = !!(sound._loop || self._sprite[sprite][2]);
	
	      // Begin the actual playback.
	      var node = sound._node;
	      if (self._webAudio) {
	        // Fire this when the sound is ready to play to begin Web Audio playback.
	        var playWebAudio = function() {
	          self._refreshBuffer(sound);
	
	          // Setup the playback params.
	          var vol = (sound._muted || self._muted) ? 0 : sound._volume;
	          node.gain.setValueAtTime(vol, Howler.ctx.currentTime);
	          sound._playStart = Howler.ctx.currentTime;
	
	          // Play the sound using the supported method.
	          if (typeof node.bufferSource.start === 'undefined') {
	            sound._loop ? node.bufferSource.noteGrainOn(0, seek, 86400) : node.bufferSource.noteGrainOn(0, seek, duration);
	          } else {
	            sound._loop ? node.bufferSource.start(0, seek, 86400) : node.bufferSource.start(0, seek, duration);
	          }
	
	          // Start a new timer if none is present.
	          if (timeout !== Infinity) {
	            self._endTimers[sound._id] = setTimeout(self._ended.bind(self, sound), timeout);
	          }
	
	          if (!internal) {
	            setTimeout(function() {
	              self._emit('play', sound._id);
	            }, 0);
	          }
	        };
	
	        if (self._state === 'loaded') {
	          playWebAudio();
	        } else {
	          // Wait for the audio to load and then begin playback.
	          self.once('load', playWebAudio, sound._id);
	
	          // Cancel the end timer.
	          self._clearTimer(sound._id);
	        }
	      } else {
	        // Fire this when the sound is ready to play to begin HTML5 Audio playback.
	        var playHtml5 = function() {
	          node.currentTime = seek;
	          node.muted = sound._muted || self._muted || Howler._muted || node.muted;
	          node.volume = sound._volume * Howler.volume();
	          node.playbackRate = sound._rate;
	
	          setTimeout(function() {
	            node.play();
	
	            // Setup the new end timer.
	            if (timeout !== Infinity) {
	              self._endTimers[sound._id] = setTimeout(self._ended.bind(self, sound), timeout);
	            }
	
	            if (!internal) {
	              self._emit('play', sound._id);
	            }
	          }, 0);
	        };
	
	        // Play immediately if ready, or wait for the 'canplaythrough'e vent.
	        var loadedNoReadyState = (self._state === 'loaded' && (window && window.ejecta || !node.readyState && Howler._navigator.isCocoonJS));
	        if (node.readyState === 4 || loadedNoReadyState) {
	          playHtml5();
	        } else {
	          var listener = function() {
	            // Begin playback.
	            playHtml5();
	
	            // Clear this listener.
	            node.removeEventListener(Howler._canPlayEvent, listener, false);
	          };
	          node.addEventListener(Howler._canPlayEvent, listener, false);
	
	          // Cancel the end timer.
	          self._clearTimer(sound._id);
	        }
	      }
	
	      return sound._id;
	    },
	
	    /**
	     * Pause playback and save current position.
	     * @param  {Number} id The sound ID (empty to pause all in group).
	     * @return {Howl}
	     */
	    pause: function(id) {
	      var self = this;
	
	      // If the sound hasn't loaded, add it to the load queue to pause when capable.
	      if (self._state !== 'loaded') {
	        self._queue.push({
	          event: 'pause',
	          action: function() {
	            self.pause(id);
	          }
	        });
	
	        return self;
	      }
	
	      // If no id is passed, get all ID's to be paused.
	      var ids = self._getSoundIds(id);
	
	      for (var i=0; i<ids.length; i++) {
	        // Clear the end timer.
	        self._clearTimer(ids[i]);
	
	        // Get the sound.
	        var sound = self._soundById(ids[i]);
	
	        if (sound && !sound._paused) {
	          // Reset the seek position.
	          sound._seek = self.seek(ids[i]);
	          sound._rateSeek = 0;
	          sound._paused = true;
	
	          // Stop currently running fades.
	          self._stopFade(ids[i]);
	
	          if (sound._node) {
	            if (self._webAudio) {
	              // make sure the sound has been created
	              if (!sound._node.bufferSource) {
	                return self;
	              }
	
	              if (typeof sound._node.bufferSource.stop === 'undefined') {
	                sound._node.bufferSource.noteOff(0);
	              } else {
	                sound._node.bufferSource.stop(0);
	              }
	
	              // Clean up the buffer source.
	              self._cleanBuffer(sound._node);
	            } else if (!isNaN(sound._node.duration) || sound._node.duration === Infinity) {
	              sound._node.pause();
	            }
	          }
	
	          // Fire the pause event, unless `true` is passed as the 2nd argument.
	          if (!arguments[1]) {
	            self._emit('pause', sound._id);
	          }
	        }
	      }
	
	      return self;
	    },
	
	    /**
	     * Stop playback and reset to start.
	     * @param  {Number} id The sound ID (empty to stop all in group).
	     * @param  {Boolean} internal Internal Use: true prevents event firing.
	     * @return {Howl}
	     */
	    stop: function(id, internal) {
	      var self = this;
	
	      // If the sound hasn't loaded, add it to the load queue to stop when capable.
	      if (self._state !== 'loaded') {
	        self._queue.push({
	          event: 'stop',
	          action: function() {
	            self.stop(id);
	          }
	        });
	
	        return self;
	      }
	
	      // If no id is passed, get all ID's to be stopped.
	      var ids = self._getSoundIds(id);
	
	      for (var i=0; i<ids.length; i++) {
	        // Clear the end timer.
	        self._clearTimer(ids[i]);
	
	        // Get the sound.
	        var sound = self._soundById(ids[i]);
	
	        if (sound && !sound._paused) {
	          // Reset the seek position.
	          sound._seek = sound._start || 0;
	          sound._rateSeek = 0;
	          sound._paused = true;
	          sound._ended = true;
	
	          // Stop currently running fades.
	          self._stopFade(ids[i]);
	
	          if (sound._node) {
	            if (self._webAudio) {
	              // make sure the sound has been created
	              if (!sound._node.bufferSource) {
	                return self;
	              }
	
	              if (typeof sound._node.bufferSource.stop === 'undefined') {
	                sound._node.bufferSource.noteOff(0);
	              } else {
	                sound._node.bufferSource.stop(0);
	              }
	
	              // Clean up the buffer source.
	              self._cleanBuffer(sound._node);
	            } else if (!isNaN(sound._node.duration) || sound._node.duration === Infinity) {
	              sound._node.currentTime = sound._start || 0;
	              sound._node.pause();
	            }
	          }
	        }
	
	        if (sound && !internal) {
	          self._emit('stop', sound._id);
	        }
	      }
	
	      return self;
	    },
	
	    /**
	     * Mute/unmute a single sound or all sounds in this Howl group.
	     * @param  {Boolean} muted Set to true to mute and false to unmute.
	     * @param  {Number} id    The sound ID to update (omit to mute/unmute all).
	     * @return {Howl}
	     */
	    mute: function(muted, id) {
	      var self = this;
	
	      // If the sound hasn't loaded, add it to the load queue to mute when capable.
	      if (self._state !== 'loaded') {
	        self._queue.push({
	          event: 'mute',
	          action: function() {
	            self.mute(muted, id);
	          }
	        });
	
	        return self;
	      }
	
	      // If applying mute/unmute to all sounds, update the group's value.
	      if (typeof id === 'undefined') {
	        if (typeof muted === 'boolean') {
	          self._muted = muted;
	        } else {
	          return self._muted;
	        }
	      }
	
	      // If no id is passed, get all ID's to be muted.
	      var ids = self._getSoundIds(id);
	
	      for (var i=0; i<ids.length; i++) {
	        // Get the sound.
	        var sound = self._soundById(ids[i]);
	
	        if (sound) {
	          sound._muted = muted;
	
	          if (self._webAudio && sound._node) {
	            sound._node.gain.setValueAtTime(muted ? 0 : sound._volume, Howler.ctx.currentTime);
	          } else if (sound._node) {
	            sound._node.muted = Howler._muted ? true : muted;
	          }
	
	          self._emit('mute', sound._id);
	        }
	      }
	
	      return self;
	    },
	
	    /**
	     * Get/set the volume of this sound or of the Howl group. This method can optionally take 0, 1 or 2 arguments.
	     *   volume() -> Returns the group's volume value.
	     *   volume(id) -> Returns the sound id's current volume.
	     *   volume(vol) -> Sets the volume of all sounds in this Howl group.
	     *   volume(vol, id) -> Sets the volume of passed sound id.
	     * @return {Howl/Number} Returns self or current volume.
	     */
	    volume: function() {
	      var self = this;
	      var args = arguments;
	      var vol, id;
	
	      // Determine the values based on arguments.
	      if (args.length === 0) {
	        // Return the value of the groups' volume.
	        return self._volume;
	      } else if (args.length === 1) {
	        // First check if this is an ID, and if not, assume it is a new volume.
	        var ids = self._getSoundIds();
	        var index = ids.indexOf(args[0]);
	        if (index >= 0) {
	          id = parseInt(args[0], 10);
	        } else {
	          vol = parseFloat(args[0]);
	        }
	      } else if (args.length >= 2) {
	        vol = parseFloat(args[0]);
	        id = parseInt(args[1], 10);
	      }
	
	      // Update the volume or return the current volume.
	      var sound;
	      if (typeof vol !== 'undefined' && vol >= 0 && vol <= 1) {
	        // If the sound hasn't loaded, add it to the load queue to change volume when capable.
	        if (self._state !== 'loaded') {
	          self._queue.push({
	            event: 'volume',
	            action: function() {
	              self.volume.apply(self, args);
	            }
	          });
	
	          return self;
	        }
	
	        // Set the group volume.
	        if (typeof id === 'undefined') {
	          self._volume = vol;
	        }
	
	        // Update one or all volumes.
	        id = self._getSoundIds(id);
	        for (var i=0; i<id.length; i++) {
	          // Get the sound.
	          sound = self._soundById(id[i]);
	
	          if (sound) {
	            sound._volume = vol;
	
	            // Stop currently running fades.
	            if (!args[2]) {
	              self._stopFade(id[i]);
	            }
	
	            if (self._webAudio && sound._node && !sound._muted) {
	              sound._node.gain.setValueAtTime(vol, Howler.ctx.currentTime);
	            } else if (sound._node && !sound._muted) {
	              sound._node.volume = vol * Howler.volume();
	            }
	
	            self._emit('volume', sound._id);
	          }
	        }
	      } else {
	        sound = id ? self._soundById(id) : self._sounds[0];
	        return sound ? sound._volume : 0;
	      }
	
	      return self;
	    },
	
	    /**
	     * Fade a currently playing sound between two volumes (if no id is passsed, all sounds will fade).
	     * @param  {Number} from The value to fade from (0.0 to 1.0).
	     * @param  {Number} to   The volume to fade to (0.0 to 1.0).
	     * @param  {Number} len  Time in milliseconds to fade.
	     * @param  {Number} id   The sound id (omit to fade all sounds).
	     * @return {Howl}
	     */
	    fade: function(from, to, len, id) {
	      var self = this;
	      var diff = Math.abs(from - to);
	      var dir = from > to ? 'out' : 'in';
	      var steps = diff / 0.01;
	      var stepLen = len / steps;
	
	      // If the sound hasn't loaded, add it to the load queue to fade when capable.
	      if (self._state !== 'loaded') {
	        self._queue.push({
	          event: 'fade',
	          action: function() {
	            self.fade(from, to, len, id);
	          }
	        });
	
	        return self;
	      }
	
	      // Set the volume to the start position.
	      self.volume(from, id);
	
	      // Fade the volume of one or all sounds.
	      var ids = self._getSoundIds(id);
	      for (var i=0; i<ids.length; i++) {
	        // Get the sound.
	        var sound = self._soundById(ids[i]);
	
	        // Create a linear fade or fall back to timeouts with HTML5 Audio.
	        if (sound) {
	          // Stop the previous fade if no sprite is being used (otherwise, volume handles this).
	          if (!id) {
	            self._stopFade(ids[i]);
	          }
	
	          // If we are using Web Audio, let the native methods do the actual fade.
	          if (self._webAudio && !sound._muted) {
	            var currentTime = Howler.ctx.currentTime;
	            var end = currentTime + (len / 1000);
	            sound._volume = from;
	            sound._node.gain.setValueAtTime(from, currentTime);
	            sound._node.gain.linearRampToValueAtTime(to, end);
	          }
	
	          var vol = from;
	          sound._interval = setInterval(function(soundId, sound) {
	            // Update the volume amount.
	            vol += (dir === 'in' ? 0.01 : -0.01);
	
	            // Make sure the volume is in the right bounds.
	            vol = Math.max(0, vol);
	            vol = Math.min(1, vol);
	
	            // Round to within 2 decimal points.
	            vol = Math.round(vol * 100) / 100;
	
	            // Change the volume.
	            if (self._webAudio) {
	              if (typeof id === 'undefined') {
	                self._volume = vol;
	              }
	
	              sound._volume = vol;
	            } else {
	              self.volume(vol, soundId, true);
	            }
	
	            // When the fade is complete, stop it and fire event.
	            if (vol === to) {
	              clearInterval(sound._interval);
	              sound._interval = null;
	              self.volume(vol, soundId);
	              self._emit('fade', soundId);
	            }
	          }.bind(self, ids[i], sound), stepLen);
	        }
	      }
	
	      return self;
	    },
	
	    /**
	     * Internal method that stops the currently playing fade when
	     * a new fade starts, volume is changed or the sound is stopped.
	     * @param  {Number} id The sound id.
	     * @return {Howl}
	     */
	    _stopFade: function(id) {
	      var self = this;
	      var sound = self._soundById(id);
	
	      if (sound && sound._interval) {
	        if (self._webAudio) {
	          sound._node.gain.cancelScheduledValues(Howler.ctx.currentTime);
	        }
	
	        clearInterval(sound._interval);
	        sound._interval = null;
	        self._emit('fade', id);
	      }
	
	      return self;
	    },
	
	    /**
	     * Get/set the loop parameter on a sound. This method can optionally take 0, 1 or 2 arguments.
	     *   loop() -> Returns the group's loop value.
	     *   loop(id) -> Returns the sound id's loop value.
	     *   loop(loop) -> Sets the loop value for all sounds in this Howl group.
	     *   loop(loop, id) -> Sets the loop value of passed sound id.
	     * @return {Howl/Boolean} Returns self or current loop value.
	     */
	    loop: function() {
	      var self = this;
	      var args = arguments;
	      var loop, id, sound;
	
	      // Determine the values for loop and id.
	      if (args.length === 0) {
	        // Return the grou's loop value.
	        return self._loop;
	      } else if (args.length === 1) {
	        if (typeof args[0] === 'boolean') {
	          loop = args[0];
	          self._loop = loop;
	        } else {
	          // Return this sound's loop value.
	          sound = self._soundById(parseInt(args[0], 10));
	          return sound ? sound._loop : false;
	        }
	      } else if (args.length === 2) {
	        loop = args[0];
	        id = parseInt(args[1], 10);
	      }
	
	      // If no id is passed, get all ID's to be looped.
	      var ids = self._getSoundIds(id);
	      for (var i=0; i<ids.length; i++) {
	        sound = self._soundById(ids[i]);
	
	        if (sound) {
	          sound._loop = loop;
	          if (self._webAudio && sound._node && sound._node.bufferSource) {
	            sound._node.bufferSource.loop = loop;
	          }
	        }
	      }
	
	      return self;
	    },
	
	    /**
	     * Get/set the playback rate of a sound. This method can optionally take 0, 1 or 2 arguments.
	     *   rate() -> Returns the first sound node's current playback rate.
	     *   rate(id) -> Returns the sound id's current playback rate.
	     *   rate(rate) -> Sets the playback rate of all sounds in this Howl group.
	     *   rate(rate, id) -> Sets the playback rate of passed sound id.
	     * @return {Howl/Number} Returns self or the current playback rate.
	     */
	    rate: function() {
	      var self = this;
	      var args = arguments;
	      var rate, id;
	
	      // Determine the values based on arguments.
	      if (args.length === 0) {
	        // We will simply return the current rate of the first node.
	        id = self._sounds[0]._id;
	      } else if (args.length === 1) {
	        // First check if this is an ID, and if not, assume it is a new rate value.
	        var ids = self._getSoundIds();
	        var index = ids.indexOf(args[0]);
	        if (index >= 0) {
	          id = parseInt(args[0], 10);
	        } else {
	          rate = parseFloat(args[0]);
	        }
	      } else if (args.length === 2) {
	        rate = parseFloat(args[0]);
	        id = parseInt(args[1], 10);
	      }
	
	      // Update the playback rate or return the current value.
	      var sound;
	      if (typeof rate === 'number') {
	        // If the sound hasn't loaded, add it to the load queue to change playback rate when capable.
	        if (self._state !== 'loaded') {
	          self._queue.push({
	            event: 'rate',
	            action: function() {
	              self.rate.apply(self, args);
	            }
	          });
	
	          return self;
	        }
	
	        // Set the group rate.
	        if (typeof id === 'undefined') {
	          self._rate = rate;
	        }
	
	        // Update one or all volumes.
	        id = self._getSoundIds(id);
	        for (var i=0; i<id.length; i++) {
	          // Get the sound.
	          sound = self._soundById(id[i]);
	
	          if (sound) {
	            // Keep track of our position when the rate changed and update the playback
	            // start position so we can properly adjust the seek position for time elapsed.
	            sound._rateSeek = self.seek(id[i]);
	            sound._playStart = self._webAudio ? Howler.ctx.currentTime : sound._playStart;
	            sound._rate = rate;
	
	            // Change the playback rate.
	            if (self._webAudio && sound._node && sound._node.bufferSource) {
	              sound._node.bufferSource.playbackRate.value = rate;
	            } else if (sound._node) {
	              sound._node.playbackRate = rate;
	            }
	
	            // Reset the timers.
	            var seek = self.seek(id[i]);
	            var duration = ((self._sprite[sound._sprite][0] + self._sprite[sound._sprite][1]) / 1000) - seek;
	            var timeout = (duration * 1000) / Math.abs(sound._rate);
	
	            // Start a new end timer if sound is already playing.
	            if (self._endTimers[id[i]] || !sound._paused) {
	              self._clearTimer(id[i]);
	              self._endTimers[id[i]] = setTimeout(self._ended.bind(self, sound), timeout);
	            }
	
	            self._emit('rate', sound._id);
	          }
	        }
	      } else {
	        sound = self._soundById(id);
	        return sound ? sound._rate : self._rate;
	      }
	
	      return self;
	    },
	
	    /**
	     * Get/set the seek position of a sound. This method can optionally take 0, 1 or 2 arguments.
	     *   seek() -> Returns the first sound node's current seek position.
	     *   seek(id) -> Returns the sound id's current seek position.
	     *   seek(seek) -> Sets the seek position of the first sound node.
	     *   seek(seek, id) -> Sets the seek position of passed sound id.
	     * @return {Howl/Number} Returns self or the current seek position.
	     */
	    seek: function() {
	      var self = this;
	      var args = arguments;
	      var seek, id;
	
	      // Determine the values based on arguments.
	      if (args.length === 0) {
	        // We will simply return the current position of the first node.
	        id = self._sounds[0]._id;
	      } else if (args.length === 1) {
	        // First check if this is an ID, and if not, assume it is a new seek position.
	        var ids = self._getSoundIds();
	        var index = ids.indexOf(args[0]);
	        if (index >= 0) {
	          id = parseInt(args[0], 10);
	        } else {
	          id = self._sounds[0]._id;
	          seek = parseFloat(args[0]);
	        }
	      } else if (args.length === 2) {
	        seek = parseFloat(args[0]);
	        id = parseInt(args[1], 10);
	      }
	
	      // If there is no ID, bail out.
	      if (typeof id === 'undefined') {
	        return self;
	      }
	
	      // If the sound hasn't loaded, add it to the load queue to seek when capable.
	      if (self._state !== 'loaded') {
	        self._queue.push({
	          event: 'seek',
	          action: function() {
	            self.seek.apply(self, args);
	          }
	        });
	
	        return self;
	      }
	
	      // Get the sound.
	      var sound = self._soundById(id);
	
	      if (sound) {
	        if (typeof seek === 'number' && seek >= 0) {
	          // Pause the sound and update position for restarting playback.
	          var playing = self.playing(id);
	          if (playing) {
	            self.pause(id, true);
	          }
	
	          // Move the position of the track and cancel timer.
	          sound._seek = seek;
	          sound._ended = false;
	          self._clearTimer(id);
	
	          // Restart the playback if the sound was playing.
	          if (playing) {
	            self.play(id, true);
	          }
	
	          // Update the seek position for HTML5 Audio.
	          if (!self._webAudio && sound._node) {
	            sound._node.currentTime = seek;
	          }
	
	          self._emit('seek', id);
	        } else {
	          if (self._webAudio) {
	            var realTime = self.playing(id) ? Howler.ctx.currentTime - sound._playStart : 0;
	            var rateSeek = sound._rateSeek ? sound._rateSeek - sound._seek : 0;
	            return sound._seek + (rateSeek + realTime * Math.abs(sound._rate));
	          } else {
	            return sound._node.currentTime;
	          }
	        }
	      }
	
	      return self;
	    },
	
	    /**
	     * Check if a specific sound is currently playing or not (if id is provided), or check if at least one of the sounds in the group is playing or not.
	     * @param  {Number}  id The sound id to check. If none is passed, the whole sound group is checked.
	     * @return {Boolean} True if playing and false if not.
	     */
	    playing: function(id) {
	      var self = this;
	
	      // Check the passed sound ID (if any).
	      if (typeof id === 'number') {
	        var sound = self._soundById(id);
	        return sound ? !sound._paused : false;
	      }
	
	      // Otherwise, loop through all sounds and check if any are playing.
	      for (var i=0; i<self._sounds.length; i++) {
	        if (!self._sounds[i]._paused) {
	          return true;
	        }
	      }
	
	      return false;
	    },
	
	    /**
	     * Get the duration of this sound. Passing a sound id will return the sprite duration.
	     * @param  {Number} id The sound id to check. If none is passed, return full source duration.
	     * @return {Number} Audio duration in seconds.
	     */
	    duration: function(id) {
	      var self = this;
	      var duration = self._duration;
	
	      // If we pass an ID, get the sound and return the sprite length.
	      var sound = self._soundById(id);
	      if (sound) {
	        duration = self._sprite[sound._sprite][1] / 1000;
	      }
	
	      return duration;
	    },
	
	    /**
	     * Returns the current loaded state of this Howl.
	     * @return {String} 'unloaded', 'loading', 'loaded'
	     */
	    state: function() {
	      return this._state;
	    },
	
	    /**
	     * Unload and destroy the current Howl object.
	     * This will immediately stop all sound instances attached to this group.
	     */
	    unload: function() {
	      var self = this;
	
	      // Stop playing any active sounds.
	      var sounds = self._sounds;
	      for (var i=0; i<sounds.length; i++) {
	        // Stop the sound if it is currently playing.
	        if (!sounds[i]._paused) {
	          self.stop(sounds[i]._id);
	          self._emit('end', sounds[i]._id);
	        }
	
	        // Remove the source or disconnect.
	        if (!self._webAudio) {
	          // Set the source to 0-second silence to stop any downloading.
	          sounds[i]._node.src = 'data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQAAAAA=';
	
	          // Remove any event listeners.
	          sounds[i]._node.removeEventListener('error', sounds[i]._errorFn, false);
	          sounds[i]._node.removeEventListener(Howler._canPlayEvent, sounds[i]._loadFn, false);
	        }
	
	        // Empty out all of the nodes.
	        delete sounds[i]._node;
	
	        // Make sure all timers are cleared out.
	        self._clearTimer(sounds[i]._id);
	
	        // Remove the references in the global Howler object.
	        var index = Howler._howls.indexOf(self);
	        if (index >= 0) {
	          Howler._howls.splice(index, 1);
	        }
	      }
	
	      // Delete this sound from the cache (if no other Howl is using it).
	      var remCache = true;
	      for (i=0; i<Howler._howls.length; i++) {
	        if (Howler._howls[i]._src === self._src) {
	          remCache = false;
	          break;
	        }
	      }
	
	      if (cache && remCache) {
	        delete cache[self._src];
	      }
	
	      // Clear out `self`.
	      self._state = 'unloaded';
	      self._sounds = [];
	      self = null;
	
	      return null;
	    },
	
	    /**
	     * Listen to a custom event.
	     * @param  {String}   event Event name.
	     * @param  {Function} fn    Listener to call.
	     * @param  {Number}   id    (optional) Only listen to events for this sound.
	     * @param  {Number}   once  (INTERNAL) Marks event to fire only once.
	     * @return {Howl}
	     */
	    on: function(event, fn, id, once) {
	      var self = this;
	      var events = self['_on' + event];
	
	      if (typeof fn === 'function') {
	        events.push(once ? {id: id, fn: fn, once: once} : {id: id, fn: fn});
	      }
	
	      return self;
	    },
	
	    /**
	     * Remove a custom event. Call without parameters to remove all events.
	     * @param  {String}   event Event name.
	     * @param  {Function} fn    Listener to remove. Leave empty to remove all.
	     * @param  {Number}   id    (optional) Only remove events for this sound.
	     * @return {Howl}
	     */
	    off: function(event, fn, id) {
	      var self = this;
	      var events = self['_on' + event];
	      var i = 0;
	
	      if (fn) {
	        // Loop through event store and remove the passed function.
	        for (i=0; i<events.length; i++) {
	          if (fn === events[i].fn && id === events[i].id) {
	            events.splice(i, 1);
	            break;
	          }
	        }
	      } else if (event) {
	        // Clear out all events of this type.
	        self['_on' + event] = [];
	      } else {
	        // Clear out all events of every type.
	        var keys = Object.keys(self);
	        for (i=0; i<keys.length; i++) {
	          if ((keys[i].indexOf('_on') === 0) && Array.isArray(self[keys[i]])) {
	            self[keys[i]] = [];
	          }
	        }
	      }
	
	      return self;
	    },
	
	    /**
	     * Listen to a custom event and remove it once fired.
	     * @param  {String}   event Event name.
	     * @param  {Function} fn    Listener to call.
	     * @param  {Number}   id    (optional) Only listen to events for this sound.
	     * @return {Howl}
	     */
	    once: function(event, fn, id) {
	      var self = this;
	
	      // Setup the event listener.
	      self.on(event, fn, id, 1);
	
	      return self;
	    },
	
	    /**
	     * Emit all events of a specific type and pass the sound id.
	     * @param  {String} event Event name.
	     * @param  {Number} id    Sound ID.
	     * @param  {Number} msg   Message to go with event.
	     * @return {Howl}
	     */
	    _emit: function(event, id, msg) {
	      var self = this;
	      var events = self['_on' + event];
	
	      // Loop through event store and fire all functions.
	      for (var i=events.length-1; i>=0; i--) {
	        if (!events[i].id || events[i].id === id || event === 'load') {
	          setTimeout(function(fn) {
	            fn.call(this, id, msg);
	          }.bind(self, events[i].fn), 0);
	
	          // If this event was setup with `once`, remove it.
	          if (events[i].once) {
	            self.off(event, events[i].fn, events[i].id);
	          }
	        }
	      }
	
	      return self;
	    },
	
	    /**
	     * Queue of actions initiated before the sound has loaded.
	     * These will be called in sequence, with the next only firing
	     * after the previous has finished executing (even if async like play).
	     * @return {Howl}
	     */
	    _loadQueue: function() {
	      var self = this;
	
	      if (self._queue.length > 0) {
	        var task = self._queue[0];
	
	        // don't move onto the next task until this one is done
	        self.once(task.event, function() {
	          self._queue.shift();
	          self._loadQueue();
	        });
	
	        task.action();
	      }
	
	      return self;
	    },
	
	    /**
	     * Fired when playback ends at the end of the duration.
	     * @param  {Sound} sound The sound object to work with.
	     * @return {Howl}
	     */
	    _ended: function(sound) {
	      var self = this;
	      var sprite = sound._sprite;
	
	      // Should this sound loop?
	      var loop = !!(sound._loop || self._sprite[sprite][2]);
	
	      // Fire the ended event.
	      self._emit('end', sound._id);
	
	      // Restart the playback for HTML5 Audio loop.
	      if (!self._webAudio && loop) {
	        self.stop(sound._id, true).play(sound._id);
	      }
	
	      // Restart this timer if on a Web Audio loop.
	      if (self._webAudio && loop) {
	        self._emit('play', sound._id);
	        sound._seek = sound._start || 0;
	        sound._rateSeek = 0;
	        sound._playStart = Howler.ctx.currentTime;
	
	        var timeout = ((sound._stop - sound._start) * 1000) / Math.abs(sound._rate);
	        self._endTimers[sound._id] = setTimeout(self._ended.bind(self, sound), timeout);
	      }
	
	      // Mark the node as paused.
	      if (self._webAudio && !loop) {
	        sound._paused = true;
	        sound._ended = true;
	        sound._seek = sound._start || 0;
	        sound._rateSeek = 0;
	        self._clearTimer(sound._id);
	
	        // Clean up the buffer source.
	        self._cleanBuffer(sound._node);
	
	        // Attempt to auto-suspend AudioContext if no sounds are still playing.
	        Howler._autoSuspend();
	      }
	
	      // When using a sprite, end the track.
	      if (!self._webAudio && !loop) {
	        self.stop(sound._id);
	      }
	
	      return self;
	    },
	
	    /**
	     * Clear the end timer for a sound playback.
	     * @param  {Number} id The sound ID.
	     * @return {Howl}
	     */
	    _clearTimer: function(id) {
	      var self = this;
	
	      if (self._endTimers[id]) {
	        clearTimeout(self._endTimers[id]);
	        delete self._endTimers[id];
	      }
	
	      return self;
	    },
	
	    /**
	     * Return the sound identified by this ID, or return null.
	     * @param  {Number} id Sound ID
	     * @return {Object}    Sound object or null.
	     */
	    _soundById: function(id) {
	      var self = this;
	
	      // Loop through all sounds and find the one with this ID.
	      for (var i=0; i<self._sounds.length; i++) {
	        if (id === self._sounds[i]._id) {
	          return self._sounds[i];
	        }
	      }
	
	      return null;
	    },
	
	    /**
	     * Return an inactive sound from the pool or create a new one.
	     * @return {Sound} Sound playback object.
	     */
	    _inactiveSound: function() {
	      var self = this;
	
	      self._drain();
	
	      // Find the first inactive node to recycle.
	      for (var i=0; i<self._sounds.length; i++) {
	        if (self._sounds[i]._ended) {
	          return self._sounds[i].reset();
	        }
	      }
	
	      // If no inactive node was found, create a new one.
	      return new Sound(self);
	    },
	
	    /**
	     * Drain excess inactive sounds from the pool.
	     */
	    _drain: function() {
	      var self = this;
	      var limit = self._pool;
	      var cnt = 0;
	      var i = 0;
	
	      // If there are less sounds than the max pool size, we are done.
	      if (self._sounds.length < limit) {
	        return;
	      }
	
	      // Count the number of inactive sounds.
	      for (i=0; i<self._sounds.length; i++) {
	        if (self._sounds[i]._ended) {
	          cnt++;
	        }
	      }
	
	      // Remove excess inactive sounds, going in reverse order.
	      for (i=self._sounds.length - 1; i>=0; i--) {
	        if (cnt <= limit) {
	          return;
	        }
	
	        if (self._sounds[i]._ended) {
	          // Disconnect the audio source when using Web Audio.
	          if (self._webAudio && self._sounds[i]._node) {
	            self._sounds[i]._node.disconnect(0);
	          }
	
	          // Remove sounds until we have the pool size.
	          self._sounds.splice(i, 1);
	          cnt--;
	        }
	      }
	    },
	
	    /**
	     * Get all ID's from the sounds pool.
	     * @param  {Number} id Only return one ID if one is passed.
	     * @return {Array}    Array of IDs.
	     */
	    _getSoundIds: function(id) {
	      var self = this;
	
	      if (typeof id === 'undefined') {
	        var ids = [];
	        for (var i=0; i<self._sounds.length; i++) {
	          ids.push(self._sounds[i]._id);
	        }
	
	        return ids;
	      } else {
	        return [id];
	      }
	    },
	
	    /**
	     * Load the sound back into the buffer source.
	     * @param  {Sound} sound The sound object to work with.
	     * @return {Howl}
	     */
	    _refreshBuffer: function(sound) {
	      var self = this;
	
	      // Setup the buffer source for playback.
	      sound._node.bufferSource = Howler.ctx.createBufferSource();
	      sound._node.bufferSource.buffer = cache[self._src];
	
	      // Connect to the correct node.
	      if (sound._panner) {
	        sound._node.bufferSource.connect(sound._panner);
	      } else {
	        sound._node.bufferSource.connect(sound._node);
	      }
	
	      // Setup looping and playback rate.
	      sound._node.bufferSource.loop = sound._loop;
	      if (sound._loop) {
	        sound._node.bufferSource.loopStart = sound._start || 0;
	        sound._node.bufferSource.loopEnd = sound._stop;
	      }
	      sound._node.bufferSource.playbackRate.value = sound._rate;
	
	      return self;
	    },
	
	    /**
	     * Prevent memory leaks by cleaning up the buffer source after playback.
	     * @param  {Object} node Sound's audio node containing the buffer source.
	     * @return {Howl}
	     */
	    _cleanBuffer: function(node) {
	      var self = this;
	
	      if (self._scratchBuffer) {
	        node.bufferSource.onended = null;
	        node.bufferSource.disconnect(0);
	        try { node.bufferSource.buffer = self._scratchBuffer; } catch(e) {}
	      }
	      node.bufferSource = null;
	
	      return self;
	    }
	  };
	
	  /** Single Sound Methods **/
	  /***************************************************************************/
	
	  /**
	   * Setup the sound object, which each node attached to a Howl group is contained in.
	   * @param {Object} howl The Howl parent group.
	   */
	  var Sound = function(howl) {
	    this._parent = howl;
	    this.init();
	  };
	  Sound.prototype = {
	    /**
	     * Initialize a new Sound object.
	     * @return {Sound}
	     */
	    init: function() {
	      var self = this;
	      var parent = self._parent;
	
	      // Setup the default parameters.
	      self._muted = parent._muted;
	      self._loop = parent._loop;
	      self._volume = parent._volume;
	      self._muted = parent._muted;
	      self._rate = parent._rate;
	      self._seek = 0;
	      self._paused = true;
	      self._ended = true;
	      self._sprite = '__default';
	
	      // Generate a unique ID for this sound.
	      self._id = Math.round(Date.now() * Math.random());
	
	      // Add itself to the parent's pool.
	      parent._sounds.push(self);
	
	      // Create the new node.
	      self.create();
	
	      return self;
	    },
	
	    /**
	     * Create and setup a new sound object, whether HTML5 Audio or Web Audio.
	     * @return {Sound}
	     */
	    create: function() {
	      var self = this;
	      var parent = self._parent;
	      var volume = (Howler._muted || self._muted || self._parent._muted) ? 0 : self._volume;
	
	      if (parent._webAudio) {
	        // Create the gain node for controlling volume (the source will connect to this).
	        self._node = (typeof Howler.ctx.createGain === 'undefined') ? Howler.ctx.createGainNode() : Howler.ctx.createGain();
	        self._node.gain.setValueAtTime(volume, Howler.ctx.currentTime);
	        self._node.paused = true;
	        self._node.connect(Howler.masterGain);
	      } else {
	        self._node = new Audio();
	
	        // Listen for errors (http://dev.w3.org/html5/spec-author-view/spec.html#mediaerror).
	        self._errorFn = self._errorListener.bind(self);
	        self._node.addEventListener('error', self._errorFn, false);
	
	        // Listen for 'canplaythrough' event to let us know the sound is ready.
	        self._loadFn = self._loadListener.bind(self);
	        self._node.addEventListener(Howler._canPlayEvent, self._loadFn, false);
	
	        // Setup the new audio node.
	        self._node.src = parent._src;
	        self._node.preload = 'auto';
	        self._node.volume = volume * Howler.volume();
	
	        // Begin loading the source.
	        self._node.load();
	      }
	
	      return self;
	    },
	
	    /**
	     * Reset the parameters of this sound to the original state (for recycle).
	     * @return {Sound}
	     */
	    reset: function() {
	      var self = this;
	      var parent = self._parent;
	
	      // Reset all of the parameters of this sound.
	      self._muted = parent._muted;
	      self._loop = parent._loop;
	      self._volume = parent._volume;
	      self._muted = parent._muted;
	      self._rate = parent._rate;
	      self._seek = 0;
	      self._rateSeek = 0;
	      self._paused = true;
	      self._ended = true;
	      self._sprite = '__default';
	
	      // Generate a new ID so that it isn't confused with the previous sound.
	      self._id = Math.round(Date.now() * Math.random());
	
	      return self;
	    },
	
	    /**
	     * HTML5 Audio error listener callback.
	     */
	    _errorListener: function() {
	      var self = this;
	
	      if (self._node.error && self._node.error.code === 4) {
	        Howler.noAudio = true;
	      }
	
	      // Fire an error event and pass back the code.
	      self._parent._emit('loaderror', self._id, self._node.error ? self._node.error.code : 0);
	
	      // Clear the event listener.
	      self._node.removeEventListener('error', self._errorListener, false);
	    },
	
	    /**
	     * HTML5 Audio canplaythrough listener callback.
	     */
	    _loadListener: function() {
	      var self = this;
	      var parent = self._parent;
	
	      // Round up the duration to account for the lower precision in HTML5 Audio.
	      parent._duration = Math.ceil(self._node.duration * 10) / 10;
	
	      // Setup a sprite if none is defined.
	      if (Object.keys(parent._sprite).length === 0) {
	        parent._sprite = {__default: [0, parent._duration * 1000]};
	      }
	
	      if (parent._state !== 'loaded') {
	        parent._state = 'loaded';
	        parent._emit('load');
	        parent._loadQueue();
	      }
	
	      if (parent._autoplay) {
	        parent.play();
	      }
	
	      // Clear the event listener.
	      self._node.removeEventListener(Howler._canPlayEvent, self._loadFn, false);
	    }
	  };
	
	  /** Helper Methods **/
	  /***************************************************************************/
	
	  var cache = {};
	
	  /**
	   * Buffer a sound from URL, Data URI or cache and decode to audio source (Web Audio API).
	   * @param  {Howl} self
	   */
	  var loadBuffer = function(self) {
	    var url = self._src;
	
	    // Check if the buffer has already been cached and use it instead.
	    if (cache[url]) {
	      // Set the duration from the cache.
	      self._duration = cache[url].duration;
	
	      // Load the sound into this Howl.
	      loadSound(self);
	
	      return;
	    }
	
	    if (/^data:[^;]+;base64,/.test(url)) {
	      // Decode the base64 data URI without XHR, since some browsers don't support it.
	      var data = atob(url.split(',')[1]);
	      var dataView = new Uint8Array(data.length);
	      for (var i=0; i<data.length; ++i) {
	        dataView[i] = data.charCodeAt(i);
	      }
	
	      decodeAudioData(dataView.buffer, self);
	    } else {
	      // Load the buffer from the URL.
	      var xhr = new XMLHttpRequest();
	      xhr.open('GET', url, true);
	      xhr.responseType = 'arraybuffer';
	      xhr.onload = function() {
	        // Make sure we get a successful response back.
	        var code = (xhr.status + '')[0];
	        if (code !== '0' && code !== '2' && code !== '3') {
	          self._emit('loaderror', null, 'Failed loading audio file with status: ' + xhr.status + '.');
	          return;
	        }
	
	        decodeAudioData(xhr.response, self);
	      };
	      xhr.onerror = function() {
	        // If there is an error, switch to HTML5 Audio.
	        if (self._webAudio) {
	          self._html5 = true;
	          self._webAudio = false;
	          self._sounds = [];
	          delete cache[url];
	          self.load();
	        }
	      };
	      safeXhrSend(xhr);
	    }
	  };
	
	  /**
	   * Send the XHR request wrapped in a try/catch.
	   * @param  {Object} xhr XHR to send.
	   */
	  var safeXhrSend = function(xhr) {
	    try {
	      xhr.send();
	    } catch (e) {
	      xhr.onerror();
	    }
	  };
	
	  /**
	   * Decode audio data from an array buffer.
	   * @param  {ArrayBuffer} arraybuffer The audio data.
	   * @param  {Howl}        self
	   */
	  var decodeAudioData = function(arraybuffer, self) {
	    // Decode the buffer into an audio source.
	    Howler.ctx.decodeAudioData(arraybuffer, function(buffer) {
	      if (buffer && self._sounds.length > 0) {
	        cache[self._src] = buffer;
	        loadSound(self, buffer);
	      }
	    }, function() {
	      self._emit('loaderror', null, 'Decoding audio data failed.');
	    });
	  };
	
	  /**
	   * Sound is now loaded, so finish setting everything up and fire the loaded event.
	   * @param  {Howl} self
	   * @param  {Object} buffer The decoded buffer sound source.
	   */
	  var loadSound = function(self, buffer) {
	    // Set the duration.
	    if (buffer && !self._duration) {
	      self._duration = buffer.duration;
	    }
	
	    // Setup a sprite if none is defined.
	    if (Object.keys(self._sprite).length === 0) {
	      self._sprite = {__default: [0, self._duration * 1000]};
	    }
	
	    // Fire the loaded event.
	    if (self._state !== 'loaded') {
	      self._state = 'loaded';
	      self._emit('load');
	      self._loadQueue();
	    }
	
	    // Begin playback if specified.
	    if (self._autoplay) {
	      self.play();
	    }
	  };
	
	  /**
	   * Setup the audio context when available, or switch to HTML5 Audio mode.
	   */
	  var setupAudioContext = function() {
	    Howler.noAudio = false;
	
	    // Check if we are using Web Audio and setup the AudioContext if we are.
	    try {
	      if (typeof AudioContext !== 'undefined') {
	        Howler.ctx = new AudioContext();
	      } else if (typeof webkitAudioContext !== 'undefined') {
	        Howler.ctx = new webkitAudioContext();
	      } else {
	        Howler.usingWebAudio = false;
	      }
	    } catch(e) {
	      Howler.usingWebAudio = false;
	    }
	
	    if (!Howler.usingWebAudio) {
	      // No audio is available on this system if noAudio is set to true.
	      if (typeof Audio !== 'undefined') {
	        try {
	          var test = new Audio();
	
	          // Check if the canplaythrough event is available.
	          if (typeof test.oncanplaythrough === 'undefined') {
	            Howler._canPlayEvent = 'canplay';
	          }
	        } catch(e) {
	          Howler.noAudio = true;
	        }
	      } else {
	        Howler.noAudio = true;
	      }
	    }
	
	    // Test to make sure audio isn't disabled in Internet Explorer
	    try {
	      var test = new Audio();
	      if (test.muted) {
	        Howler.noAudio = true;
	      }
	    } catch (e) {}
	
	    // Check if a webview is being used on iOS8 or earlier (rather than the browser).
	    // If it is, disable Web Audio as it causes crashing.
	    var iOS = (/iP(hone|od|ad)/.test(Howler._navigator && Howler._navigator.platform));
	    var appVersion = Howler._navigator && Howler._navigator.appVersion.match(/OS (\d+)_(\d+)_?(\d+)?/);
	    var version = appVersion ? parseInt(appVersion[1], 10) : null;
	    if (iOS && version && version < 9) {
	      var safari = /safari/.test(Howler._navigator && Howler._navigator.userAgent.toLowerCase());
	      if (Howler._navigator && Howler._navigator.standalone && !safari || Howler._navigator && !Howler._navigator.standalone && !safari) {
	        Howler.usingWebAudio = false;
	      }
	    }
	
	    // Create and expose the master GainNode when using Web Audio (useful for plugins or advanced usage).
	    if (Howler.usingWebAudio) {
	      Howler.masterGain = (typeof Howler.ctx.createGain === 'undefined') ? Howler.ctx.createGainNode() : Howler.ctx.createGain();
	      Howler.masterGain.gain.value = 1;
	      Howler.masterGain.connect(Howler.ctx.destination);
	    }
	
	    // Re-run the setup on Howler.
	    Howler._setup();
	  };
	
	  // Add support for AMD (Asynchronous Module Definition) libraries such as require.js.
	  if (true) {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {
	      return {
	        Howler: Howler,
	        Howl: Howl
	      };
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  }
	
	  // Add support for CommonJS libraries such as browserify.
	  if (true) {
	    exports.Howler = Howler;
	    exports.Howl = Howl;
	  }
	
	  // Define globally in case AMD is not available or unused.
	  if (typeof window !== 'undefined') {
	    window.HowlerGlobal = HowlerGlobal;
	    window.Howler = Howler;
	    window.Howl = Howl;
	    window.Sound = Sound;
	  } else if (typeof global !== 'undefined') { // Add to global in Node.js (for testing, etc).
	    global.HowlerGlobal = HowlerGlobal;
	    global.Howler = Howler;
	    global.Howl = Howl;
	    global.Sound = Sound;
	  }
	})();
	
	
	/*!
	 *  Spatial Plugin - Adds support for stereo and 3D audio where Web Audio is supported.
	 *  
	 *  howler.js v2.0.0
	 *  howlerjs.com
	 *
	 *  (c) 2013-2016, James Simpson of GoldFire Studios
	 *  goldfirestudios.com
	 *
	 *  MIT License
	 */
	
	(function() {
	
	  'use strict';
	
	  // Setup default properties.
	  HowlerGlobal.prototype._pos = [0, 0, 0];
	  HowlerGlobal.prototype._orientation = [0, 0, -1, 0, 1, 0];
	  
	  /** Global Methods **/
	  /***************************************************************************/
	
	  /**
	   * Helper method to update the stereo panning position of all current Howls.
	   * Future Howls will not use this value unless explicitely set.
	   * @param  {Number} pan A value of -1.0 is all the way left and 1.0 is all the way right.
	   * @return {Howler/Number}     Self or current stereo panning value.
	   */
	  HowlerGlobal.prototype.stereo = function(pan) {
	    var self = this;
	
	    // Stop right here if not using Web Audio.
	    if (!self.ctx || !self.ctx.listener) {
	      return self;
	    }
	
	    // Loop through all Howls and update their stereo panning.
	    for (var i=self._howls.length-1; i>=0; i--) {
	      self._howls[i].stereo(pan);
	    }
	
	    return self;
	  };
	
	  /**
	   * Get/set the position of the listener in 3D cartesian space. Sounds using
	   * 3D position will be relative to the listener's position.
	   * @param  {Number} x The x-position of the listener.
	   * @param  {Number} y The y-position of the listener.
	   * @param  {Number} z The z-position of the listener.
	   * @return {Howler/Array}   Self or current listener position.
	   */
	  HowlerGlobal.prototype.pos = function(x, y, z) {
	    var self = this;
	
	    // Stop right here if not using Web Audio.
	    if (!self.ctx || !self.ctx.listener) {
	      return self;
	    }
	
	    // Set the defaults for optional 'y' & 'z'.
	    y = (typeof y !== 'number') ? self._pos[1] : y;
	    z = (typeof z !== 'number') ? self._pos[2] : z;
	
	    if (typeof x === 'number') {
	      self._pos = [x, y, z];
	      self.ctx.listener.setPosition(self._pos[0], self._pos[1], self._pos[2]);
	    } else {
	      return self._pos;
	    }
	
	    return self;
	  };
	
	  /**
	   * Get/set the direction the listener is pointing in the 3D cartesian space.
	   * A front and up vector must be provided. The front is the direction the
	   * face of the listener is pointing, and up is the direction the top of the
	   * listener is pointing. Thus, these values are expected to be at right angles
	   * from each other.
	   * @param  {Number} x   The x-orientation of the listener.
	   * @param  {Number} y   The y-orientation of the listener.
	   * @param  {Number} z   The z-orientation of the listener.
	   * @param  {Number} xUp The x-orientation of the top of the listener.
	   * @param  {Number} yUp The y-orientation of the top of the listener.
	   * @param  {Number} zUp The z-orientation of the top of the listener.
	   * @return {Howler/Array}     Returns self or the current orientation vectors.
	   */
	  HowlerGlobal.prototype.orientation = function(x, y, z, xUp, yUp, zUp) {
	    var self = this;
	
	    // Stop right here if not using Web Audio.
	    if (!self.ctx || !self.ctx.listener) {
	      return self;
	    }
	
	    // Set the defaults for optional 'y' & 'z'.
	    var or = self._orientation;
	    y = (typeof y !== 'number') ? or[1] : y;
	    z = (typeof z !== 'number') ? or[2] : z;
	    xUp = (typeof xUp !== 'number') ? or[3] : xUp;
	    yUp = (typeof yUp !== 'number') ? or[4] : yUp;
	    zUp = (typeof zUp !== 'number') ? or[5] : zUp;
	
	    if (typeof x === 'number') {
	      self._orientation = [x, y, z, xUp, yUp, zUp];
	      self.ctx.listener.setOrientation(x, y, z, xUp, yUp, zUp);
	    } else {
	      return or;
	    }
	
	    return self;
	  };
	
	  /** Group Methods **/
	  /***************************************************************************/
	
	  /**
	   * Add new properties to the core init.
	   * @param  {Function} _super Core init method.
	   * @return {Howl}
	   */
	  Howl.prototype.init = (function(_super) {
	    return function(o) {
	      var self = this;
	
	      // Setup user-defined default properties.
	      self._orientation = o.orientation || [1, 0, 0];
	      self._stereo = o.stereo || null;
	      self._pos = o.pos || null;
	      self._pannerAttr = {
	        coneInnerAngle: typeof o.coneInnerAngle !== 'undefined' ? o.coneInnerAngle : 360,
	        coneOuterAngle: typeof o.coneOuterAngle !== 'undefined' ? o.coneOuterAngle : 360,
	        coneOuterGain: typeof o.coneOuterGain !== 'undefined' ? o.coneOuterGain : 0,
	        distanceModel: typeof o.distanceModel !== 'undefined' ? o.distanceModel : 'inverse',
	        maxDistance: typeof o.maxDistance !== 'undefined' ? o.maxDistance : 10000,
	        panningModel: typeof o.panningModel !== 'undefined' ? o.panningModel : 'HRTF',
	        refDistance: typeof o.refDistance !== 'undefined' ? o.refDistance : 1,
	        rolloffFactor: typeof o.rolloffFactor !== 'undefined' ? o.rolloffFactor : 1
	      };
	
	      // Setup event listeners.
	      self._onstereo = o.onstereo ? [{fn: o.onstereo}] : [];
	      self._onpos = o.onpos ? [{fn: o.onpos}] : [];
	      self._onorientation = o.onorientation ? [{fn: o.onorientation}] : [];
	
	      // Complete initilization with howler.js core's init function.
	      return _super.call(this, o);
	    };
	  })(Howl.prototype.init);
	
	  /**
	   * Get/set the stereo panning of the audio source for this sound or all in the group.
	   * @param  {Number} pan  A value of -1.0 is all the way left and 1.0 is all the way right.
	   * @param  {Number} id (optional) The sound ID. If none is passed, all in group will be updated.
	   * @return {Howl/Number}    Returns self or the current stereo panning value.
	   */
	  Howl.prototype.stereo = function(pan, id) {
	    var self = this;
	
	    // Stop right here if not using Web Audio.
	    if (!self._webAudio) {
	      return self;
	    }
	
	    // If the sound hasn't loaded, add it to the load queue to change stereo pan when capable.
	    if (self._state !== 'loaded') {
	      self._queue.push({
	        event: 'stereo',
	        action: function() {
	          self.stereo(pan, id);
	        }
	      });
	
	      return self;
	    }
	
	    // Check for PannerStereoNode support and fallback to PannerNode if it doesn't exist.
	    var pannerType = (typeof Howler.ctx.createStereoPanner === 'undefined') ? 'spatial' : 'stereo';
	
	    // Setup the group's stereo panning if no ID is passed.
	    if (typeof id === 'undefined') {
	      // Return the group's stereo panning if no parameters are passed.
	      if (typeof pan === 'number') {
	        self._stereo = pan;
	        self._pos = [pan, 0, 0];
	      } else {
	        return self._stereo;
	      }
	    }
	
	    // Change the streo panning of one or all sounds in group.
	    var ids = self._getSoundIds(id);
	    for (var i=0; i<ids.length; i++) {
	      // Get the sound.
	      var sound = self._soundById(ids[i]);
	
	      if (sound) {
	        if (typeof pan === 'number') {
	          sound._stereo = pan;
	          sound._pos = [pan, 0, 0];
	
	          if (sound._node) {
	            // If we are falling back, make sure the panningModel is equalpower.
	            sound._pannerAttr.panningModel = 'equalpower';
	
	            // Check if there is a panner setup and create a new one if not.
	            if (!sound._panner || !sound._panner.pan) {
	              setupPanner(sound, pannerType);
	            }
	
	            if (pannerType === 'spatial') {
	              sound._panner.setPosition(pan, 0, 0);
	            } else {
	              sound._panner.pan.value = pan;
	            }
	          }
	
	          self._emit('stereo', sound._id);
	        } else {
	          return sound._stereo;
	        }
	      }
	    }
	
	    return self;
	  };
	
	  /**
	   * Get/set the 3D spatial position of the audio source for this sound or
	   * all in the group. The most common usage is to set the 'x' position for
	   * left/right panning. Setting any value higher than 1.0 will begin to
	   * decrease the volume of the sound as it moves further away.
	   * @param  {Number} x  The x-position of the audio from -1000.0 to 1000.0.
	   * @param  {Number} y  The y-position of the audio from -1000.0 to 1000.0.
	   * @param  {Number} z  The z-position of the audio from -1000.0 to 1000.0.
	   * @param  {Number} id (optional) The sound ID. If none is passed, all in group will be updated.
	   * @return {Howl/Array}    Returns self or the current 3D spatial position: [x, y, z].
	   */
	  Howl.prototype.pos = function(x, y, z, id) {
	    var self = this;
	
	    // Stop right here if not using Web Audio.
	    if (!self._webAudio) {
	      return self;
	    }
	
	    // If the sound hasn't loaded, add it to the load queue to change position when capable.
	    if (self._state !== 'loaded') {
	      self._queue.push({
	        event: 'pos',
	        action: function() {
	          self.pos(x, y, z, id);
	        }
	      });
	
	      return self;
	    }
	
	    // Set the defaults for optional 'y' & 'z'.
	    y = (typeof y !== 'number') ? 0 : y;
	    z = (typeof z !== 'number') ? -0.5 : z;
	
	    // Setup the group's spatial position if no ID is passed.
	    if (typeof id === 'undefined') {
	      // Return the group's spatial position if no parameters are passed.
	      if (typeof x === 'number') {
	        self._pos = [x, y, z];
	      } else {
	        return self._pos;
	      }
	    }
	
	    // Change the spatial position of one or all sounds in group.
	    var ids = self._getSoundIds(id);
	    for (var i=0; i<ids.length; i++) {
	      // Get the sound.
	      var sound = self._soundById(ids[i]);
	
	      if (sound) {
	        if (typeof x === 'number') {
	          sound._pos = [x, y, z];
	
	          if (sound._node) {
	            // Check if there is a panner setup and create a new one if not.
	            if (!sound._panner || sound._panner.pan) {
	              setupPanner(sound, 'spatial');
	            }
	
	            sound._panner.setPosition(x, y, z);
	          }
	
	          self._emit('pos', sound._id);
	        } else {
	          return sound._pos;
	        }
	      }
	    }
	
	    return self;
	  };
	
	  /**
	   * Get/set the direction the audio source is pointing in the 3D cartesian coordinate
	   * space. Depending on how direction the sound is, based on the `cone` attributes,
	   * a sound pointing away from the listener can be quiet or silent.
	   * @param  {Number} x  The x-orientation of the source.
	   * @param  {Number} y  The y-orientation of the source.
	   * @param  {Number} z  The z-orientation of the source.
	   * @param  {Number} id (optional) The sound ID. If none is passed, all in group will be updated.
	   * @return {Howl/Array}    Returns self or the current 3D spatial orientation: [x, y, z].
	   */
	  Howl.prototype.orientation = function(x, y, z, id) {
	    var self = this;
	
	    // Stop right here if not using Web Audio.
	    if (!self._webAudio) {
	      return self;
	    }
	
	    // If the sound hasn't loaded, add it to the load queue to change orientation when capable.
	    if (self._state !== 'loaded') {
	      self._queue.push({
	        event: 'orientation',
	        action: function() {
	          self.orientation(x, y, z, id);
	        }
	      });
	
	      return self;
	    }
	
	    // Set the defaults for optional 'y' & 'z'.
	    y = (typeof y !== 'number') ? self._orientation[1] : y;
	    z = (typeof z !== 'number') ? self._orientation[2] : z;
	
	    // Setup the group's spatial orientation if no ID is passed.
	    if (typeof id === 'undefined') {
	      // Return the group's spatial orientation if no parameters are passed.
	      if (typeof x === 'number') {
	        self._orientation = [x, y, z];
	      } else {
	        return self._orientation;
	      }
	    }
	
	    // Change the spatial orientation of one or all sounds in group.
	    var ids = self._getSoundIds(id);
	    for (var i=0; i<ids.length; i++) {
	      // Get the sound.
	      var sound = self._soundById(ids[i]);
	
	      if (sound) {
	        if (typeof x === 'number') {
	          sound._orientation = [x, y, z];
	
	          if (sound._node) {
	            // Check if there is a panner setup and create a new one if not.
	            if (!sound._panner) {
	              // Make sure we have a position to setup the node with.
	              if (!sound._pos) {
	                sound._pos = self._pos || [0, 0, -0.5];
	              }
	
	              setupPanner(sound, 'spatial');
	            }
	
	            sound._panner.setOrientation(x, y, z);
	          }
	
	          self._emit('orientation', sound._id);
	        } else {
	          return sound._orientation;
	        }
	      }
	    }
	
	    return self;
	  };
	
	  /**
	   * Get/set the panner node's attributes for a sound or group of sounds.
	   * This method can optionall take 0, 1 or 2 arguments.
	   *   pannerAttr() -> Returns the group's values.
	   *   pannerAttr(id) -> Returns the sound id's values.
	   *   pannerAttr(o) -> Set's the values of all sounds in this Howl group.
	   *   pannerAttr(o, id) -> Set's the values of passed sound id.
	   *
	   *   Attributes:
	   *     coneInnerAngle - (360 by default) There will be no volume reduction inside this angle.
	   *     coneOuterAngle - (360 by default) The volume will be reduced to a constant value of
	   *                      `coneOuterGain` outside this angle.
	   *     coneOuterGain - (0 by default) The amount of volume reduction outside of `coneOuterAngle`.
	   *     distanceModel - ('inverse' by default) Determines algorithm to use to reduce volume as audio moves
	   *                      away from listener. Can be `linear`, `inverse` or `exponential`.
	   *     maxDistance - (10000 by default) Volume won't reduce between source/listener beyond this distance.
	   *     panningModel - ('HRTF' by default) Determines which spatialization algorithm is used to position audio.
	   *                     Can be `HRTF` or `equalpower`.
	   *     refDistance - (1 by default) A reference distance for reducing volume as the source
	   *                    moves away from the listener.
	   *     rolloffFactor - (1 by default) How quickly the volume reduces as source moves from listener.
	   * 
	   * @return {Howl/Object} Returns self or current panner attributes.
	   */
	  Howl.prototype.pannerAttr = function() {
	    var self = this;
	    var args = arguments;
	    var o, id, sound;
	
	    // Stop right here if not using Web Audio.
	    if (!self._webAudio) {
	      return self;
	    }
	
	    // Determine the values based on arguments.
	    if (args.length === 0) {
	      // Return the group's panner attribute values.
	      return self._pannerAttr;
	    } else if (args.length === 1) {
	      if (typeof args[0] === 'object') {
	        o = args[0];
	
	        // Set the grou's panner attribute values.
	        if (typeof id === 'undefined') {
	          self._pannerAttr = {
	            coneInnerAngle: typeof o.coneInnerAngle !== 'undefined' ? o.coneInnerAngle : self._coneInnerAngle,
	            coneOuterAngle: typeof o.coneOuterAngle !== 'undefined' ? o.coneOuterAngle : self._coneOuterAngle,
	            coneOuterGain: typeof o.coneOuterGain !== 'undefined' ? o.coneOuterGain : self._coneOuterGain,
	            distanceModel: typeof o.distanceModel !== 'undefined' ? o.distanceModel : self._distanceModel,
	            maxDistance: typeof o.maxDistance !== 'undefined' ? o.maxDistance : self._maxDistance,
	            panningModel: typeof o.panningModel !== 'undefined' ? o.panningModel : self._panningModel,
	            refDistance: typeof o.refDistance !== 'undefined' ? o.refDistance : self._refDistance,
	            rolloffFactor: typeof o.rolloffFactor !== 'undefined' ? o.rolloffFactor : self._rolloffFactor
	          };
	        }
	      } else {
	        // Return this sound's panner attribute values.
	        sound = self._soundById(parseInt(args[0], 10));
	        return sound ? sound._pannerAttr : self._pannerAttr;
	      }
	    } else if (args.length === 2) {
	      o = args[0];
	      id = parseInt(args[1], 10);
	    }
	
	    // Update the values of the specified sounds.
	    var ids = self._getSoundIds(id);
	    for (var i=0; i<ids.length; i++) {
	      sound = self._soundById(ids[i]);
	
	      if (sound) {
	        // Merge the new values into the sound.
	        var pa = sound._pannerAttr;
	        pa = {
	          coneInnerAngle: typeof o.coneInnerAngle !== 'undefined' ? o.coneInnerAngle : pa.coneInnerAngle,
	          coneOuterAngle: typeof o.coneOuterAngle !== 'undefined' ? o.coneOuterAngle : pa.coneOuterAngle,
	          coneOuterGain: typeof o.coneOuterGain !== 'undefined' ? o.coneOuterGain : pa.coneOuterGain,
	          distanceModel: typeof o.distanceModel !== 'undefined' ? o.distanceModel : pa.distanceModel,
	          maxDistance: typeof o.maxDistance !== 'undefined' ? o.maxDistance : pa.maxDistance,
	          panningModel: typeof o.panningModel !== 'undefined' ? o.panningModel : pa.panningModel,
	          refDistance: typeof o.refDistance !== 'undefined' ? o.refDistance : pa.refDistance,
	          rolloffFactor: typeof o.rolloffFactor !== 'undefined' ? o.rolloffFactor : pa.rolloffFactor
	        };
	
	        // Update the panner values or create a new panner if none exists.
	        var panner = sound._panner;
	        if (panner) {
	          panner.coneInnerAngle = pa.coneInnerAngle;
	          panner.coneOuterAngle = pa.coneOuterAngle;
	          panner.coneOuterGain = pa.coneOuterGain;
	          panner.distanceModel = pa.distanceModel;
	          panner.maxDistance = pa.maxDistance;
	          panner.panningModel = pa.panningModel;
	          panner.refDistance = pa.refDistance;
	          panner.rolloffFactor = pa.rolloffFactor;
	        } else {
	          // Make sure we have a position to setup the node with.
	          if (!sound._pos) {
	            sound._pos = self._pos || [0, 0, -0.5];
	          }
	
	          // Create a new panner node.
	          setupPanner(sound, 'spatial');
	        }
	      }
	    }
	
	    return self;
	  };
	
	  /** Single Sound Methods **/
	  /***************************************************************************/
	
	  /**
	   * Add new properties to the core Sound init.
	   * @param  {Function} _super Core Sound init method.
	   * @return {Sound}
	   */
	  Sound.prototype.init = (function(_super) {
	    return function() {
	      var self = this;
	      var parent = self._parent;
	
	      // Setup user-defined default properties.
	      self._orientation = parent._orientation;
	      self._stereo = parent._stereo;
	      self._pos = parent._pos;
	      self._pannerAttr = parent._pannerAttr;
	
	      // Complete initilization with howler.js core Sound's init function.
	      _super.call(this);
	
	      // If a stereo or position was specified, set it up.
	      if (self._stereo) {
	        parent.stereo(self._stereo);
	      } else if (self._pos) {
	        parent.pos(self._pos[0], self._pos[1], self._pos[2], self._id);
	      }
	    };
	  })(Sound.prototype.init);
	
	  /**
	   * Override the Sound.reset method to clean up properties from the spatial plugin.
	   * @param  {Function} _super Sound reset method.
	   * @return {Sound}
	   */
	  Sound.prototype.reset = (function(_super) {
	    return function() {
	      var self = this;
	      var parent = self._parent;
	
	      // Reset all spatial plugin properties on this sound.
	      self._orientation = parent._orientation;
	      self._pos = parent._pos;
	      self._pannerAttr = parent._pannerAttr;
	
	      // Complete resetting of the sound.
	      return _super.call(this);
	    };
	  })(Sound.prototype.reset);
	
	  /** Helper Methods **/
	  /***************************************************************************/
	
	  /**
	   * Create a new panner node and save it on the sound.
	   * @param  {Sound} sound Specific sound to setup panning on.
	   * @param {String} type Type of panner to create: 'stereo' or 'spatial'.
	   */
	  var setupPanner = function(sound, type) {
	    type = type || 'spatial';
	
	    // Create the new panner node.
	    if (type === 'spatial') {
	      sound._panner = Howler.ctx.createPanner();
	      sound._panner.coneInnerAngle = sound._pannerAttr.coneInnerAngle;
	      sound._panner.coneOuterAngle = sound._pannerAttr.coneOuterAngle;
	      sound._panner.coneOuterGain = sound._pannerAttr.coneOuterGain;
	      sound._panner.distanceModel = sound._pannerAttr.distanceModel;
	      sound._panner.maxDistance = sound._pannerAttr.maxDistance;
	      sound._panner.panningModel = sound._pannerAttr.panningModel;
	      sound._panner.refDistance = sound._pannerAttr.refDistance;
	      sound._panner.rolloffFactor = sound._pannerAttr.rolloffFactor;
	      sound._panner.setPosition(sound._pos[0], sound._pos[1], sound._pos[2]);
	      sound._panner.setOrientation(sound._orientation[0], sound._orientation[1], sound._orientation[2]);
	    } else {
	      sound._panner = Howler.ctx.createStereoPanner();
	      sound._panner.pan.value = sound._stereo;
	    }
	
	    sound._panner.connect(sound._node);
	
	    // Update the connections.
	    if (!sound._paused) {
	      sound._parent.pause(sound._id, true).play(sound._id);
	    }
	  };
	})();
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 5 */
/***/ function(module, exports) {

	var PubSub = {};
	
	(function(p){
		
		var events = {},
			idRegistry = 9100;
		
		
		p.subscribe = function(event, func){
			if(!events.hasOwnProperty(event)){
				events[event] = [];
			}
			
			var eventID = ++idRegistry;
			
			events[event].push({
				
				id : eventID,
				handler : func
							   
				});
			
			return eventID;
	
		};
		
		p.publish = function(event, data){
			
			for(var event in events){
				if(!events.hasOwnProperty(event)){
					return false;
				}
			}
				
			var subs = events[event];
	
			for(var i = 0, j = subs.length; i<j; i++){
				
				subs[i].handler(event, data);
				
			}
			
		};
		
		p.unsubscribe = function(id){
			
			for(var event in events){
				if(events.hasOwnProperty(event)){
					for(var i = 0, j = events[event].length; i<j; i++){
						if(events[event][i].id === id){
							events[event].splice(i, 1);
							return id;
						}
					}
				}
			}
			
		};
	
	})(PubSub);
	
	module.exports = PubSub;

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	
	var PubSub = __webpack_require__(5);
	
	var keyboardControl = function(){
		
		//control keys
		const UP_ARROW = 38,
			LEFT_ARROW = 37,
			RIGHT_ARROW = 39,
			DOWN_ARROW = 40,
			X_KEY = 88,
			SPACE_BAR = 32,
			LETTER_P = 80;
		
		//array of active and deactive keys
		var keyPressList = [],
			objects = [],
			initialized = false,
			inGamePlay = false;
		
		function init(objectsToControl){
			
			//pushes the elements to be manipulated by the keyword keys
			if(!objects.length){
				for(element in arguments){
					objects.push(arguments[element]);
				}
			}
			
			PubSub.subscribe('statechange', handleStateChange);
		
			document.addEventListener('keyup', onKeyUp, false);
			document.addEventListener('keydown', onKeyDown, false);
			initialized = true;
			console.log('Keyword Control Module Initialized');
			
		}
		
		function handleStateChange(event, data){
			inGamePlay = (data != "gameplay")? false : true;
		}
		
		function onKeyUp(e){
			if(!initialized) return(console.log('Keyword Module has not been initialized...'));
			e.preventDefault();
			keyPressList[e.keyCode] = false;
		}
		
		function onKeyDown(e){
			if(!initialized) return(console.log('Keyword Module has not been initialized...'));
			e.preventDefault();
			keyPressList[e.keyCode] = true; 
		}
		
		function runKeys(){
			
			var length = objects.length;
			
			
			for(var i = 0; i<length; i++){
				
				var object = objects[i];
				
				if(keyPressList[LEFT_ARROW]){
					object.angle -= 5*Math.PI/180;
				}else if(keyPressList[RIGHT_ARROW]){
					object.angle += 5*Math.PI/180;
				}
				if(keyPressList[UP_ARROW]){
					object.thrust = true;
					var faceX = Math.cos(object.angle);
					var faceY = Math.sin(object.angle);
					var newVelX = object.velX+faceX*object.thrustAccel;
					var newVelY = object.velY+faceY*object.thrustAccel;
	
					var futureVelocity = Math.sqrt((newVelX*newVelX)+(newVelY*newVelY));
	
					if(futureVelocity > object.maxVelocity){
						newVelX = object.velX;
						newVelY = object.velY;
					}
	
					object.velX = newVelX;
					object.velY = newVelY;	
	
				}else{
					object.thrust = false;
				}
				if(keyPressList[SPACE_BAR] == false){
					keyPressList[SPACE_BAR] = true;
					if(!object.shield.active){
					object.shoot();
					}
					console.log(object.missiles.pool.length);
					//PubSub.publish('gamestate', 'paused');
				}
				if(keyPressList[X_KEY]){
					object.shield.active = true;
	
				}else if(keyPressList[X_KEY] == false){
					object.shield.active = false;
				}
				if(keyPressList[LETTER_P] == false){
					keyPressList[LETTER_P] = true;
					console.log('Letter P has been pressed');
					var unsubID = PubSub.unsubscribe(9101);
					console.log(unsubID);
				}
				
			}
			
		}
		
		function end(){
			document.removeEventListener('keyup', onKeyUp, false);
			document.removeEventListener('keydown', onKeyDown, false);
			initialized = false;
			console.log('Keyword Module Terminated');
		}
		
		return{
			init : init,
			update : runKeys,
			end : end
		}
		
	}();
	
	module.exports = keyboardControl;

/***/ }
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgM2E5NmU5NDc4MDFhNTE4NmZmZmMiLCJ3ZWJwYWNrOi8vLy4vanMvbWFpbi5qcyIsIndlYnBhY2s6Ly8vLi9qcy9EaXNwbGF5LmpzIiwid2VicGFjazovLy8uL2pzL1Nwcml0ZUFuaW1hdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9qcy9SZXNvdXJjZUxvYWRlci5qcyIsIndlYnBhY2s6Ly8vLi9+L2hvd2xlci9kaXN0L2hvd2xlci5qcyIsIndlYnBhY2s6Ly8vLi9qcy9QdWJTdWIuanMiLCJ3ZWJwYWNrOi8vLy4vanMva2V5Ym9hcmRDb250cm9sLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1QkFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7O0FDdENBOztBQUVBLHNCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQSxlQUFjOztBQUVkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEQ7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFrRTtBQUNsRSxzREFBcUQ7QUFDckQscUVBQW9FO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0EsSUFBRztBQUNIO0FBQ0EsSUFBRztBQUNIO0FBQ0EsSTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsNkNBQTRDO0FBQzVDO0FBQ0E7QUFDQSxNQUFLLGdEQUFnRDtBQUNyRDtBQUNBO0FBQ0E7O0FBRUE7Ozs7QUFJQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtRUFBa0U7QUFDbEUscURBQW9EO0FBQ3BELG1FQUFrRTtBQUNsRSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDRCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsTztBQUNBOztBQUVBO0FBQ0E7QUFDQSxLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4RDtBQUNBLDZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEs7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLCtCO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxxQkFBb0IsNkJBQTZCO0FBQ2pELHdEO0FBQ0E7QUFDQSx1QztBQUNBO0FBQ0E7O0FBRUEsNEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7O0FBRUE7QUFDQTs7QUFFQSw0Q0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDRDQUEyQywwRztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsNENBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSx1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxvRTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkI7QUFDQSxjO0FBQ0EsTzs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx1TDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSzs7Ozs7QUFLQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWEsUztBQUNiOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7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QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7O0FBR0EsRUFBQzs7QUFFRCwwQjs7Ozs7O0FDbkRBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdEOztBQUVBO0FBQ0E7O0FBRUEsMkJBQTBCLHVCQUF1QjtBQUNqRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGNBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtLO0FBQ0EsYztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEO0FBQ0EsVzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7OztBQUdBLEdBQUU7O0FBRUYsa0M7Ozs7OztBQ2xJQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkI7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0EsU0FBUTtBQUNSO0FBQ0E7O0FBRUE7O0FBRUE7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QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsRUFBQzs7QUFFRCxrQyIsImZpbGUiOiIuL3NjcmlwdHMubWluLmpzIiwic291cmNlc0NvbnRlbnQiOlsiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pXG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG5cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGV4cG9ydHM6IHt9LFxuIFx0XHRcdGlkOiBtb2R1bGVJZCxcbiBcdFx0XHRsb2FkZWQ6IGZhbHNlXG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmxvYWRlZCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiB3ZWJwYWNrL2Jvb3RzdHJhcCAzYTk2ZTk0NzgwMWE1MTg2ZmZmY1xuICoqLyIsIndpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgY2FudmFzQXBwLCBmYWxzZSk7XG5cbmZ1bmN0aW9uIGNhbnZhc0FwcCgpe1x0XG5cdFxuXHR2YXIgRGlzcGxheSA9IHJlcXVpcmUoJy4vRGlzcGxheScpLFxuXHRcdFNwcml0ZUFuaW1hdGlvbiA9IHJlcXVpcmUoJy4vU3ByaXRlQW5pbWF0aW9uLmpzJyksXG5cdFx0UmVzb3VyY2VMb2FkZXIgPSByZXF1aXJlKCcuL1Jlc291cmNlTG9hZGVyLmpzJyksXG5cdFx0UHViU3ViID0gcmVxdWlyZSgnLi9QdWJTdWIuanMnKSxcblx0XHRrZXlib2FyZENvbnRyb2wgPSByZXF1aXJlKCcuL2tleWJvYXJkQ29udHJvbC5qcycpO1xuXHRcblx0XG5cdFxuXHRcdFx0Ly9zZXRzIHVwIGdhbWUgZW5naW5lXG5cdFx0d2luZG93LnJlcXVlc3RBbmltRnJhbWUgPSAoZnVuY3Rpb24oKXtcblx0cmV0dXJuICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lICAgfHxcblx0XHRcdHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcblx0XHRcdHdpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgICAgfHxcblx0XHRcdHdpbmRvdy5vUmVxdWVzdEFuaW1hdGlvbkZyYW1lICAgICAgfHxcblx0XHRcdHdpbmRvdy5tc1JlcXVlc3RBbmltYXRpb25GcmFtZSAgICAgfHxcblx0XHRcdGZ1bmN0aW9uKC8qIGZ1bmN0aW9uICovIGNhbGxiYWNrLCAvKiBET01FbGVtZW50ICovIGVsZW1lbnQpe1xuXHRcdFx0XHR3aW5kb3cuc2V0VGltZW91dChjYWxsYmFjaywgRlJBTUVfUkFURSk7XG5cdFx0XHR9O1xufSkoKTtcblxuXHQvL3BjIG5vcm1hbCBzdGF0ZXNcblx0Y29uc3QgU1RBVEVfTE9BRElORyA9IDEsXG4gICAgU1RBVEVfSU5JVCA9IDIsXG4gICAgU1RBVEVfU1RPUllfTElORSA9IDMsXG5cdFNUQVRFX1RJVExFX1NDUkVFTiA9IDQsXG4gICAgU1RBVEVfSE9XX1RPX1BMQVkgPSA1LFxuXHRTVEFURV9QTEFZSU5HID0gNixcbiAgICBTVEFURV9XQUlUSU5HID0gNyxcbiAgICBTVEFURV9MRVZFTF9UUkFOU0lUSU9OID0gOCxcbiAgICBTVEFURV9ORVhUX0xFVkVMID0gOSxcblx0U1RBVEVfVVNFUl9CRUFUX0dBTUUgPSAxMCxcblx0U1RBVEVfR0FNRV9PVkVSID0gMTEsXG5cdFNUQVRFX0FTUEVDVF9SQVRJTyA9IDEzLFxuXHRTVEFURV9PUklFTlRBVElPTl9DSEFOR0UgPSAxNCxcblx0U1RBVEVfVVNFUl9BR0VOVCA9IDE1LFxuICAgIFNUQVRFX0NSRURJVFMgPSAxMjtcblx0XHR2YXIgYXBwU3RhdGU7XG5cdFx0dmFyIHByZXZpb3VzQXBwU3RhdGU7XG5cdFxuXHQvL3VzZXJBZ2VudCBpbmZvIGFuZCBjYW52YXMgY29udHJvbFxuXHR2YXIgdXNlckFnZW50ID0ge21vYmlsZTpmYWxzZSxwbGF0Zm9ybTpcIlwiLCBwb3J0cmFpdDpmYWxzZX07XG5cdHZhciBjYW52YXNIb2xkZXIgPSAkKCcjY2FudmFzSG9sZGVyJyk7XG4gICAgdmFyIHByZWxvYWRJbWFnZSA9ICQoJyNwcmVsb2FkJyk7XG4gICAgdmFyIGludGVyZmFjZVdyYXBwZXIgPSAkKCcjaW50ZXJmYWNlV3JhcHBlcicpO1xuXHR2YXIgb3JpZW50YXRpb25NZXNzYWdlSG9sZGVyID0gJCgnI29yaWVudGF0aW9uTWVzc2FnZScpO1xuXHRcblx0Ly9mcmFtZSwgYXNzZXRzIGNvdW50ZXIgYW5kIGF1ZGlvIHN1cHBvcnRcblx0dmFyIGZyYW1lUmF0ZSA9IG5ldyBGcmFtZVJhdGVDb3VudGVyKCk7XG5cdHZhciBpdGVtc1RvTG9hZCA9IDE3O1xuXHR2YXIgbG9hZENvdW50ID0gMDtcblx0dmFyIEZSQU1FX1JBVEUgPSAxMDAwLzYwO1xuXHR2YXIgbG9vcE9uID0gZmFsc2U7XG5cdFxuXHQvL3NldCB1cCBsb2FkZXJcblx0dmFyIGxvYWRlck9wdGlvbnMgPSB7XG5cdFx0XHRhc3NldHMgOiB7XG5cdFx0XHRcdGltZ3MgOiB7XG5cdFx0XHRlYXJ0aFNwcml0ZSA6IFwiYXNzZXRzL3Nwcml0ZXMvZWFydGgucG5nXCIsXG5cdFx0XHRwbGF5ZXJTcHJpdGVTaGVldCA6IFwiYXNzZXRzL3Nwcml0ZXMvcGxheWVyU2hpcC5wbmdcIixcblx0XHRcdGVuZW15U3ByaXRlU2hlZXQgOiBcImFzc2V0cy9zcHJpdGVzL2VuZW15U2hpcHMucG5nXCIsXG5cdFx0XHRNb3RoZXJzaGlwU3ByaXRlU2hlZXQgOiBcImFzc2V0cy9zcHJpdGVzL21vdGhlcnNoaXBzLnBuZ1wiLFxuXHRcdFx0YmFja2dyb3VuZFNwcml0ZSA6IFwiYXNzZXRzL3Nwcml0ZXMvYmFja2dyb3VuZC5wbmdcIixcblx0XHRcdG1ldGVvclNwcml0ZSA6IFwiYXNzZXRzL3Nwcml0ZXMvbWV0ZW9yU3ByaXRlLnBuZ1wiLFxuXHRcdFx0cGVya1Nwcml0ZSA6IFwiYXNzZXRzL3Nwcml0ZXMvcGVya3MucG5nXCJcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdG9ubG9hZCA6IGZ1bmN0aW9uKGl0ZW0pe1xuXHRcdFx0XHRjb25zb2xlLmxvZyhcIlRoZSBzb3VyY2Ugb2YgdGhlIGl0ZW0gdGhhdCBoYXMganVzdCBsb2FkZWQgaXMgXCIgKyBpdGVtLnNyYyk7XG5cdFx0XHR9LFxuXHRcdFx0ZmluYWwgOiBmdW5jdGlvbigpe1xuXHRcdFx0XHRpbml0QXNzZXRzKCk7XG5cdFx0XHR9XG5cdFx0fTtcbiAgICBcbiAgICBcblx0Ly9tb3VzZVxuXHR2YXIgbW91c2UgPSB7eDowLHk6MCwgYWxpdmU6dHJ1ZX07XG5cdFxuXHQvL2NvdW50ZXJzXG5cdHZhciBzY29yZUNvdW50ZXIgPSAkKCcjc2NvcmVDb3VudGVyJyk7XG5cdHZhciBsZXZlbENvdW50ZXIgPSAkKCcjbGV2ZWxDb3VudGVyJyk7XG5cdHZhciBsaXZlc0NvdW50ZXIgPSAkKCcjbGl2ZXNDb3VudGVyJyk7XG5cdHZhciBmcmFtZVJhdGVDb3VudGVyID0gJCgnI2ZyYW1lUmF0ZScpO1xuICAgIHZhciByZXBvcnRFbmVtaWVzS2lsbGVkID0gJCgnI3JlcG9ydENhcm5hZ2UnKTtcbiAgICB2YXIgcmVwb3J0Um9ja3NEZXN0cm95ZWQgPSAkKCcjcmVwb3J0QXN0ZXJvaWRzJyk7XG4gICAgdmFyIHJlcG9ydFNjb3JlID0gJCgnI3JlcG9ydFNjb3JlJyk7XG4gICAgdmFyIGJlYXRHYW1lU2NvcmUgPSAkKCcjYmVhdEdhbWVTY29yZScpO1xuXHRcblx0Ly90aXRsZSBzY3JlZW4gYnV0dG9ucyBcblx0dmFyIHN0YXJ0QnV0dG9uID0gJCgnI3N0YXJ0R2FtZScpO1xuICAgIHZhciBob3dUb1BsYXlCdXR0b24gPSAkKCcjaG93VG9QbGF5Jyk7XG5cdHZhciByZXN0YXJ0QnV0dG9uID0gJCgnI3Jlc3RhcnQnKTtcbiAgICB2YXIgc3RvcnlMaW5lQnV0dG9uID0gJCgnI3N0b3J5TGluZScpO1xuICAgIHZhciBjcmVkaXRzQnV0dG9uID0gJCgnI2NyZWRpdHNCdXR0b24nKTtcbiAgICBcblx0XG5cdC8vZ2FtZSB0ZXh0IGRpdiBob2xkZXJzIGFuZCBjb250cm9sc1xuXHR2YXIgZ2FtZVN0YXJ0SG9sZGVyID0gJCgnI2dhbWVTdGFydCcpO1xuXHR2YXIgZ2FtZVBsYXlIb2xkZXIgPSAkKCcjZ2FtZVBsYXknKTtcblx0dmFyIGdhbWVPdmVySG9sZGVyID0gJCgnI2dhbWVPdmVyJyk7XG4gICAgdmFyIGhvd1RvUGxheUhvbGRlciA9ICQoJyNob3dUb1BsYXlIb2xkZXInKTtcbiAgICB2YXIgc3RvcnlMaW5lSG9sZGVyID0gJCgnI3N0b3J5TGluZUhvbGRlcicpO1xuICAgIHZhciBsZXZlbFRyYW5zaXRpb25Ib2xkZXIgPSAkKCcjbGV2ZWxUcmFuc2l0aW9uJyk7XG4gICAgdmFyIGNyZWRpdHNIb2xkZXIgPSAkKCcjY3JlZGl0cycpO1xuICAgIHZhciBiZWF0R2FtZUhvbGRlciA9ICQoJyNiZWF0R2FtZScpO1xuICAgIFxuICAgIHZhciBuZXh0TGV2ZWxCdXR0b24gPSAkKCcjbmV4dExldmVsJyk7XG5cdHZhciBob3dUb0JhY2tCdXR0b24gPSAkKCcjaG93VG9CYWNrJyk7XG4gICAgdmFyIHN0b3J5TGluZVNraXBCdXR0b24gPSAkKCcjc2tpcFN0b3J5TGluZScpO1xuICAgIHZhciBzaGFyZUJ1dHRvbiA9ICQoJyNzaGFyZVN0YXJ0Jyk7XG4gICAgdmFyIHNraXBDcmVkaXRzID0gJCgnI3NraXBDcmVkaXRzJyk7XG4gICAgXG5cdC8vc2NvcmUgICYgbGV2ZWwgdmFyaWFibGVzXG5cdHZhciBjdXJyZW50U2NvcmUgPSAwLFxuXHQgICAgY3VycmVudExldmVsID0gMCxcbiAgICAgICAgbGFzdExldmVsID0gMTQsXG4gICAgICAgIHVzZXJCZWF0R2FtZSA9IGZhbHNlLFxuICAgICAgICBlbmVteVNoaXBXb3J0aCA9IDEwLFxuICAgICAgICByb2NrV29ydGggPSA1LFxuXHQgICAgc2hpcExpdmVzID0gNDtcblx0XG5cdHZhciBmcmljdGlvbiA9IDAuMDA1O1xuICAgIFxuICAgIGluaGVyaXRGcm9tKERpc3BsYXksIFBoeXNpY3MpO1xuICAgIGluaGVyaXRGcm9tKFBoeXNpY3MsIFNwYWNlY3JhZnQpO1xuICAgIGluaGVyaXRGcm9tKERpc3BsYXksIEJhY2tncm91bmQpO1xuICAgIFxuXHQvL21ha2UgY3VzdG9tIGNsYXNzZXMgaW5oZXJpdCBkaXNwbGF5IGNsYXNzXG4gICAgaW5oZXJpdEZyb20oUGh5c2ljcywgTWlzc2lsZSk7XG4gICAgaW5oZXJpdEZyb20oRGlzcGxheSwgU2hpZWxkKTtcbiAgICBpbmhlcml0RnJvbShTcGFjZWNyYWZ0LCBTaGlwKTtcbiAgICBpbmhlcml0RnJvbShEaXNwbGF5LCBFeHBsb3Npb24pO1xuICAgIGluaGVyaXRGcm9tKFNwYWNlY3JhZnQsIEVuZW15KTtcbiAgICBpbmhlcml0RnJvbShQaHlzaWNzLCBSb2NrKTtcbiAgICBpbmhlcml0RnJvbShTcGFjZWNyYWZ0LCBNb3RoZXJzaGlwKTtcbiAgICBpbmhlcml0RnJvbShQaHlzaWNzLCBQZXJrKTtcbiAgICBcblxuICAgIFxuXHQvL3NvdW5kcyBBUElcblx0dmFyIG15U3Vic2NyaXB0aW9uID0gUHViU3ViLnN1YnNjcmliZSgnZ2FtZXN0YXRlJywgaGFuZGxlU3ViKTtcblx0dmFyIHNlY29uZFN1YiA9IFB1YlN1Yi5zdWJzY3JpYmUoJ2dhbWVzdGF0ZScsIGhhbmRsZVN1YlR3byk7XG5cdGNvbnNvbGUubG9nKFwiVGhlIGV2ZW50IGtleSBmb3Igc3ViIG9uZSBpcyA6IFwiLCBteVN1YnNjcmlwdGlvbik7XG5cdGNvbnNvbGUubG9nKFwiVGhlIGV2ZW50IGtleSBmb3Igc3ViIHR3byBpcyA6IFwiLCBzZWNvbmRTdWIpOyBcbiAgICBcbiAgICBcblx0Ly9nZXRzIGNhbnZhcyBhbmQgaXRzIGNvbnRleHQgYW5kIGNyZWF0ZXMgY2VudGVyIHggYW5kIHkgdmFyaWFibGVzXG5cdHZhciBtYWluQ2FudmFzID0gJCgnI2JnQ2FudmFzJyk7XG5cdHZhciBtYWluQ29udGV4dCA9IG1haW5DYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcblx0dmFyIGNlbnRlclg7XG5cdHZhciBjZW50ZXJZO1xuICAgIFxuXHQvL2FycmF5IGhvbGRpbmcga2V5IHByZXNzZXNcblx0dmFyIGtleVByZXNzTGlzdCA9IFtdO1xuXG5cdC8vVEVNUDogcGxheWVyIGluc3RhbmNlIGFuZCBlbmVtaWVzXG4gICAgdmFyIHBsYXllclNoaXAgPSBuZXcgU2hpcCgpO1xuXHR2YXIgYWxpZW5Nb3RoZXJzaGlwID0gbmV3IE1vdGhlcnNoaXAoKTtcbiAgICB2YXIgaHVtYW5Nb3RoZXJzaGlwID0gbmV3IE1vdGhlcnNoaXAoKTtcblx0dmFyIGJhY2tncm91bmQgPSBuZXcgQmFja2dyb3VuZCgpO1xuXG4gICAgdmFyIGdhbWVJbnRlcmZhY2UgPSBuZXcgSW50ZXJmYWNlKCk7XG4gICAgLy90ZW1wIGFzc2V0c1xuICAgIHZhciB0ZW1wRW5lbXkgPSBuZXcgRW5lbXkoKTtcbiAgICB2YXIgdGVtcE1vdGhlcnNoaXAgPSBuZXcgTW90aGVyc2hpcCgpO1xuXHR2YXIgdGVtcFNwcml0ZVNoZWV0QW5pbWF0aW9uID0gbmV3IFNwcml0ZUFuaW1hdGlvbigpO1xuICAgIFxuICAgIFxuICAgIHZhciB0b3RhbEVuZW1pZXMgPSA4LFxuICAgICAgICB0b3RhbFJvY2tzID0gMTAsXG4gICAgICAgIGxldmVsUm9ja3MgPSA1LFxuICAgICAgICBsZXZlbEVuZW1pZXMgPSA4LFxuICAgICAgICBsZXZlbFBlcmtzID0gNCxcbiAgICAgICAgZW5lbWllc0tpbGxlZCA9IDAsXG4gICAgICAgIHJvY2tzRGVzdHJveWVkID0gMDtcblxuICAgICAvL3Bvb2xzIGhvbGRpbmcgZW5lbWllcyBhbmQgcm9ja3NcbiAgICB2YXIgZW5lbXlTaGlwc1Bvb2wgPSBuZXcgUG9vbCh0b3RhbEVuZW1pZXMpLFxuICAgICAgICBodW1hblNoaXBzUG9vbCA9IG5ldyBQb29sKDEwKSxcbiAgICAgICAgcGVya3NQb29sID0gbmV3IFBvb2woMTApLFxuICAgICAgICBtZXRlb3JQb29sID0gbmV3IFBvb2wodG90YWxSb2Nrcyk7XG4gICAgXG4gICAgY29uc29sZS5sb2coYmFja2dyb3VuZCk7XG4gICAgY29uc29sZS5sb2cocGxheWVyU2hpcCk7XG4gICAgY29uc29sZS5sb2codGVtcEVuZW15KTtcbiAgICBjb25zb2xlLmxvZyh0ZW1wTW90aGVyc2hpcCk7XG4gICAgXG5cblx0XG5cdGFwcFN0YXRlID0gU1RBVEVfVVNFUl9BR0VOVDtcblx0cnVuU3RhdGUoKTtcblx0XG5cdGZ1bmN0aW9uIHJ1blN0YXRlKCl7XG5cdFx0XG5cdHN3aXRjaChhcHBTdGF0ZSl7XG5cdFx0XHRcblx0XHRjYXNlIFNUQVRFX1VTRVJfQUdFTlQ6XG5cdFx0XHRcdGdldFVzZXJBZ2VudEluZm8oKTtcblx0XHRcdGJyZWFrO1xuXHRcdFx0XG5cdFx0Y2FzZSBTVEFURV9BU1BFQ1RfUkFUSU86XG5cdFx0XHRcdHNldEFzcGVjdFJhdGlvKCk7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlIFNUQVRFX09SSUVOVEFUSU9OX0NIQU5HRTpcblx0XHRcdFx0b25PcmllbnRhdGlvbkNoYW5nZSgpO1xuXHRcdFx0YnJlYWs7XG5cdFx0Ly9ub3JtYWwgc3RhdGVzXG5cdFx0Y2FzZSBTVEFURV9JTklUOiBcblx0XHRcdGxvYWRBc3NldHMoKTtcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgU1RBVEVfTE9BRElORzpcblx0XHRcdC8vd2FpdCBmb3IgY2FsbHMgYmFja3Mgb2YgbG9hZCBldmVudHNcblx0XHRcdGJyZWFrO1xuICAgICAgICBjYXNlIFNUQVRFX1NUT1JZX0xJTkU6XG4gICAgICAgICAgICBzdG9yeUxpbmUoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXHRcdGNhc2UgU1RBVEVfVElUTEVfU0NSRUVOOlxuXHRcdFx0aW50cm9BbmltYXRpb24oKTtcblx0XHRcdGJyZWFrO1xuICAgICAgICBjYXNlIFNUQVRFX0hPV19UT19QTEFZOlxuICAgICAgICAgICAgaG93VG9QbGF5KCk7XG4gICAgICAgICAgICBicmVhaztcblx0XHRjYXNlIFNUQVRFX1BMQVlJTkc6XG5cdFx0XHRkcmF3Q2FudmFzKCk7XG5cdFx0XHRicmVhaztcbiAgICAgICAgY2FzZSBTVEFURV9MRVZFTF9UUkFOU0lUSU9OOlxuICAgICAgICAgICAgLy90aGUgdHJhbnNpdGlvbiBiZXR3ZWVuIG9uZSBsZXZlbCBhbmQgdGhlIG90aGVyLlxuICAgICAgICAgICAgdHJhbnNMZXZlbEFuaW1hdGlvbigpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgU1RBVEVfTkVYVF9MRVZFTDpcbiAgICAgICAgICAgIG5leHRMZXZlbERpYWxvZygpO1xuXHRcdFx0YnJlYWs7XG4gICAgICAgIGNhc2UgU1RBVEVfV0FJVElORzpcbiAgICAgICAgICAgIC8vbG9vcCBkb2VzIG5vdGhpbmcsIHdhaXRzIGZvciBhIGNoYW5nZSBpbiBzdGF0ZS5cbiAgICAgICAgICAgIGJyZWFrO1xuXHRcdGNhc2UgU1RBVEVfVVNFUl9CRUFUX0dBTUU6XG4gICAgICAgICAgICBiZWF0R2FtZSgpO1xuXHRcdFx0YnJlYWs7XG4gICAgICAgIGNhc2UgU1RBVEVfQ1JFRElUUzpcbiAgICAgICAgICAgIC8vc2V0cyB0byBjcmVkaXRzXG4gICAgICAgICAgICBicmVhaztcblx0XHRjYXNlIFNUQVRFX0dBTUVfT1ZFUjpcblx0XHRcdGdhbWVPdmVyKCk7XG5cdFx0XHRicmVhaztcblx0XHR9XG5cdH1cblx0XG5cdGZ1bmN0aW9uIGdhbWVMb29wKCl7XG5cdFx0aWYobG9vcE9uKXtcblx0XHRcdHJlcXVlc3RBbmltRnJhbWUoZ2FtZUxvb3AsIEZSQU1FX1JBVEUpO1xuICAgICAgICAgICAgLy93aW5kb3cuc2V0VGltZW91dChnYW1lTG9vcCwgRlJBTUVfUkFURSk7XG5cdFx0XHRydW5TdGF0ZSgpO1xuXHRcdH1cblx0fVxuXHRcblx0ZnVuY3Rpb24gZ2V0VXNlckFnZW50SW5mbygpe1xuXHRcdFxuXHRcdHVzZXJBZ2VudC5wbGF0Zm9ybSA9IG5hdmlnYXRvci5wbGF0Zm9ybTtcblx0XHRcblx0XHRpZih1c2VyQWdlbnQucGxhdGZvcm0gIT0gXCJXaW4zMlwiICYmIHVzZXJBZ2VudC5wbGF0Zm9ybSAhPSBcIk1hY0ludGVsXCIpe1xuXHRcdFx0dXNlckFnZW50Lm1vYmlsZSA9IHRydWU7XG5cdFx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgb25PcmllbnRhdGlvbkNoYW5nZSwgZmFsc2UpO1xuXHRcdFx0aWYod2luZG93LmlubmVySGVpZ2h0Pj0gd2luZG93LmlubmVyV2lkdGgpe1xuXHRcdFx0XHRvcmllbnRhdGlvbk1lc3NhZ2VIb2xkZXIuc2V0QXR0cmlidXRlKCdzdHlsZScsICdkaXNwbGF5OmJsb2NrOycpO1xuXHRcdFx0XHRjYW52YXNIb2xkZXIuc2V0QXR0cmlidXRlKCdzdHlsZScsICdkaXNwbGF5Om5vbmU7Jyk7XG4gICAgICAgICAgICAgICAgaW50ZXJmYWNlV3JhcHBlci5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywnZGlzcGxheTpub25lOycpO1xuXHRcdFx0XHR1c2VyQWdlbnQucG9ydHJhaXQgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRhcHBTdGF0ZSA9IFNUQVRFX0FTUEVDVF9SQVRJTztcblx0XHRydW5TdGF0ZSgpO1xuXHR9XG5cdFxuXHRmdW5jdGlvbiBzZXRBc3BlY3RSYXRpbygpe1xuXHRcdFxuXHRcdC8vaWYgbm90IG9uIG1vYmlsZSwgc2V0IHRoZSBjYW52YXMgcmF0aW8gdG8gNjAwIGJ5IDQ4MFxuXHRcdGlmKCF1c2VyQWdlbnQubW9iaWxlKXtcblx0XHRcdG1haW5DYW52YXMud2lkdGggPSA2MDA7XG5cdFx0XHRtYWluQ2FudmFzLmhlaWdodCA9IDQ4MDtcblx0XHRcdGNlbnRlclggPSBtYWluQ2FudmFzLndpZHRoLzI7XG5cdCAgICAgICAgY2VudGVyWSA9IG1haW5DYW52YXMuaGVpZ2h0LzI7XG5cdFx0fWVsc2V7XG4gICAgICAgICAgICBjZW50ZXJYID0gbWFpbkNhbnZhcy53aWR0aC8yO1xuXHQgICAgICAgIGNlbnRlclkgPSBtYWluQ2FudmFzLmhlaWdodC8yO1xuXHRcdFx0bWFpbkNhbnZhcy5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgJ3dpZHRoOiAxMDAlOyBoZWlnaHQ6IDEwMCUnKTtcblx0XHRcdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIG9uVG91Y2hNb3ZlLCBmYWxzZSk7XG5cdFx0XHRpbnRlcmZhY2VXcmFwcGVyLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCAnbWFyZ2luOiBhdXRvOycpO1xuXHRcdH0gICAgICAgIFxuXHRcdFxuXHRcdGxvb3BPbiA9IHRydWU7XG5cdFx0YXBwU3RhdGUgPSBTVEFURV9JTklUO1xuXHRcdGdhbWVMb29wKCk7XG5cdFx0XG5cdH1cblx0XG5cdGZ1bmN0aW9uIGxvYWRBc3NldHMoKXtcbiAgICAgICAgXG4gICAgICAgIC8vY2hhbmdlIGFwcCBzdGF0ZVxuXHRcdGFwcFN0YXRlID0gU1RBVEVfTE9BRElORztcblx0ICAgIFxuXHRcdC8vc291bmRzIDUgc291bmRzXG5cdFx0c291bmRUcmFjayA9IG5ldyBIb3dsKHtcbiAgICAgICAgICAgICAgICAgICAgc3JjOiBbJ2Fzc2V0cy9zb3VuZHMvc291bmR0cmFjay5tcDMnLCdhc3NldHMvc291bmRzL3NvdW5kdHJhY2sud2F2J10sXG4gICAgICAgICAgICAgICAgICAgIHZvbHVtZTogMC41LFxuICAgICAgICAgICAgICAgICAgICBsb29wOiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cblx0XHRcbiAgICAgICAgZmluYWxMZXZlbFNvdW5kID0gbmV3IEhvd2woe1xuICAgICAgICAgICAgICAgICAgICAgc3JjOiBbJ2Fzc2V0cy9zb3VuZHMvZmluYWxMZXZlbFNvdW5kLm1wMycsJ2Fzc2V0cy9zb3VuZHMvZmluYWxMZXZlbFNvdW5kLndhdiddLFxuICAgICAgICAgICAgICAgICAgICAgdm9sdW1lOiAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdFxuICAgICAgICBtZXRlb3JFeHBsb3Npb25Tb3VuZCA9IG5ldyBIb3dsKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNyYzogWydhc3NldHMvc291bmRzL21ldGVvckV4cGxvc2lvbi5tcDMnLCdhc3NldHMvc291bmRzL21ldGVvckV4cGxvc2lvbi53YXYnXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZvbHVtZTogMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICBwbGF5ZXJTaG9vdFNvdW5kID0gbmV3IEhvd2woe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3JjOiBbJ2Fzc2V0cy9zb3VuZHMvc2hvb3QubXAzJywnYXNzZXRzL3NvdW5kcy9zaG9vdC53YXYnXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZvbHVtZTogMC4zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIGV4cGxvc2lvblNvdW5kID0gbmV3IEhvd2woe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3JjOiBbJ2Fzc2V0cy9zb3VuZHMvZXhwbG9zaW9uLm1wMycsJ2Fzc2V0cy9zb3VuZHMvZXhwbG9zaW9uLndhdiddLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdm9sdW1lOiAwLjIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgcGVya1NvdW5kID0gbmV3IEhvd2woe1xuICAgICAgICAgICAgICAgICAgICBzcmM6IFsnYXNzZXRzL3NvdW5kcy9wZXJrLm1wMycsJ2Fzc2V0cy9zb3VuZHMvcGVyay53YXYnXSxcbiAgICAgICAgICAgICAgICAgICAgdm9sdW1lOiAxLjAsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0XHRcbiAgICAgICAgdmljdG9yeVNvdW5kID0gbmV3IEhvd2woe1xuICAgICAgICAgICAgICAgICAgICBzcmM6IFsnYXNzZXRzL3NvdW5kcy92aWN0b3J5Lm1wMycsJ2Fzc2V0cy9zb3VuZHMvdmljdG9yeS53YXYnXSxcbiAgICAgICAgICAgICAgICAgICAgdm9sdW1lOiAxLjAsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgZ2FtZU92ZXJTb3VuZCA9IG5ldyBIb3dsKHtcbiAgICAgICAgICAgICAgICAgICAgc3JjOiBbJ2Fzc2V0cy9zb3VuZHMvZ2FtZW92ZXIubXAzJywnYXNzZXRzL3NvdW5kcy9nYW1lb3Zlci53YXYnXSxcbiAgICAgICAgICAgICAgICAgICAgdm9sdW1lOiAxLjAsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgXG5cdFx0UmVzb3VyY2VMb2FkZXIuaW5pdChsb2FkZXJPcHRpb25zKTtcblx0XHRSZXNvdXJjZUxvYWRlci5kb3dubG9hZEFsbCgpO1xuXHRcbiAgICAgICAgLy9oaWRlcyBwcmVsb2FkIGltYWdlXG4gICAgICAgIHByZWxvYWRJbWFnZS5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgJ2Rpc3BsYXk6bm9uZTsnKTtcbiAgICAgICAgXG5cdH1cblx0XG5cdGZ1bmN0aW9uIGluaXRBc3NldHMoKXtcbiAgICAgICAgXG4gICAgICAgIGJhY2tncm91bmQuc2V0Q2FudmFzKG1haW5DYW52YXMpO1xuXHRcdGJhY2tncm91bmQuaW5pdCgxMDAwLCA0ODApO1xuXHRcdGJhY2tncm91bmQudmVsWCA9IDE7XG4gICAgICAgIFxuICAgICAgICBwZXJrc1Bvb2wuaW5pdChcInBlcmtzXCIpO1xuICAgICAgICBtZXRlb3JQb29sLmluaXQoXCJyb2Nrc1wiKTtcbiAgICAgICAgZW5lbXlTaGlwc1Bvb2wuaW5pdCgnZW5lbXknKTtcbiAgICAgICAgXG4gICAgICAgIGFsaWVuTW90aGVyc2hpcC5zZXRDYW52YXMobWFpbkNhbnZhcyk7XG4gICAgICAgIGFsaWVuTW90aGVyc2hpcC5pbml0KCdhbGllbicpO1xuICAgICAgXG4gICAgICAgIFxuICAgICAgICBcblxuICAgICAgICBwbGF5ZXJTaGlwLnNldENhbnZhcyhtYWluQ2FudmFzKTtcbiAgICAgICAgcGxheWVyU2hpcC5pbml0KDIzLCAyMyk7XG4gICAgICAgIHBsYXllclNoaXAuc3Bhd24oY2VudGVyWCwgY2VudGVyWSk7XG4gICAgICAgIFxuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgb25Nb3VzZU1vdmUsIGZhbHNlKTtcbiAgICAgICAgZ2FtZUludGVyZmFjZS5hZGRCdXR0b25MaXN0ZW5lcnMoKTtcblxuXHRcdHVzZXJBZ2VudC5tb2JpbGUgPSBmYWxzZTtcbiAgICAgICAgXG4gICAgXG4gICAgICAgIGlmKHVzZXJBZ2VudC5tb2JpbGUpe1xuXHRcdFx0Ly9hZGQgZ2FtZSBjb250cm9scyBmb3IgbW9iaWxlIGRldmljZXMgYmFzZWQgb24gbW90aW9uXG5cdFx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCBvblRvdWNoRW5kSGFuZGxlciwgZmFsc2UpO1xuXHRcdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2RldmljZW1vdGlvbicsIGRldk1vdGlvbkhhbmRsZXIsIGZhbHNlKTtcblx0XHRcdC8vYWRkcyBsaXN0ZW5lciBmb3IgdG91Y2ggbW92ZSB0byByZW1vdmUgdGhlIGRlZmF1bHQgYmVoYXZpb3Jcblx0XHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0Jywgb25Ub3VjaFN0YXJ0LCBmYWxzZSk7XG5cdFx0XHRcblx0XHR9ZWxzZXtcblx0XHRcdC8vYWRkIGdhbWUgY29udHJvbCBmb3IgZGVza3RvcCBiYXNlZCBvbiBrZXlib2FyZCBldmVudHNcblx0XHRcdGtleWJvYXJkQ29udHJvbC5pbml0KHBsYXllclNoaXApO1xuXHRcdH1cblx0XHRcbiAgICAgICAgZ2FtZUludGVyZmFjZS5kaXNwbGF5KCdzdG9yeUxpbmUnKTtcblx0XHRhcHBTdGF0ZSA9IFNUQVRFX1NUT1JZX0xJTkU7XG5cdFx0XG5cdH1cbiAgICBcbiAgICBcbiAgICAvL2Z1bmN0aW9uIGluIGNoYXJnZWQgb2YgcGxheWluZyB0aGUgc3RvcnkgbGluZVxuICAgIGZ1bmN0aW9uIHN0b3J5TGluZSgpe1xuICAgICAgICBcbiAgICAgICAgYmFja2dyb3VuZC5kcmF3KCk7IFxuICAgIH1cblx0XG5cdGZ1bmN0aW9uIGludHJvQW5pbWF0aW9uKCl7XG4gICAgICAgIFxuICAgICAgICBcbiAgICAgICAgXG5cdFx0YmFja2dyb3VuZC5kcmF3KCk7XG5cdFx0bWFpbkNvbnRleHQuZHJhd0ltYWdlKFJlc291cmNlTG9hZGVyLmFzc2V0cy5lYXJ0aFNwcml0ZSwgKG1haW5DYW52YXMud2lkdGgvMi0oUmVzb3VyY2VMb2FkZXIuYXNzZXRzLmVhcnRoU3ByaXRlLndpZHRoLzIpKSwgMCk7XG4gICAgICAgIGZvcih2YXIgaT0wOyBpPDc7IGkrKyl7XG4gICAgICAgICAgICB2YXIgY3VycmVudEVuZW15ID0gZW5lbXlTaGlwc1Bvb2wucG9vbFtpXTtcbiAgICAgICAgICAgIGN1cnJlbnRFbmVteS5kcmF3KCk7XG4gICAgICAgICAgICBjdXJyZW50RW5lbXkuZm9sbG93KG1vdXNlKTtcbiAgICAgICAgICAgIGNoZWNrQm91bmRhcnkoY3VycmVudEVuZW15KTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgXG4gICAgICAgIFxuICAgICAgICBcblx0fVxuICAgIFxuICAgIGZ1bmN0aW9uIGhvd1RvUGxheSgpe1xuICAgICAgICBcbiAgICB9XG4gICAgXG4gICAgLy9mdW5jdGlvbiBpbiBjaGFyZ2VkIG9mIHNldHRpbmcgdXAgdGhlIGVuZW1pZXMgYW5kIHJvY2tzIGluIHRoZSBuZXcgbGV2ZWwgZ2l2ZW4gdGhlIGN1cnJlbnQgbGV2ZWxcbiAgICBmdW5jdGlvbiBzZXRVcExldmVsKCl7XG4gICAgICAgIFxuICAgICAgICBcbiAgICAgICAgXG4gICAgICAgIGNvbnNvbGUubG9nKCdTZXQgVXAgTGV2ZWwgZnVuY3Rpb24gQ0FMTEVEJyk7XG4gICAgICAgIFxuICAgICAgICBcbiAgICAgICAgLy9zZXRzIHVwIHJhbmRvbSBsb2NhdGlvbiBmb3Igcm9ja3MgYW5kIG1vdGhlcnNoaXBcbiAgICAgICAgICAgIHZhciByYW5kb21YLCByYW5kb21ZO1xuICAgICAgICBcbiAgICAgICAgLy9pbmNyZWFzZXMgbGV2ZWwgYnkgMVxuICAgICAgICBjdXJyZW50TGV2ZWwgKz0gMTtcbiAgICAgICAgXG4gICAgICAgIC8vY2hlY2tzIGlmIGdhbWUgaXMgb3ZlclxuICAgICAgICBpZihjdXJyZW50TGV2ZWwgPiBsYXN0TGV2ZWwpe1xuICAgICAgICAgICAgdXNlckJlYXRHYW1lID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAgICBcbiAgICAgICAgaWYoY3VycmVudExldmVsID09IGxhc3RMZXZlbCl7XG4gICAgICAgICAgICBmaW5hbExldmVsU291bmQucGxheSgpO1xuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgIC8vYmVnaW5zIG5vcm1hbCBzb3VuZHRyYWNrIFxuXHRcdCAgIHNvdW5kVHJhY2sucGxheSgpO1xuICAgICAgICB9XG5cdFx0XG4gICAgICAgIC8vcmVzZXRzIGVuZW15IGtpbGxlZCBhbmQgcm9ja3MgZGVzdHJveWVkIGNvdW50ZXIgYW5kIHNoaXAgbGl2ZXNcbiAgICAgICAgZW5lbWllc0tpbGxlZCA9IDA7XG4gICAgICAgIHJvY2tzRGVzdHJveWVkID0gMDtcbiAgICAgICAgaWYoY3VycmVudExldmVsID09IDEpe1xuICAgICAgICBzaGlwTGl2ZXMgPSA0O1xuICAgICAgICB9XG4gICAgICAgIC8vc2V0cyB1cCBudW1iZXIgb2Ygcm9ja3MgYW5kIGVuZW1pZXMgdGhhdCB3aWxsIGJlIGRpc3BsYXllZFxuICAgICAgICBsZXZlbEVuZW1pZXMgPSBjdXJyZW50TGV2ZWwrMTtcbiAgICAgICAgbGV2ZWxSb2NrcyA9IGN1cnJlbnRMZXZlbCsyO1xuICAgICAgICBcbiAgICAgICAgLy9jaGVja3MgdG8gc2VlIGlmIHRoZSBsZXZlbCByb2NrcyBhbmQgZW5lbWllcyBleGNlZWQgdG90YWwgaW4gcG9vbC5cbiAgICAgICAgbGV2ZWxFbmVtaWVzID0gKGxldmVsRW5lbWllcz49dG90YWxFbmVtaWVzKT8gdG90YWxFbmVtaWVzIDogbGV2ZWxFbmVtaWVzO1xuICAgICAgICBsZXZlbFJvY2tzID0gKGxldmVsUm9ja3M+PXRvdGFsUm9ja3MpPyB0b3RhbFJvY2tzIDogbGV2ZWxSb2NrcztcbiAgICAgICAgXG4gICAgICAgIC8vY2VudGVycyBzaGlwIGFuZCBoaWRlIGFsbCBvZiBpdHMgbWlzc2lsZXNcbiAgICAgICAgcGxheWVyU2hpcC5zcGF3bihjZW50ZXJYLCBjZW50ZXJZKTtcbiAgICAgICAgXG4gICAgICAgIC8va2lsbCBvZmYgYW55IGFsaXZlIHJvY2tzIGFuZCBlbmVtaWVzXG4gICAgICAgIHBlcmtzUG9vbC5oaWRlSXRlbXMoKTtcbiAgICAgICAgZW5lbXlTaGlwc1Bvb2wuaGlkZUl0ZW1zKCk7XG4gICAgICAgIG1ldGVvclBvb2wuaGlkZUl0ZW1zKCk7XG4gICAgICAgIFxuICAgICAgICAvL2luaXRzIHRoZSByb2Nrc1xuICAgICAgICBmb3IodmFyIGk9MDsgaTxsZXZlbFJvY2tzOyBpKyspe1xuICAgICAgICAgICAgcmFuZG9tWCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSoobWFpbkNhbnZhcy53aWR0aC01MCkpLFxuICAgICAgICAgICAgcmFuZG9tWSA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSoobWFpbkNhbnZhcy5oZWlnaHQtNTApKTtcbiAgICAgICAgICAgIG1ldGVvclBvb2wuZ2V0KHJhbmRvbVgsIHJhbmRvbVksIFwibGFyZ2VSb2NrXCIpO1xuICAgICAgICAgICAgbWV0ZW9yUG9vbC5nZXQocmFuZG9tWCwgcmFuZG9tWSwgXCJzbWFsbFJvY2tcIik7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGZvcih2YXIgaD0wOyBoPGxldmVsUGVya3M7IGgrKyl7XG4gICAgICAgICAgICByYW5kb21YID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpKihtYWluQ2FudmFzLndpZHRoLTUwKSksXG4gICAgICAgICAgICByYW5kb21ZID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpKihtYWluQ2FudmFzLmhlaWdodC01MCkpO1xuICAgICAgICAgICAgcGVya3NQb29sLmdldChyYW5kb21YLCByYW5kb21ZLCBcImxpZmVcIik7XG4gICAgICAgICAgICBwZXJrc1Bvb2wuZ2V0KHJhbmRvbVksIHJhbmRvbVgsIFwic2hpZWxkXCIpO1xuICAgICAgICB9XG4gICAgXG4gICAgICAgIC8vYWxpZW5Nb3RoZXJzaGlwLmluaXQoXCJhbGllblwiKTtcbiAgICAgICAgYWxpZW5Nb3RoZXJzaGlwLnNwYXduKHJhbmRvbVgsIHJhbmRvbVkpO1xuICAgICAgICBhbGllbk1vdGhlcnNoaXAuc2hpZWxkLmFjdGl2ZSA9IHRydWU7XG4gICAgICAgIGFsaWVuTW90aGVyc2hpcC5zZXRSZWxlYXNlKGxldmVsRW5lbWllcywgOCk7XG4gICAgICAgIFxuICAgICAgICB1cGRhdGVDb3VudGVyKCdsZXZlbCcpO1xuICAgICAgICB1cGRhdGVDb3VudGVyKCdsaWZlJyk7XG4gICAgICAgIHVwZGF0ZUNvdW50ZXIoJ3Njb3JlJyk7XG4gICAgICAgIFxuICAgIH1cblx0XG5cdC8vdGVtcCBjb2RlXG5cdFxuXHRmdW5jdGlvbiBoYW5kbGVTdWIoZXZlbnQsIGRhdGEpe1xuXHRcdHdpbmRvdy5hbGVydChcIlRoZSBnYW1lIHN0YXRlIGhhcyBjaGFuZ2VkIHRvIDogXCIgKyBkYXRhKTtcblx0fVxuXHRcblx0ZnVuY3Rpb24gaGFuZGxlU3ViVHdvKGV2ZW50LCBkYXRhKXtcblx0XHRjb25zb2xlLmxvZyhcInRoZSBnYW1lIHN0YXRlIGhhcyBjaGFuZ2VkIHRvIDogXCIgKyBkYXRhKTtcblx0fVxuXHRcblx0XG5cdFxuXHRcblx0XG5cblx0Ly9vbmNlIHRoZSB1c2VyIGhhcyBjbGlja2VkIHRoZSBzdGFydCBidXR0b24sIHRoaXMgZnVuY3Rpb24gZHJhd3MgdGhlIGdhbWVcblx0ZnVuY3Rpb24gZHJhd0NhbnZhcygpe1xuICAgICAgICBcbiAgICAgICAgYmFja2dyb3VuZC5kcmF3KCk7XG5cbiAgICAgICAgaWYoYWxpZW5Nb3RoZXJzaGlwLmFsaXZlKXtcbiAgICAgICAgYWxpZW5Nb3RoZXJzaGlwLmRyYXcoKTtcbiAgICAgICAgY2hlY2tCb3VuZGFyeShhbGllbk1vdGhlcnNoaXApO1xuICAgICAgICBhbGllbk1vdGhlcnNoaXAuZm9sbG93KHBsYXllclNoaXApO1xuICAgICAgICBhbGllbk1vdGhlcnNoaXAuYXR0YWNrKHBsYXllclNoaXApO1xuICAgICAgICBhbGllbk1vdGhlcnNoaXAubWlzc2lsZXMuaXNDb2xsaWRpbmdXaXRoKHBsYXllclNoaXAsIHBsYXllclNoaXAuc2hpZWxkKTtcbiAgICAgICAgcGxheWVyU2hpcC5taXNzaWxlcy5pc0NvbGxpZGluZ1dpdGgoYWxpZW5Nb3RoZXJzaGlwLCBhbGllbk1vdGhlcnNoaXAuc2hpZWxkKTtcbiAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IodmFyIG09MDsgbTxwZXJrc1Bvb2wucG9vbC5sZW5ndGg7IG0rKyl7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjdXJyZW50UGVyayA9IHBlcmtzUG9vbC5wb29sW21dO1xuICAgICAgICAgICAgICAgICAgICBpZihjdXJyZW50UGVyay5hbGl2ZSl7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50UGVyay5kcmF3KCk7IFxuICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihoaXRUZXN0KGN1cnJlbnRQZXJrLCBwbGF5ZXJTaGlwKSl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0RFVEVDVElPTiBDT05GSVJNRUQhIScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGN1cnJlbnRQZXJrKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhwbGF5ZXJTaGlwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50UGVyay5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjb3JkQ29sbGlzaW9uKGN1cnJlbnRQZXJrLnR5cGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaTxtZXRlb3JQb29sLnBvb2wubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICBcbiAgICAgICAgICAgIHZhciBjdXJyZW50TWV0ZW9yID0gbWV0ZW9yUG9vbC5wb29sW2ldO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZihjdXJyZW50TWV0ZW9yLmFsaXZlKXtcbiAgICAgICAgICAgICAgICBjdXJyZW50TWV0ZW9yLmRyYXcoKTtcbiAgICAgICAgICAgICAgICBjaGVja0JvdW5kYXJ5KGN1cnJlbnRNZXRlb3IpO1xuICAgICAgICAgICAgICAgIHBsYXllclNoaXAubWlzc2lsZXMuaXNDb2xsaWRpbmdXaXRoKGN1cnJlbnRNZXRlb3IpO1xuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgZW5lbXlTaGlwc1Bvb2wucG9vbC5mb3JFYWNoKGZ1bmN0aW9uKGVuZW15KXtcbiAgICAgICAgICAgICAgICAgICAgZW5lbXkubWlzc2lsZXMuaXNDb2xsaWRpbmdXaXRoKGN1cnJlbnRNZXRlb3IpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIG1ldGVvclBvb2wuaXNDb2xsaWRpbmdXaXRoKHBsYXllclNoaXAsIHBsYXllclNoaXAuc2hpZWxkKTtcbiAgICAgICAgXG4gICAgICAgIGZvcih2YXIgaCA9IDA7IGg8ZW5lbXlTaGlwc1Bvb2wucG9vbC5sZW5ndGg7IGgrKyl7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHZhciBjdXJyZW50RW5lbXkgPSBlbmVteVNoaXBzUG9vbC5wb29sW2hdO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZihjdXJyZW50RW5lbXkuYWxpdmUpe1xuICAgICAgICAgICAgICAgIGN1cnJlbnRFbmVteS5kcmF3KCk7XG4gICAgICAgICAgICAgICAgY2hlY2tCb3VuZGFyeShjdXJyZW50RW5lbXkpO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRFbmVteS5mb2xsb3cocGxheWVyU2hpcCk7XG4gICAgICAgICAgICAgICAgY3VycmVudEVuZW15LmF0dGFjayhwbGF5ZXJTaGlwKTtcbiAgICAgICAgICAgICAgICBjdXJyZW50RW5lbXkubWlzc2lsZXMuaXNDb2xsaWRpbmdXaXRoKHBsYXllclNoaXAsIHBsYXllclNoaXAuc2hpZWxkLCBtZXRlb3JQb29sLnBvb2wpO1xuICAgICAgICAgICAgICAgIHBsYXllclNoaXAubWlzc2lsZXMuaXNDb2xsaWRpbmdXaXRoKGN1cnJlbnRFbmVteSwgY3VycmVudEVuZW15LnNoaWVsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgfVxuXG4gICAgICAgIC8vY291bnRzIGFjdHVhbCBmcmFtZXNcblx0XHRmcmFtZVJhdGUuY291bnRGcmFtZXMoKTtcbiAgICAgICAgXG4gICAgICAgIC8vaGlkZSBkZWJ1Z2dpbmcgZnJhbWUgY291bnRlciBvbiBmaW5hbCB2ZXJzaW9uc1xuXHRcdGZyYW1lUmF0ZUNvdW50ZXIuaW5uZXJIVE1MID0gXCJGcmFtZXM6IFwiK2ZyYW1lUmF0ZS5sYXN0RnJhbWVDb3VudDtcbiAgICAgICAgZnJhbWVSYXRlQ291bnRlci5pbm5lckhUTUwgPSBcIlwiO1xuICAgICAgICBcblx0XHRcbiAgICAgICAgaWYocGxheWVyU2hpcC5hbGl2ZSl7XG5cdFx0XHRrZXlib2FyZENvbnRyb2wudXBkYXRlKCk7XG4gICAgICAgICAgICBjaGVja0JvdW5kYXJ5KHBsYXllclNoaXApO1xuICAgICAgICAgICAgcGxheWVyU2hpcC5kcmF3KCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIFxuICAgICAgICBpZihzaGlwTGl2ZXMgPD0gMCAmJiAhcGxheWVyU2hpcC5jb2xsaWRpbmcgJiYgYXBwU3RhdGUgPT0gU1RBVEVfUExBWUlORyl7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgaWYoY3VycmVudExldmVsID09IGxhc3RMZXZlbCl7XG5cdFx0XHRcdFx0XHRmaW5hbExldmVsU291bmQuc3RvcCgpO1xuXHRcdFx0XHRcdH1lbHNle1xuXHRcdFx0XHRcdFx0c291bmRUcmFjay5zdG9wKCk7IFxuXHRcdFx0XHRcdH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGN1cnJlbnRMZXZlbCA9IDA7XG4gICAgICAgICAgICAgICAgYXBwU3RhdGUgPSBTVEFURV9HQU1FX09WRVI7XG4gICAgICAgICAgICBcbiAgICAgICAgfWVsc2UgaWYobGV2ZWxFbmVtaWVzIDw9IDAgJiYgIXBsYXllclNoaXAuY29sbGlkaW5nICYmIHBsYXllclNoaXAuYWxpdmUgJiYgYXBwU3RhdGUgPT0gU1RBVEVfUExBWUlORyl7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgaWYoY3VycmVudExldmVsID09IGxhc3RMZXZlbCl7XG5cdFx0XHRcdFx0XHRmaW5hbExldmVsU291bmQuc3RvcCgpO1xuXHRcdFx0XHRcdH1lbHNle1xuXHRcdFx0XHRcdFx0c291bmRUcmFjay5zdG9wKCk7IFxuXHRcdFx0XHRcdH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgcGxheWVyU2hpcC5hbmdsZSA9IHBsYXllclNoaXAudmVsWSA9IHBsYXllclNoaXAudmVsWCA9IDA7XG4gICAgICAgICAgICBwbGF5ZXJTaGlwLnZlbFggPSAxO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBnYW1lSW50ZXJmYWNlLmhpZGUoJ2dhbWVQbGF5Jyk7XG4gICAgICAgICAgICB1cGRhdGVDb3VudGVyKCdsZXZlbCcpO1xuICAgICAgICAgICAgYXBwU3RhdGUgPSBTVEFURV9MRVZFTF9UUkFOU0lUSU9OO1xuXG4gICAgICAgIH1cbiAgICBcblx0fVxuICAgIFxuICAgIC8vZnVuY3Rpb24gaW4gY2hhcmdlZCBvZiB0cmFuc2l0aW9uIGxldmVsXG4gICAgZnVuY3Rpb24gbmV4dExldmVsRGlhbG9nKCl7XG4gICAgICAgIFxuICAgICAgICBhcHBTdGF0ZSA9IFNUQVRFX1dBSVRJTkc7XG4gICAgICAgIFxuICAgICAgICByZXBvcnRFbmVtaWVzS2lsbGVkLmlubmVySFRNTCA9IFwiRW5lbWllcyBLaWxsZWQ6IFwiK2VuZW1pZXNLaWxsZWQ7XG4gICAgICAgIHJlcG9ydFJvY2tzRGVzdHJveWVkLmlubmVySFRNTCA9IFwiQXN0ZXJvaWRzIERlc3Ryb3llZDogXCIrcm9ja3NEZXN0cm95ZWQ7XG4gICAgICAgIHJlcG9ydFNjb3JlLmlubmVySFRNTCA9IFwiU2NvcmU6IFwiK2N1cnJlbnRTY29yZTtcbiAgICAgICAgXG4gICAgICAgIGdhbWVJbnRlcmZhY2UuaGlkZSgnZ2FtZVBsYXknKTtcbiAgICAgICAgZ2FtZUludGVyZmFjZS5kaXNwbGF5KCduZXh0TGV2ZWwnKTtcbiAgICAgICAgXG4gICAgfVxuICAgIFxuICAgIGZ1bmN0aW9uIHRyYW5zTGV2ZWxBbmltYXRpb24oKXtcbiAgICAgICAgXG4gICAgICAgIC8vZHJhdyBiYWNrZ3JvdW5kXG4gICAgICAgIGJhY2tncm91bmQuZHJhdygpO1xuICAgICAgICBcbiAgICAgICAgLy9kcmF3UmVtYWluaW5nIHJvY2tzXG4gICAgICAgIGZvcih2YXIgaz0wOyBrPG1ldGVvclBvb2wucG9vbC5sZW5ndGg7IGsrKyl7XG4gICAgICAgICAgICB2YXIgY3VycmVudFJvY2sgPSBtZXRlb3JQb29sLnBvb2xba107XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vaWYgcm9jayBhbGl2ZSBkcmF3IGl0XG4gICAgICAgICAgICBpZihjdXJyZW50Um9jay5hbGl2ZSl7XG4gICAgICAgICAgICBjaGVja0JvdW5kYXJ5KGN1cnJlbnRSb2NrKTtcbiAgICAgICAgICAgIGN1cnJlbnRSb2NrLmRyYXcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgZW5lbXlTaGlwc1Bvb2wucG9vbC5mb3JFYWNoKGZ1bmN0aW9uKGVuZW15KXtcbiAgICAgICAgICAgIGlmKGVuZW15LmFsaXZlKXtcbiAgICAgICAgICAgICAgICBlbmVteS5kcmF3KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgcGxheWVyU2hpcC52ZWxYICs9IHBsYXllclNoaXAudmVsWCpwbGF5ZXJTaGlwLmVhc2VWYWx1ZTtcbiAgICAgICAgcGxheWVyU2hpcC5kcmF3KCk7XG4gICAgICAgIFxuICAgICAgICBjb25zb2xlLmxvZyhwbGF5ZXJTaGlwLnZlbFgpO1xuICAgICAgICBcbiAgICAgICAgXG4gICAgICAgIGlmKHBsYXllclNoaXAueCA+PSAxMDIwLXBsYXllclNoaXAud2lkdGgpe1xuICAgICAgICAgICAgYXBwU3RhdGUgPSBTVEFURV9ORVhUX0xFVkVMOyAgIFxuICAgICAgICB9XG4gICAgICAgIFxuICAgIH1cbiAgICBcbiAgICBmdW5jdGlvbiBiZWF0R2FtZSgpe1xuICAgICAgICBhcHBTdGF0ZSA9IFNUQVRFX1dBSVRJTkc7XG5cdFx0XG4gICAgICAgIC8vb3V0cHV0cyB0aGUgZmluYWwgc2NvcmUgdG8gdGhlIHdpbm5lciBnYW1lciA6KVxuICAgICAgICBmaW5hbExldmVsU291bmQuc3RvcCgpOyAgICAgICBcbiAgICAgICAgYmVhdEdhbWVTY29yZS5pbm5lckhUTUwgPSBcIllvdXIgU2NvcmU6IFwiK2N1cnJlbnRTY29yZTtcbiAgICAgICAgdXNlckJlYXRHYW1lID0gZmFsc2U7XG4gICAgICAgIGdhbWVJbnRlcmZhY2UuaGlkZSgnZ2FtZVBsYXknKTtcbiAgICAgICAgZ2FtZUludGVyZmFjZS5kaXNwbGF5KCdiZWF0R2FtZScpOyBcbiAgICAgICAgdmljdG9yeVNvdW5kLnBsYXkoKTtcbiAgICAgICAgXG4gICAgICAgIC8vcmVzZXRzIHRoYXQgc2NvcmVcbiAgICAgICAgY3VycmVudFNjb3JlID0gMDtcbiAgICAgICAgY3VycmVudExldmVsID0gMDtcbiAgICAgICAgXG4gICAgfVxuXG5cdC8vZnVuY3Rpb24gaW4gY2hhcmdlZCBvZiBlbmRpbmcgdGhlIGdhbWVcblx0ZnVuY3Rpb24gZ2FtZU92ZXIoKXtcbiAgICAgICAgXG4gICAgICAgIC8vY2hhbmdlcyB0aGUgc3RhdGUgdG8gY2FsbCBjb2RlIG9ubHkgb25jZS5cblx0XHRhcHBTdGF0ZSA9IFNUQVRFX1dBSVRJTkc7XG4gICAgICAgIFxuICAgICAgICAvL2NoZWNrcyB0byBzZWUgd2hpY2ggc291bmQgdG8gc3RvcCBwbGF5aW5nIGdpdmVuIHRoZSBsZXZlbCB0aGUgdXNlciB3YXMgYmVmb3JlIGR5aW5nXG5cdFx0Z2FtZU92ZXJTb3VuZC5wbGF5KCk7XG4gICAgICAgIFxuICAgICAgICAvL3Jlc2V0cyB0aGUgc2NvcmUgYW5kIGxldmVsXG4gICAgICAgIGN1cnJlbnRMZXZlbCA9IDA7XG4gICAgICAgIGN1cnJlbnRTY29yZSA9IDA7XG5cbiAgICAgICAgLy9kaXNwbGF5cyB0aGUgYXBwcm9wcmlhdGUgaW50ZXJmYWNlXG4gICAgICAgIGdhbWVJbnRlcmZhY2UuaGlkZSgnZ2FtZVBsYXknKTtcbiAgICAgICAgZ2FtZUludGVyZmFjZS5kaXNwbGF5KCdnYW1lT3ZlcicpO1xuICAgICAgICBcblx0fVxuXHRcblx0XG5cdC8vY2hlY2tzIGlmIGFuIG9iamVjdCBoYXMgbGVmdCB0aGUgY2FudmFzIGJvdWRpbmcgYm94XG5cdGZ1bmN0aW9uIGNoZWNrQm91bmRhcnkob2JqZWN0KXtcblxuXHRcdGlmKG9iamVjdC54ID49IG9iamVjdC5jYW52YXNXaWR0aCl7XG5cdFx0XHRvYmplY3QueCA9IDA7XG5cdFx0fWVsc2UgaWYob2JqZWN0LnggPD0gLW9iamVjdC53aWR0aCl7XG5cdFx0XHRvYmplY3QueCA9IG9iamVjdC5jYW52YXNXaWR0aC1vYmplY3Qud2lkdGg7XG5cdFx0fWVsc2UgaWYob2JqZWN0LnkgPj0gb2JqZWN0LmNhbnZhc0hlaWdodCtvYmplY3QuaGVpZ2h0KXtcblx0XHRcdG9iamVjdC55ID0gMDtcblx0XHR9ZWxzZSBpZihvYmplY3QueSA8PSAtb2JqZWN0LmhlaWdodCl7XG5cdFx0XHRvYmplY3QueSA9IG9iamVjdC5jYW52YXNIZWlnaHQtb2JqZWN0LmhlaWdodDtcblx0XHR9XHRcblx0fVxuXHRcblx0Ly9jb2xsaXNpb24gZGV0ZWN0aW9uLlxuXHRmdW5jdGlvbiBoaXRUZXN0KG9iamVjdDEsIG9iamVjdDIpe1xuICAgXHRcdHZhciBsZWZ0MSA9IG9iamVjdDEueDtcbiAgIFx0XHR2YXIgbGVmdDIgPSBvYmplY3QyLng7XG4gICBcdFx0dmFyIHJpZ2h0MSA9IG9iamVjdDEueCArIG9iamVjdDEud2lkdGg7XG4gICBcdFx0dmFyIHJpZ2h0MiA9IG9iamVjdDIueCArIG9iamVjdDIud2lkdGg7XG4gICBcdFx0dmFyIHRvcDEgPSBvYmplY3QxLnk7XG4gICBcdFx0dmFyIHRvcDIgPSBvYmplY3QyLnk7XG4gICBcdFx0dmFyIGJvdHRvbTEgPSBvYmplY3QxLnkgKyBvYmplY3QxLmhlaWdodDtcbiAgIFx0XHR2YXIgYm90dG9tMiA9IG9iamVjdDIueSArIG9iamVjdDIuaGVpZ2h0O1xuXG4gICBcdFx0aWYgKGJvdHRvbTEgPCB0b3AyKSByZXR1cm4oZmFsc2UpO1xuICAgXHRcdGlmICh0b3AxID4gYm90dG9tMikgcmV0dXJuKGZhbHNlKTtcbiAgIFx0XHRpZiAocmlnaHQxIDwgbGVmdDIpIHJldHVybihmYWxzZSk7XG4gICBcdFx0aWYgKGxlZnQxID4gcmlnaHQyKSByZXR1cm4oZmFsc2UpO1xuICAgICAgICBpZiAoIW9iamVjdDEuYWxpdmUgfHwgb2JqZWN0MS5jb2xsaWRpbmcgfHwgb2JqZWN0Mi5jb2xsaWRpbmcgfHwgIW9iamVjdDIuYWxpdmUpIHJldHVybihmYWxzZSk7XG4gICAgICAgIFxuICAgICAgICBpZiAob2JqZWN0MS50eXBlID09IFwiaHVtYW5TaGlwXCIgJiYgb2JqZWN0MS52ZWxYID09IDApIHJldHVybihmYWxzZSk7XG4gICAgICAgIGlmIChvYmplY3QyLnR5cGUgPT0gXCJodW1hblNoaXBcIiAmJiBvYmplY3QyLnZlbFggPT0gMCkgcmV0dXJuKGZhbHNlKTtcbiAgICAgICAgXG4gICAgICAgIGlmKG9iamVjdDIgaW5zdGFuY2VvZiBTcGFjZWNyYWZ0KXtcbiAgICAgICAgICAgIGlmKG9iamVjdDIuc2hpZWxkLmFjdGl2ZSl7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYob2JqZWN0MSBpbnN0YW5jZW9mIFNwYWNlY3JhZnQpe1xuICAgICAgICAgICAgaWYob2JqZWN0MS5zaGllbGQuYWN0aXZlKXtcbiAgICAgICAgICAgICAgICByZXR1cm4gKGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcblxuICAgICAgICAvL290aGVyd2lzZSByZXR1cm4gdHJ1ZSBcbiAgIFx0XHRyZXR1cm4odHJ1ZSk7XG5cblx0fVxuICAgICAgICBcbiAgICAvL2dhbWUgc2NvcmUgdHJhY2tlclxuICAgIFxuICAgIGZ1bmN0aW9uIHJlY29yZENvbGxpc2lvbihvYmplY3RUeXBlKXtcbiAgICAgICAgc3dpdGNoKG9iamVjdFR5cGUpe1xuICAgICAgICAgICAgY2FzZSBcImxhcmdlUm9ja1wiOlxuICAgICAgICAgICAgICAgIGN1cnJlbnRTY29yZSArPSAyMDtcbiAgICAgICAgICAgICAgICB1cGRhdGVDb3VudGVyKCdzY29yZScpO1xuICAgICAgICAgICAgICAgIHJvY2tzRGVzdHJveWVkKys7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICBjYXNlIFwibWVkaXVtUm9ja1wiOlxuICAgICAgICAgICAgICAgIGN1cnJlbnRTY29yZSArPSAxMDtcbiAgICAgICAgICAgICAgICB1cGRhdGVDb3VudGVyKCdzY29yZScpO1xuICAgICAgICAgICAgICAgIHJvY2tzRGVzdHJveWVkKys7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICBjYXNlIFwic21hbGxSb2NrXCI6XG4gICAgICAgICAgICAgICAgY3VycmVudFNjb3JlICs9IDU7XG4gICAgICAgICAgICAgICAgdXBkYXRlQ291bnRlcignc2NvcmUnKTtcbiAgICAgICAgICAgICAgICByb2Nrc0Rlc3Ryb3llZCsrO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgY2FzZSBcImh1bWFuU2hpcFwiOlxuICAgICAgICAgICAgICAgIHNoaXBMaXZlcy0tO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRTY29yZSAtPSA1MDtcbiAgICAgICAgICAgICAgICB1cGRhdGVDb3VudGVyKCdzY29yZScpO1xuICAgICAgICAgICAgICAgIHVwZGF0ZUNvdW50ZXIoJ2xpZmUnKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIGNhc2UgXCJlbmVteVwiOlxuICAgICAgICAgICAgICAgIGN1cnJlbnRTY29yZSArPSA1MDtcbiAgICAgICAgICAgICAgICB1cGRhdGVDb3VudGVyKCdzY29yZScpO1xuICAgICAgICAgICAgICAgIGxldmVsRW5lbWllcy0tO1xuICAgICAgICAgICAgICAgIGVuZW1pZXNLaWxsZWQrKztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIGNhc2UgXCJsaWZlXCI6XG4gICAgICAgICAgICAgICAgc2hpcExpdmVzKys7XG4gICAgICAgICAgICAgICAgdXBkYXRlQ291bnRlcignbGlmZScpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgY2FzZSBcInNoaWVsZFwiOlxuICAgICAgICAgICAgICAgIHBsYXllclNoaXAuc2hpZWxkLnJlc2V0KCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiY2FzaFwiOlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgIH1cbiAgICBcbiAgICBcblx0Ly91cGRhdGVzIGdhbWUgYm9hcmQsIHNjb3JlcywgbGV2ZWwgZXRjLi5cblx0ZnVuY3Rpb24gdXBkYXRlQ291bnRlcihvYmplY3Qpe1xuXHRcdHN3aXRjaChvYmplY3Qpe1xuXHRcdFx0Y2FzZSBcImxpZmVcIjpcblx0XHRcdFx0bGl2ZXNDb3VudGVyLmlubmVySFRNTCA9IFwiTGl2ZXM6IFwiK3NoaXBMaXZlcztcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIFwic2NvcmVcIjpcblx0XHRcdFx0c2NvcmVDb3VudGVyLmlubmVySFRNTCA9IFwiU2NvcmU6IFwiK2N1cnJlbnRTY29yZTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIFwibGV2ZWxcIjpcblx0XHRcdFx0bGV2ZWxDb3VudGVyLmlubmVySFRNTCA9IFwiTGV2ZWw6IFwiK2N1cnJlbnRMZXZlbDtcblx0XHRcdFx0YnJlYWs7XG5cdFx0fVxuXHR9XG5cdFxuXHQvL2hhbmRsZXMgdGhlIG1vdXNlbW92ZSBpbnRlcmFjdGlvbiBhdCB0aXRsZSBzY3JlZW4uXG5cdGZ1bmN0aW9uIG9uTW91c2VNb3ZlKGV2ZW50KXtcbiAgICAgICAgXG5cdFx0aWYoYXBwU3RhdGUgIT0gU1RBVEVfVElUTEVfU0NSRUVOKXtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBcblx0XHRpZiAoIGV2ZW50LmxheWVyWCB8fCAgZXZlbnQubGF5ZXJYID09IDApIHsgLy8gRmlyZWZveFxuICAgXHRcdFx0bW91c2UueCA9IGV2ZW50LmxheWVyWCA7XG4gICAgXHRcdG1vdXNlLnkgPSBldmVudC5sYXllclk7XG4gIFx0XHR9IGVsc2UgaWYgKGV2ZW50Lm9mZnNldFggfHwgZXZlbnQub2Zmc2V0WCA9PSAwKSB7IC8vIE9wZXJhXG4gICAgXHRcdG1vdXNlLnggPSBldmVudC5vZmZzZXRYO1xuICAgIFx0XHRtb3VzZS55ID0gZXZlbnQub2Zmc2V0WTtcbiAgXHRcdH1cblx0XHRcblx0fVxuXHRcblxuXHRcblx0Ly9DaGVja3MgZm9yIGRldmljZSBvcmllbnRhdGlvblxuXHRmdW5jdGlvbiBvbk9yaWVudGF0aW9uQ2hhbmdlKGUpe1xuXG5cdFx0aWYod2luZG93LmlubmVySGVpZ2h0Pj0gd2luZG93LmlubmVyV2lkdGgpe1xuXHRcdFx0dXNlckFnZW50LnBvcnRyYWl0ID0gdHJ1ZTtcblx0XHRcdG9yaWVudGF0aW9uTWVzc2FnZUhvbGRlci5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgJ2Rpc3BsYXk6IGJsb2NrOycpO1xuXHRcdFx0Y2FudmFzSG9sZGVyLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCAnZGlzcGxheTpub25lOycpO1xuICAgICAgICAgICAgaW50ZXJmYWNlV3JhcHBlci5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgJ2Rpc3BsYXk6IG5vbmU7Jyk7XG5cdFx0fWVsc2UgaWYod2luZG93LmlubmVySGVpZ2h0PD13aW5kb3cuaW5uZXJXaWR0aCl7XG5cdFx0XHRvcmllbnRhdGlvbk1lc3NhZ2VIb2xkZXIuc2V0QXR0cmlidXRlKCdzdHlsZScsICcnKTtcblx0XHRcdGNhbnZhc0hvbGRlci5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgJycpO1xuICAgICAgICAgICAgaW50ZXJmYWNlV3JhcHBlci5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgJycpO1xuXHRcdFx0dXNlckFnZW50LnBvcnRyYWl0ID0gZmFsc2U7XG5cdFx0fVxuXHRcdFxuXHR9XG5cdFxuXHQvL3JlbW92ZXMgdGhlIGRlZmF1bHQgYmVoYXZpb3Igb2YgcGluY2hpbmcgem9vbSBvbiBNb2JpbGVcblx0ZnVuY3Rpb24gb25Ub3VjaE1vdmUoZSl7XG5cdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHR9XG5cdFxuXHQvL3BhdXNlcyB0aGUgZ2FtZSB2aWEgdGhlIHBhdXNlIGJ1dHRvblxuXHRmdW5jdGlvbiBvblBhdXNlQnV0dG9uKGUpe1xuXHRcdGxvb3BPbiA9ICFsb29wT247XG5cdFx0Z2FtZUxvb3AoKTtcblx0fVxuXHRcblx0XG5cdC8vRnJhbVJhdGUgQ2xhc3Ncblx0XG5cdGZ1bmN0aW9uIEZyYW1lUmF0ZUNvdW50ZXIoKSB7XG5cbiAgIHRoaXMubGFzdEZyYW1lQ291bnQgPSAwO1xuICAgdmFyIGRhdGVUZW1wID0gbmV3IERhdGUoKTtcbiAgIHRoaXMuZnJhbWVMYXN0ID0gZGF0ZVRlbXAuZ2V0VGltZSgpO1xuICAgZGVsZXRlIGRhdGVUZW1wO1xuICAgdGhpcy5mcmFtZUN0ciA9IDA7XG4gICAgfVxuXG4gICAgRnJhbWVSYXRlQ291bnRlci5wcm90b3R5cGUuY291bnRGcmFtZXM9ZnVuY3Rpb24oKSB7XG4gICAgICAgdmFyIGRhdGVUZW1wID0gbmV3IERhdGUoKTtcbiAgICAgICB0aGlzLmZyYW1lQ3RyKys7XG5cbiAgICAgICBpZiAoZGF0ZVRlbXAuZ2V0VGltZSgpID49dGhpcy5mcmFtZUxhc3QrMTAwMCkge1xuICAgICAgICAgIC8vQ29uc29sZUxvZy5sb2coXCJmcmFtZSBldmVudFwiKTtcbiAgICAgICAgICB0aGlzLmxhc3RGcmFtZUNvdW50ID0gdGhpcy5mcmFtZUN0cjtcbiAgICAgICAgICB0aGlzLmZyYW1lTGFzdCA9IGRhdGVUZW1wLmdldFRpbWUoKTtcbiAgICAgICAgICB0aGlzLmZyYW1lQ3RyID0gMDtcbiAgICAgICB9XG5cbiAgICAgICBkZWxldGUgZGF0ZVRlbXA7XG4gICAgfVxuXG5cbiAgICAvL2luaGVyaXRlciBmdW5jdGlvblxuICAgIGZ1bmN0aW9uIGluaGVyaXRGcm9tKHBhcmVudCwgY2hpbGQpe1xuICAgICAgICB2YXIgY29weU9mUGFyZW50ID0gT2JqZWN0LmNyZWF0ZShwYXJlbnQucHJvdG90eXBlKTtcbiAgICAgICAgY29weU9mUGFyZW50LmNvbnN0cnVjdG9yID0gY2hpbGQ7XG4gICAgICAgIGNoaWxkLnByb3RvdHlwZSA9IGNvcHlPZlBhcmVudDtcbiAgICB9XG5cdFxuXHQvL2N1c3RvbSBjbGFzc2VzXG4gICAgZnVuY3Rpb24gUGh5c2ljcygpe1xuICAgICAgICBcbiAgICAgICAgICAgIERpc3BsYXkuY2FsbCh0aGlzKTtcbiAgICAgICAgXG4gICAgICAgIHRoaXMudmVsWCA9IDA7XG4gICAgICAgIHRoaXMudmVsWSA9IDA7XG4gICAgICAgIHRoaXMuYWNlbFggPSAwO1xuICAgICAgICB0aGlzLmFjZWxZID0gMDtcbiAgICAgICAgdGhpcy5jb2xsaWRpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zcGVlZCA9IDA7IFxuICAgICAgICB0aGlzLnRocnVzdCA9IDA7XG4gICAgICAgIHRoaXMuYW5nbGUgPSAwO1xuICAgIH1cbiAgICBcbiAgICBQaHlzaWNzLnByb3RvdHlwZS5zcGF3biA9IGZ1bmN0aW9uKHgsIHksIGFuZ2xlLCBzcGVlZCl7XG4gICAgICAgIFxuICAgICAgICB0aGlzLnggPSB4IHx8IGNlbnRlclg7XG4gICAgICAgIHRoaXMueSA9IHkgfHwgY2VudGVyWTtcbiAgICAgICAgdGhpcy5jb2xsaWRpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5hbGl2ZSA9IHRydWU7XG4gICAgICAgIHRoaXMuYW5nbGUgPSBhbmdsZSB8fCB0aGlzLmFuZ2xlO1xuICAgICAgICB0aGlzLnNwZWVkID0gc3BlZWQgfHwgdGhpcy5zcGVlZDtcbiAgICAgICAgdGhpcy52ZWxYID0gTWF0aC5jb3ModGhpcy5hbmdsZSkqdGhpcy5zcGVlZDtcbiAgICAgICAgdGhpcy52ZWxZID0gTWF0aC5zaW4odGhpcy5hbmdsZSkqdGhpcy5zcGVlZDtcbiAgICAgICAgXG4gICAgfTtcbiAgICBcbiAgICBQaHlzaWNzLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKXtcbiAgICAgICAgdGhpcy5hbGl2ZSA9IGZhbHNlOyBcbiAgICB9O1xuICAgIFxuICAgIC8vc3BhY2VDcmFmdCBmdW5jdGlvbiBjb25zdHJ1Y3RvciBcbiAgICBmdW5jdGlvbiBTcGFjZWNyYWZ0KCl7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgUGh5c2ljcy5jYWxsKHRoaXMpO1xuICAgICAgICBcbiAgICAgICAgdGhpcy5hdXRvU3Bhd24gPSBmYWxzZTtcbiAgICAgICAgdGhpcy50aHJ1c3RBY2NlbCA9IDAuMDM7XG4gICAgICAgIHRoaXMuYWxwaGFTcGVlZCA9IDAuMDM7XG4gICAgICAgIHRoaXMuc2hpZWxkQWN0aXZlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc2hpZWxkRGlzYWJsZWQgPSBmYWxzZTtcblx0XHR0aGlzLm1heFZlbG9jaXR5ID0gNDtcbiAgICAgICAgdGhpcy5taXNzaWxlc1NwZWVkID0gMi41O1xuICAgICAgICBcbiAgICB9XG4gICAgXG4gICAgU3BhY2VjcmFmdC5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQpe1xuICAgICAgICBcbiAgICAgICAgICAgIERpc3BsYXkucHJvdG90eXBlLmluaXQuY2FsbCh0aGlzLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgXG4gICAgICAgIHZhciBzaGllbGQgPSBuZXcgU2hpZWxkKCk7XG4gICAgICAgICAgICBzaGllbGQuc2V0Q2FudmFzKG1haW5DYW52YXMpO1xuICAgICAgICAgICAgc2hpZWxkLmluaXQoODAsODApO1xuICAgICAgICB2YXIgbWlzc2lsZVBvb2wgPSBuZXcgUG9vbCgxMCk7XG4gICAgICAgICAgICBtaXNzaWxlUG9vbC5pbml0KCdtaXNzaWxlJyk7XG4gICAgICAgIHZhciBleHBsb3Npb24gPSBuZXcgRXhwbG9zaW9uKDE1KTtcbiAgICAgICAgICAgIGV4cGxvc2lvbi5zZXRDYW52YXMobWFpbkNhbnZhcyk7XG4gICAgICAgICAgICBcbiAgICAgICAgdGhpcy5leHBsb3Npb24gPSBleHBsb3Npb247XG4gICAgICAgIHRoaXMuc2hpZWxkID0gc2hpZWxkO1xuICAgICAgICB0aGlzLm1pc3NpbGVzID0gbWlzc2lsZVBvb2w7XG4gICAgICAgIFxuICAgIH07ICAgIFxuICAgIFNwYWNlY3JhZnQucHJvdG90eXBlLmZvbGxvdyA9IGZ1bmN0aW9uKG9iamVjdCl7XG4gICAgICAgIFxuXHRcdFx0aWYoIW9iamVjdC5hbGl2ZSl7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cdFxuXHRcdFx0dmFyIGR4LCBkeSwgZGlzdGFuY2UsIG5ld1ZlbFgsIG5ld1ZlbFksIGZ1dHVyZVZlbCwgZGlyZWN0aW9uO1xuXHRcdFx0ZHggPSBvYmplY3QueCAtIHRoaXMueDtcblx0XHRcdGR5ID0gb2JqZWN0LnkgLSB0aGlzLnk7XG5cdFx0XHRkaXN0YW5jZSA9IE1hdGguc3FydChkeCpkeCtkeSpkeSk7XG5cdFx0XHRkaXJlY3Rpb24gPSBNYXRoLmF0YW4yKGR5LCBkeCk7XG5cdFx0XHR0aGlzLmFuZ2xlID0gZGlyZWN0aW9uO1xuXHRcdFx0XG5cdFx0XHRpZihkaXN0YW5jZT49MTQwKXtcblx0XHRcdG5ld1ZlbFggPSB0aGlzLnZlbFgrTWF0aC5jb3ModGhpcy5hbmdsZSkqdGhpcy50aHJ1c3RBY2NlbDtcblx0XHRcdG5ld1ZlbFkgPSB0aGlzLnZlbFkrTWF0aC5zaW4odGhpcy5hbmdsZSkqdGhpcy50aHJ1c3RBY2NlbDtcdFxuXHRcdFx0ZnV0dXJlVmVsID0gTWF0aC5zcXJ0KG5ld1ZlbFgqbmV3VmVsWCArIG5ld1ZlbFkqbmV3VmVsWSk7XHRcblx0XHRcdFx0XHRpZihmdXR1cmVWZWw+MS41KXtcblx0XHRcdFx0bmV3VmVsWCA9IHRoaXMudmVsWDtcblx0XHRcdFx0bmV3VmVsWSA9IHRoaXMudmVsWTtcblx0XHRcdFx0fWVsc2V7XG5cdFx0XHRcdHRoaXMudmVsWCA9IG5ld1ZlbFg7XG5cdFx0XHRcdHRoaXMudmVsWSA9IG5ld1ZlbFk7XG5cdFx0XHRcdH1cblx0XHRcdH1cdFxuICAgIH07XG4gICAgXG4gICAgU3BhY2VjcmFmdC5wcm90b3R5cGUuYXR0YWNrID0gZnVuY3Rpb24ob2JqZWN0KXtcblx0XHRcdGlmKE1hdGgucmFuZG9tKCkgPj0gMC4wMDUgfHwgIXRoaXMuYWxpdmUgfHwgIW9iamVjdC5hbGl2ZSl7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdHRoaXMuc2hvb3QoKTtcbiAgICB9O1xuICAgIFxuICAgIFNwYWNlY3JhZnQucHJvdG90eXBlLnNwYXduID0gZnVuY3Rpb24oeCwgeSwgYW5nbGUsIHNwZWVkKXtcbiAgICAgICAgXG4gICAgICAgICAgICBQaHlzaWNzLnByb3RvdHlwZS5zcGF3bi5jYWxsKHRoaXMsIHgsIHksIGFuZ2xlLCBzcGVlZCk7XG4gICAgICAgICAgICB0aGlzLm1pc3NpbGVzLmhpZGVJdGVtcygpO1xuICAgICAgICAgICAgLy90aGlzLnNoaWVsZC5yZXNldCgpO1xuICAgICAgICBcbiAgICB9O1xuICAgIFxuICAgIFNwYWNlY3JhZnQucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpe1xuICAgICAgICBcbiAgICAgICAgdGhpcy5jb2xsaWRpbmcgPSB0cnVlOyAgXG4gICAgICAgIGV4cGxvc2lvblNvdW5kLnBsYXkoKTtcbiAgICAgICAgXG4gICAgfTtcblxuICAgIFNwYWNlY3JhZnQucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbigpe1xuICAgICAgICBcbiAgICAgICAgLy9kcmF3cyBzcGFjZWNyYWZ0IGxhdW5jaGVkIG1pc3NpbGVzXG4gICAgICAgIGZvcih2YXIgaT0wOyBpPHRoaXMubWlzc2lsZXMucG9vbC5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICB2YXIgY3VycmVudE1pc3NpbGUgPSB0aGlzLm1pc3NpbGVzLnBvb2xbaV07ICAgXG4gICAgICAgICAgICBpZihjdXJyZW50TWlzc2lsZS5hbGl2ZSl7XG4gICAgICAgICAgICAgICAgY3VycmVudE1pc3NpbGUuZHJhdygpOyAgIFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZih0aGlzLmNvbGxpZGluZyl7XHRcbiAgICAgICAgICAgICAgICAvL2lmIHNwYWNlY3JhZnQgaXMgY29sbGlkaW5nLCBjcmVhdGUgYW4gZXhwbG9zaW9uXG4gICAgICAgICAgICB0aGlzLmV4cGxvc2lvbi5jcmVhdGUodGhpcy54K3RoaXMuY2VudGVyWCwgdGhpcy55K3RoaXMuY2VudGVyWSk7XG4gICAgICAgICAgICB0aGlzLmV4cGxvc2lvbi5kcmF3KCk7XG4gICAgICAgICAgICAgICAgLy9vbmNlIHRoZSBleHBsb3Npb24gaXMgbm90IHJ1bm5pbmcsIGtpbGwgb2ZmIHNwYWNlY3JhZnRcbiAgICAgICAgICAgIGlmKCF0aGlzLmV4cGxvc2lvbi5ydW5uaW5nKXtcbiAgICAgICAgICAgICAgICB0aGlzLmFsaXZlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5jb2xsaWRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpZih0aGlzLmF1dG9TcGF3bil7XG4gICAgICAgICAgICAgICAgIHRoaXMuc3Bhd24oKTsgICBcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy9yZXR1cm4gd2hpbGUgY29sbGlkaW5nXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICB9XG4gICAgICAgICAgICAvL2lmIHNoaWVsZCBpcyBhY3RpdmUgZHJhdyBpdC5cbiAgICAgICAgaWYodGhpcy5zaGllbGQuYWN0aXZlKXtcbiAgICAgICAgICAgICAgICB0aGlzLnNoaWVsZC54ID0gdGhpcy54LXRoaXMuc2hpZWxkLmNlbnRlclgrdGhpcy5jZW50ZXJYO1xuICAgICAgICAgICAgICAgIHRoaXMuc2hpZWxkLnkgPSB0aGlzLnktdGhpcy5zaGllbGQuY2VudGVyWSt0aGlzLmNlbnRlclk7XG4gICAgICAgICAgICAgICAgdGhpcy5zaGllbGQuZHJhdygpO1xuICAgICAgICB9ICAgIFxuICAgICAgICBcbiAgICB9O1xuICAgIFxuICAgIFNwYWNlY3JhZnQucHJvdG90eXBlLnNob290ID0gZnVuY3Rpb24oKXtcbiAgICAgICAgXG4gICAgICAgIC8vaWYgaW5zdGFuY2UgaXMgbm90IGFsaXZlLCBpcyBjb2xsaWRpbmcgb3Igbm90IG1vdmluZywgaXQgd2lsbCBOT1Qgc2hvb3RcbiAgICAgICAgaWYoIXRoaXMuYWxpdmUgfHwgdGhpcy5jb2xsaWRpbmcgfHwgdGhpcy52ZWxYID09IDApe1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubWlzc2lsZXMuZ2V0KHRoaXMueCsxMCwgdGhpcy55KzEwLCBcIm1pc3NpbGVcIiwgdGhpcy5hbmdsZSwgdGhpcy5taXNzaWxlc1NwZWVkKTtcblx0XHRcbiAgICB9O1xuICAgIFxuICAgIC8vY2xhc3MgZm9yIHRoZSByb2NrcyBmbG9hdGluZ1xuICAgIFxuICAgIGZ1bmN0aW9uIFJvY2soKXtcbiAgICAgICAgXG4gICAgICAgICAgICBQaHlzaWNzLmNhbGwodGhpcyk7XG4gICAgICAgIFxuICAgICAgICB0aGlzLnNpemU7XG4gICAgICAgIHRoaXMuc3ByaXRlQW5pbWF0aW9uID0gbmV3IFNwcml0ZUFuaW1hdGlvbigpO1xuICAgICAgICB0aGlzLnNwcml0ZUFuaW1hdGlvbi5zZXRDYW52YXMobWFpbkNhbnZhcyk7XG4gICAgICAgIHRoaXMuZXhwbG9zaW9uID0gbmV3IEV4cGxvc2lvbig3KTtcbiAgICAgICAgdGhpcy5leHBsb3Npb24uc2V0Q2FudmFzKG1haW5DYW52YXMpO1xuICAgICAgICB0aGlzLnR5cGUgPSAncm9jayc7XG4gICAgXG4gICAgfVxuICAgIFxuICAgIFJvY2sucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbihzaXplKXtcbiAgICAgICAgXG4gICAgICAgICAgdmFyIHNwcml0ZUFuaW1hdGlvbkluZm8sXG4gICAgICAgICAgICAgIGxhcmdlUm9ja1NwZWVkID0gMC41LFxuICAgICAgICAgICAgICBtZWRpdW1Sb2NrU3BlZWQgPSAxLFxuICAgICAgICAgICAgICBzbWFsbFJvY2tTcGVlZCA9IDEuMixcbiAgICAgICAgICAgICAgcmFuZG9tQW5nbGU7XG4gICAgICAgIFxuICAgICAgICBcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgc2l6ZSA9IHNpemUgfHwgXCJsYXJnZVwiO1xuICAgIFxuICAgICAgICAgICAgc3dpdGNoKHNpemUpe1xuICAgICAgICAgICAgICAgIGNhc2UgXCJsYXJnZVwiOlxuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgc3ByaXRlQW5pbWF0aW9uSW5mbyA9IHt3aWR0aDo1NixoZWlnaHQ6NTUsIG9mZnNldFg6IDAsIG9mZnNldFk6IDAsIG51bUNvbDoyLCBudW1Sb3c6OSxmcHM6NjAsc3BlZWQ6OCxsb29wOmZhbHNlLGZyb206MCx0bzoxN307XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3ByaXRlQW5pbWF0aW9uLmluaXQoc3ByaXRlQW5pbWF0aW9uSW5mbyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3ByaXRlID0gUmVzb3VyY2VMb2FkZXIuYXNzZXRzLm1ldGVvclNwcml0ZTtcbiAgICAgICAgICAgICAgICAgICAgcmFuZG9tQW5nbGUgPSBNYXRoLnJhbmRvbSgpKihNYXRoLlBJKjIpO1xuICAgICAgICAgICAgICAgICAgICBEaXNwbGF5LnByb3RvdHlwZS5pbml0LmNhbGwodGhpcywgc3ByaXRlQW5pbWF0aW9uSW5mby53aWR0aCwgc3ByaXRlQW5pbWF0aW9uSW5mby5oZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICBQaHlzaWNzLnByb3RvdHlwZS5zcGF3bi5jYWxsKHRoaXMsIDAsIDAsIHJhbmRvbUFuZ2xlLCBsYXJnZVJvY2tTcGVlZCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWxpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zaXplID0gXCJsYXJnZVwiO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnR5cGUgPSBcImxhcmdlUm9ja1wiO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcIm1lZGl1bVwiOlxuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgc3ByaXRlQW5pbWF0aW9uSW5mbyA9IHt3aWR0aDo0NCxoZWlnaHQ6NDQsIG51bUNvbDozLCBudW1Sb3c6NixmcHM6NjAsb2Zmc2V0WDogMTMwLCBvZmZzZXRZIDogMCwgc3BlZWQ6MTIsbG9vcDp0cnVlLGZyb206MCx0bzoxN307ICAgXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3ByaXRlQW5pbWF0aW9uLmluaXQoc3ByaXRlQW5pbWF0aW9uSW5mbyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3ByaXRlID0gUmVzb3VyY2VMb2FkZXIuYXNzZXRzLm1ldGVvclNwcml0ZTtcbiAgICAgICAgICAgICAgICAgICAgcmFuZG9tQW5nbGUgPSBNYXRoLnJhbmRvbSgpKihNYXRoLlBJKjIpO1xuICAgICAgICAgICAgICAgICAgICBEaXNwbGF5LnByb3RvdHlwZS5pbml0LmNhbGwodGhpcywgc3ByaXRlQW5pbWF0aW9uSW5mby53aWR0aCwgc3ByaXRlQW5pbWF0aW9uSW5mby5oZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICBQaHlzaWNzLnByb3RvdHlwZS5zcGF3bi5jYWxsKHRoaXMsIDAsIDAsIHJhbmRvbUFuZ2xlLCBtZWRpdW1Sb2NrU3BlZWQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFsaXZlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2l6ZSA9IFwibWVkaXVtXCI7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHlwZSA9IFwibWVkaXVtUm9ja1wiO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcInNtYWxsXCI6XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBzcHJpdGVBbmltYXRpb25JbmZvID0ge3dpZHRoOjMzLGhlaWdodDozMywgbnVtQ29sOjMsb2Zmc2V0WDogMjkwLCBvZmZzZXRZOiAwLCBudW1Sb3c6NixmcHM6NjAsc3BlZWQ6MTUsbG9vcDp0cnVlLGZyb206MCx0bzoxN307XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3ByaXRlQW5pbWF0aW9uLmluaXQoc3ByaXRlQW5pbWF0aW9uSW5mbyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3ByaXRlID0gUmVzb3VyY2VMb2FkZXIuYXNzZXRzLm1ldGVvclNwcml0ZTtcbiAgICAgICAgICAgICAgICAgICAgcmFuZG9tQW5nbGUgPSBNYXRoLnJhbmRvbSgpKihNYXRoLlBJKjIpO1xuICAgICAgICAgICAgICAgICAgICBEaXNwbGF5LnByb3RvdHlwZS5pbml0LmNhbGwodGhpcywgc3ByaXRlQW5pbWF0aW9uSW5mby53aWR0aCwgc3ByaXRlQW5pbWF0aW9uSW5mby5oZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICBQaHlzaWNzLnByb3RvdHlwZS5zcGF3bi5jYWxsKHRoaXMsIDAsIDAsIHJhbmRvbUFuZ2xlLCBzbWFsbFJvY2tTcGVlZCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWxpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zaXplID0gXCJzbWFsbFwiO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnR5cGUgPSBcInNtYWxsUm9ja1wiO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICB9O1xuICAgIFxuICAgIFJvY2sucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbigpe1xuICAgICAgICAgICAgXG5cdFx0XHRpZih0aGlzLmNvbGxpZGluZyl7IFxuICAgICAgICAgICAgLy93aGVuIG9iamVjdCBpcyBjb2xsaWRpbmcsIGNyZWF0ZXMgYW5kIGRyYXdzIGV4cGxvc2lvblxuXHRcdFx0dGhpcy5leHBsb3Npb24uY3JlYXRlKHRoaXMueCt0aGlzLmNlbnRlclgsIHRoaXMueSt0aGlzLmNlbnRlclkpO1xuXHRcdFx0dGhpcy5leHBsb3Npb24uZHJhdygpO1xuICAgICAgICAgICAgICAgIHRoaXMuZGVzdHJveSgpO1xuXG5cdFx0XHQgICAgIGlmKCF0aGlzLmV4cGxvc2lvbi5ydW5uaW5nKXtcblx0XHRcdCAgICAgLy9vbmNlIGV4cGxvc2lvbiBpcyBvdmVyLCBraWxscyBvZmYgb2JqZWN0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29sbGlkaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWxpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBleHBsb3Npb24gaXMgc3RpbGwgcnVubmluZyByZXR1cm4gdG8gZHJhd2luZyB0aGUgZXhwbG9zaW9uXG5cdFx0XHQgICAgIHJldHVybjtcblx0XHRcdH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy54ICs9IHRoaXMudmVsWDtcbiAgICAgICAgICAgIHRoaXMueSArPSB0aGlzLnZlbFk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuc3ByaXRlQW5pbWF0aW9uLnBsYXkodGhpcy54LCB0aGlzLnksIHRoaXMuc3ByaXRlKTsgICAgXG4gICAgICAgICAgICBcbiAgICAgICAgfTtcbiAgICBcbiAgICBSb2NrLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKXtcbiAgICAgICAgXG4gICAgICAgICAgICBpZih0aGlzLmNvbGxpZGluZyl7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgICAgIG1ldGVvckV4cGxvc2lvblNvdW5kLnBsYXkoKTtcbiAgICAgICAgICAgIHRoaXMuY29sbGlkaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgc3dpdGNoKHRoaXMuc2l6ZSl7XG4gICAgICAgICAgICAgICAgY2FzZSBcImxhcmdlXCI6XG4gICAgICAgICAgICAgICAgbWV0ZW9yUG9vbC5nZXQodGhpcy54LCB0aGlzLnksIFwibWVkaXVtUm9ja1wiKTtcbiAgICAgICAgICAgICAgICBtZXRlb3JQb29sLmdldCh0aGlzLngsIHRoaXMueSwgXCJtZWRpdW1Sb2NrXCIpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwibWVkaXVtXCI6XG4gICAgICAgICAgICAgICAgbWV0ZW9yUG9vbC5nZXQodGhpcy54LCB0aGlzLnksIFwic21hbGxSb2NrXCIpO1xuICAgICAgICAgICAgICAgIG1ldGVvclBvb2wuZ2V0KHRoaXMueCwgdGhpcy55LCBcInNtYWxsUm9ja1wiKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcInNtYWxsXCI6XG4gICAgICAgICAgICAgICAgICAgIC8vbm8gcm9ja3NcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7ICAgICBcbiAgICAgICAgICAgIH0gIFxuICAgIH07ICAgIFxuICAgIFxuXHRmdW5jdGlvbiBCYWNrZ3JvdW5kKCl7XG4gICAgICAgIFxuICAgICAgICAgICAgRGlzcGxheS5jYWxsKHRoaXMpO1xuICAgICAgICBcbiAgICAgICAgdGhpcy52ZWxYID0gMDtcbiAgICAgICAgdGhpcy52ZWxZID0gMDtcblx0XHR0aGlzLnByb2dyZXNzQmFyV2lkdGggPSA0MDA7XG5cdFx0dGhpcy5wcm9ncmVzc0JhckhlaWdodCA9IDQwO1xuXHR9XG4gICAgXG4gICAgQmFja2dyb3VuZC5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICB0aGlzLnggKz0gdGhpcy52ZWxYO1xuXHRcdFx0dGhpcy55ICs9IHRoaXMudmVsWTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy5jb250ZXh0LmRyYXdJbWFnZShSZXNvdXJjZUxvYWRlci5hc3NldHMuYmFja2dyb3VuZFNwcml0ZSwgMCwwLHRoaXMuY2FudmFzV2lkdGgsdGhpcy5jYW52YXNIZWlnaHQsdGhpcy54LXRoaXMuY2FudmFzV2lkdGgsIHRoaXMueSx0aGlzLmNhbnZhc1dpZHRoLHRoaXMuY2FudmFzSGVpZ2h0KTtcdFxuICAgICAgICAgICAgdGhpcy5jb250ZXh0LmRyYXdJbWFnZShSZXNvdXJjZUxvYWRlci5hc3NldHMuYmFja2dyb3VuZFNwcml0ZSwgMCwwLHRoaXMuY2FudmFzV2lkdGgsdGhpcy5jYW52YXNIZWlnaHQsdGhpcy54LHRoaXMueSx0aGlzLmNhbnZhc1dpZHRoLHRoaXMuY2FudmFzSGVpZ2h0KTtcblx0XHRcdFxuXHRcdFx0aWYodGhpcy54PnRoaXMuY2FudmFzV2lkdGgpe1xuXHRcdFx0XHR0aGlzLnggPSAwO1xuXHRcdFx0fVx0XG4gICAgfTtcbiAgICBCYWNrZ3JvdW5kLnByb3RvdHlwZS5kcmF3UHJvZ3Jlc3MgPSBmdW5jdGlvbihsb2FkZWQsIHRvTG9hZCl7XG5cdFx0XHR0aGlzLmNvbnRleHQuZmlsbFN0eWxlID0gJyMwMDAwMDAnO1xuXHRcdFx0dGhpcy5jb250ZXh0LmZpbGxSZWN0KDAsMCwgdGhpcy5jYW52YXNXaWR0aCwgdGhpcy5jYW52YXNIZWlnaHQpO1xuXHRcdFx0dGhpcy5jb250ZXh0LnN0cm9rZVN0eWxlID0gJyNGRkZGRkYnO1xuXHRcdFx0dGhpcy5jb250ZXh0LnN0cm9rZVJlY3QoKHRoaXMuY2FudmFzV2lkdGgtNDAwKS8yLCB0aGlzLmNhbnZhc0hlaWdodC8yLTQwLCB0aGlzLnByb2dyZXNzQmFyV2lkdGgsIHRoaXMucHJvZ3Jlc3NCYXJIZWlnaHQpO1xuXHRcdFx0dGhpcy5jb250ZXh0LmZpbGxTdHlsZSA9ICcjRkZGRkZGJztcblx0XHRcdHRoaXMuY29udGV4dC5maWxsUmVjdCgodGhpcy5jYW52YXNXaWR0aC00MDApLzIsIHRoaXMuY2FudmFzSGVpZ2h0LzItNDAsICh0aGlzLnByb2dyZXNzQmFyV2lkdGgqKGxvYWRlZC90b0xvYWQpKSwgdGhpcy5wcm9ncmVzc0JhckhlaWdodCk7XG5cdFx0XHR0aGlzLmNvbnRleHQuZm9udCA9ICcyMHB4IEFyaWVsJztcblx0XHRcdHRoaXMuY29udGV4dC50ZXh0QWxpZ24gPSAnY2VudGVyJztcblx0XHRcdHRoaXMuY29udGV4dC5maWxsVGV4dCgnTG9hZGluZy4uLicsIHRoaXMuY2FudmFzV2lkdGgvMiwgdGhpcy5jYW52YXNIZWlnaHQvMis0MCk7XG5cdFx0fTtcbiAgICBCYWNrZ3JvdW5kLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKCl7XG5cdFx0XHR0aGlzLmNvbnRleHQuZmlsbFN0eWxlID0gJyMwMDAwMDAnO1xuXHRcdFx0dGhpcy5jb250ZXh0LmZpbGxSZWN0KDAsMCx0aGlzLmNhbnZhc1dpZHRoLCB0aGlzLmNhbnZhc0hlaWdodCk7XG5cdFx0fTtcdFxuICAgIFxuICAgIFxuICAgIFxuICAgIFxuICAgIGZ1bmN0aW9uIEludGVyZmFjZSgpe1xuICAgICAgICBcbiAgICAgICAgdGhpcy5hZGRCdXR0b25MaXN0ZW5lcnMgPSBmdW5jdGlvbigpe1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBzdG9yeUxpbmVTa2lwQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgZ2FtZUludGVyZmFjZS5oaWRlKCdzdG9yeUxpbmUnKTtcbiAgICAgICAgICAgICAgICBnYW1lSW50ZXJmYWNlLmRpc3BsYXkoJ3RpdGxlU2NyZWVuJyk7XG4gICAgICAgICAgICAgICAgYXBwU3RhdGUgPSBTVEFURV9USVRMRV9TQ1JFRU47XG4gICAgICAgICAgICB9LCBmYWxzZSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vdGhlIG9ubHkgZXhjZXB0aW9uXG4gICAgICAgICAgICBzdGFydEJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgIGdhbWVJbnRlcmZhY2UuaGlkZSgndGl0bGVTY3JlZW4nKTtcbiAgICAgICAgICAgICAgICBnYW1lSW50ZXJmYWNlLmRpc3BsYXkoJ2dhbWVQbGF5Jyk7XG4gICAgICAgICAgICAgICAgc2V0VXBMZXZlbCgpO1xuICAgICAgICAgICAgICAgIGFwcFN0YXRlID0gU1RBVEVfUExBWUlORztcbiAgICAgICAgICAgIH0sIGZhbHNlKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgc3RvcnlMaW5lQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgZ2FtZUludGVyZmFjZS5oaWRlKCd0aXRsZVNjcmVlbicpO1xuICAgICAgICAgICAgICAgIGdhbWVJbnRlcmZhY2UuZGlzcGxheSgnc3RvcnlMaW5lJyk7XG4gICAgICAgICAgICAgICAgYXBwU3RhdGUgPSBTVEFURV9TVE9SWV9MSU5FO1xuICAgICAgICAgICAgfSwgZmFsc2UpO1xuICAgICAgICAgICAgaG93VG9QbGF5QnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgZ2FtZUludGVyZmFjZS5oaWRlKCd0aXRsZVNjcmVlbicpO1xuICAgICAgICAgICAgICAgIGdhbWVJbnRlcmZhY2UuZGlzcGxheSgnaG93VG9QbGF5Jyk7XG4gICAgICAgICAgICAgICAgYXBwU3RhdGUgPSBTVEFURV9IT1dfVE9fUExBWTtcbiAgICAgICAgICAgIH0sIGZhbHNlKTtcbiAgICAgICAgICAgIGNyZWRpdHNCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICBnYW1lSW50ZXJmYWNlLmhpZGUoJ3RpdGxlU2NyZWVuJyk7XG4gICAgICAgICAgICAgICAgZ2FtZUludGVyZmFjZS5kaXNwbGF5KCdjcmVkaXRzJyk7XG4gICAgICAgICAgICAgICAgYXBwU3RhdGUgPSBTVEFURV9DUkVESVRTO1xuICAgICAgICAgICAgfSwgZmFsc2UpO1xuICAgICAgICAgICAgc2tpcENyZWRpdHMuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICBnYW1lSW50ZXJmYWNlLmhpZGUoJ2NyZWRpdHMnKTtcbiAgICAgICAgICAgICAgICBnYW1lSW50ZXJmYWNlLmRpc3BsYXkoJ3RpdGxlU2NyZWVuJyk7XG4gICAgICAgICAgICAgICAgYXBwU3RhdGUgPSBTVEFURV9USVRMRV9TQ1JFRU47XG4gICAgICAgICAgICB9LCBmYWxzZSk7XG4gICAgICAgICAgICBob3dUb0JhY2tCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICBnYW1lSW50ZXJmYWNlLmhpZGUoJ2hvd1RvUGxheScpO1xuICAgICAgICAgICAgICAgIGdhbWVJbnRlcmZhY2UuZGlzcGxheSgndGl0bGVTY3JlZW4nKTtcbiAgICAgICAgICAgICAgICBhcHBTdGF0ZSA9IFNUQVRFX1RJVExFX1NDUkVFTjtcbiAgICAgICAgICAgIH0sIGZhbHNlKTsgICAgXG4gICAgICAgICAgICBuZXh0TGV2ZWxCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgc2V0VXBMZXZlbCgpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmKCF1c2VyQmVhdEdhbWUpe1xuICAgICAgICAgICAgICAgICAgICBnYW1lSW50ZXJmYWNlLmhpZGUoJ25leHRMZXZlbCcpO1xuICAgICAgICAgICAgICAgICAgICBnYW1lSW50ZXJmYWNlLmRpc3BsYXkoJ2dhbWVQbGF5Jyk7XG4gICAgICAgICAgICAgICAgICAgIGFwcFN0YXRlID0gU1RBVEVfUExBWUlORztcbiAgICAgICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgICAgICAgZ2FtZUludGVyZmFjZS5oaWRlKCduZXh0TGV2ZWwnKTtcbiAgICAgICAgICAgICAgICAgICAgZ2FtZUludGVyZmFjZS5kaXNwbGF5KCdiZWF0R2FtZScpO1xuICAgICAgICAgICAgICAgICAgICBhcHBTdGF0ZSA9IFNUQVRFX1VTRVJfQkVBVF9HQU1FO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIH0sIGZhbHNlKTtcbiAgICAgICAgICAgIHNoYXJlQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgdXNlckJlYXRHYW1lID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgY3VycmVudExldmVsID0gMDtcbiAgICAgICAgICAgICAgICB3aW5kb3cub3BlbignaHR0cHM6Ly93d3cuZmFjZWJvb2suY29tL3NoYXJlci5waHA/dT1odHRwOi8vd3d3Lm5veHRhci5jb20vMjAxNi8wNi9wbGF5LWVhcnRoLWRlZmVuZGVyLWdhbWUuaHRtbCcpO1xuICAgICAgICAgICAgICAgIGdhbWVJbnRlcmZhY2UuaGlkZSgnYmVhdEdhbWUnKTtcbiAgICAgICAgICAgICAgICBnYW1lSW50ZXJmYWNlLmRpc3BsYXkoJ3RpdGxlU2NyZWVuJyk7XG4gICAgICAgICAgICAgICAgYXBwU3RhdGUgPSBTVEFURV9USVRMRV9TQ1JFRU47XG4gICAgICAgICAgICB9LCBmYWxzZSk7XG4gICAgICAgICAgICByZXN0YXJ0QnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgZ2FtZUludGVyZmFjZS5oaWRlKCdnYW1lUGxheScpO1xuICAgICAgICAgICAgICAgIGdhbWVJbnRlcmZhY2UuaGlkZSgnZ2FtZU92ZXInKTtcbiAgICAgICAgICAgICAgICBnYW1lSW50ZXJmYWNlLmRpc3BsYXkoJ3RpdGxlU2NyZWVuJyk7XG4gICAgICAgICAgICAgICAgYXBwU3RhdGUgPSBTVEFURV9USVRMRV9TQ1JFRU47XG4gICAgICAgICAgICB9LCBmYWxzZSk7XG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICB0aGlzLmRpc3BsYXkgPSBmdW5jdGlvbihwYWdlKXtcbiAgICAgICAgICAgIHN3aXRjaChwYWdlKXtcbiAgICAgICAgICAgICAgICBjYXNlIFwidGl0bGVTY3JlZW5cIjpcbiAgICAgICAgICAgICAgICAgICAgZ2FtZVN0YXJ0SG9sZGVyLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCAnZGlzcGxheTogYmxvY2s7Jyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJnYW1lUGxheVwiOlxuICAgICAgICAgICAgICAgICAgICBnYW1lUGxheUhvbGRlci5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgJ2Rpc3BsYXk6IGJsb2NrOycpOyBcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcInN0b3J5TGluZVwiOlxuICAgICAgICAgICAgICAgICAgICBzdG9yeUxpbmVIb2xkZXIuc2V0QXR0cmlidXRlKCdzdHlsZScsICdkaXNwbGF5OiBibG9jazsnKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcImhvd1RvUGxheVwiOlxuICAgICAgICAgICAgICAgICAgICBob3dUb1BsYXlIb2xkZXIuc2V0QXR0cmlidXRlKCdzdHlsZScsICdkaXNwbGF5OmJsb2NrOycpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwibmV4dExldmVsXCI6XG4gICAgICAgICAgICAgICAgICAgIGxldmVsVHJhbnNpdGlvbkhvbGRlci5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgJ2Rpc3BsYXk6IGJsb2NrOycpOyAgXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJnYW1lT3ZlclwiOlxuICAgICAgICAgICAgICAgICAgICBnYW1lT3ZlckhvbGRlci5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgJ2Rpc3BsYXk6IGJsb2NrOycpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiYmVhdEdhbWVcIjpcbiAgICAgICAgICAgICAgICAgICAgYmVhdEdhbWVIb2xkZXIuc2V0QXR0cmlidXRlKCdzdHlsZScsICdkaXNwbGF5OiBibG9jazsnKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcImNyZWRpdHNcIjpcbiAgICAgICAgICAgICAgICAgICAgY3JlZGl0c0hvbGRlci5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgJ2Rpc3BsYXk6IGJsb2NrOycpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwibm9uZVwiOlxuICAgICAgICAgICAgICAgICAgICBpbnRlcmZhY2VXcmFwcGVyLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCAnJyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrOyAgICAgICAgXG4gICAgICAgICAgICB9IFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhpZGUgPSBmdW5jdGlvbihwYWdlKXtcbiAgICAgICAgICAgIHN3aXRjaChwYWdlKXtcbiAgICAgICAgICAgICAgICBjYXNlIFwidGl0bGVTY3JlZW5cIjpcbiAgICAgICAgICAgICAgICAgICAgZ2FtZVN0YXJ0SG9sZGVyLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCAnJyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJnYW1lUGxheVwiOlxuICAgICAgICAgICAgICAgICAgICBnYW1lUGxheUhvbGRlci5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgJycpOyBcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcInN0b3J5TGluZVwiOlxuICAgICAgICAgICAgICAgICAgICBzdG9yeUxpbmVIb2xkZXIuc2V0QXR0cmlidXRlKCdzdHlsZScsICcnKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcImhvd1RvUGxheVwiOlxuICAgICAgICAgICAgICAgICAgICBob3dUb1BsYXlIb2xkZXIuc2V0QXR0cmlidXRlKCdzdHlsZScsICcnKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcIm5leHRMZXZlbFwiOlxuICAgICAgICAgICAgICAgICAgICBsZXZlbFRyYW5zaXRpb25Ib2xkZXIuc2V0QXR0cmlidXRlKCdzdHlsZScsICcnKTsgIFxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiZ2FtZU92ZXJcIjpcbiAgICAgICAgICAgICAgICAgICAgZ2FtZU92ZXJIb2xkZXIuc2V0QXR0cmlidXRlKCdzdHlsZScsICcnKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcImJlYXRHYW1lXCI6XG4gICAgICAgICAgICAgICAgICAgIGJlYXRHYW1lSG9sZGVyLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCAnJyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJjcmVkaXRzXCI6XG4gICAgICAgICAgICAgICAgICAgIGNyZWRpdHNIb2xkZXIuc2V0QXR0cmlidXRlKCdzdHlsZScsICcnKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcIm5vbmVcIjpcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJmYWNlV3JhcHBlci5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgJycpO1xuICAgICAgICAgICAgICAgICAgICBicmVhazsgICAgICAgIFxuICAgICAgICAgICAgfSBcbiAgICAgICAgfTtcbiAgICB9XG4gICAgXG4gICAgXG5cdFxuXHRmdW5jdGlvbiBTaGlwKCl7XG4gICAgICAgIFxuICAgICAgICAgICAgICAgIFNwYWNlY3JhZnQuY2FsbCh0aGlzKTtcbiAgICAgICAgXG4gICAgICAgICAgICB2YXIgc2hpcFNwcml0ZUluZm8gPSB7d2lkdGg6MjEsaGVpZ2h0OjIyLCBudW1Db2w6MSwgbnVtUm93OjIsZnBzOjYwLHNwZWVkOjMwLGxvb3A6ZmFsc2UsZnJvbTowLHRvOjB9O1xuICAgICAgICBcbiAgICAgICAgICAgIHRoaXMudGhydXN0ID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmF1dG9TcGF3biA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnRocnVzdEFjY2VsID0gMC4wNDtcbiAgICAgICAgICAgIHRoaXMubWlzc2lsZXNTcGVlZCA9IDMuMjtcbiAgICAgICAgICAgIHRoaXMuZWFzZVZhbHVlID0gMC4wMztcbiAgICAgICAgICAgIHRoaXMuc3ByaXRlQW5pbWF0aW9uID0gbmV3IFNwcml0ZUFuaW1hdGlvbigpO1xuICAgICAgICAgICAgdGhpcy5zcHJpdGVBbmltYXRpb24uc2V0Q2FudmFzKG1haW5DYW52YXMpO1xuICAgICAgICAgICAgdGhpcy5zcHJpdGVBbmltYXRpb24uaW5pdChzaGlwU3ByaXRlSW5mbyk7IFxuICAgICAgICAgICAgdGhpcy50eXBlID0gXCJodW1hblNoaXBcIjtcbiAgICAgICAgXG5cdH1cbiAgICBcbiAgICBTaGlwLnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24oKXtcbiAgICAgICAgXG4gICAgICAgICAgIFNwYWNlY3JhZnQucHJvdG90eXBlLmRyYXcuY2FsbCh0aGlzKTtcbiAgICAgICAgXG4gICAgICAgIGlmKHRoaXMuY29sbGlkaW5nKXtcbiAgICAgICAgICAgIHJldHVybjsgICBcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuc2F2ZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuYWxwaGEgKz0gdGhpcy5hbHBoYVNwZWVkO1xuICAgICAgICAgICAgICAgIHRoaXMuYWxwaGEgPSAodGhpcy5hbHBoYSA+PSAxKT8gMTogdGhpcy5hbHBoYTtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuZ2xvYmFsQWxwaGEgPSB0aGlzLmFscGhhO1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC50cmFuc2xhdGUodGhpcy54KzEwLCB0aGlzLnkrMTApO1x0XG4gICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LnJvdGF0ZSh0aGlzLmFuZ2xlKTtcbiAgICAgICAgICAgICAgICB0aGlzLnggKz0gdGhpcy52ZWxYO1xuICAgICAgICAgICAgICAgIHRoaXMueSArPSB0aGlzLnZlbFk7XG4gICAgICAgICAgICAgICAgaWYodGhpcy50aHJ1c3Qpe1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNwcml0ZUFuaW1hdGlvbi5zdGFydEZyYW1lID0gMTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zcHJpdGVBbmltYXRpb24uZmluYWxGcmFtZSA9IDE7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3ByaXRlQW5pbWF0aW9uLnBsYXkoLXRoaXMuY2VudGVyWCwgLXRoaXMuY2VudGVyWSwgUmVzb3VyY2VMb2FkZXIuYXNzZXRzLnBsYXllclNwcml0ZVNoZWV0KTtcbiAgICAgICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgICAgICAgLy90aGlzLmNvbnRleHQuZHJhd0ltYWdlKHNoaXBTcHJpdGUsIDAsIDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCAtMTAsLTEwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3ByaXRlQW5pbWF0aW9uLnN0YXJ0RnJhbWUgPSAwO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNwcml0ZUFuaW1hdGlvbi5maW5hbEZyYW1lID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zcHJpdGVBbmltYXRpb24ucGxheSgtdGhpcy5jZW50ZXJYLCAtdGhpcy5jZW50ZXJZLCBSZXNvdXJjZUxvYWRlci5hc3NldHMucGxheWVyU3ByaXRlU2hlZXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQucmVzdG9yZSgpO1xuICAgIH07XG5cdFxuXHRTaGlwLnByb3RvdHlwZS5zaG9vdCA9IGZ1bmN0aW9uKCl7XG5cdFx0U3BhY2VjcmFmdC5wcm90b3R5cGUuc2hvb3QuY2FsbCh0aGlzKTtcblx0XHRwbGF5ZXJTaG9vdFNvdW5kLnBsYXkoKTtcblx0fTtcbiAgICBcbiAgICBmdW5jdGlvbiBQZXJrKCl7XG4gICAgICAgIFxuICAgICAgICAgICAgUGh5c2ljcy5jYWxsKHRoaXMpO1xuICAgICAgICBcbiAgICAgICAgdGhpcy5zcHJpdGVBbmltYXRpb24gPSBuZXcgU3ByaXRlQW5pbWF0aW9uKCk7IFxuICAgICAgICB0aGlzLnNwcml0ZUFuaW1hdGlvbi5zZXRDYW52YXMobWFpbkNhbnZhcyk7XG4gICAgXG4gICAgICAgIHRoaXMudHlwZSA9ICdwZXJrJzsgICAgXG4gICAgfVxuICAgIFBlcmsucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbigpe1xuICAgICAgICBcbiAgICAgICAgaWYoIXRoaXMuYWxpdmUpe1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICB0aGlzLnggKz0gdGhpcy52ZWxYO1xuICAgICAgICB0aGlzLnkgKz0gdGhpcy52ZWxZO1xuICAgICAgICBcbiAgICAgICAgdGhpcy5zcHJpdGVBbmltYXRpb24ucGxheSh0aGlzLngsIHRoaXMueSwgUmVzb3VyY2VMb2FkZXIuYXNzZXRzLnBlcmtTcHJpdGUpO1xuICAgICAgICBcbiAgICB9O1xuICAgIFBlcmsucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbihwZXJrKXtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdmFyIHNwcml0ZUluZm87IFxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgXG4gICAgICAgICAgICBzd2l0Y2gocGVyayl7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGNhc2UgXCJzaGllbGRcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwcml0ZUluZm8gPSB7d2lkdGg6MTgsaGVpZ2h0OjE5LCBudW1Db2w6MSwgbnVtUm93OjIsZnBzOjYwLHNwZWVkOjEsbG9vcDpmYWxzZSxmcm9tOjAsdG86MH07XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNwcml0ZUFuaW1hdGlvbi5pbml0KHNwcml0ZUluZm8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgRGlzcGxheS5wcm90b3R5cGUuaW5pdC5jYWxsKHRoaXMsIHNwcml0ZUluZm8ud2lkdGgsIHNwcml0ZUluZm8uaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudHlwZSA9IFwic2hpZWxkXCI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBjYXNlIFwibGlmZVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgc3ByaXRlSW5mbyA9IHt3aWR0aDoxOCxoZWlnaHQ6MTksIG51bUNvbDoxLCBudW1Sb3c6MixmcHM6NjAsc3BlZWQ6MSxsb29wOmZhbHNlLGZyb206MSx0bzoxfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3ByaXRlQW5pbWF0aW9uLmluaXQoc3ByaXRlSW5mbyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBEaXNwbGF5LnByb3RvdHlwZS5pbml0LmNhbGwodGhpcywgc3ByaXRlSW5mby53aWR0aCwgc3ByaXRlSW5mby5oZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50eXBlID0gXCJsaWZlXCI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgIH07IFxuXHRcblx0UGVyay5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCl7XG5cdFx0UGh5c2ljcy5wcm90b3R5cGUuZGVzdHJveS5jYWxsKHRoaXMpO1xuXHRcdHBlcmtTb3VuZC5wbGF5KCk7XG5cdH07ICAgICAgICBcbiAgICAvL21pc3NsZSBjb25zdHJ1Y3RvclxuICAgIFxuXHRmdW5jdGlvbiBNaXNzaWxlKCl7XG4gICAgICAgIFxuICAgICAgICAgICAgUGh5c2ljcy5jYWxsKHRoaXMpO1xuICAgICAgICBcblx0XHR0aGlzLnNwZWVkID0gMztcblx0XHR0aGlzLmxpZmUgPSAwO1xuXHRcdHRoaXMubWF4TGlmZSA9IDEwMDtcbiAgICAgICAgdGhpcy50eXBlID0gXCJtaXNzaWxlXCI7XG5cblx0fVxuICAgIFxuICAgIE1pc3NpbGUucHJvdG90eXBlLnNwYXduID0gZnVuY3Rpb24oeCwgeSwgYW5nbGUsIHNwZWVkKXtcbiAgICAgICAgUGh5c2ljcy5wcm90b3R5cGUuc3Bhd24uY2FsbCh0aGlzLCB4LCB5LCBhbmdsZSwgc3BlZWQpOyAgXG4gICAgICAgIHRoaXMubGlmZSA9IDA7XG4gICAgfTtcbiAgICBcbiAgICBNaXNzaWxlLnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24oKXtcbiAgICAgICAgXG4gICAgICAgIHRoaXMubGlmZSsrO1xuXHRcdFx0aWYodGhpcy5saWZlPj10aGlzLm1heExpZmUpe1xuXHRcdFx0XHR0aGlzLmxpZmUgPSAwO1xuXHRcdFx0XHR0aGlzLmFsaXZlID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLnggKz0gdGhpcy52ZWxYO1xuXHRcdFx0dGhpcy55ICs9IHRoaXMudmVsWTtcblx0XHRcdHRoaXMuY29udGV4dC5maWxsU3R5bGUgPSB0aGlzLmNvbG9yO1xuXHRcdFx0dGhpcy5jb250ZXh0LmZpbGxSZWN0KHRoaXMueCwgdGhpcy55LCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgXG4gICAgfTtcbiAgICBcblx0ZnVuY3Rpb24gRW5lbXkoKXtcbiAgICAgICAgXG4gICAgICAgICAgICBTcGFjZWNyYWZ0LmNhbGwodGhpcyk7XG4gICAgICAgIFxuXHRcdHRoaXMudGhydXN0QWNjZWwgPSAwLjAzO1xuICAgICAgICB0aGlzLnR5cGUgPSBcImVuZW15XCI7XG4gICAgICAgIFxuXHRcdFxuICAgICAgICB2YXIgc3ByaXRlUmFuZG9tSW5kZXggPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkqNCk7XG4gICAgICAgIHRoaXMuc3ByaXRlQW5pbWF0aW9uID0gbmV3IFNwcml0ZUFuaW1hdGlvbigpO1xuICAgICAgICB0aGlzLnNwcml0ZUFuaW1hdGlvbi5zZXRDYW52YXMobWFpbkNhbnZhcyk7XG4gICAgICAgIHZhciBlbmVteVNwcml0ZUluZm8gPSB7d2lkdGg6MjMsaGVpZ2h0OjIxLCBudW1Db2w6MSwgbnVtUm93OjQsZnBzOjYwLHNwZWVkOjMwLGxvb3A6ZmFsc2UsZnJvbTpzcHJpdGVSYW5kb21JbmRleCx0bzpzcHJpdGVSYW5kb21JbmRleH07XG4gICAgICAgIHRoaXMuc3ByaXRlQW5pbWF0aW9uLmluaXQoZW5lbXlTcHJpdGVJbmZvKTtcbiAgICBcblx0fVxuICAgIFxuICAgIEVuZW15LnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24oKXtcbiAgICAgICAgXG4gICAgICAgICAgICAgICAgU3BhY2VjcmFmdC5wcm90b3R5cGUuZHJhdy5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZih0aGlzLmNvbGxpZGluZyB8fCAhdGhpcy5hbGl2ZSl7XG4gICAgICAgICAgICAgICAgcmV0dXJuOyAgIFxuICAgICAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgICAgICAgICB0aGlzLnggKz0gdGhpcy52ZWxYO1xuICAgICAgICAgICAgICAgIHRoaXMueSArPSB0aGlzLnZlbFk7XG4gICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LnNhdmUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQudHJhbnNsYXRlKHRoaXMueCt0aGlzLmNlbnRlclgsIHRoaXMueSt0aGlzLmNlbnRlclkpO1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5yb3RhdGUodGhpcy5hbmdsZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zcHJpdGVBbmltYXRpb24ucGxheSgtdGhpcy5jZW50ZXJYLCAtdGhpcy5jZW50ZXJYLCBSZXNvdXJjZUxvYWRlci5hc3NldHMuZW5lbXlTcHJpdGVTaGVldCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LnJlc3RvcmUoKTsgIFxuICAgICAgICAgICAgICAgIFxuXG4gICAgfTtcbiAgICAgICAgXG4gICAgLy9tb3RoZXJzaGlwIGNvbnN0cnVjdG9yXG4gICAgZnVuY3Rpb24gTW90aGVyc2hpcCgpe1xuICAgICAgICBcbiAgICAgICAgICAgICBTcGFjZWNyYWZ0LmNhbGwodGhpcyk7XG4gICAgICAgIFxuICAgICAgICBcbiAgICAgICAgdGhpcy5oYXNSZWxlYXNlZFNoaXBzID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc3ByaXRlQW5pbWF0aW9uID0gbmV3IFNwcml0ZUFuaW1hdGlvbigpO1xuICAgICAgICB0aGlzLnNwcml0ZUFuaW1hdGlvbi5zZXRDYW52YXMobWFpbkNhbnZhcyk7XG4gICAgICAgIHRoaXMudHlwZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5taXNzaWxlc1NwZWVkID0gMztcbiAgICAgICAgdGhpcy5hbHBoYSA9IDA7XG4gICAgICAgIHRoaXMuYWxwaGFTcGVlZCA9IDAuMDI7XG4gICAgICAgIHRoaXMubnVtU2hpcHMgPSAwO1xuICAgICAgICB0aGlzLnR5cGUgPSBcIm1vdGhlcnNoaXBcIjtcbiAgICBcbiAgICB9XG4gICAgXG4gICAgTW90aGVyc2hpcC5wcm90b3R5cGUuanVtcCA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIFxuICAgICAgICAgICAgY29uc29sZS5sb2coJ0pVTVBFRCBNT1RIRVJTSElQIScpO1xuICAgICAgICAgICAgaWYodGhpcy5hbHBoYSA9PSAwICYmIHRoaXMuaGFzUmVsZWFzZWRTaGlwcyl7XG4gICAgICAgICAgICAgICAgdGhpcy5hbGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgfSBcbiAgICAgICAgICAgIHRoaXMuYWxpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuc2hpZWxkLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICBcbiAgICAgICAgfTtcbiAgICBcbiAgICBNb3RoZXJzaGlwLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24oc2hpcFR5cGUpe1xuICAgICAgICBcbiAgICAgICAgICAgIHN3aXRjaChzaGlwVHlwZSl7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGNhc2UgXCJodW1hblwiOlxuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgdmFyIHNwcml0ZVNoZWV0SW5mbyA9IHt3aWR0aDo1MSxoZWlnaHQ6NDYsIG51bUNvbDoxLCBudW1Sb3c6MixmcHM6NjAsc3BlZWQ6MzAsbG9vcDpmYWxzZSxmcm9tOjAsdG86MH07XG4gICAgICAgICAgICAgICAgIHZhciBzcHJpdGVJbmRleCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSpzcHJpdGVTaGVldEluZm8udG8pO1xuICAgICAgICAgICAgICAgICBzcHJpdGVTaGVldEluZm8uZnJvbSA9IHNwcml0ZVNoZWV0SW5mby50byA9IHNwcml0ZUluZGV4O1xuICAgICAgICAgICAgICAgICB0aGlzLnNwcml0ZUFuaW1hdGlvbi5pbml0KHNwcml0ZVNoZWV0SW5mbyk7XG4gICAgICAgICAgICAgICAgIHRoaXMudHlwZSA9IFwiaHVtYW5cIjtcbiAgICAgICAgICAgICAgICAgdGhpcy53aWR0aCA9IHNwcml0ZVNoZWV0SW5mby53aWR0aDtcbiAgICAgICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSBzcHJpdGVTaGVldEluZm8uaGVpZ2h0O1xuICAgICAgICAgICAgICAgICB0aGlzLmNlbnRlclggPSB0aGlzLndpZHRoIC8gMjtcbiAgICAgICAgICAgICAgICAgdGhpcy5jZW50ZXJZID0gdGhpcy5oZWlnaHQgLyAyO1xuICAgICAgICAgICAgICAgICAgICBTcGFjZWNyYWZ0LnByb3RvdHlwZS5pbml0LmNhbGwodGhpcywgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgY2FzZSBcImFsaWVuXCI6XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHZhciBzcHJpdGVTaGVldEluZm8gPSB7d2lkdGg6NTEsaGVpZ2h0OjQ2LCBudW1Db2w6NCwgbnVtUm93OjIsZnBzOjYwLHNwZWVkOjMwLGxvb3A6ZmFsc2UsZnJvbTowLHRvOjR9O1xuICAgICAgICAgICAgICAgIHZhciBzcHJpdGVJbmRleCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSpzcHJpdGVTaGVldEluZm8udG8pO1xuICAgICAgICAgICAgICAgIHNwcml0ZVNoZWV0SW5mby5mcm9tID0gc3ByaXRlU2hlZXRJbmZvLnRvID0gc3ByaXRlSW5kZXg7XG4gICAgICAgICAgICAgICAgdGhpcy5zcHJpdGVBbmltYXRpb24uaW5pdChzcHJpdGVTaGVldEluZm8pO1xuICAgICAgICAgICAgICAgIHRoaXMudHlwZSA9IFwiYWxpZW5cIjtcbiAgICAgICAgICAgICAgICB0aGlzLndpZHRoID0gc3ByaXRlU2hlZXRJbmZvLndpZHRoO1xuICAgICAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gc3ByaXRlU2hlZXRJbmZvLmhlaWdodDtcbiAgICAgICAgICAgICAgICB0aGlzLmNlbnRlclggPSB0aGlzLndpZHRoIC8gMjtcbiAgICAgICAgICAgICAgICB0aGlzLmNlbnRlclkgPSB0aGlzLmhlaWdodCAvIDI7XG4gICAgICAgICAgICAgICAgICAgIFNwYWNlY3JhZnQucHJvdG90eXBlLmluaXQuY2FsbCh0aGlzLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBicmVhazsgICAgIFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgIH07XG4gICAgXG4gICAgTW90aGVyc2hpcC5wcm90b3R5cGUuc2V0UmVsZWFzZSA9IGZ1bmN0aW9uKG51bVNoaXAsIHRpbWUpe1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZih0aGlzLmhhc1JlbGVhc2VkU2hpcHMpe1xuICAgICAgICAgICAgICByZXR1cm47ICAgXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vYXNzaWducyBudW1iZXIgb2Ygc2hpcHMgdG8gcmVsZWFzZVxuICAgICAgICAgICAgdGhpcy5udW1TaGlwcyA9IG51bVNoaXA7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vY2hlY2tzIGlmIHRpbWUgdG8gcmVsZWFzZSBzaGlwcyB3YXMgcGFzc2VkIGluXG4gICAgICAgICAgICB0aW1lID0gKHRpbWUgPT0gdW5kZWZpbmVkKT8gNTogdGltZTtcblxuICAgICAgICAgICAgdmFyIGNvdW50RG93blJ1bm5pbmcgPSB0cnVlO1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRUaW1lID0gMDtcbiAgICAgICAgICAgIHZhciBmaW5hbFRpbWUgPSB0aW1lO1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aWNrKCk7ICBcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgZnVuY3Rpb24gdGljaygpe1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYoY291bnREb3duUnVubmluZyl7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgY3VycmVudFRpbWUrKztcbiAgICAgICAgICAgICAgICAgICAgaWYoY3VycmVudFRpbWUgPj0gZmluYWxUaW1lKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgTW90aGVyc2hpcC5wcm90b3R5cGUucmVsZWFzZVNoaXBzLmNhbGwoc2VsZik7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudERvd25SdW5uaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50VGltZSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aWNrKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB3aW5kb3cuc2V0VGltZW91dCh0aWNrLCAxMDAwKTsgICBcbiAgICAgICAgICAgICAgICB9ICAgIFxuICAgICAgICAgICAgfSAgIFxuICAgICAgICAgICAgIFxuICAgICAgICB9O1xuICAgIFxuICAgIE1vdGhlcnNoaXAucHJvdG90eXBlLnJlbGVhc2VTaGlwcyA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIFxuICAgICAgICAgICAgaWYoIXRoaXMuYWxpdmUpIHJldHVybjtcbiAgICAgICAgXG4gICAgICAgIGNvbnNvbGUubG9nKCdzaGlwIHJlbGVhc2UgZnVuY3Rpb24gaGFzIGJlZW4gY2FsbGVkJyk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuaGFzUmVsZWFzZWRTaGlwcyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnNoaWVsZC5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgc3dpdGNoKHRoaXMudHlwZSl7XG4gICAgICAgICAgICAgICAgY2FzZSBcImFsaWVuXCI6XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBmb3IodmFyIGk9MDsgaTx0aGlzLm51bVNoaXBzOyBpKyspe1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBvc2l0aW9uWCA9IHRoaXMueCArIGVuZW15U2hpcHNQb29sLnBvb2xbaV0ud2lkdGgqaTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBvc2l0aW9uWSA9IHRoaXMueSArIGVuZW15U2hpcHNQb29sLnBvb2xbaV0uaGVpZ2h0Kmk7XG4gICAgICAgICAgICAgICAgICAgIGVuZW15U2hpcHNQb29sLmdldChwb3NpdGlvblgsIHBvc2l0aW9uWSwgJ2VuZW15Jyk7XG4gICAgICAgICAgICAgICAgICAgIGVuZW15U2hpcHNQb29sLnBvb2xbaV0uc2hpZWxkLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICB9IFxuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcImh1bWFuXCI6XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgIGZvcih2YXIgaj0wOyBqPHRoaXMubnVtU2hpcHM7IGorKyl7XG5cbiAgICAgICAgICAgICAgICAgICAgZW5lbXlTaGlwc1Bvb2wucG9vbFtqXS5zcGF3bih0aGlzLngsIHRoaXMueSk7ICAgXG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgfSAgXG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBicmVhazsgICAgICBcbiAgICAgICAgICAgIH0gXG4gICAgICAgICAgICBcbiAgICAgICAgfTtcbiAgICBcbiAgICBcbiAgICBNb3RoZXJzaGlwLnByb3RvdHlwZS5zcGF3biA9IGZ1bmN0aW9uKHgsIHksIGFuZ2xlLCBzcGVlZCl7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIFNwYWNlY3JhZnQucHJvdG90eXBlLnNwYXduLmNhbGwodGhpcywgeCwgeSwgYW5nbGUsIHNwZWVkKTtcbiAgICAgICAgICAgIHRoaXMuaGFzUmVsZWFzZWRTaGlwcyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5hbHBoYSA9IDA7XG4gICAgICAgICAgICBcbiAgICAgICAgfTtcbiAgICBcbiAgICBNb3RoZXJzaGlwLnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgU3BhY2VjcmFmdC5wcm90b3R5cGUuZHJhdy5jYWxsKHRoaXMpO1xuICAgICAgICBcbiAgICAgICAgICAgIGlmKHRoaXMuY29sbGlkaW5nIHx8ICF0aGlzLmFsaXZlKXtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnc2hpcHMgZGVhZCB3b250IGRyYXcgaXQnKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnggKz0gdGhpcy52ZWxYO1xuICAgICAgICAgICAgdGhpcy55ICs9IHRoaXMudmVsWTtcbiAgICAgICAgXG4gICAgICAgIFxuICAgICAgICAgICAgdGhpcy5jb250ZXh0LnNhdmUoKTtcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC50cmFuc2xhdGUodGhpcy54K3RoaXMuY2VudGVyWCwgdGhpcy55K3RoaXMuY2VudGVyWSk7XG4gICAgICAgICAgICB0aGlzLmNvbnRleHQucm90YXRlKHRoaXMuYW5nbGUpO1xuICAgICAgICAgICAgaWYodGhpcy5oYXNSZWxlYXNlZFNoaXBzKXtcbiAgICAgICAgICAgICAgICB0aGlzLmFscGhhIC09IHRoaXMuYWxwaGFTcGVlZDsgICBcbiAgICAgICAgICAgICAgICB0aGlzLmFscGhhID0gKHRoaXMuYWxwaGEgPD0gMCk/IDA6IHRoaXMuYWxwaGE7IFxuICAgICAgICAgICAgICAgIHRoaXMuYWxpdmUgPSAodGhpcy5hbHBoYSA8PSAwKT8gZmFsc2UgOiB0cnVlO1xuICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICB0aGlzLmFscGhhICs9IHRoaXMuYWxwaGFTcGVlZDtcbiAgICAgICAgICAgIHRoaXMuYWxwaGEgPSAodGhpcy5hbHBoYSA+PSAxKT8gMTogdGhpcy5hbHBoYTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5nbG9iYWxBbHBoYSA9IHRoaXMuYWxwaGE7XG4gICAgICAgICAgICB0aGlzLnNwcml0ZUFuaW1hdGlvbi5wbGF5KC10aGlzLmNlbnRlclgsIC10aGlzLmNlbnRlclksIFJlc291cmNlTG9hZGVyLmFzc2V0cy5Nb3RoZXJzaGlwU3ByaXRlU2hlZXQpO1xuICAgICAgICAgICAgdGhpcy5jb250ZXh0LnJlc3RvcmUoKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYodGhpcy5hbHBoYSA8PSAwKXtcbiAgICAgICAgICAgICAgICB0aGlzLmFsaXZlID0gZmFsc2U7XG4gICAgICAgICAgICB9IFxuICAgICAgICB9O1xuICAgIFxuICAgIFxuICAgIFxuICAgIFxuICAgIC8vIGV4cGxvc2lvbiBjb25zdHJ1Y3RvclxuXHRmdW5jdGlvbiBFeHBsb3Npb24obnVtUGFydGljbGVzKXtcbiAgICAgICAgXG4gICAgICAgICAgICBEaXNwbGF5LmNhbGwodGhpcyk7XG4gICAgICAgIFxuXHRcdHRoaXMucnVubmluZyA9IGZhbHNlO1xuXHRcdHRoaXMucGFydGljbGVzID0gW107XG5cdFx0dGhpcy5kZWFkUGFydGljbGVDb3VudGVyID0gMDtcblx0XHR0aGlzLnNpemUgPSBudW1QYXJ0aWNsZXM7XG4gICAgICAgIFxuXHRcdGZvcih2YXIgaSA9IDA7IGk8bnVtUGFydGljbGVzOyBpKyspe1xuXHRcdFx0dGhpcy5wYXJ0aWNsZXMucHVzaCh7eDowLHk6MCxhbGl2ZTpmYWxzZSxtYXhMaWZlOjAsdmVsWDowLHZlbFk6MCwgd2lkdGg6MiwgaGVpZ2h0OjIsIGxpZmU6MH0pO1xuXHRcdH1cblx0XHRcdFxuXHR9XG4gICAgXG4gICAgRXhwbG9zaW9uLnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbih4LCB5KXtcbiAgICAgICAgaWYodGhpcy5ydW5uaW5nKXtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRmb3IodmFyIGk9MDtpPHRoaXMuc2l6ZTtpKyspe1xuXHRcdFx0XHR2YXIgY3VycmVudFBhcnRpY2xlID0gdGhpcy5wYXJ0aWNsZXNbaV07XG5cdFx0XHRcdGN1cnJlbnRQYXJ0aWNsZS54ID0geDtcblx0XHRcdFx0Y3VycmVudFBhcnRpY2xlLnkgPSB5O1xuXHRcdFx0XHRjdXJyZW50UGFydGljbGUubWF4TGlmZSA9IE1hdGgucmFuZG9tKCkqNDUrMTU7XG5cdFx0XHRcdGN1cnJlbnRQYXJ0aWNsZS52ZWxYID0gTWF0aC5yYW5kb20oKSo0LTIuODtcblx0XHRcdFx0Y3VycmVudFBhcnRpY2xlLnZlbFkgPSBNYXRoLnJhbmRvbSgpKjQtMi44O1xuXHRcdFx0XHRjdXJyZW50UGFydGljbGUuYWxpdmUgPSB0cnVlO1xuXHRcdFx0XHRjdXJyZW50UGFydGljbGUubGlmZSA9IDA7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLnJ1bm5pbmcgPSB0cnVlO1xuXHRcdFx0dGhpcy5kZWFkUGFydGljbGVDb3VudGVyID0gMDtcbiAgICB9O1xuICAgIEV4cGxvc2lvbi5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIFxuICAgICAgICBpZighdGhpcy5ydW5uaW5nKXtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHR0aGlzLmNvbnRleHQuZmlsbFN0eWxlID0gJyMwMEZGMDAnO1xuXHRcdFx0Zm9yKHZhciBpPTA7IGk8dGhpcy5zaXplOyBpKyspe1xuXHRcdFx0XHR2YXIgY3VycmVudFBhcnRpY2xlID0gdGhpcy5wYXJ0aWNsZXNbaV07XG5cdFx0XHRcdGlmKGN1cnJlbnRQYXJ0aWNsZS5hbGl2ZSl7XG5cdFx0XHRcdGN1cnJlbnRQYXJ0aWNsZS54ICs9IGN1cnJlbnRQYXJ0aWNsZS52ZWxYO1xuXHRcdFx0XHRjdXJyZW50UGFydGljbGUueSArPSBjdXJyZW50UGFydGljbGUudmVsWTtcblx0XHRcdFx0Y3VycmVudFBhcnRpY2xlLmxpZmUrKztcblx0XHRcdFx0dGhpcy5jb250ZXh0LmZpbGxSZWN0KGN1cnJlbnRQYXJ0aWNsZS54LCBjdXJyZW50UGFydGljbGUueSwgY3VycmVudFBhcnRpY2xlLndpZHRoLCBjdXJyZW50UGFydGljbGUuaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGN1cnJlbnRQYXJ0aWNsZS5saWZlID49IGN1cnJlbnRQYXJ0aWNsZS5tYXhMaWZlKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQYXJ0aWNsZS5hbGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFBhcnRpY2xlLmxpZmUgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWFkUGFydGljbGVDb3VudGVyKys7XG4gICAgICAgICAgICAgICAgICAgIH1cblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdH1cbi8vY2hhbmdlIHRoZSBzdGF0ZSBmcm9tIHJ1bm5pbmcgdG8gZmFsc2UgYnkgY2hlY2tpbmcgaWYgdGhlcmUgYXJlIGFueSBwYXJ0aWNsZXMgYWxpdmUgbGVmdFxuXHRcdFx0aWYodGhpcy5kZWFkUGFydGljbGVDb3VudGVyPj10aGlzLnNpemUpe1xuXHRcdFx0XHR0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcblx0XHRcdH1cbiAgICAgICAgXG4gICAgfTtcbiAgICBcbiAgICAvL1NoaWVsZCBjb25zdHJ1Y3RvclxuXHRmdW5jdGlvbiBTaGllbGQoKXtcbiAgICAgICAgXG4gICAgICAgICAgICBEaXNwbGF5LmNhbGwodGhpcyk7XG4gICAgICAgIFxuXHRcdHRoaXMucmFkaXVzID0gNDA7XG5cdFx0dGhpcy5tYXhSYWRpdXMgPSA0NTtcbiAgICAgICAgdGhpcy5saWZlID0gMTAwO1xuICAgICAgICB0aGlzLmRpc2FibGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY29sb3IgPSAnIzAwMDBGRic7XG4gICAgICAgIHRoaXMudHlwZSA9ICdzaGllbGQnO1xuICAgICAgICB2YXIgc2hpZWxkU3RhdGUgPSBmYWxzZTtcbiAgICBcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiYWN0aXZlXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICByZXR1cm4gc2hpZWxkU3RhdGU7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSl7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgc2hpZWxkU3RhdGUgPSAodGhpcy5kaXNhYmxlZCk/IGZhbHNlOiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmFsaXZlID0gc2hpZWxkU3RhdGU7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIFxuXHR9XG4gICAgXG4gICAgU2hpZWxkLnByb3RvdHlwZS5yZWR1Y2VMaWZlID0gZnVuY3Rpb24oYW1vdW50KXtcbiAgICAgICAgYW1vdW50ID0gKGFtb3VudCA9PT0gdW5kZWZpbmVkKT8gNTA6IGFtb3VudDtcbiAgICAgICAgdGhpcy5saWZlIC09IGFtb3VudDtcbiAgICB9O1xuICAgIFxuICAgIFNoaWVsZC5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIFxuICAgICAgICAgICAgaWYoIXRoaXMuYWN0aXZlKXtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnc2hpZWxkIGlzIGRpc2FibGVkJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYodGhpcy5saWZlIDw9IDApe1xuICAgICAgICAgICAgICAgIHRoaXMubGlmZSA9IDA7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNhYmxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXHRcdFx0dGhpcy5jb250ZXh0LnN0cm9rZVN0eWxlID0gdGhpcy5jb2xvcjtcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5saW5lV2lkdGggPSAxO1xuXHRcdFx0dGhpcy5jb250ZXh0LmJlZ2luUGF0aCgpOyBcblx0XHRcdHRoaXMuY29udGV4dC5hcmModGhpcy54K3RoaXMuY2VudGVyWCwgdGhpcy55K3RoaXMuY2VudGVyWSwgdGhpcy5yYWRpdXMsIDAsIE1hdGguUEkqMiwgdHJ1ZSk7XG5cdFx0XHR0aGlzLmNvbnRleHQuY2xvc2VQYXRoKCk7XG5cdFx0XHR0aGlzLmNvbnRleHQuc3Ryb2tlKCk7IFxuXHRcdFx0dGhpcy5yYWRpdXMgKz0gLjI1O1xuXHRcdFx0dGhpcy5yYWRpdXMgPSAodGhpcy5yYWRpdXM+dGhpcy5tYXhSYWRpdXMpPyA0MDogdGhpcy5yYWRpdXM7XG4gICAgICAgIFxuICAgIH07XG4gICAgXG4gICAgU2hpZWxkLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICB0aGlzLmxpZmUgPSAxMDA7XG4gICAgICAgICAgICB0aGlzLmRpc2FibGVkID0gZmFsc2U7XG4gICAgfTtcbiAgICBcbiAgICBcbiAgICAvL21ldGVvciBwb29sXG5cdGZ1bmN0aW9uIFBvb2wobWF4U2l6ZSl7XG4gICAgICAgIFxuXHRcdHZhciBwb29sID0gW107XG4gICAgICAgIFxuXHRcdHRoaXMucG9vbCA9IHBvb2w7XG4gICAgICAgIHRoaXMuc2l6ZSA9IG1heFNpemU7XG4gICAgICAgIFxuXHR9XG4gICAgXG4gICAgUG9vbC5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKHR5cGUpe1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBzd2l0Y2godHlwZSl7XG4gICAgICAgICAgICAgICAgY2FzZSBcIm1pc3NpbGVcIjpcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICBmb3IodmFyIGk9MDsgaTx0aGlzLnNpemU7IGkrKyl7XG5cdFx0XHRcdFx0dmFyIG1pc3NpbGUgPSBuZXcgTWlzc2lsZSgpO1xuXHRcdFx0XHRcdG1pc3NpbGUuc2V0Q2FudmFzKG1haW5DYW52YXMpO1xuXHRcdFx0XHRcdG1pc3NpbGUuaW5pdCgyLDIpO1xuXHRcdFx0XHRcdHRoaXMucG9vbFtpXSA9IG1pc3NpbGU7XG5cdFx0XHRcdH0gIFxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgY2FzZSBcImVuZW15XCI6XG4gICAgICAgICAgICAgICAgICAgZm9yKHZhciBqPTA7IGo8dGhpcy5zaXplOyBqKyspe1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmFuZG9tWCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSptYWluQ2FudmFzLndpZHRoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJhbmRvbVkgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkqbWFpbkNhbnZhcy5oZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVuZW15ID0gbmV3IEVuZW15KCk7XG4gICAgICAgICAgICAgICAgICAgIGVuZW15LnNldENhbnZhcyhtYWluQ2FudmFzKTtcbiAgICAgICAgICAgICAgICAgICAgZW5lbXkuaW5pdCgyMywgMjEpO1xuICAgICAgICAgICAgICAgICAgICBlbmVteS54ID0gcmFuZG9tWDtcbiAgICAgICAgICAgICAgICAgICAgZW5lbXkueSA9IHJhbmRvbVk7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wb29sW2pdID0gZW5lbXk7XG4gICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIH0gXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBjYXNlIFwicGVya3NcIjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zaXplID0gTWF0aC5mbG9vcih0aGlzLnNpemUgLyAyKTtcblxuICAgICAgICAgICAgICAgICAgICBmb3IodmFyIGs9MDsgazx0aGlzLnNpemU7IGsrKyl7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGlmZSA9IG5ldyBQZXJrKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaWZlLnNldENhbnZhcyhtYWluQ2FudmFzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpZmUuaW5pdChcImxpZmVcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBvb2wucHVzaChsaWZlKTsgXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBmb3IodmFyIGg9MDsgaDx0aGlzLnNpemU7IGgrKyl7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2hpZWxkID0gbmV3IFBlcmsoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNoaWVsZC5zZXRDYW52YXMobWFpbkNhbnZhcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaGllbGQuaW5pdChcInNoaWVsZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucG9vbC5wdXNoKHNoaWVsZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2l6ZSAqPSAyO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGNhc2UgXCJyb2Nrc1wiOlxuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgdmFyIG51bU1lZGl1bVJvY2tzID0gdGhpcy5zaXplKjI7XG4gICAgICAgICAgICAgICAgICAgIHZhciBudW1TbWFsbFJvY2tzID0gbnVtTWVkaXVtUm9ja3MqMjtcblxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBsPTA7IGw8dGhpcy5zaXplOyBsKyspe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtZXRlb3IgPSBuZXcgUm9jaygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGVvci5zZXRDYW52YXMobWFpbkNhbnZhcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0ZW9yLmluaXQoXCJsYXJnZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRlb3IudHlwZSA9IFwibGFyZ2VSb2NrXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wb29sLnB1c2gobWV0ZW9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcih2YXIgbT0wOyBtPG51bU1lZGl1bVJvY2tzOyBtKyspe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtZXRlb3JNZWRpdW0gPSBuZXcgUm9jaygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGVvck1lZGl1bS5zZXRDYW52YXMobWFpbkNhbnZhcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0ZW9yTWVkaXVtLmluaXQoXCJtZWRpdW1cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0ZW9yTWVkaXVtLnR5cGUgPSBcIm1lZGl1bVJvY2tcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBvb2wucHVzaChtZXRlb3JNZWRpdW0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBuPTA7IG48bnVtU21hbGxSb2NrczsgbisrKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWV0ZW9yU21hbGwgPSBuZXcgUm9jaygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGVvclNtYWxsLnNldENhbnZhcyhtYWluQ2FudmFzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRlb3JTbWFsbC5pbml0KFwic21hbGxcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0ZW9yU21hbGwudHlwZSA9IFwic21hbGxSb2NrXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wb29sLnB1c2gobWV0ZW9yU21hbGwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zaXplICs9IChudW1NZWRpdW1Sb2NrcytudW1TbWFsbFJvY2tzKTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgfTtcbiAgICBcbiAgICBQb29sLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbih4LCB5LCB0eXBlLCBhbmdsZSwgc3BlZWQpe1xuICAgICAgICBcbiAgICAgICAgICAgIHR5cGUgPSB0eXBlIHx8IFwibWlzc2lsZVwiO1xuICAgICAgICBcbiAgICAgICAgICAgIC8qIGNvZGUgZnJvbSBiZWZvcmUgbWl4aW5nIGJvdGggcG9vbHMgbWV0ZW9yIGFuZCByZWd1bGFyIFxuXHRcdFx0aWYoIXRoaXMucG9vbFtzaXplLTFdLmFsaXZlKXtcblx0XHRcdFx0dGhpcy5wb29sW3NpemUtMV0uc3Bhd24oeCx5LCBhbmdsZSwgc3BlZWQpO1xuXHRcdFx0XHR0aGlzLnBvb2wudW5zaGlmdChwb29sLnBvcCgpKTtcblx0XHRcdH1cbiAgICAgICAgICAgICovXG4gICAgICAgICAgICB2YXIgaSA9IDA7XG5cbiAgICAgICAgICAgICAgICB3aGlsZShpPHRoaXMuc2l6ZSl7XG4gICAgICAgICAgICAgICAgICAgIGlmKHRoaXMucG9vbFtpXS50eXBlID09PSB0eXBlICYmICF0aGlzLnBvb2xbaV0uYWxpdmUpe1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wb29sW2ldLnNwYXduKHgsIHksIGFuZ2xlLCBzcGVlZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpKys7ICAgICBcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIFxuICAgIH07XG5cbiAgICBQb29sLnByb3RvdHlwZS5pc0NvbGxpZGluZ1dpdGggPSBmdW5jdGlvbihhcmdzKXtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdmFyIGxlbmd0aCA9IHRoaXMucG9vbC5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgYXJnc0xlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGk8bGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHZhciBjdXJyZW50SXRlbSA9IHRoaXMucG9vbFtpXTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZihjdXJyZW50SXRlbS5hbGl2ZSl7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgZm9yKHZhciBoID0gMDsgaDxhcmdzTGVuZ3RoOyBoKyspe1xuICAgICAgICAgICAgICAgICAgICAvL2VhY2ggYXJndW1lbnQgcmVwcmVzZW50cyB0aGUgb2JqZWN0cyBiZWluZyBwYXNzZWQgaW4gdG8gdGhpcyBtZXRob2QuXG4gICAgICAgICAgICAgICAgICAgIHZhciBjdXJyZW50QXJndW1lbnQgPSBhcmd1bWVudHNbaF07XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Ly9pZiBvbmUgb2YgdGhlIGFyZ3VtZW50cyB0byBjaGVjayBmb3IgY29sbGlzaW9uIGlzIGEgcG9vbCBvZiBvYmplY3RzLCBpdGVyYXRlIG92ZXIgZWFjaCBpdGVtLlxuXHRcdFx0XHRcdGlmKEFycmF5LmlzQXJyYXkoY3VycmVudEFyZ3VtZW50KSl7XG5cdFx0XHRcdFx0XHRmb3IodmFyIGogPSAwLCBsZW4gPSBjdXJyZW50QXJndW1lbnQubGVuZ3RoOyBqIDwgbGVuOyBqKyspe1xuXHRcdFx0XHRcdFx0XHR2YXIgY3VycmVudFBvb2xJdGVtID0gY3VycmVudEFyZ3VtZW50W2pdO1xuXHRcdFx0XHRcdFx0XHRjaGVja0NvbGxpc2lvbihjdXJyZW50SXRlbSwgY3VycmVudFBvb2xJdGVtKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9ZWxzZXtcblx0XHRcdFx0XHRcdFx0Y2hlY2tDb2xsaXNpb24oY3VycmVudEl0ZW0sIGN1cnJlbnRBcmd1bWVudCk7XG5cdFx0XHRcdFx0fVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgfVxuXHRcdFx0Ly9mdW5jdGlvbiBpbiBjaGFyZ2Ugb2YgdGVzdGluZyBmb3IgY29sbGlzaW9uIGFuZCBleGVjdXRpbmcgd2hhdCB0byBkbyB3aGVuIHRoZXJlIGlzIGEgY29sbGlzaW9uLCBpdCBhbHNvIG1ha2VzIGEgY2FsbCB0byB0aGUgcmVjb3JkQ29sbGlzaW9uIGZ1bmN0aW9uIHdoaWNoIGhhbmRsZXMgdGhlIHJlY29yZGluZyBvZiBjb2xsaXNpb25zIGZvciBwb2ludHMgYW5kIHNjb3JlLlxuXHRcdFx0ZnVuY3Rpb24gY2hlY2tDb2xsaXNpb24oaXRlbTEsIGl0ZW0yKXtcblx0XHRcdFx0XG5cdFx0XHRcdFx0aWYoaGl0VGVzdChpdGVtMSwgaXRlbTIpKXtcblx0XHRcdFx0XHRcdFx0aWYoaXRlbTIgaW5zdGFuY2VvZiBTaGllbGQpe1xuXHRcdFx0XHRcdFx0XHRcdGlmKCEoaXRlbTEgaW5zdGFuY2VvZiBSb2NrKSl7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGl0ZW0xLmRlc3Ryb3koKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0aXRlbTIucmVkdWNlTGlmZSgxMCk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJlY29yZENvbGxpc2lvbihpdGVtMS50eXBlKTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9ZWxzZSBpZihpdGVtMSBpbnN0YW5jZW9mIFBlcmspe1xuXHRcdFx0XHRcdFx0XHRcdFx0aXRlbTEuZGVzdHJveSgpO1xuXHRcdFx0XHRcdFx0XHRcdFx0cmVjb3JkQ29sbGlzaW9uKGl0ZW0xLnR5cGUpO1xuXHRcdFx0XHRcdFx0XHRcdH1lbHNle1xuXHRcdFx0XHRcdFx0XHRcdFx0aXRlbTIuZGVzdHJveSgpO1xuXHRcdFx0XHRcdFx0XHRcdFx0aXRlbTEuZGVzdHJveSgpO1xuXHRcdFx0XHRcdFx0XHRcdFx0cmVjb3JkQ29sbGlzaW9uKGl0ZW0yLnR5cGUpO1xuXHRcdFx0XHRcdFx0XHRcdFx0cmVjb3JkQ29sbGlzaW9uKGl0ZW0xLnR5cGUpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0fVxuICAgIH07XG4gICAgXG4gICAgUG9vbC5wcm90b3R5cGUuaGlkZUl0ZW1zICA9IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICB2YXIgbGVuZ3RoID0gdGhpcy5wb29sLmxlbmd0aDtcbiAgICAgICAgICAgIGZvcih2YXIgaT0wOyBpPGxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgICAgICB0aGlzLnBvb2xbaV0uYWxpdmUgPSBmYWxzZTsgXG4gICAgICAgICAgICB9XG4gICAgfTtcbiAgICAgICAgXG5cdGZ1bmN0aW9uICQoc2VsZWN0b3Ipe1xuXHQgICAgICAgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpO1xuICAgIH1cblx0XG5cdC8vZW5kIG9mIGNhbnZhc0FwcCBmdW5jdGlvblxufVxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2pzL21haW4uanNcbiAqKiBtb2R1bGUgaWQgPSAwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgRGlzcGxheSA9IChmdW5jdGlvbigpe1xyXG5cdFxyXG5cdGZ1bmN0aW9uIERpc3BsYXkoKXtcclxuICAgICAgIFxyXG5cdFx0dGhpcy5jYW52YXNXaWR0aCA9IDA7XHJcblx0XHR0aGlzLmNhbnZhc0hlaWdodCA9IDA7XHJcblx0XHR0aGlzLmNlbnRlclggPSAwO1xyXG5cdFx0dGhpcy5jZW50ZXJZID0gMDtcclxuXHRcdHRoaXMuaGVpZ2h0ID0gMDtcclxuXHRcdHRoaXMud2lkdGggPSAwO1xyXG5cdFx0dGhpcy54ID0gMDtcclxuXHRcdHRoaXMueSA9IDA7XHJcblx0XHR0aGlzLmNvbG9yID0gXCIjMDBGRjAwXCI7XHJcblx0XHR0aGlzLmFscGhhID0gMTtcclxuICAgICAgICB0aGlzLmFsaXZlID0gZmFsc2U7ICBcclxuICAgICAgICB0aGlzLmNvbnRleHQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy50eXBlID0gXCJkaXNwbGF5XCI7XHJcbiAgICAgICBcclxuXHR9XHJcbiAgICAgICAgLy90ZW1wIHByb3RvIG1ldGhvZC4uLi5cclxuICAgIERpc3BsYXkucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24oKXtcclxuXHRcdFx0dGhpcy54ID0gMDtcclxuXHRcdFx0dGhpcy55ID0gMDtcclxuXHRcdFx0dGhpcy5hbmdsZSA9IDA7XHJcblx0XHRcdHRoaXMudmVsWCA9IDA7XHJcblx0XHRcdHRoaXMudmVsWSA9IDA7XHJcblx0XHRcdHRoaXMuYWxpdmUgPSBmYWxzZTtcclxuXHRcdFx0dGhpcy5jb2xsaWRpbmcgPSBmYWxzZTtcclxuXHRcdH07XHJcbiAgICBcclxuICAgIERpc3BsYXkucHJvdG90eXBlLnNldENhbnZhcyA9IGZ1bmN0aW9uKGNhbnZhcyl7XHJcblx0XHRcdHRoaXMuY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xyXG5cdFx0XHR0aGlzLmNhbnZhc1dpZHRoID0gY2FudmFzLndpZHRoO1xyXG5cdFx0XHR0aGlzLmNhbnZhc0hlaWdodCA9IGNhbnZhcy5oZWlnaHQ7XHJcblx0XHR9O1xyXG4gICAgXHJcbiAgICBEaXNwbGF5LnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24od2lkdGgsIGhlaWdodCl7XHJcblx0XHRcdHRoaXMud2lkdGggPSB3aWR0aCB8fCAyMDtcclxuXHRcdFx0dGhpcy5oZWlnaHQgPSBoZWlnaHQgfHwgMjA7XHJcblx0XHRcdHRoaXMuY2VudGVyWCA9IHdpZHRoLzI7XHJcblx0XHRcdHRoaXMuY2VudGVyWSA9IGhlaWdodC8yO1xyXG5cdFx0XHR0aGlzLmFsaXZlID0gZmFsc2U7XHJcblx0XHR9O1xyXG4gICAgXHJcbiAgICAvL1BoeXNpY3MgZGF0YSB0eXBlXHJcblx0XHJcblx0cmV0dXJuIERpc3BsYXk7XHJcblx0XHJcblx0XHJcbn0pKCk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IERpc3BsYXk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2pzL0Rpc3BsYXkuanNcbiAqKiBtb2R1bGUgaWQgPSAxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgU3ByaXRlQW5pbWF0aW9uID0gKGZ1bmN0aW9uKCl7XG5cdCBcbiAgICAgZnVuY3Rpb24gU3ByaXRlQW5pbWF0aW9uKCl7XG5cdFx0IFxuICAgICAgICB0aGlzLndpZHRoO1xuICAgICAgICB0aGlzLmhlaWdodDtcbiAgICAgICAgdGhpcy54O1xuICAgICAgICB0aGlzLnk7XG5cdFx0dGhpcy5vZmZzZXRYID0gMDtcblx0XHR0aGlzLm9mZnNldFkgPSAwO1xuICAgICAgICB0aGlzLmNvbnRleHQ7XG4gICAgICAgIHRoaXMuY2FudmFzSGVpZ2h0O1xuICAgICAgICB0aGlzLmNhbnZhc1dpZHRoO1xuICAgICAgICB0aGlzLnNwZWVkO1xuICAgICAgICB0aGlzLm51bUNvbDtcbiAgICAgICAgdGhpcy5udW1Sb3c7XG4gICAgICAgIHRoaXMuY3VycmVudEZyYW1lO1xuICAgICAgICB0aGlzLmZpbmFsRnJhbWU7XG4gICAgICAgIHRoaXMuc3RhcnRGcmFtZTtcbiAgICAgICAgdGhpcy50b3RhbEZyYW1lcztcbiAgICAgICAgdGhpcy5hcHBGUFM7XG5cdFx0IC8vc3ByaXRlc2hlZXQgYW5pbWF0aW9ucyBsb29wcyBieSBkZWZhdWx0XG4gICAgICAgIHRoaXMubG9vcCA9IHRydWU7XG5cdFx0ICAgIC8vcHJpdmF0ZSBtZW1iZXJzIFxuICAgICBcdHRoaXMuX2ZyYW1lcyA9IFtdO1xuICAgICAgICB0aGlzLl9mcmFtZUluY3JlbWVudDtcbiAgICAgICAgdGhpcy5fZnJhbWVJbmRleDtcblxuXHRcdCBcblx0IH1cblx0XG4gICAgIFNwcml0ZUFuaW1hdGlvbi5wcm90b3R5cGUuc2V0Q2FudmFzID0gZnVuY3Rpb24oY2FudmFzKXtcbiAgICAgICAgICAgIHRoaXMuY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICAgICAgdGhpcy5jYW52YXNIZWlnaHQgPSBjYW52YXMuaGVpZ2h0O1xuICAgICAgICAgICAgdGhpcy5jYW52YXNXaWR0aCA9IGNhbnZhcy53aWR0aDtcbiAgICAgIH07XG5cdFxuICAgICBTcHJpdGVBbmltYXRpb24ucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbihzcHJpdGVPYmplY3Qpe1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvL3NldHMgdXAgc3ByaXRlIHByb3BlcnRpZXMgZnJvbSB0aGUgc3ByaXRlc2hlZXQgaW5mbyBvYmplY3QgYmVpbmcgcGFzc2VkIGluLlxuICAgICAgICAgICAgdGhpcy53aWR0aCA9IHNwcml0ZU9iamVjdC53aWR0aCB8fCAzMjtcbiAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gc3ByaXRlT2JqZWN0LmhlaWdodCB8fCAzMjtcbiAgICAgICAgICAgIHRoaXMubnVtQ29sID0gc3ByaXRlT2JqZWN0Lm51bUNvbCB8fCAxO1xuICAgICAgICAgICAgdGhpcy5udW1Sb3cgPSBzcHJpdGVPYmplY3QubnVtUm93IHx8IDE7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0RnJhbWUgPSBzcHJpdGVPYmplY3QuZnJvbSB8fCAwO1xuICAgICAgICAgICAgdGhpcy5maW5hbEZyYW1lID0gc3ByaXRlT2JqZWN0LnRvIHx8IDA7XG4gICAgICAgICAgICB0aGlzLnNwZWVkID0gc3ByaXRlT2JqZWN0LnNwZWVkIHx8IDE1O1xuXHRcdCBcdHRoaXMub2Zmc2V0WCA9IHNwcml0ZU9iamVjdC5vZmZzZXRYIHx8IDA7XG5cdFx0IFx0dGhpcy5vZmZzZXRZID0gc3ByaXRlT2JqZWN0Lm9mZnNldFkgfHwgMDtcbiAgICAgICAgICAgIHRoaXMudG90YWxGcmFtZXMgPSBzcHJpdGVPYmplY3QubnVtQ29sICogc3ByaXRlT2JqZWN0Lm51bVJvdyAtIDE7XG4gICAgICAgICAgICB0aGlzLmxvb3AgPSBzcHJpdGVPYmplY3QubG9vcCB8fCB0cnVlO1xuICAgICAgICAgICAgdGhpcy5hcHBGUFMgPSBzcHJpdGVPYmplY3QuZnBzO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvL2NyZWF0ZXMgdGhlIGRlY2ltYWwgb2YgaW5jcmVtZW50IGZvciBlYWNoIHNlY29uZFxuICAgICAgICAgICAgdGhpcy5fZnJhbWVJbmNyZW1lbnQgPSB0aGlzLnNwZWVkL3Nwcml0ZU9iamVjdC5mcHM7XG4gICAgICAgICAgICB0aGlzLl9mcmFtZUluZGV4ID0gdGhpcy5zdGFydEZyYW1lOyAgICAgICAgXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vY3JlYXRlcyBhIHZhcmlhYmxlIGhvbGRpbmcgdGhlIGxlbmd0aCBvZiB0aGUgYXJyYXkgaG9sZGluZyB0aGUgZnJhbWVzXG4gICAgICAgICAgICB2YXIgdG90YWxGcmFtZXNMZW5ndGggPSBzcHJpdGVPYmplY3QubnVtQ29sICogc3ByaXRlT2JqZWN0Lm51bVJvdztcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHRvdGFsRnJhbWVzTGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgICAgIHZhciBmcmFtZSA9IHt9O1xuXHRcdFx0XHRcdGZyYW1lLnJlZ1ggPSB0aGlzLm9mZnNldFg7XG5cdFx0XHRcdFx0ZnJhbWUucmVnWSA9IHRoaXMub2Zmc2V0WTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvL2luZGV4ZXMgdGhlIHJlZ1ggYW5kIHJlZ1kgcG9pbnRzIG9mIGVhY2ggc3ByaXRlIGZyYW1lIGludG8gdGhlIGFycmF5LlxuICAgICAgICAgICAgICAgIGlmKGk+PXRoaXMubnVtQ29sKXtcbiAgICAgICAgICAgICAgICAgICAgZnJhbWUucmVnWCArPSAoaSAtIE1hdGguZmxvb3IoaS90aGlzLm51bUNvbCkqdGhpcy5udW1Db2wpKnRoaXMud2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIGZyYW1lLnJlZ1kgKz0gTWF0aC5mbG9vcihpL3RoaXMubnVtQ29sKSp0aGlzLmhlaWdodDtcblxuICAgICAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICAgICAgICBmcmFtZS5yZWdYICs9IGkgKiB0aGlzLndpZHRoO1xuICAgICAgICAgICAgICAgICAgICBmcmFtZS5yZWdZICs9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vcHVzaGVzIHRoZSBvYmplY3RzIHdpdGggdGhlIHJlZ1ggYW5kIHJlZ1kgZm9yIGVhY2ggZnJhbWUgaW50byBhIGZyYW1lIGFycmF5LlxuICAgICAgICAgICAgICAgIHRoaXMuX2ZyYW1lcy5wdXNoKGZyYW1lKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgXG4gICAgICAgIH07XG4gICAgICAgIC8vdXNlIHRoaXMgbWV0aG9kIHRvIGxvY2F0ZSBvciBtb3ZlIHRoZSBzcHJpdGUgc2hlZXQgdG8gYSBjb3JkaW5hdGVcbiAgICAgICAgU3ByaXRlQW5pbWF0aW9uLnByb3RvdHlwZS5wbGF5ID0gZnVuY3Rpb24oeCwgeSwgc3ByaXRlKXtcbiAgICAgICAgICAgIHRoaXMueCA9IHggfHwgMDtcbiAgICAgICAgICAgIHRoaXMueSA9IHkgfHwgMDtcblxuICAgICAgICAgICAgLy9ubyBhbmltYXRpb24gd2lsbCBiZSBwbGF5ZWVkIGlmIHRoZSBzdGFydGluZyBmcmFtZSBpcyBlcXVhbCB0byB0aGUgZmluYWwgZnJhbWUuXG4gICAgICAgICAgICBpZih0aGlzLnN0YXJ0RnJhbWUgPT09IHRoaXMuZmluYWxGcmFtZSl7XG5cdFx0XHRcdFxuXHQvL3N1cnJvdW5kcyB0aGUgc3ByaXRlIGludG8gYSB3aGl0ZSBibG9jayBmb3IgZGVidWdnaW5nIHB1cnBvc2VzLCB5b3UgY2FuIHJlbW92ZSB0aGlzIGluIHlvdXIgZmluYWwgYXBwXG4gICAgICAgICAgICAgICAgLy90aGlzLmNvbnRleHQuc3Ryb2tlU3R5bGUgPSAnI0ZGRkZGRic7XG4gICAgICAgICAgICAgICAgLy90aGlzLmNvbnRleHQuc3Ryb2tlUmVjdCh0aGlzLngsIHRoaXMueSwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50RnJhbWUgPSB0aGlzLl9mcmFtZXNbdGhpcy5zdGFydEZyYW1lXTtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuZHJhd0ltYWdlKHNwcml0ZSwgdGhpcy5jdXJyZW50RnJhbWUucmVnWCwgdGhpcy5jdXJyZW50RnJhbWUucmVnWSwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQsIHRoaXMueCwgdGhpcy55LCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgICAvL2luY3JlbWVudHMgdGhlIGZyYW1lSW5kZXggYnkgYSBkZWNpbWFsLCB0aGlzIHdpbGwgYmUgZmxvb3JlZCBiZWNhdXNlIGl0IGlzIHVzZWQgdG8gZmluZCBhbiBpdGVtIGluIHRoZSBmcmFtZSBhcnJheS5cbiAgICAgICAgICAgICAgICB0aGlzLl9mcmFtZUluZGV4ICs9IHRoaXMuX2ZyYW1lSW5jcmVtZW50O1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmKHRoaXMuX2ZyYW1lSW5kZXggPj0gdGhpcy5maW5hbEZyYW1lICsgMSl7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2ZyYW1lSW5kZXggPSAodGhpcy5sb29wKT8gdGhpcy5zdGFydEZyYW1lOiB0aGlzLmZpbmFsRnJhbWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vZmxvb3JzIHRoZSBjdXJyZW50IGluZGV4IHRvIGEgd2hvbGUgbnVtYmVyIHNvIHRvIGZpbmQgYW4gb2JqZWN0IGluIHRoZSBmcmFtZSBhcnJheVxuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudEZyYW1lID0gdGhpcy5fZnJhbWVzW01hdGguZmxvb3IodGhpcy5fZnJhbWVJbmRleCldO1xuICAgICAgICAgICAgICAgIC8vc3Vycm91bmRzIHRoZSBzcHJpdGUgaW50byBhIHdoaXRlIGJsb2NrIGZvciBkZWJ1Z2dpbmcgcHVycG9zZXMsIHlvdSBjYW4gcmVtb3ZlIHRoaXMgaW4geW91ciBmaW5hbCBhcHBcbiAgICAgICAgICAgICAgICAvL3RoaXMuY29udGV4dC5zdHJva2VTdHlsZSA9ICcjRkZGRkZGJztcbiAgICAgICAgICAgICAgICAvL3RoaXMuY29udGV4dC5zdHJva2VSZWN0KHRoaXMueCwgdGhpcy55LCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgICAgICAgICAgICAgLy9kcmF3cyB0aGUgc2VjdGlvbiBvZiB0aGUgaW1hZ2UgZ2l2ZW4gdGhlIHJlZ1ggYW5kIHJlZ1kgYXMgd2VsbCBhcyB0aGUgd2lkdGggYW5kIGhlaWdodFxuICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5kcmF3SW1hZ2Uoc3ByaXRlLCB0aGlzLmN1cnJlbnRGcmFtZS5yZWdYLCB0aGlzLmN1cnJlbnRGcmFtZS5yZWdZLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgdGhpcy54LCB0aGlzLnksIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTsgXG4gICAgICAgICAgICB9IFxuICAgICAgICB9O1xuICAgICAgICAvL3VzZSB0aGlzIG1ldGhvZCB0byBjaGFuZ2UgdGhlIGZwcyBzcGVlZCBvZiB5b3VyIHNwcml0ZSBzaGVldCBhbmltYXRpb25cbiAgICAgICAgU3ByaXRlQW5pbWF0aW9uLnByb3RvdHlwZS5zZXRTcGVlZCA9IGZ1bmN0aW9uKHNwZWVkKXtcbiAgICAgICAgICAgIC8vcmVhc29uIHdoeSBhIG1ldGhvZCBmb3IgdGhpcyBpcyBuZWVkZWQgaXMgYmVjYXVzZSB0aGVyZSBpcyAgbWF0aCB0byBiZSBkb25lIHdoZW4gc3BlZWQgaXMgY2hhbmdlZC5cbiAgICAgICAgICB0aGlzLnNwZWVkID0gc3BlZWQgfHwgdGhpcy5zcGVlZDtcbiAgICAgICAgICAgIHRoaXMuX2ZyYW1lSW5jcmVtZW50ID0gdGhpcy5zcGVlZCAvIHRoaXMuYXBwRlBTO1xuICAgICAgICAgICAgdGhpcy5fZnJhbWVJbmRleCA9IHRoaXMuc3RhcnRGcmFtZTsgICBcbiAgICAgICAgfTsgXG5cdFxuICAgICAgICBTcHJpdGVBbmltYXRpb24ucHJvdG90eXBlLmdldEZyYW1lID0gZnVuY3Rpb24oZnJhbWVJbmRleCl7XG4gICAgICAgICAgICB0aGlzLl9mcmFtZUluZGV4ID0gKGZyYW1lSW5kZXggPT0gdW5kZWZpbmVkKT8gMDogZnJhbWVJbmRleDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9mcmFtZXNbdGhpcy5fZnJhbWVJbmRleF07XG4gICAgICAgIH07XG4gICAgICAgICAgIFxuICAgIFxuICAgICByZXR1cm4gU3ByaXRlQW5pbWF0aW9uO1xuXHRcblx0XG4gfSkoKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTcHJpdGVBbmltYXRpb247XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2pzL1Nwcml0ZUFuaW1hdGlvbi5qc1xuICoqIG1vZHVsZSBpZCA9IDJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBIb3dsID0gcmVxdWlyZSgnaG93bGVyJyk7XHJcblxyXG52YXIgUmVzb3VyY2VMb2FkZXIgPSAoZnVuY3Rpb24oKXtcclxuXHRcclxuXHR2YXIgdG90YWxBc3NldHMgPSAwLFxyXG5cdFx0bG9hZGVkQXNzZXRzID0gMCxcclxuXHRcdGFzc2V0c0Rvd25sb2FkZWQgPSBmYWxzZSxcclxuXHRcdFVzZXJPcHRpb25zLFxyXG5cdFx0cGVyY2VudGFnZUxvYWRlZCxcclxuXHRcdGF1ZGlvU3VwcG9ydCxcclxuXHRcdGFzc2V0cyA9IHt9O1xyXG5cdFxyXG5cdFx0Ly9kZWZhdWx0IG9wdGlvbnMgaWYgbm8gb3B0aW9uIGFyZ3VtZW50IGlzIHBhc3NlZCBieSB1c2VyLlxyXG5cdFx0dmFyIGRlZmF1bHRPcHRpb25zID0ge1xyXG5cdFx0XHRcdFx0ICBvbmxvYWQ6IGZ1bmN0aW9uKCl7IFxyXG5cdFx0XHRcdFx0XHRjb25zb2xlLmxvZygnTm8gY2FsbGJhY2sgd2FzIHBhc3NlZCBpbi4uJyk7XHJcblx0XHRcdFx0XHRcdH0sXHJcblx0XHRcdFx0XHQgIGZpbmFsIDogZnVuY3Rpb24oKXtcclxuXHRcdFx0XHRcdFx0ICBjb25zb2xlLmxvZygnTm8gZmluYWwgZnVuY3Rpb24gdG8gY2FsbCB3YXMgcGFzc2VkIGluLi4nKTtcclxuXHRcdFx0XHRcdCAgfSxcclxuXHRcdFx0XHRcdCBhc3NldHMgOiBbXVxyXG5cdFx0XHRcdFx0IH07XHJcblx0XHJcblx0LyogRXhhbXBsZSBvZiBvcHRpb25zOlxyXG5cdFxyXG5cdHtcclxuXHRcdGFzc2V0cyA6IHtcclxuXHRcdFxyXG5cdFx0XHRpbWdzIDoge1xyXG5cdFx0XHRcdC8vaW1nIG5hbWVzIHdpdGggVVJMc1xyXG5cdFx0XHRcdGJnX2JsYWNrIDogXCJhc3NldHMvaW1nL2JhY2tncm91bmQucG5nLFxyXG5cdFx0XHRcdG1ldGVvclNwcml0ZSA6IFwiYXNzZXRzL2ltZy9tZXRlb3IucG5nLFxyXG5cdFx0XHRcdGVuZW1pZXNTcHJpdGUgOiBcImFzc2V0cy9pbWcvZW5lbWllcy5wbmcsXHJcblx0XHRcdFx0ZW5lbXlTaGlwU3ByaXRlczogXCJhc3NldHMvaW1nL2VuZW15U2hpcHMucG5nXHJcblx0XHRcdH0sXHJcblx0XHRcdHNvdW5kcyA6IHtcclxuXHRcdFx0XHQvL3NvdW5kcyBuYW1lIHdpdGggVVJMc1xyXG5cdFx0XHRcdHNvdW5kdHJhY2sgOiBbXCJhc3NldHMvc291bmRzL3BsYXllci5tcDNcIiwgXCJhc3NldHMvc291bmRzL3BsYXllci53YXZcIl0sXHJcblx0XHRcdFx0ZW5kU291bmQgOiBbXCJhc3NldHMvc291bmRzL2dhbWVvdmVyLm1wM1wiLCBcImFzc2V0cy9zb3VuZHMvZ2FtZW92ZXIud2F2XCJdXHJcblx0XHRcdH1cclxuXHRcdH1cclxuICAgICAgICB1c2VIb3dsIDogZmFsc2UsXHJcblx0XHRcdC8vZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgb24gZXZlcnkgaXRlbSBsb2FkZWRcclxuXHRcdG9ubG9hZCA6IHVwZGF0ZUxvYWRlckRpc3BsYXllcixcclxuXHRcdFx0Ly9mdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCBvbmNlIGFsbCBoYXZlIGxvYWRlZFxyXG5cdFx0ZmluYWwgOiBmaW5hbEZ1bmN0aW9uVG9DYWxsXHJcblx0fVxyXG5cclxuXHQqL1xyXG5cdFx0XHJcblx0ZnVuY3Rpb24gaW5pdChvcHRpb25zKXtcclxuXHRcdFVzZXJPcHRpb25zID0gb3B0aW9ucyB8fCBkZWZhdWx0T3B0aW9ucztcclxuXHR9XHJcblx0XHJcblx0ZnVuY3Rpb24gZG93bmxvYWQoKXtcclxuXHRcdFxyXG5cdFx0Ly9yZXR1cm4gaWYgYWxsIGFzc2V0cyBoYXZlIGFscmVhZHkgbG9hZGVkIGFuZCBpbmRleGVkLlxyXG5cdFx0aWYoYXNzZXRzRG93bmxvYWRlZCkgcmV0dXJuO1xyXG5cdFx0XHJcblx0XHQvL3NldHMgdG8gdHJ1ZSBzbyB0aGlzIG1ldGhvZCAoZG93bmxvYWRBbGwoKSkgaXMgY2FsbGVkIG9ubHkgb25jZWQuXHJcblx0XHRhc3NldHNEb3dubG9hZGVkID0gdHJ1ZTtcclxuXHRcdC8vY3JlYXRlcyB0aGUgc291bmQgYW5kIGltYWdlIGVsZW1lbnRzIGZvciBlYWNoIGFzc2V0IGluIHRoZSBvcHRpb25zIGFyZ3VtZW50LlxyXG5cdFx0Zm9yKHZhciBpdGVtIGluIFVzZXJPcHRpb25zLmFzc2V0cy5pbWdzKXtcclxuXHRcdFx0YXNzZXRzW2l0ZW1dID0gbmV3IEltYWdlKCk7XHJcblx0XHRcdGFzc2V0c1tpdGVtXS5zcmMgPSBVc2VyT3B0aW9ucy5hc3NldHMuaW1nc1tpdGVtXTtcclxuXHRcdFx0YXNzZXRzW2l0ZW1dLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBvbkxvYWQsIGZhbHNlKTtcclxuXHRcdFx0dG90YWxBc3NldHMrKztcclxuXHRcdH1cclxuXHRcdC8vYXJyYXlzIGFyZSBwYXNzZWQgZm9yIGVhY2ggc291bmQgYXNzZXQgY29udGFpbmluZyB0aGUgc291cmNlIHRvIHRoZSBzb3VuZC5cclxuICAgICAgICBpZighVXNlck9wdGlvbnMudXNlSG93bCl7XHJcbiAgICAgICAgICAgIGZvcih2YXIgaXRlbSBpbiBVc2VyT3B0aW9ucy5hc3NldHMuc291bmRzKXtcclxuICAgICAgICAgICAgICAgIGZvcih2YXIgaT0wLCBqPVVzZXJPcHRpb25zLmFzc2V0cy5zb3VuZHNbaXRlbV0ubGVuZ3RoOyBpPGo7IGkrKyl7XHJcbiAgICAgICAgICAgICAgICB2YXIgY3VycmVudFNvdW5kID0gVXNlck9wdGlvbnMuYXNzZXRzLnNvdW5kc1tpdGVtXVtpXTtcclxuICAgICAgICAgICAgICAgICAgICAvL2FuYWx5emVzIHRoZSBleHRlbnNpb24gYW5kIHBpY2tzIHRoZSBmaXJzdCBvbmUgdGhhdCBpcyBzdXBwb3J0ZWQgYnkgdGhlIGJyb3dzZXIuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYoaXNBdWRpb1N1cHBvcnQoY3VycmVudFNvdW5kLnNsaWNlKC0zKSkpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhc3NldHNbaXRlbV0gPSBuZXcgQXVkaW8oKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXRzW2l0ZW1dLnNyYyA9IFVzZXJPcHRpb25zLmFzc2V0cy5zb3VuZHNbaXRlbV1baV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzc2V0c1tpdGVtXS5hZGRFdmVudExpc3RlbmVyKCdjYW5wbGF5dGhyb3VnaCcsIG9uTG9hZCwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3RhbEFzc2V0cysrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgIC8vY3JlYXRlcyBob3dsIGluc3RhbmNlIGFuZCBwYXNzZXMgaW4gaG93bCBvcHRpb25zIGdpdmVuIGJ5IHRoZSB1c2VyLlxyXG4gICAgICAgICAgICBmb3IodmFyIGl0ZW0gaW4gVXNlck9wdGlvbnMuYXNzZXRzLnNvdW5kcyl7XHJcbiAgICAgICAgICAgICAgICB2YXIgaG93bE9wdGlvbnMgPSBVc2VyT3B0aW9ucy5hc3NldHMuc291bmRzW2l0ZW1dO1xyXG4gICAgICAgICAgICAgICAgaG93bE9wdGlvbnMub25sb2FkID0gb25Mb2FkO1xyXG4gICAgICAgICAgICAgICAgYXNzZXRzW2l0ZW1dID0gbmV3IEhvd2woaG93bE9wdGlvbnMpOyBcclxuICAgICAgICAgICAgICAgIHRvdGFsQXNzZXRzKys7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHRcdFxyXG5cdH1cclxuXHRcclxuXHRmdW5jdGlvbiBvbkxvYWQoaXRlbSl7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy9pbmNyZW1lbnRzIGxvYWQgY291bnQgYW5kIHJlbW92ZSBsaXN0ZW5lcnMuXHJcblx0XHRsb2FkZWRBc3NldHMrKztcclxuICAgICAgICBcclxuICAgICAgICB2YXIgaXRlbUxvYWRlZDtcclxuXHJcbiAgICAgICAgaWYoaXRlbSl7XHJcbiAgICAgICAgICAgIGlmKGl0ZW0udGFyZ2V0LnRhZ05hbWUgPT09IFwiQVVESU9cIil7XHJcbiAgICAgICAgICAgICAgICBpdGVtTG9hZGVkID0gaXRlbS50YXJnZXQ7XHJcbiAgICAgICAgICAgICAgICBpdGVtLnRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCdjYW5wbGF5dGhyb3VnaCcsIG9uTG9hZCwgZmFsc2UpO1xyXG4gICAgICAgICAgICB9ZWxzZSBpZiAoaXRlbS50YXJnZXQudGFnTmFtZSA9PT0gXCJJTUdcIil7XHJcbiAgICAgICAgICAgICAgICBpdGVtTG9hZGVkID0gaXRlbS50YXJnZXQ7XHJcbiAgICAgICAgICAgICAgICBpdGVtLnRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCdsb2FkJywgb25Mb2FkLCBmYWxzZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgaXRlbUxvYWRlZCA9IHtuYW1lOiBcIkhvd2wgc291bmRcIiwgc3JjOiBcIkhvd2wgc291bmQgY2hlY2sgc291bmRcIn07ICAgXHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG5cdFx0Ly9jYWxjdWxhdGVzIHRoZSBkZWNpbWFsIHZhbHVlIGZyb20gcmF0aW9cclxuXHRcdHBlcmNlbnRhZ2VMb2FkZWQgPSBNYXRoLmZsb29yKChsb2FkZWRBc3NldHMgLyB0b3RhbEFzc2V0cykqMTAwKS8xMDA7XHJcblx0XHRcclxuXHRcdC8vY2FsbCB0aGUgYXBwcm9wcmlhdGUgY2FsbGJhY2sgZnVuY3Rpb24gZ2l2ZW4gdGhlIGFtbW91bnQgb2YgYXNzZXRzIGxvYWRlZC5cclxuXHRcdGlmKFVzZXJPcHRpb25zLm9ubG9hZCl7XHJcblx0XHRcdFVzZXJPcHRpb25zLm9ubG9hZChpdGVtTG9hZGVkKTtcclxuXHRcdH1cclxuXHRcdGlmKGxvYWRlZEFzc2V0cyA+PSB0b3RhbEFzc2V0cyAmJiBVc2VyT3B0aW9ucy5maW5hbCl7XHJcblx0XHRcdFVzZXJPcHRpb25zLmZpbmFsKGl0ZW1Mb2FkZWQpO1xyXG5cdFx0fVxyXG5cdFx0XHJcblx0fVxyXG5cdFxyXG5cdC8vZ2V0cyB0aGUgYXBwcm9wcmlhdGUgc3VwcG9ydGVkIGF1ZGlvIGZvcm1hdC5cclxuXHRmdW5jdGlvbiBpc0F1ZGlvU3VwcG9ydChleHRlbnNpb24pe1xyXG5cdFx0XHJcblx0XHR2YXIgYXVkaW8gPSBuZXcgQXVkaW8oKTtcclxuXHRcdHZhciBzdXBwb3J0VmFsdWUgPSBhdWRpby5jYW5QbGF5VHlwZShcImF1ZGlvL1wiK2V4dGVuc2lvbik7XHJcblx0XHRpZiggc3VwcG9ydFZhbHVlID09PSBcIm1heWJlXCIgfHwgc3VwcG9ydFZhbHVlID09PSBcInByb2JhYmx5XCIgKXtcclxuXHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHR9ZWxzZXtcclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRcclxuXHRyZXR1cm4ge1xyXG5cdFx0aW5pdCA6IGluaXQsXHJcblx0XHRhc3NldHMgOiBhc3NldHMsXHJcblx0XHRnZXQgbG9hZGVkKCl7XHJcblx0XHRcdHJldHVybiBwZXJjZW50YWdlTG9hZGVkO1xyXG5cdFx0fSxcclxuICAgIFx0ZG93bmxvYWRBbGwgOiBkb3dubG9hZFxyXG5cdH1cclxuXHRcclxufSkoKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUmVzb3VyY2VMb2FkZXI7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2pzL1Jlc291cmNlTG9hZGVyLmpzXG4gKiogbW9kdWxlIGlkID0gM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyohXG4gKiAgaG93bGVyLmpzIHYyLjAuMFxuICogIGhvd2xlcmpzLmNvbVxuICpcbiAqICAoYykgMjAxMy0yMDE2LCBKYW1lcyBTaW1wc29uIG9mIEdvbGRGaXJlIFN0dWRpb3NcbiAqICBnb2xkZmlyZXN0dWRpb3MuY29tXG4gKlxuICogIE1JVCBMaWNlbnNlXG4gKi9cblxuKGZ1bmN0aW9uKCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICAvKiogR2xvYmFsIE1ldGhvZHMgKiovXG4gIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgZ2xvYmFsIGNvbnRyb2xsZXIuIEFsbCBjb250YWluZWQgbWV0aG9kcyBhbmQgcHJvcGVydGllcyBhcHBseVxuICAgKiB0byBhbGwgc291bmRzIHRoYXQgYXJlIGN1cnJlbnRseSBwbGF5aW5nIG9yIHdpbGwgYmUgaW4gdGhlIGZ1dHVyZS5cbiAgICovXG4gIHZhciBIb3dsZXJHbG9iYWwgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmluaXQoKTtcbiAgfTtcbiAgSG93bGVyR2xvYmFsLnByb3RvdHlwZSA9IHtcbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplIHRoZSBnbG9iYWwgSG93bGVyIG9iamVjdC5cbiAgICAgKiBAcmV0dXJuIHtIb3dsZXJ9XG4gICAgICovXG4gICAgaW5pdDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXMgfHwgSG93bGVyO1xuXG4gICAgICAvLyBJbnRlcm5hbCBwcm9wZXJ0aWVzLlxuICAgICAgc2VsZi5fY29kZWNzID0ge307XG4gICAgICBzZWxmLl9ob3dscyA9IFtdO1xuICAgICAgc2VsZi5fbXV0ZWQgPSBmYWxzZTtcbiAgICAgIHNlbGYuX3ZvbHVtZSA9IDE7XG4gICAgICBzZWxmLl9jYW5QbGF5RXZlbnQgPSAnY2FucGxheXRocm91Z2gnO1xuICAgICAgc2VsZi5fbmF2aWdhdG9yID0gKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5uYXZpZ2F0b3IpID8gd2luZG93Lm5hdmlnYXRvciA6IG51bGw7XG5cbiAgICAgIC8vIFB1YmxpYyBwcm9wZXJ0aWVzLlxuICAgICAgc2VsZi5tYXN0ZXJHYWluID0gbnVsbDtcbiAgICAgIHNlbGYubm9BdWRpbyA9IGZhbHNlO1xuICAgICAgc2VsZi51c2luZ1dlYkF1ZGlvID0gdHJ1ZTtcbiAgICAgIHNlbGYuYXV0b1N1c3BlbmQgPSB0cnVlO1xuICAgICAgc2VsZi5jdHggPSBudWxsO1xuXG4gICAgICAvLyBTZXQgdG8gZmFsc2UgdG8gZGlzYWJsZSB0aGUgYXV0byBpT1MgZW5hYmxlci5cbiAgICAgIHNlbGYubW9iaWxlQXV0b0VuYWJsZSA9IHRydWU7XG5cbiAgICAgIC8vIFNldHVwIHRoZSB2YXJpb3VzIHN0YXRlIHZhbHVlcyBmb3IgZ2xvYmFsIHRyYWNraW5nLlxuICAgICAgc2VsZi5fc2V0dXAoKTtcblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldC9zZXQgdGhlIGdsb2JhbCB2b2x1bWUgZm9yIGFsbCBzb3VuZHMuXG4gICAgICogQHBhcmFtICB7RmxvYXR9IHZvbCBWb2x1bWUgZnJvbSAwLjAgdG8gMS4wLlxuICAgICAqIEByZXR1cm4ge0hvd2xlci9GbG9hdH0gICAgIFJldHVybnMgc2VsZiBvciBjdXJyZW50IHZvbHVtZS5cbiAgICAgKi9cbiAgICB2b2x1bWU6IGZ1bmN0aW9uKHZvbCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzIHx8IEhvd2xlcjtcbiAgICAgIHZvbCA9IHBhcnNlRmxvYXQodm9sKTtcblxuICAgICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBhbiBBdWRpb0NvbnRleHQgY3JlYXRlZCB5ZXQsIHJ1biB0aGUgc2V0dXAuXG4gICAgICBpZiAoIXNlbGYuY3R4KSB7XG4gICAgICAgIHNldHVwQXVkaW9Db250ZXh0KCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2Ygdm9sICE9PSAndW5kZWZpbmVkJyAmJiB2b2wgPj0gMCAmJiB2b2wgPD0gMSkge1xuICAgICAgICBzZWxmLl92b2x1bWUgPSB2b2w7XG5cbiAgICAgICAgLy8gRG9uJ3QgdXBkYXRlIGFueSBvZiB0aGUgbm9kZXMgaWYgd2UgYXJlIG11dGVkLlxuICAgICAgICBpZiAoc2VsZi5fbXV0ZWQpIHtcbiAgICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFdoZW4gdXNpbmcgV2ViIEF1ZGlvLCB3ZSBqdXN0IG5lZWQgdG8gYWRqdXN0IHRoZSBtYXN0ZXIgZ2Fpbi5cbiAgICAgICAgaWYgKHNlbGYudXNpbmdXZWJBdWRpbykge1xuICAgICAgICAgIHNlbGYubWFzdGVyR2Fpbi5nYWluLnZhbHVlID0gdm9sO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTG9vcCB0aHJvdWdoIGFuZCBjaGFuZ2Ugdm9sdW1lIGZvciBhbGwgSFRNTDUgYXVkaW8gbm9kZXMuXG4gICAgICAgIGZvciAodmFyIGk9MDsgaTxzZWxmLl9ob3dscy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmICghc2VsZi5faG93bHNbaV0uX3dlYkF1ZGlvKSB7XG4gICAgICAgICAgICAvLyBHZXQgYWxsIG9mIHRoZSBzb3VuZHMgaW4gdGhpcyBIb3dsIGdyb3VwLlxuICAgICAgICAgICAgdmFyIGlkcyA9IHNlbGYuX2hvd2xzW2ldLl9nZXRTb3VuZElkcygpO1xuXG4gICAgICAgICAgICAvLyBMb29wIHRocm91Z2ggYWxsIHNvdW5kcyBhbmQgY2hhbmdlIHRoZSB2b2x1bWVzLlxuICAgICAgICAgICAgZm9yICh2YXIgaj0wOyBqPGlkcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICB2YXIgc291bmQgPSBzZWxmLl9ob3dsc1tpXS5fc291bmRCeUlkKGlkc1tqXSk7XG5cbiAgICAgICAgICAgICAgaWYgKHNvdW5kICYmIHNvdW5kLl9ub2RlKSB7XG4gICAgICAgICAgICAgICAgc291bmQuX25vZGUudm9sdW1lID0gc291bmQuX3ZvbHVtZSAqIHZvbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZi5fdm9sdW1lO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGUgbXV0aW5nIGFuZCB1bm11dGluZyBnbG9iYWxseS5cbiAgICAgKiBAcGFyYW0gIHtCb29sZWFufSBtdXRlZCBJcyBtdXRlZCBvciBub3QuXG4gICAgICovXG4gICAgbXV0ZTogZnVuY3Rpb24obXV0ZWQpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcyB8fCBIb3dsZXI7XG5cbiAgICAgIC8vIElmIHdlIGRvbid0IGhhdmUgYW4gQXVkaW9Db250ZXh0IGNyZWF0ZWQgeWV0LCBydW4gdGhlIHNldHVwLlxuICAgICAgaWYgKCFzZWxmLmN0eCkge1xuICAgICAgICBzZXR1cEF1ZGlvQ29udGV4dCgpO1xuICAgICAgfVxuXG4gICAgICBzZWxmLl9tdXRlZCA9IG11dGVkO1xuXG4gICAgICAvLyBXaXRoIFdlYiBBdWRpbywgd2UganVzdCBuZWVkIHRvIG11dGUgdGhlIG1hc3RlciBnYWluLlxuICAgICAgaWYgKHNlbGYudXNpbmdXZWJBdWRpbykge1xuICAgICAgICBzZWxmLm1hc3RlckdhaW4uZ2Fpbi52YWx1ZSA9IG11dGVkID8gMCA6IHNlbGYuX3ZvbHVtZTtcbiAgICAgIH1cblxuICAgICAgLy8gTG9vcCB0aHJvdWdoIGFuZCBtdXRlIGFsbCBIVE1MNSBBdWRpbyBub2Rlcy5cbiAgICAgIGZvciAodmFyIGk9MDsgaTxzZWxmLl9ob3dscy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoIXNlbGYuX2hvd2xzW2ldLl93ZWJBdWRpbykge1xuICAgICAgICAgIC8vIEdldCBhbGwgb2YgdGhlIHNvdW5kcyBpbiB0aGlzIEhvd2wgZ3JvdXAuXG4gICAgICAgICAgdmFyIGlkcyA9IHNlbGYuX2hvd2xzW2ldLl9nZXRTb3VuZElkcygpO1xuXG4gICAgICAgICAgLy8gTG9vcCB0aHJvdWdoIGFsbCBzb3VuZHMgYW5kIG1hcmsgdGhlIGF1ZGlvIG5vZGUgYXMgbXV0ZWQuXG4gICAgICAgICAgZm9yICh2YXIgaj0wOyBqPGlkcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgdmFyIHNvdW5kID0gc2VsZi5faG93bHNbaV0uX3NvdW5kQnlJZChpZHNbal0pO1xuXG4gICAgICAgICAgICBpZiAoc291bmQgJiYgc291bmQuX25vZGUpIHtcbiAgICAgICAgICAgICAgc291bmQuX25vZGUubXV0ZWQgPSAobXV0ZWQpID8gdHJ1ZSA6IHNvdW5kLl9tdXRlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFVubG9hZCBhbmQgZGVzdHJveSBhbGwgY3VycmVudGx5IGxvYWRlZCBIb3dsIG9iamVjdHMuXG4gICAgICogQHJldHVybiB7SG93bGVyfVxuICAgICAqL1xuICAgIHVubG9hZDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXMgfHwgSG93bGVyO1xuXG4gICAgICBmb3IgKHZhciBpPXNlbGYuX2hvd2xzLmxlbmd0aC0xOyBpPj0wOyBpLS0pIHtcbiAgICAgICAgc2VsZi5faG93bHNbaV0udW5sb2FkKCk7XG4gICAgICB9XG5cbiAgICAgIC8vIENyZWF0ZSBhIG5ldyBBdWRpb0NvbnRleHQgdG8gbWFrZSBzdXJlIGl0IGlzIGZ1bGx5IHJlc2V0LlxuICAgICAgaWYgKHNlbGYudXNpbmdXZWJBdWRpbyAmJiB0eXBlb2Ygc2VsZi5jdHguY2xvc2UgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHNlbGYuY3R4LmNsb3NlKCk7XG4gICAgICAgIHNlbGYuY3R4ID0gbnVsbDtcbiAgICAgICAgc2V0dXBBdWRpb0NvbnRleHQoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrIGZvciBjb2RlYyBzdXBwb3J0IG9mIHNwZWNpZmljIGV4dGVuc2lvbi5cbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IGV4dCBBdWRpbyBmaWxlIGV4dGVudGlvbi5cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuICAgIGNvZGVjczogZnVuY3Rpb24oZXh0KSB7XG4gICAgICByZXR1cm4gKHRoaXMgfHwgSG93bGVyKS5fY29kZWNzW2V4dF07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHVwIHZhcmlvdXMgc3RhdGUgdmFsdWVzIGZvciBnbG9iYWwgdHJhY2tpbmcuXG4gICAgICogQHJldHVybiB7SG93bGVyfVxuICAgICAqL1xuICAgIF9zZXR1cDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXMgfHwgSG93bGVyO1xuXG4gICAgICAvLyBLZWVwcyB0cmFjayBvZiB0aGUgc3VzcGVuZC9yZXN1bWUgc3RhdGUgb2YgdGhlIEF1ZGlvQ29udGV4dC5cbiAgICAgIHNlbGYuc3RhdGUgPSBzZWxmLmN0eCA/IHNlbGYuY3R4LnN0YXRlIHx8ICdydW5uaW5nJyA6ICdydW5uaW5nJztcblxuICAgICAgLy8gQXV0b21hdGljYWxseSBiZWdpbiB0aGUgMzAtc2Vjb25kIHN1c3BlbmQgcHJvY2Vzc1xuICAgICAgc2VsZi5fYXV0b1N1c3BlbmQoKTtcblxuICAgICAgLy8gQ2hlY2sgZm9yIHN1cHBvcnRlZCBjb2RlY3MuXG4gICAgICBpZiAoIXNlbGYubm9BdWRpbykge1xuICAgICAgICBzZWxmLl9zZXR1cENvZGVjcygpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgZm9yIGJyb3dzZXIgc3VwcG9ydCBmb3IgdmFyaW91cyBjb2RlY3MgYW5kIGNhY2hlIHRoZSByZXN1bHRzLlxuICAgICAqIEByZXR1cm4ge0hvd2xlcn1cbiAgICAgKi9cbiAgICBfc2V0dXBDb2RlY3M6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzIHx8IEhvd2xlcjtcbiAgICAgIHZhciBhdWRpb1Rlc3QgPSAodHlwZW9mIEF1ZGlvICE9PSAndW5kZWZpbmVkJykgPyBuZXcgQXVkaW8oKSA6IG51bGw7XG5cbiAgICAgIGlmICghYXVkaW9UZXN0IHx8IHR5cGVvZiBhdWRpb1Rlc3QuY2FuUGxheVR5cGUgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICB9XG5cbiAgICAgIHZhciBtcGVnVGVzdCA9IGF1ZGlvVGVzdC5jYW5QbGF5VHlwZSgnYXVkaW8vbXBlZzsnKS5yZXBsYWNlKC9ebm8kLywgJycpO1xuXG4gICAgICAvLyBPcGVyYSB2ZXJzaW9uIDwzMyBoYXMgbWl4ZWQgTVAzIHN1cHBvcnQsIHNvIHdlIG5lZWQgdG8gY2hlY2sgZm9yIGFuZCBibG9jayBpdC5cbiAgICAgIHZhciBjaGVja09wZXJhID0gc2VsZi5fbmF2aWdhdG9yICYmIHNlbGYuX25hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL09QUlxcLyhbMC02XS4pL2cpO1xuICAgICAgdmFyIGlzT2xkT3BlcmEgPSAoY2hlY2tPcGVyYSAmJiBwYXJzZUludChjaGVja09wZXJhWzBdLnNwbGl0KCcvJylbMV0sIDEwKSA8IDMzKTtcblxuICAgICAgc2VsZi5fY29kZWNzID0ge1xuICAgICAgICBtcDM6ICEhKCFpc09sZE9wZXJhICYmIChtcGVnVGVzdCB8fCBhdWRpb1Rlc3QuY2FuUGxheVR5cGUoJ2F1ZGlvL21wMzsnKS5yZXBsYWNlKC9ebm8kLywgJycpKSksXG4gICAgICAgIG1wZWc6ICEhbXBlZ1Rlc3QsXG4gICAgICAgIG9wdXM6ICEhYXVkaW9UZXN0LmNhblBsYXlUeXBlKCdhdWRpby9vZ2c7IGNvZGVjcz1cIm9wdXNcIicpLnJlcGxhY2UoL15ubyQvLCAnJyksXG4gICAgICAgIG9nZzogISFhdWRpb1Rlc3QuY2FuUGxheVR5cGUoJ2F1ZGlvL29nZzsgY29kZWNzPVwidm9yYmlzXCInKS5yZXBsYWNlKC9ebm8kLywgJycpLFxuICAgICAgICBvZ2E6ICEhYXVkaW9UZXN0LmNhblBsYXlUeXBlKCdhdWRpby9vZ2c7IGNvZGVjcz1cInZvcmJpc1wiJykucmVwbGFjZSgvXm5vJC8sICcnKSxcbiAgICAgICAgd2F2OiAhIWF1ZGlvVGVzdC5jYW5QbGF5VHlwZSgnYXVkaW8vd2F2OyBjb2RlY3M9XCIxXCInKS5yZXBsYWNlKC9ebm8kLywgJycpLFxuICAgICAgICBhYWM6ICEhYXVkaW9UZXN0LmNhblBsYXlUeXBlKCdhdWRpby9hYWM7JykucmVwbGFjZSgvXm5vJC8sICcnKSxcbiAgICAgICAgY2FmOiAhIWF1ZGlvVGVzdC5jYW5QbGF5VHlwZSgnYXVkaW8veC1jYWY7JykucmVwbGFjZSgvXm5vJC8sICcnKSxcbiAgICAgICAgbTRhOiAhIShhdWRpb1Rlc3QuY2FuUGxheVR5cGUoJ2F1ZGlvL3gtbTRhOycpIHx8IGF1ZGlvVGVzdC5jYW5QbGF5VHlwZSgnYXVkaW8vbTRhOycpIHx8IGF1ZGlvVGVzdC5jYW5QbGF5VHlwZSgnYXVkaW8vYWFjOycpKS5yZXBsYWNlKC9ebm8kLywgJycpLFxuICAgICAgICBtcDQ6ICEhKGF1ZGlvVGVzdC5jYW5QbGF5VHlwZSgnYXVkaW8veC1tcDQ7JykgfHwgYXVkaW9UZXN0LmNhblBsYXlUeXBlKCdhdWRpby9tcDQ7JykgfHwgYXVkaW9UZXN0LmNhblBsYXlUeXBlKCdhdWRpby9hYWM7JykpLnJlcGxhY2UoL15ubyQvLCAnJyksXG4gICAgICAgIHdlYmE6ICEhYXVkaW9UZXN0LmNhblBsYXlUeXBlKCdhdWRpby93ZWJtOyBjb2RlY3M9XCJ2b3JiaXNcIicpLnJlcGxhY2UoL15ubyQvLCAnJyksXG4gICAgICAgIHdlYm06ICEhYXVkaW9UZXN0LmNhblBsYXlUeXBlKCdhdWRpby93ZWJtOyBjb2RlY3M9XCJ2b3JiaXNcIicpLnJlcGxhY2UoL15ubyQvLCAnJyksXG4gICAgICAgIGRvbGJ5OiAhIWF1ZGlvVGVzdC5jYW5QbGF5VHlwZSgnYXVkaW8vbXA0OyBjb2RlY3M9XCJlYy0zXCInKS5yZXBsYWNlKC9ebm8kLywgJycpXG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTW9iaWxlIGJyb3dzZXJzIHdpbGwgb25seSBhbGxvdyBhdWRpbyB0byBiZSBwbGF5ZWQgYWZ0ZXIgYSB1c2VyIGludGVyYWN0aW9uLlxuICAgICAqIEF0dGVtcHQgdG8gYXV0b21hdGljYWxseSB1bmxvY2sgYXVkaW8gb24gdGhlIGZpcnN0IHVzZXIgaW50ZXJhY3Rpb24uXG4gICAgICogQ29uY2VwdCBmcm9tOiBodHRwOi8vcGF1bGJha2F1cy5jb20vdHV0b3JpYWxzL2h0bWw1L3dlYi1hdWRpby1vbi1pb3MvXG4gICAgICogQHJldHVybiB7SG93bGVyfVxuICAgICAqL1xuICAgIF9lbmFibGVNb2JpbGVBdWRpbzogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXMgfHwgSG93bGVyO1xuXG4gICAgICAvLyBPbmx5IHJ1biB0aGlzIG9uIG1vYmlsZSBkZXZpY2VzIGlmIGF1ZGlvIGlzbid0IGFscmVhZHkgZWFuYmxlZC5cbiAgICAgIHZhciBpc01vYmlsZSA9IC9pUGhvbmV8aVBhZHxpUG9kfEFuZHJvaWR8QmxhY2tCZXJyeXxCQjEwfFNpbGt8TW9iaS9pLnRlc3Qoc2VsZi5fbmF2aWdhdG9yICYmIHNlbGYuX25hdmlnYXRvci51c2VyQWdlbnQpO1xuICAgICAgdmFyIGlzVG91Y2ggPSAhISgoJ29udG91Y2hlbmQnIGluIHdpbmRvdykgfHwgKHNlbGYuX25hdmlnYXRvciAmJiBzZWxmLl9uYXZpZ2F0b3IubWF4VG91Y2hQb2ludHMgPiAwKSB8fCAoc2VsZi5fbmF2aWdhdG9yICYmIHNlbGYuX25hdmlnYXRvci5tc01heFRvdWNoUG9pbnRzID4gMCkpO1xuICAgICAgaWYgKHNlbGYuX21vYmlsZUVuYWJsZWQgfHwgIXNlbGYuY3R4IHx8ICghaXNNb2JpbGUgJiYgIWlzVG91Y2gpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgc2VsZi5fbW9iaWxlRW5hYmxlZCA9IGZhbHNlO1xuXG4gICAgICAvLyBTb21lIG1vYmlsZSBkZXZpY2VzL3BsYXRmb3JtcyBoYXZlIGRpc3RvcnRpb24gaXNzdWVzIHdoZW4gb3BlbmluZy9jbG9zaW5nIHRhYnMgYW5kL29yIHdlYiB2aWV3cy5cbiAgICAgIC8vIEJ1Z3MgaW4gdGhlIGJyb3dzZXIgKGVzcGVjaWFsbHkgTW9iaWxlIFNhZmFyaSkgY2FuIGNhdXNlIHRoZSBzYW1wbGVSYXRlIHRvIGNoYW5nZSBmcm9tIDQ0MTAwIHRvIDQ4MDAwLlxuICAgICAgLy8gQnkgY2FsbGluZyBIb3dsZXIudW5sb2FkKCksIHdlIGNyZWF0ZSBhIG5ldyBBdWRpb0NvbnRleHQgd2l0aCB0aGUgY29ycmVjdCBzYW1wbGVSYXRlLlxuICAgICAgaWYgKCFzZWxmLl9tb2JpbGVVbmxvYWRlZCAmJiBzZWxmLmN0eC5zYW1wbGVSYXRlICE9PSA0NDEwMCkge1xuICAgICAgICBzZWxmLl9tb2JpbGVVbmxvYWRlZCA9IHRydWU7XG4gICAgICAgIHNlbGYudW5sb2FkKCk7XG4gICAgICB9XG5cbiAgICAgIC8vIFNjcmF0Y2ggYnVmZmVyIGZvciBlbmFibGluZyBpT1MgdG8gZGlzcG9zZSBvZiB3ZWIgYXVkaW8gYnVmZmVycyBjb3JyZWN0bHksIGFzIHBlcjpcbiAgICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMjQxMTk2ODRcbiAgICAgIHNlbGYuX3NjcmF0Y2hCdWZmZXIgPSBzZWxmLmN0eC5jcmVhdGVCdWZmZXIoMSwgMSwgMjIwNTApO1xuXG4gICAgICAvLyBDYWxsIHRoaXMgbWV0aG9kIG9uIHRvdWNoIHN0YXJ0IHRvIGNyZWF0ZSBhbmQgcGxheSBhIGJ1ZmZlcixcbiAgICAgIC8vIHRoZW4gY2hlY2sgaWYgdGhlIGF1ZGlvIGFjdHVhbGx5IHBsYXllZCB0byBkZXRlcm1pbmUgaWZcbiAgICAgIC8vIGF1ZGlvIGhhcyBub3cgYmVlbiB1bmxvY2tlZCBvbiBpT1MsIEFuZHJvaWQsIGV0Yy5cbiAgICAgIHZhciB1bmxvY2sgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gQ3JlYXRlIGFuIGVtcHR5IGJ1ZmZlci5cbiAgICAgICAgdmFyIHNvdXJjZSA9IHNlbGYuY3R4LmNyZWF0ZUJ1ZmZlclNvdXJjZSgpO1xuICAgICAgICBzb3VyY2UuYnVmZmVyID0gc2VsZi5fc2NyYXRjaEJ1ZmZlcjtcbiAgICAgICAgc291cmNlLmNvbm5lY3Qoc2VsZi5jdHguZGVzdGluYXRpb24pO1xuXG4gICAgICAgIC8vIFBsYXkgdGhlIGVtcHR5IGJ1ZmZlci5cbiAgICAgICAgaWYgKHR5cGVvZiBzb3VyY2Uuc3RhcnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgc291cmNlLm5vdGVPbigwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzb3VyY2Uuc3RhcnQoMCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTZXR1cCBhIHRpbWVvdXQgdG8gY2hlY2sgdGhhdCB3ZSBhcmUgdW5sb2NrZWQgb24gdGhlIG5leHQgZXZlbnQgbG9vcC5cbiAgICAgICAgc291cmNlLm9uZW5kZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICBzb3VyY2UuZGlzY29ubmVjdCgwKTtcblxuICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgdW5sb2NrZWQgc3RhdGUgYW5kIHByZXZlbnQgdGhpcyBjaGVjayBmcm9tIGhhcHBlbmluZyBhZ2Fpbi5cbiAgICAgICAgICBzZWxmLl9tb2JpbGVFbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgICBzZWxmLm1vYmlsZUF1dG9FbmFibGUgPSBmYWxzZTtcblxuICAgICAgICAgIC8vIFJlbW92ZSB0aGUgdG91Y2ggc3RhcnQgbGlzdGVuZXIuXG4gICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB1bmxvY2ssIHRydWUpO1xuICAgICAgICB9O1xuICAgICAgfTtcblxuICAgICAgLy8gU2V0dXAgYSB0b3VjaCBzdGFydCBsaXN0ZW5lciB0byBhdHRlbXB0IGFuIHVubG9jayBpbi5cbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdW5sb2NrLCB0cnVlKTtcblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEF1dG9tYXRpY2FsbHkgc3VzcGVuZCB0aGUgV2ViIEF1ZGlvIEF1ZGlvQ29udGV4dCBhZnRlciBubyBzb3VuZCBoYXMgcGxheWVkIGZvciAzMCBzZWNvbmRzLlxuICAgICAqIFRoaXMgc2F2ZXMgcHJvY2Vzc2luZy9lbmVyZ3kgYW5kIGZpeGVzIHZhcmlvdXMgYnJvd3Nlci1zcGVjaWZpYyBidWdzIHdpdGggYXVkaW8gZ2V0dGluZyBzdHVjay5cbiAgICAgKiBAcmV0dXJuIHtIb3dsZXJ9XG4gICAgICovXG4gICAgX2F1dG9TdXNwZW5kOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgaWYgKCFzZWxmLmF1dG9TdXNwZW5kIHx8ICFzZWxmLmN0eCB8fCB0eXBlb2Ygc2VsZi5jdHguc3VzcGVuZCA9PT0gJ3VuZGVmaW5lZCcgfHwgIUhvd2xlci51c2luZ1dlYkF1ZGlvKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgaWYgYW55IHNvdW5kcyBhcmUgcGxheWluZy5cbiAgICAgIGZvciAodmFyIGk9MDsgaTxzZWxmLl9ob3dscy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoc2VsZi5faG93bHNbaV0uX3dlYkF1ZGlvKSB7XG4gICAgICAgICAgZm9yICh2YXIgaj0wOyBqPHNlbGYuX2hvd2xzW2ldLl9zb3VuZHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGlmICghc2VsZi5faG93bHNbaV0uX3NvdW5kc1tqXS5fcGF1c2VkKSB7XG4gICAgICAgICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoc2VsZi5fc3VzcGVuZFRpbWVyKSB7XG4gICAgICAgIGNsZWFyVGltZW91dChzZWxmLl9zdXNwZW5kVGltZXIpO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiBubyBzb3VuZCBoYXMgcGxheWVkIGFmdGVyIDMwIHNlY29uZHMsIHN1c3BlbmQgdGhlIGNvbnRleHQuXG4gICAgICBzZWxmLl9zdXNwZW5kVGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXNlbGYuYXV0b1N1c3BlbmQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBzZWxmLl9zdXNwZW5kVGltZXIgPSBudWxsO1xuICAgICAgICBzZWxmLnN0YXRlID0gJ3N1c3BlbmRpbmcnO1xuICAgICAgICBzZWxmLmN0eC5zdXNwZW5kKCkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICBzZWxmLnN0YXRlID0gJ3N1c3BlbmRlZCc7XG5cbiAgICAgICAgICBpZiAoc2VsZi5fcmVzdW1lQWZ0ZXJTdXNwZW5kKSB7XG4gICAgICAgICAgICBkZWxldGUgc2VsZi5fcmVzdW1lQWZ0ZXJTdXNwZW5kO1xuICAgICAgICAgICAgc2VsZi5fYXV0b1Jlc3VtZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9LCAzMDAwMCk7XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBdXRvbWF0aWNhbGx5IHJlc3VtZSB0aGUgV2ViIEF1ZGlvIEF1ZGlvQ29udGV4dCB3aGVuIGEgbmV3IHNvdW5kIGlzIHBsYXllZC5cbiAgICAgKiBAcmV0dXJuIHtIb3dsZXJ9XG4gICAgICovXG4gICAgX2F1dG9SZXN1bWU6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICBpZiAoIXNlbGYuY3R4IHx8IHR5cGVvZiBzZWxmLmN0eC5yZXN1bWUgPT09ICd1bmRlZmluZWQnIHx8ICFIb3dsZXIudXNpbmdXZWJBdWRpbykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChzZWxmLnN0YXRlID09PSAncnVubmluZycgJiYgc2VsZi5fc3VzcGVuZFRpbWVyKSB7XG4gICAgICAgIGNsZWFyVGltZW91dChzZWxmLl9zdXNwZW5kVGltZXIpO1xuICAgICAgICBzZWxmLl9zdXNwZW5kVGltZXIgPSBudWxsO1xuICAgICAgfSBlbHNlIGlmIChzZWxmLnN0YXRlID09PSAnc3VzcGVuZGVkJykge1xuICAgICAgICBzZWxmLnN0YXRlID0gJ3Jlc3VtaW5nJztcbiAgICAgICAgc2VsZi5jdHgucmVzdW1lKCkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICBzZWxmLnN0YXRlID0gJ3J1bm5pbmcnO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoc2VsZi5fc3VzcGVuZFRpbWVyKSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHNlbGYuX3N1c3BlbmRUaW1lcik7XG4gICAgICAgICAgc2VsZi5fc3VzcGVuZFRpbWVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChzZWxmLnN0YXRlID09PSAnc3VzcGVuZGluZycpIHtcbiAgICAgICAgc2VsZi5fcmVzdW1lQWZ0ZXJTdXNwZW5kID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuICB9O1xuXG4gIC8vIFNldHVwIHRoZSBnbG9iYWwgYXVkaW8gY29udHJvbGxlci5cbiAgdmFyIEhvd2xlciA9IG5ldyBIb3dsZXJHbG9iYWwoKTtcblxuICAvKiogR3JvdXAgTWV0aG9kcyAqKi9cbiAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAvKipcbiAgICogQ3JlYXRlIGFuIGF1ZGlvIGdyb3VwIGNvbnRyb2xsZXIuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvIFBhc3NlZCBpbiBwcm9wZXJ0aWVzIGZvciB0aGlzIGdyb3VwLlxuICAgKi9cbiAgdmFyIEhvd2wgPSBmdW5jdGlvbihvKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgLy8gVGhyb3cgYW4gZXJyb3IgaWYgbm8gc291cmNlIGlzIHByb3ZpZGVkLlxuICAgIGlmICghby5zcmMgfHwgby5zcmMubGVuZ3RoID09PSAwKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdBbiBhcnJheSBvZiBzb3VyY2UgZmlsZXMgbXVzdCBiZSBwYXNzZWQgd2l0aCBhbnkgbmV3IEhvd2wuJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc2VsZi5pbml0KG8pO1xuICB9O1xuICBIb3dsLnByb3RvdHlwZSA9IHtcbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplIGEgbmV3IEhvd2wgZ3JvdXAgb2JqZWN0LlxuICAgICAqIEBwYXJhbSAge09iamVjdH0gbyBQYXNzZWQgaW4gcHJvcGVydGllcyBmb3IgdGhpcyBncm91cC5cbiAgICAgKiBAcmV0dXJuIHtIb3dsfVxuICAgICAqL1xuICAgIGluaXQ6IGZ1bmN0aW9uKG8pIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBhbiBBdWRpb0NvbnRleHQgY3JlYXRlZCB5ZXQsIHJ1biB0aGUgc2V0dXAuXG4gICAgICBpZiAoIUhvd2xlci5jdHgpIHtcbiAgICAgICAgc2V0dXBBdWRpb0NvbnRleHQoKTtcbiAgICAgIH1cblxuICAgICAgLy8gU2V0dXAgdXNlci1kZWZpbmVkIGRlZmF1bHQgcHJvcGVydGllcy5cbiAgICAgIHNlbGYuX2F1dG9wbGF5ID0gby5hdXRvcGxheSB8fCBmYWxzZTtcbiAgICAgIHNlbGYuX2Zvcm1hdCA9ICh0eXBlb2Ygby5mb3JtYXQgIT09ICdzdHJpbmcnKSA/IG8uZm9ybWF0IDogW28uZm9ybWF0XTtcbiAgICAgIHNlbGYuX2h0bWw1ID0gby5odG1sNSB8fCBmYWxzZTtcbiAgICAgIHNlbGYuX211dGVkID0gby5tdXRlIHx8IGZhbHNlO1xuICAgICAgc2VsZi5fbG9vcCA9IG8ubG9vcCB8fCBmYWxzZTtcbiAgICAgIHNlbGYuX3Bvb2wgPSBvLnBvb2wgfHwgNTtcbiAgICAgIHNlbGYuX3ByZWxvYWQgPSAodHlwZW9mIG8ucHJlbG9hZCA9PT0gJ2Jvb2xlYW4nKSA/IG8ucHJlbG9hZCA6IHRydWU7XG4gICAgICBzZWxmLl9yYXRlID0gby5yYXRlIHx8IDE7XG4gICAgICBzZWxmLl9zcHJpdGUgPSBvLnNwcml0ZSB8fCB7fTtcbiAgICAgIHNlbGYuX3NyYyA9ICh0eXBlb2Ygby5zcmMgIT09ICdzdHJpbmcnKSA/IG8uc3JjIDogW28uc3JjXTtcbiAgICAgIHNlbGYuX3ZvbHVtZSA9IG8udm9sdW1lICE9PSB1bmRlZmluZWQgPyBvLnZvbHVtZSA6IDE7XG5cbiAgICAgIC8vIFNldHVwIGFsbCBvdGhlciBkZWZhdWx0IHByb3BlcnRpZXMuXG4gICAgICBzZWxmLl9kdXJhdGlvbiA9IDA7XG4gICAgICBzZWxmLl9zdGF0ZSA9ICd1bmxvYWRlZCc7XG4gICAgICBzZWxmLl9zb3VuZHMgPSBbXTtcbiAgICAgIHNlbGYuX2VuZFRpbWVycyA9IHt9O1xuICAgICAgc2VsZi5fcXVldWUgPSBbXTtcblxuICAgICAgLy8gU2V0dXAgZXZlbnQgbGlzdGVuZXJzLlxuICAgICAgc2VsZi5fb25lbmQgPSBvLm9uZW5kID8gW3tmbjogby5vbmVuZH1dIDogW107XG4gICAgICBzZWxmLl9vbmZhZGUgPSBvLm9uZmFkZSA/IFt7Zm46IG8ub25mYWRlfV0gOiBbXTtcbiAgICAgIHNlbGYuX29ubG9hZCA9IG8ub25sb2FkID8gW3tmbjogby5vbmxvYWR9XSA6IFtdO1xuICAgICAgc2VsZi5fb25sb2FkZXJyb3IgPSBvLm9ubG9hZGVycm9yID8gW3tmbjogby5vbmxvYWRlcnJvcn1dIDogW107XG4gICAgICBzZWxmLl9vbnBhdXNlID0gby5vbnBhdXNlID8gW3tmbjogby5vbnBhdXNlfV0gOiBbXTtcbiAgICAgIHNlbGYuX29ucGxheSA9IG8ub25wbGF5ID8gW3tmbjogby5vbnBsYXl9XSA6IFtdO1xuICAgICAgc2VsZi5fb25zdG9wID0gby5vbnN0b3AgPyBbe2ZuOiBvLm9uc3RvcH1dIDogW107XG4gICAgICBzZWxmLl9vbm11dGUgPSBvLm9ubXV0ZSA/IFt7Zm46IG8ub25tdXRlfV0gOiBbXTtcbiAgICAgIHNlbGYuX29udm9sdW1lID0gby5vbnZvbHVtZSA/IFt7Zm46IG8ub252b2x1bWV9XSA6IFtdO1xuICAgICAgc2VsZi5fb25yYXRlID0gby5vbnJhdGUgPyBbe2ZuOiBvLm9ucmF0ZX1dIDogW107XG4gICAgICBzZWxmLl9vbnNlZWsgPSBvLm9uc2VlayA/IFt7Zm46IG8ub25zZWVrfV0gOiBbXTtcblxuICAgICAgLy8gV2ViIEF1ZGlvIG9yIEhUTUw1IEF1ZGlvP1xuICAgICAgc2VsZi5fd2ViQXVkaW8gPSBIb3dsZXIudXNpbmdXZWJBdWRpbyAmJiAhc2VsZi5faHRtbDU7XG5cbiAgICAgIC8vIEF1dG9tYXRpY2FsbHkgdHJ5IHRvIGVuYWJsZSBhdWRpbyBvbiBpT1MuXG4gICAgICBpZiAodHlwZW9mIEhvd2xlci5jdHggIT09ICd1bmRlZmluZWQnICYmIEhvd2xlci5jdHggJiYgSG93bGVyLm1vYmlsZUF1dG9FbmFibGUpIHtcbiAgICAgICAgSG93bGVyLl9lbmFibGVNb2JpbGVBdWRpbygpO1xuICAgICAgfVxuXG4gICAgICAvLyBLZWVwIHRyYWNrIG9mIHRoaXMgSG93bCBncm91cCBpbiB0aGUgZ2xvYmFsIGNvbnRyb2xsZXIuXG4gICAgICBIb3dsZXIuX2hvd2xzLnB1c2goc2VsZik7XG5cbiAgICAgIC8vIExvYWQgdGhlIHNvdXJjZSBmaWxlIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkLlxuICAgICAgaWYgKHNlbGYuX3ByZWxvYWQpIHtcbiAgICAgICAgc2VsZi5sb2FkKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBMb2FkIHRoZSBhdWRpbyBmaWxlLlxuICAgICAqIEByZXR1cm4ge0hvd2xlcn1cbiAgICAgKi9cbiAgICBsb2FkOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciB1cmwgPSBudWxsO1xuXG4gICAgICAvLyBJZiBubyBhdWRpbyBpcyBhdmFpbGFibGUsIHF1aXQgaW1tZWRpYXRlbHkuXG4gICAgICBpZiAoSG93bGVyLm5vQXVkaW8pIHtcbiAgICAgICAgc2VsZi5fZW1pdCgnbG9hZGVycm9yJywgbnVsbCwgJ05vIGF1ZGlvIHN1cHBvcnQuJyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gTWFrZSBzdXJlIG91ciBzb3VyY2UgaXMgaW4gYW4gYXJyYXkuXG4gICAgICBpZiAodHlwZW9mIHNlbGYuX3NyYyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgc2VsZi5fc3JjID0gW3NlbGYuX3NyY107XG4gICAgICB9XG5cbiAgICAgIC8vIExvb3AgdGhyb3VnaCB0aGUgc291cmNlcyBhbmQgcGljayB0aGUgZmlyc3Qgb25lIHRoYXQgaXMgY29tcGF0aWJsZS5cbiAgICAgIGZvciAodmFyIGk9MDsgaTxzZWxmLl9zcmMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGV4dCwgc3RyO1xuXG4gICAgICAgIGlmIChzZWxmLl9mb3JtYXQgJiYgc2VsZi5fZm9ybWF0W2ldKSB7XG4gICAgICAgICAgLy8gSWYgYW4gZXh0ZW5zaW9uIHdhcyBzcGVjaWZpZWQsIHVzZSB0aGF0IGluc3RlYWQuXG4gICAgICAgICAgZXh0ID0gc2VsZi5fZm9ybWF0W2ldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgc291cmNlIGlzIGEgc3RyaW5nLlxuICAgICAgICAgIHN0ciA9IHNlbGYuX3NyY1tpXTtcbiAgICAgICAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHNlbGYuX2VtaXQoJ2xvYWRlcnJvcicsIG51bGwsICdOb24tc3RyaW5nIGZvdW5kIGluIHNlbGVjdGVkIGF1ZGlvIHNvdXJjZXMgLSBpZ25vcmluZy4nKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIEV4dHJhY3QgdGhlIGZpbGUgZXh0ZW5zaW9uIGZyb20gdGhlIFVSTCBvciBiYXNlNjQgZGF0YSBVUkkuXG4gICAgICAgICAgZXh0ID0gL15kYXRhOmF1ZGlvXFwvKFteOyxdKyk7L2kuZXhlYyhzdHIpO1xuICAgICAgICAgIGlmICghZXh0KSB7XG4gICAgICAgICAgICBleHQgPSAvXFwuKFteLl0rKSQvLmV4ZWMoc3RyLnNwbGl0KCc/JywgMSlbMF0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChleHQpIHtcbiAgICAgICAgICAgIGV4dCA9IGV4dFsxXS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIGlmIHRoaXMgZXh0ZW5zaW9uIGlzIGF2YWlsYWJsZS5cbiAgICAgICAgaWYgKEhvd2xlci5jb2RlY3MoZXh0KSkge1xuICAgICAgICAgIHVybCA9IHNlbGYuX3NyY1tpXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIXVybCkge1xuICAgICAgICBzZWxmLl9lbWl0KCdsb2FkZXJyb3InLCBudWxsLCAnTm8gY29kZWMgc3VwcG9ydCBmb3Igc2VsZWN0ZWQgYXVkaW8gc291cmNlcy4nKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBzZWxmLl9zcmMgPSB1cmw7XG4gICAgICBzZWxmLl9zdGF0ZSA9ICdsb2FkaW5nJztcblxuICAgICAgLy8gSWYgdGhlIGhvc3RpbmcgcGFnZSBpcyBIVFRQUyBhbmQgdGhlIHNvdXJjZSBpc24ndCxcbiAgICAgIC8vIGRyb3AgZG93biB0byBIVE1MNSBBdWRpbyB0byBhdm9pZCBNaXhlZCBDb250ZW50IGVycm9ycy5cbiAgICAgIGlmICh3aW5kb3cubG9jYXRpb24ucHJvdG9jb2wgPT09ICdodHRwczonICYmIHVybC5zbGljZSgwLCA1KSA9PT0gJ2h0dHA6Jykge1xuICAgICAgICBzZWxmLl9odG1sNSA9IHRydWU7XG4gICAgICAgIHNlbGYuX3dlYkF1ZGlvID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8vIENyZWF0ZSBhIG5ldyBzb3VuZCBvYmplY3QgYW5kIGFkZCBpdCB0byB0aGUgcG9vbC5cbiAgICAgIG5ldyBTb3VuZChzZWxmKTtcblxuICAgICAgLy8gTG9hZCBhbmQgZGVjb2RlIHRoZSBhdWRpbyBkYXRhIGZvciBwbGF5YmFjay5cbiAgICAgIGlmIChzZWxmLl93ZWJBdWRpbykge1xuICAgICAgICBsb2FkQnVmZmVyKHNlbGYpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUGxheSBhIHNvdW5kIG9yIHJlc3VtZSBwcmV2aW91cyBwbGF5YmFjay5cbiAgICAgKiBAcGFyYW0gIHtTdHJpbmcvTnVtYmVyfSBzcHJpdGUgICBTcHJpdGUgbmFtZSBmb3Igc3ByaXRlIHBsYXliYWNrIG9yIHNvdW5kIGlkIHRvIGNvbnRpbnVlIHByZXZpb3VzLlxuICAgICAqIEBwYXJhbSAge0Jvb2xlYW59IGludGVybmFsIEludGVybmFsIFVzZTogdHJ1ZSBwcmV2ZW50cyBldmVudCBmaXJpbmcuXG4gICAgICogQHJldHVybiB7TnVtYmVyfSAgICAgICAgICBTb3VuZCBJRC5cbiAgICAgKi9cbiAgICBwbGF5OiBmdW5jdGlvbihzcHJpdGUsIGludGVybmFsKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgaWQgPSBudWxsO1xuXG4gICAgICAvLyBEZXRlcm1pbmUgaWYgYSBzcHJpdGUsIHNvdW5kIGlkIG9yIG5vdGhpbmcgd2FzIHBhc3NlZFxuICAgICAgaWYgKHR5cGVvZiBzcHJpdGUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGlkID0gc3ByaXRlO1xuICAgICAgICBzcHJpdGUgPSBudWxsO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygc3ByaXRlID09PSAnc3RyaW5nJyAmJiBzZWxmLl9zdGF0ZSA9PT0gJ2xvYWRlZCcgJiYgIXNlbGYuX3Nwcml0ZVtzcHJpdGVdKSB7XG4gICAgICAgIC8vIElmIHRoZSBwYXNzZWQgc3ByaXRlIGRvZXNuJ3QgZXhpc3QsIGRvIG5vdGhpbmcuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygc3ByaXRlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAvLyBVc2UgdGhlIGRlZmF1bHQgc291bmQgc3ByaXRlIChwbGF5cyB0aGUgZnVsbCBhdWRpbyBsZW5ndGgpLlxuICAgICAgICBzcHJpdGUgPSAnX19kZWZhdWx0JztcblxuICAgICAgICAvLyBDaGVjayBpZiB0aGVyZSBpcyBhIHNpbmdsZSBwYXVzZWQgc291bmQgdGhhdCBpc24ndCBlbmRlZC5cbiAgICAgICAgLy8gSWYgdGhlcmUgaXMsIHBsYXkgdGhhdCBzb3VuZC4gSWYgbm90LCBjb250aW51ZSBhcyB1c3VhbC5cbiAgICAgICAgdmFyIG51bSA9IDA7XG4gICAgICAgIGZvciAodmFyIGk9MDsgaTxzZWxmLl9zb3VuZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAoc2VsZi5fc291bmRzW2ldLl9wYXVzZWQgJiYgIXNlbGYuX3NvdW5kc1tpXS5fZW5kZWQpIHtcbiAgICAgICAgICAgIG51bSsrO1xuICAgICAgICAgICAgaWQgPSBzZWxmLl9zb3VuZHNbaV0uX2lkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChudW0gPT09IDEpIHtcbiAgICAgICAgICBzcHJpdGUgPSBudWxsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlkID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBHZXQgdGhlIHNlbGVjdGVkIG5vZGUsIG9yIGdldCBvbmUgZnJvbSB0aGUgcG9vbC5cbiAgICAgIHZhciBzb3VuZCA9IGlkID8gc2VsZi5fc291bmRCeUlkKGlkKSA6IHNlbGYuX2luYWN0aXZlU291bmQoKTtcblxuICAgICAgLy8gSWYgdGhlIHNvdW5kIGRvZXNuJ3QgZXhpc3QsIGRvIG5vdGhpbmcuXG4gICAgICBpZiAoIXNvdW5kKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICAvLyBTZWxlY3QgdGhlIHNwcml0ZSBkZWZpbml0aW9uLlxuICAgICAgaWYgKGlkICYmICFzcHJpdGUpIHtcbiAgICAgICAgc3ByaXRlID0gc291bmQuX3Nwcml0ZSB8fCAnX19kZWZhdWx0JztcbiAgICAgIH1cblxuICAgICAgLy8gSWYgd2UgaGF2ZSBubyBzcHJpdGUgYW5kIHRoZSBzb3VuZCBoYXNuJ3QgbG9hZGVkLCB3ZSBtdXN0IHdhaXRcbiAgICAgIC8vIGZvciB0aGUgc291bmQgdG8gbG9hZCB0byBnZXQgb3VyIGF1ZGlvJ3MgZHVyYXRpb24uXG4gICAgICBpZiAoc2VsZi5fc3RhdGUgIT09ICdsb2FkZWQnICYmICFzZWxmLl9zcHJpdGVbc3ByaXRlXSkge1xuICAgICAgICBzZWxmLl9xdWV1ZS5wdXNoKHtcbiAgICAgICAgICBldmVudDogJ3BsYXknLFxuICAgICAgICAgIGFjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBzZWxmLnBsYXkoc2VsZi5fc291bmRCeUlkKHNvdW5kLl9pZCkgPyBzb3VuZC5faWQgOiB1bmRlZmluZWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHNvdW5kLl9pZDtcbiAgICAgIH1cblxuICAgICAgLy8gRG9uJ3QgcGxheSB0aGUgc291bmQgaWYgYW4gaWQgd2FzIHBhc3NlZCBhbmQgaXQgaXMgYWxyZWFkeSBwbGF5aW5nLlxuICAgICAgaWYgKGlkICYmICFzb3VuZC5fcGF1c2VkKSB7XG4gICAgICAgIC8vIFRyaWdnZXIgdGhlIHBsYXkgZXZlbnQsIGluIG9yZGVyIHRvIGtlZXAgaXRlcmF0aW5nIHRocm91Z2ggcXVldWUuXG4gICAgICAgIGlmICghaW50ZXJuYWwpIHtcbiAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc2VsZi5fZW1pdCgncGxheScsIHNvdW5kLl9pZCk7XG4gICAgICAgICAgfSwgMCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc291bmQuX2lkO1xuICAgICAgfVxuXG4gICAgICAvLyBNYWtlIHN1cmUgdGhlIEF1ZGlvQ29udGV4dCBpc24ndCBzdXNwZW5kZWQsIGFuZCByZXN1bWUgaXQgaWYgaXQgaXMuXG4gICAgICBpZiAoc2VsZi5fd2ViQXVkaW8pIHtcbiAgICAgICAgSG93bGVyLl9hdXRvUmVzdW1lKCk7XG4gICAgICB9XG5cbiAgICAgIC8vIERldGVybWluZSBob3cgbG9uZyB0byBwbGF5IGZvciBhbmQgd2hlcmUgdG8gc3RhcnQgcGxheWluZy5cbiAgICAgIHZhciBzZWVrID0gc291bmQuX3NlZWsgPiAwID8gc291bmQuX3NlZWsgOiBzZWxmLl9zcHJpdGVbc3ByaXRlXVswXSAvIDEwMDA7XG4gICAgICB2YXIgZHVyYXRpb24gPSAoKHNlbGYuX3Nwcml0ZVtzcHJpdGVdWzBdICsgc2VsZi5fc3ByaXRlW3Nwcml0ZV1bMV0pIC8gMTAwMCkgLSBzZWVrO1xuICAgICAgdmFyIHRpbWVvdXQgPSAoZHVyYXRpb24gKiAxMDAwKSAvIE1hdGguYWJzKHNvdW5kLl9yYXRlKTtcblxuICAgICAgLy8gVXBkYXRlIHRoZSBwYXJhbWV0ZXJzIG9mIHRoZSBzb3VuZFxuICAgICAgc291bmQuX3BhdXNlZCA9IGZhbHNlO1xuICAgICAgc291bmQuX2VuZGVkID0gZmFsc2U7XG4gICAgICBzb3VuZC5fc3ByaXRlID0gc3ByaXRlO1xuICAgICAgc291bmQuX3NlZWsgPSBzZWVrO1xuICAgICAgc291bmQuX3N0YXJ0ID0gc2VsZi5fc3ByaXRlW3Nwcml0ZV1bMF0gLyAxMDAwO1xuICAgICAgc291bmQuX3N0b3AgPSAoc2VsZi5fc3ByaXRlW3Nwcml0ZV1bMF0gKyBzZWxmLl9zcHJpdGVbc3ByaXRlXVsxXSkgLyAxMDAwO1xuICAgICAgc291bmQuX2xvb3AgPSAhIShzb3VuZC5fbG9vcCB8fCBzZWxmLl9zcHJpdGVbc3ByaXRlXVsyXSk7XG5cbiAgICAgIC8vIEJlZ2luIHRoZSBhY3R1YWwgcGxheWJhY2suXG4gICAgICB2YXIgbm9kZSA9IHNvdW5kLl9ub2RlO1xuICAgICAgaWYgKHNlbGYuX3dlYkF1ZGlvKSB7XG4gICAgICAgIC8vIEZpcmUgdGhpcyB3aGVuIHRoZSBzb3VuZCBpcyByZWFkeSB0byBwbGF5IHRvIGJlZ2luIFdlYiBBdWRpbyBwbGF5YmFjay5cbiAgICAgICAgdmFyIHBsYXlXZWJBdWRpbyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHNlbGYuX3JlZnJlc2hCdWZmZXIoc291bmQpO1xuXG4gICAgICAgICAgLy8gU2V0dXAgdGhlIHBsYXliYWNrIHBhcmFtcy5cbiAgICAgICAgICB2YXIgdm9sID0gKHNvdW5kLl9tdXRlZCB8fCBzZWxmLl9tdXRlZCkgPyAwIDogc291bmQuX3ZvbHVtZTtcbiAgICAgICAgICBub2RlLmdhaW4uc2V0VmFsdWVBdFRpbWUodm9sLCBIb3dsZXIuY3R4LmN1cnJlbnRUaW1lKTtcbiAgICAgICAgICBzb3VuZC5fcGxheVN0YXJ0ID0gSG93bGVyLmN0eC5jdXJyZW50VGltZTtcblxuICAgICAgICAgIC8vIFBsYXkgdGhlIHNvdW5kIHVzaW5nIHRoZSBzdXBwb3J0ZWQgbWV0aG9kLlxuICAgICAgICAgIGlmICh0eXBlb2Ygbm9kZS5idWZmZXJTb3VyY2Uuc3RhcnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBzb3VuZC5fbG9vcCA/IG5vZGUuYnVmZmVyU291cmNlLm5vdGVHcmFpbk9uKDAsIHNlZWssIDg2NDAwKSA6IG5vZGUuYnVmZmVyU291cmNlLm5vdGVHcmFpbk9uKDAsIHNlZWssIGR1cmF0aW9uKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc291bmQuX2xvb3AgPyBub2RlLmJ1ZmZlclNvdXJjZS5zdGFydCgwLCBzZWVrLCA4NjQwMCkgOiBub2RlLmJ1ZmZlclNvdXJjZS5zdGFydCgwLCBzZWVrLCBkdXJhdGlvbik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gU3RhcnQgYSBuZXcgdGltZXIgaWYgbm9uZSBpcyBwcmVzZW50LlxuICAgICAgICAgIGlmICh0aW1lb3V0ICE9PSBJbmZpbml0eSkge1xuICAgICAgICAgICAgc2VsZi5fZW5kVGltZXJzW3NvdW5kLl9pZF0gPSBzZXRUaW1lb3V0KHNlbGYuX2VuZGVkLmJpbmQoc2VsZiwgc291bmQpLCB0aW1lb3V0KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIWludGVybmFsKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICBzZWxmLl9lbWl0KCdwbGF5Jywgc291bmQuX2lkKTtcbiAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoc2VsZi5fc3RhdGUgPT09ICdsb2FkZWQnKSB7XG4gICAgICAgICAgcGxheVdlYkF1ZGlvKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gV2FpdCBmb3IgdGhlIGF1ZGlvIHRvIGxvYWQgYW5kIHRoZW4gYmVnaW4gcGxheWJhY2suXG4gICAgICAgICAgc2VsZi5vbmNlKCdsb2FkJywgcGxheVdlYkF1ZGlvLCBzb3VuZC5faWQpO1xuXG4gICAgICAgICAgLy8gQ2FuY2VsIHRoZSBlbmQgdGltZXIuXG4gICAgICAgICAgc2VsZi5fY2xlYXJUaW1lcihzb3VuZC5faWQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGaXJlIHRoaXMgd2hlbiB0aGUgc291bmQgaXMgcmVhZHkgdG8gcGxheSB0byBiZWdpbiBIVE1MNSBBdWRpbyBwbGF5YmFjay5cbiAgICAgICAgdmFyIHBsYXlIdG1sNSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIG5vZGUuY3VycmVudFRpbWUgPSBzZWVrO1xuICAgICAgICAgIG5vZGUubXV0ZWQgPSBzb3VuZC5fbXV0ZWQgfHwgc2VsZi5fbXV0ZWQgfHwgSG93bGVyLl9tdXRlZCB8fCBub2RlLm11dGVkO1xuICAgICAgICAgIG5vZGUudm9sdW1lID0gc291bmQuX3ZvbHVtZSAqIEhvd2xlci52b2x1bWUoKTtcbiAgICAgICAgICBub2RlLnBsYXliYWNrUmF0ZSA9IHNvdW5kLl9yYXRlO1xuXG4gICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIG5vZGUucGxheSgpO1xuXG4gICAgICAgICAgICAvLyBTZXR1cCB0aGUgbmV3IGVuZCB0aW1lci5cbiAgICAgICAgICAgIGlmICh0aW1lb3V0ICE9PSBJbmZpbml0eSkge1xuICAgICAgICAgICAgICBzZWxmLl9lbmRUaW1lcnNbc291bmQuX2lkXSA9IHNldFRpbWVvdXQoc2VsZi5fZW5kZWQuYmluZChzZWxmLCBzb3VuZCksIHRpbWVvdXQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWludGVybmFsKSB7XG4gICAgICAgICAgICAgIHNlbGYuX2VtaXQoJ3BsYXknLCBzb3VuZC5faWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIDApO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFBsYXkgaW1tZWRpYXRlbHkgaWYgcmVhZHksIG9yIHdhaXQgZm9yIHRoZSAnY2FucGxheXRocm91Z2gnZSB2ZW50LlxuICAgICAgICB2YXIgbG9hZGVkTm9SZWFkeVN0YXRlID0gKHNlbGYuX3N0YXRlID09PSAnbG9hZGVkJyAmJiAod2luZG93ICYmIHdpbmRvdy5lamVjdGEgfHwgIW5vZGUucmVhZHlTdGF0ZSAmJiBIb3dsZXIuX25hdmlnYXRvci5pc0NvY29vbkpTKSk7XG4gICAgICAgIGlmIChub2RlLnJlYWR5U3RhdGUgPT09IDQgfHwgbG9hZGVkTm9SZWFkeVN0YXRlKSB7XG4gICAgICAgICAgcGxheUh0bWw1KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGxpc3RlbmVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBCZWdpbiBwbGF5YmFjay5cbiAgICAgICAgICAgIHBsYXlIdG1sNSgpO1xuXG4gICAgICAgICAgICAvLyBDbGVhciB0aGlzIGxpc3RlbmVyLlxuICAgICAgICAgICAgbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKEhvd2xlci5fY2FuUGxheUV2ZW50LCBsaXN0ZW5lciwgZmFsc2UpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKEhvd2xlci5fY2FuUGxheUV2ZW50LCBsaXN0ZW5lciwgZmFsc2UpO1xuXG4gICAgICAgICAgLy8gQ2FuY2VsIHRoZSBlbmQgdGltZXIuXG4gICAgICAgICAgc2VsZi5fY2xlYXJUaW1lcihzb3VuZC5faWQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzb3VuZC5faWQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFBhdXNlIHBsYXliYWNrIGFuZCBzYXZlIGN1cnJlbnQgcG9zaXRpb24uXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBpZCBUaGUgc291bmQgSUQgKGVtcHR5IHRvIHBhdXNlIGFsbCBpbiBncm91cCkuXG4gICAgICogQHJldHVybiB7SG93bH1cbiAgICAgKi9cbiAgICBwYXVzZTogZnVuY3Rpb24oaWQpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgLy8gSWYgdGhlIHNvdW5kIGhhc24ndCBsb2FkZWQsIGFkZCBpdCB0byB0aGUgbG9hZCBxdWV1ZSB0byBwYXVzZSB3aGVuIGNhcGFibGUuXG4gICAgICBpZiAoc2VsZi5fc3RhdGUgIT09ICdsb2FkZWQnKSB7XG4gICAgICAgIHNlbGYuX3F1ZXVlLnB1c2goe1xuICAgICAgICAgIGV2ZW50OiAncGF1c2UnLFxuICAgICAgICAgIGFjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBzZWxmLnBhdXNlKGlkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiBubyBpZCBpcyBwYXNzZWQsIGdldCBhbGwgSUQncyB0byBiZSBwYXVzZWQuXG4gICAgICB2YXIgaWRzID0gc2VsZi5fZ2V0U291bmRJZHMoaWQpO1xuXG4gICAgICBmb3IgKHZhciBpPTA7IGk8aWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIENsZWFyIHRoZSBlbmQgdGltZXIuXG4gICAgICAgIHNlbGYuX2NsZWFyVGltZXIoaWRzW2ldKTtcblxuICAgICAgICAvLyBHZXQgdGhlIHNvdW5kLlxuICAgICAgICB2YXIgc291bmQgPSBzZWxmLl9zb3VuZEJ5SWQoaWRzW2ldKTtcblxuICAgICAgICBpZiAoc291bmQgJiYgIXNvdW5kLl9wYXVzZWQpIHtcbiAgICAgICAgICAvLyBSZXNldCB0aGUgc2VlayBwb3NpdGlvbi5cbiAgICAgICAgICBzb3VuZC5fc2VlayA9IHNlbGYuc2VlayhpZHNbaV0pO1xuICAgICAgICAgIHNvdW5kLl9yYXRlU2VlayA9IDA7XG4gICAgICAgICAgc291bmQuX3BhdXNlZCA9IHRydWU7XG5cbiAgICAgICAgICAvLyBTdG9wIGN1cnJlbnRseSBydW5uaW5nIGZhZGVzLlxuICAgICAgICAgIHNlbGYuX3N0b3BGYWRlKGlkc1tpXSk7XG5cbiAgICAgICAgICBpZiAoc291bmQuX25vZGUpIHtcbiAgICAgICAgICAgIGlmIChzZWxmLl93ZWJBdWRpbykge1xuICAgICAgICAgICAgICAvLyBtYWtlIHN1cmUgdGhlIHNvdW5kIGhhcyBiZWVuIGNyZWF0ZWRcbiAgICAgICAgICAgICAgaWYgKCFzb3VuZC5fbm9kZS5idWZmZXJTb3VyY2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmICh0eXBlb2Ygc291bmQuX25vZGUuYnVmZmVyU291cmNlLnN0b3AgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgc291bmQuX25vZGUuYnVmZmVyU291cmNlLm5vdGVPZmYoMCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc291bmQuX25vZGUuYnVmZmVyU291cmNlLnN0b3AoMCk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAvLyBDbGVhbiB1cCB0aGUgYnVmZmVyIHNvdXJjZS5cbiAgICAgICAgICAgICAgc2VsZi5fY2xlYW5CdWZmZXIoc291bmQuX25vZGUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghaXNOYU4oc291bmQuX25vZGUuZHVyYXRpb24pIHx8IHNvdW5kLl9ub2RlLmR1cmF0aW9uID09PSBJbmZpbml0eSkge1xuICAgICAgICAgICAgICBzb3VuZC5fbm9kZS5wYXVzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIEZpcmUgdGhlIHBhdXNlIGV2ZW50LCB1bmxlc3MgYHRydWVgIGlzIHBhc3NlZCBhcyB0aGUgMm5kIGFyZ3VtZW50LlxuICAgICAgICAgIGlmICghYXJndW1lbnRzWzFdKSB7XG4gICAgICAgICAgICBzZWxmLl9lbWl0KCdwYXVzZScsIHNvdW5kLl9pZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTdG9wIHBsYXliYWNrIGFuZCByZXNldCB0byBzdGFydC5cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGlkIFRoZSBzb3VuZCBJRCAoZW1wdHkgdG8gc3RvcCBhbGwgaW4gZ3JvdXApLlxuICAgICAqIEBwYXJhbSAge0Jvb2xlYW59IGludGVybmFsIEludGVybmFsIFVzZTogdHJ1ZSBwcmV2ZW50cyBldmVudCBmaXJpbmcuXG4gICAgICogQHJldHVybiB7SG93bH1cbiAgICAgKi9cbiAgICBzdG9wOiBmdW5jdGlvbihpZCwgaW50ZXJuYWwpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgLy8gSWYgdGhlIHNvdW5kIGhhc24ndCBsb2FkZWQsIGFkZCBpdCB0byB0aGUgbG9hZCBxdWV1ZSB0byBzdG9wIHdoZW4gY2FwYWJsZS5cbiAgICAgIGlmIChzZWxmLl9zdGF0ZSAhPT0gJ2xvYWRlZCcpIHtcbiAgICAgICAgc2VsZi5fcXVldWUucHVzaCh7XG4gICAgICAgICAgZXZlbnQ6ICdzdG9wJyxcbiAgICAgICAgICBhY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc2VsZi5zdG9wKGlkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiBubyBpZCBpcyBwYXNzZWQsIGdldCBhbGwgSUQncyB0byBiZSBzdG9wcGVkLlxuICAgICAgdmFyIGlkcyA9IHNlbGYuX2dldFNvdW5kSWRzKGlkKTtcblxuICAgICAgZm9yICh2YXIgaT0wOyBpPGlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAvLyBDbGVhciB0aGUgZW5kIHRpbWVyLlxuICAgICAgICBzZWxmLl9jbGVhclRpbWVyKGlkc1tpXSk7XG5cbiAgICAgICAgLy8gR2V0IHRoZSBzb3VuZC5cbiAgICAgICAgdmFyIHNvdW5kID0gc2VsZi5fc291bmRCeUlkKGlkc1tpXSk7XG5cbiAgICAgICAgaWYgKHNvdW5kICYmICFzb3VuZC5fcGF1c2VkKSB7XG4gICAgICAgICAgLy8gUmVzZXQgdGhlIHNlZWsgcG9zaXRpb24uXG4gICAgICAgICAgc291bmQuX3NlZWsgPSBzb3VuZC5fc3RhcnQgfHwgMDtcbiAgICAgICAgICBzb3VuZC5fcmF0ZVNlZWsgPSAwO1xuICAgICAgICAgIHNvdW5kLl9wYXVzZWQgPSB0cnVlO1xuICAgICAgICAgIHNvdW5kLl9lbmRlZCA9IHRydWU7XG5cbiAgICAgICAgICAvLyBTdG9wIGN1cnJlbnRseSBydW5uaW5nIGZhZGVzLlxuICAgICAgICAgIHNlbGYuX3N0b3BGYWRlKGlkc1tpXSk7XG5cbiAgICAgICAgICBpZiAoc291bmQuX25vZGUpIHtcbiAgICAgICAgICAgIGlmIChzZWxmLl93ZWJBdWRpbykge1xuICAgICAgICAgICAgICAvLyBtYWtlIHN1cmUgdGhlIHNvdW5kIGhhcyBiZWVuIGNyZWF0ZWRcbiAgICAgICAgICAgICAgaWYgKCFzb3VuZC5fbm9kZS5idWZmZXJTb3VyY2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmICh0eXBlb2Ygc291bmQuX25vZGUuYnVmZmVyU291cmNlLnN0b3AgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgc291bmQuX25vZGUuYnVmZmVyU291cmNlLm5vdGVPZmYoMCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc291bmQuX25vZGUuYnVmZmVyU291cmNlLnN0b3AoMCk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAvLyBDbGVhbiB1cCB0aGUgYnVmZmVyIHNvdXJjZS5cbiAgICAgICAgICAgICAgc2VsZi5fY2xlYW5CdWZmZXIoc291bmQuX25vZGUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghaXNOYU4oc291bmQuX25vZGUuZHVyYXRpb24pIHx8IHNvdW5kLl9ub2RlLmR1cmF0aW9uID09PSBJbmZpbml0eSkge1xuICAgICAgICAgICAgICBzb3VuZC5fbm9kZS5jdXJyZW50VGltZSA9IHNvdW5kLl9zdGFydCB8fCAwO1xuICAgICAgICAgICAgICBzb3VuZC5fbm9kZS5wYXVzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzb3VuZCAmJiAhaW50ZXJuYWwpIHtcbiAgICAgICAgICBzZWxmLl9lbWl0KCdzdG9wJywgc291bmQuX2lkKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTXV0ZS91bm11dGUgYSBzaW5nbGUgc291bmQgb3IgYWxsIHNvdW5kcyBpbiB0aGlzIEhvd2wgZ3JvdXAuXG4gICAgICogQHBhcmFtICB7Qm9vbGVhbn0gbXV0ZWQgU2V0IHRvIHRydWUgdG8gbXV0ZSBhbmQgZmFsc2UgdG8gdW5tdXRlLlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gaWQgICAgVGhlIHNvdW5kIElEIHRvIHVwZGF0ZSAob21pdCB0byBtdXRlL3VubXV0ZSBhbGwpLlxuICAgICAqIEByZXR1cm4ge0hvd2x9XG4gICAgICovXG4gICAgbXV0ZTogZnVuY3Rpb24obXV0ZWQsIGlkKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgIC8vIElmIHRoZSBzb3VuZCBoYXNuJ3QgbG9hZGVkLCBhZGQgaXQgdG8gdGhlIGxvYWQgcXVldWUgdG8gbXV0ZSB3aGVuIGNhcGFibGUuXG4gICAgICBpZiAoc2VsZi5fc3RhdGUgIT09ICdsb2FkZWQnKSB7XG4gICAgICAgIHNlbGYuX3F1ZXVlLnB1c2goe1xuICAgICAgICAgIGV2ZW50OiAnbXV0ZScsXG4gICAgICAgICAgYWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHNlbGYubXV0ZShtdXRlZCwgaWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICB9XG5cbiAgICAgIC8vIElmIGFwcGx5aW5nIG11dGUvdW5tdXRlIHRvIGFsbCBzb3VuZHMsIHVwZGF0ZSB0aGUgZ3JvdXAncyB2YWx1ZS5cbiAgICAgIGlmICh0eXBlb2YgaWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbXV0ZWQgPT09ICdib29sZWFuJykge1xuICAgICAgICAgIHNlbGYuX211dGVkID0gbXV0ZWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHNlbGYuX211dGVkO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIElmIG5vIGlkIGlzIHBhc3NlZCwgZ2V0IGFsbCBJRCdzIHRvIGJlIG11dGVkLlxuICAgICAgdmFyIGlkcyA9IHNlbGYuX2dldFNvdW5kSWRzKGlkKTtcblxuICAgICAgZm9yICh2YXIgaT0wOyBpPGlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAvLyBHZXQgdGhlIHNvdW5kLlxuICAgICAgICB2YXIgc291bmQgPSBzZWxmLl9zb3VuZEJ5SWQoaWRzW2ldKTtcblxuICAgICAgICBpZiAoc291bmQpIHtcbiAgICAgICAgICBzb3VuZC5fbXV0ZWQgPSBtdXRlZDtcblxuICAgICAgICAgIGlmIChzZWxmLl93ZWJBdWRpbyAmJiBzb3VuZC5fbm9kZSkge1xuICAgICAgICAgICAgc291bmQuX25vZGUuZ2Fpbi5zZXRWYWx1ZUF0VGltZShtdXRlZCA/IDAgOiBzb3VuZC5fdm9sdW1lLCBIb3dsZXIuY3R4LmN1cnJlbnRUaW1lKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHNvdW5kLl9ub2RlKSB7XG4gICAgICAgICAgICBzb3VuZC5fbm9kZS5tdXRlZCA9IEhvd2xlci5fbXV0ZWQgPyB0cnVlIDogbXV0ZWQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc2VsZi5fZW1pdCgnbXV0ZScsIHNvdW5kLl9pZCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldC9zZXQgdGhlIHZvbHVtZSBvZiB0aGlzIHNvdW5kIG9yIG9mIHRoZSBIb3dsIGdyb3VwLiBUaGlzIG1ldGhvZCBjYW4gb3B0aW9uYWxseSB0YWtlIDAsIDEgb3IgMiBhcmd1bWVudHMuXG4gICAgICogICB2b2x1bWUoKSAtPiBSZXR1cm5zIHRoZSBncm91cCdzIHZvbHVtZSB2YWx1ZS5cbiAgICAgKiAgIHZvbHVtZShpZCkgLT4gUmV0dXJucyB0aGUgc291bmQgaWQncyBjdXJyZW50IHZvbHVtZS5cbiAgICAgKiAgIHZvbHVtZSh2b2wpIC0+IFNldHMgdGhlIHZvbHVtZSBvZiBhbGwgc291bmRzIGluIHRoaXMgSG93bCBncm91cC5cbiAgICAgKiAgIHZvbHVtZSh2b2wsIGlkKSAtPiBTZXRzIHRoZSB2b2x1bWUgb2YgcGFzc2VkIHNvdW5kIGlkLlxuICAgICAqIEByZXR1cm4ge0hvd2wvTnVtYmVyfSBSZXR1cm5zIHNlbGYgb3IgY3VycmVudCB2b2x1bWUuXG4gICAgICovXG4gICAgdm9sdW1lOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgdmFyIHZvbCwgaWQ7XG5cbiAgICAgIC8vIERldGVybWluZSB0aGUgdmFsdWVzIGJhc2VkIG9uIGFyZ3VtZW50cy5cbiAgICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAvLyBSZXR1cm4gdGhlIHZhbHVlIG9mIHRoZSBncm91cHMnIHZvbHVtZS5cbiAgICAgICAgcmV0dXJuIHNlbGYuX3ZvbHVtZTtcbiAgICAgIH0gZWxzZSBpZiAoYXJncy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgLy8gRmlyc3QgY2hlY2sgaWYgdGhpcyBpcyBhbiBJRCwgYW5kIGlmIG5vdCwgYXNzdW1lIGl0IGlzIGEgbmV3IHZvbHVtZS5cbiAgICAgICAgdmFyIGlkcyA9IHNlbGYuX2dldFNvdW5kSWRzKCk7XG4gICAgICAgIHZhciBpbmRleCA9IGlkcy5pbmRleE9mKGFyZ3NbMF0pO1xuICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICAgIGlkID0gcGFyc2VJbnQoYXJnc1swXSwgMTApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZvbCA9IHBhcnNlRmxvYXQoYXJnc1swXSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoYXJncy5sZW5ndGggPj0gMikge1xuICAgICAgICB2b2wgPSBwYXJzZUZsb2F0KGFyZ3NbMF0pO1xuICAgICAgICBpZCA9IHBhcnNlSW50KGFyZ3NbMV0sIDEwKTtcbiAgICAgIH1cblxuICAgICAgLy8gVXBkYXRlIHRoZSB2b2x1bWUgb3IgcmV0dXJuIHRoZSBjdXJyZW50IHZvbHVtZS5cbiAgICAgIHZhciBzb3VuZDtcbiAgICAgIGlmICh0eXBlb2Ygdm9sICE9PSAndW5kZWZpbmVkJyAmJiB2b2wgPj0gMCAmJiB2b2wgPD0gMSkge1xuICAgICAgICAvLyBJZiB0aGUgc291bmQgaGFzbid0IGxvYWRlZCwgYWRkIGl0IHRvIHRoZSBsb2FkIHF1ZXVlIHRvIGNoYW5nZSB2b2x1bWUgd2hlbiBjYXBhYmxlLlxuICAgICAgICBpZiAoc2VsZi5fc3RhdGUgIT09ICdsb2FkZWQnKSB7XG4gICAgICAgICAgc2VsZi5fcXVldWUucHVzaCh7XG4gICAgICAgICAgICBldmVudDogJ3ZvbHVtZScsXG4gICAgICAgICAgICBhY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICBzZWxmLnZvbHVtZS5hcHBseShzZWxmLCBhcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2V0IHRoZSBncm91cCB2b2x1bWUuXG4gICAgICAgIGlmICh0eXBlb2YgaWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgc2VsZi5fdm9sdW1lID0gdm9sO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVXBkYXRlIG9uZSBvciBhbGwgdm9sdW1lcy5cbiAgICAgICAgaWQgPSBzZWxmLl9nZXRTb3VuZElkcyhpZCk7XG4gICAgICAgIGZvciAodmFyIGk9MDsgaTxpZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIC8vIEdldCB0aGUgc291bmQuXG4gICAgICAgICAgc291bmQgPSBzZWxmLl9zb3VuZEJ5SWQoaWRbaV0pO1xuXG4gICAgICAgICAgaWYgKHNvdW5kKSB7XG4gICAgICAgICAgICBzb3VuZC5fdm9sdW1lID0gdm9sO1xuXG4gICAgICAgICAgICAvLyBTdG9wIGN1cnJlbnRseSBydW5uaW5nIGZhZGVzLlxuICAgICAgICAgICAgaWYgKCFhcmdzWzJdKSB7XG4gICAgICAgICAgICAgIHNlbGYuX3N0b3BGYWRlKGlkW2ldKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNlbGYuX3dlYkF1ZGlvICYmIHNvdW5kLl9ub2RlICYmICFzb3VuZC5fbXV0ZWQpIHtcbiAgICAgICAgICAgICAgc291bmQuX25vZGUuZ2Fpbi5zZXRWYWx1ZUF0VGltZSh2b2wsIEhvd2xlci5jdHguY3VycmVudFRpbWUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzb3VuZC5fbm9kZSAmJiAhc291bmQuX211dGVkKSB7XG4gICAgICAgICAgICAgIHNvdW5kLl9ub2RlLnZvbHVtZSA9IHZvbCAqIEhvd2xlci52b2x1bWUoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2VsZi5fZW1pdCgndm9sdW1lJywgc291bmQuX2lkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNvdW5kID0gaWQgPyBzZWxmLl9zb3VuZEJ5SWQoaWQpIDogc2VsZi5fc291bmRzWzBdO1xuICAgICAgICByZXR1cm4gc291bmQgPyBzb3VuZC5fdm9sdW1lIDogMDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZhZGUgYSBjdXJyZW50bHkgcGxheWluZyBzb3VuZCBiZXR3ZWVuIHR3byB2b2x1bWVzIChpZiBubyBpZCBpcyBwYXNzc2VkLCBhbGwgc291bmRzIHdpbGwgZmFkZSkuXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBmcm9tIFRoZSB2YWx1ZSB0byBmYWRlIGZyb20gKDAuMCB0byAxLjApLlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gdG8gICBUaGUgdm9sdW1lIHRvIGZhZGUgdG8gKDAuMCB0byAxLjApLlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gbGVuICBUaW1lIGluIG1pbGxpc2Vjb25kcyB0byBmYWRlLlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gaWQgICBUaGUgc291bmQgaWQgKG9taXQgdG8gZmFkZSBhbGwgc291bmRzKS5cbiAgICAgKiBAcmV0dXJuIHtIb3dsfVxuICAgICAqL1xuICAgIGZhZGU6IGZ1bmN0aW9uKGZyb20sIHRvLCBsZW4sIGlkKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgZGlmZiA9IE1hdGguYWJzKGZyb20gLSB0byk7XG4gICAgICB2YXIgZGlyID0gZnJvbSA+IHRvID8gJ291dCcgOiAnaW4nO1xuICAgICAgdmFyIHN0ZXBzID0gZGlmZiAvIDAuMDE7XG4gICAgICB2YXIgc3RlcExlbiA9IGxlbiAvIHN0ZXBzO1xuXG4gICAgICAvLyBJZiB0aGUgc291bmQgaGFzbid0IGxvYWRlZCwgYWRkIGl0IHRvIHRoZSBsb2FkIHF1ZXVlIHRvIGZhZGUgd2hlbiBjYXBhYmxlLlxuICAgICAgaWYgKHNlbGYuX3N0YXRlICE9PSAnbG9hZGVkJykge1xuICAgICAgICBzZWxmLl9xdWV1ZS5wdXNoKHtcbiAgICAgICAgICBldmVudDogJ2ZhZGUnLFxuICAgICAgICAgIGFjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBzZWxmLmZhZGUoZnJvbSwgdG8sIGxlbiwgaWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICB9XG5cbiAgICAgIC8vIFNldCB0aGUgdm9sdW1lIHRvIHRoZSBzdGFydCBwb3NpdGlvbi5cbiAgICAgIHNlbGYudm9sdW1lKGZyb20sIGlkKTtcblxuICAgICAgLy8gRmFkZSB0aGUgdm9sdW1lIG9mIG9uZSBvciBhbGwgc291bmRzLlxuICAgICAgdmFyIGlkcyA9IHNlbGYuX2dldFNvdW5kSWRzKGlkKTtcbiAgICAgIGZvciAodmFyIGk9MDsgaTxpZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gR2V0IHRoZSBzb3VuZC5cbiAgICAgICAgdmFyIHNvdW5kID0gc2VsZi5fc291bmRCeUlkKGlkc1tpXSk7XG5cbiAgICAgICAgLy8gQ3JlYXRlIGEgbGluZWFyIGZhZGUgb3IgZmFsbCBiYWNrIHRvIHRpbWVvdXRzIHdpdGggSFRNTDUgQXVkaW8uXG4gICAgICAgIGlmIChzb3VuZCkge1xuICAgICAgICAgIC8vIFN0b3AgdGhlIHByZXZpb3VzIGZhZGUgaWYgbm8gc3ByaXRlIGlzIGJlaW5nIHVzZWQgKG90aGVyd2lzZSwgdm9sdW1lIGhhbmRsZXMgdGhpcykuXG4gICAgICAgICAgaWYgKCFpZCkge1xuICAgICAgICAgICAgc2VsZi5fc3RvcEZhZGUoaWRzW2ldKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBJZiB3ZSBhcmUgdXNpbmcgV2ViIEF1ZGlvLCBsZXQgdGhlIG5hdGl2ZSBtZXRob2RzIGRvIHRoZSBhY3R1YWwgZmFkZS5cbiAgICAgICAgICBpZiAoc2VsZi5fd2ViQXVkaW8gJiYgIXNvdW5kLl9tdXRlZCkge1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRUaW1lID0gSG93bGVyLmN0eC5jdXJyZW50VGltZTtcbiAgICAgICAgICAgIHZhciBlbmQgPSBjdXJyZW50VGltZSArIChsZW4gLyAxMDAwKTtcbiAgICAgICAgICAgIHNvdW5kLl92b2x1bWUgPSBmcm9tO1xuICAgICAgICAgICAgc291bmQuX25vZGUuZ2Fpbi5zZXRWYWx1ZUF0VGltZShmcm9tLCBjdXJyZW50VGltZSk7XG4gICAgICAgICAgICBzb3VuZC5fbm9kZS5nYWluLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKHRvLCBlbmQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciB2b2wgPSBmcm9tO1xuICAgICAgICAgIHNvdW5kLl9pbnRlcnZhbCA9IHNldEludGVydmFsKGZ1bmN0aW9uKHNvdW5kSWQsIHNvdW5kKSB7XG4gICAgICAgICAgICAvLyBVcGRhdGUgdGhlIHZvbHVtZSBhbW91bnQuXG4gICAgICAgICAgICB2b2wgKz0gKGRpciA9PT0gJ2luJyA/IDAuMDEgOiAtMC4wMSk7XG5cbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgdm9sdW1lIGlzIGluIHRoZSByaWdodCBib3VuZHMuXG4gICAgICAgICAgICB2b2wgPSBNYXRoLm1heCgwLCB2b2wpO1xuICAgICAgICAgICAgdm9sID0gTWF0aC5taW4oMSwgdm9sKTtcblxuICAgICAgICAgICAgLy8gUm91bmQgdG8gd2l0aGluIDIgZGVjaW1hbCBwb2ludHMuXG4gICAgICAgICAgICB2b2wgPSBNYXRoLnJvdW5kKHZvbCAqIDEwMCkgLyAxMDA7XG5cbiAgICAgICAgICAgIC8vIENoYW5nZSB0aGUgdm9sdW1lLlxuICAgICAgICAgICAgaWYgKHNlbGYuX3dlYkF1ZGlvKSB7XG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgaWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5fdm9sdW1lID0gdm9sO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgc291bmQuX3ZvbHVtZSA9IHZvbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHNlbGYudm9sdW1lKHZvbCwgc291bmRJZCwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFdoZW4gdGhlIGZhZGUgaXMgY29tcGxldGUsIHN0b3AgaXQgYW5kIGZpcmUgZXZlbnQuXG4gICAgICAgICAgICBpZiAodm9sID09PSB0bykge1xuICAgICAgICAgICAgICBjbGVhckludGVydmFsKHNvdW5kLl9pbnRlcnZhbCk7XG4gICAgICAgICAgICAgIHNvdW5kLl9pbnRlcnZhbCA9IG51bGw7XG4gICAgICAgICAgICAgIHNlbGYudm9sdW1lKHZvbCwgc291bmRJZCk7XG4gICAgICAgICAgICAgIHNlbGYuX2VtaXQoJ2ZhZGUnLCBzb3VuZElkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LmJpbmQoc2VsZiwgaWRzW2ldLCBzb3VuZCksIHN0ZXBMZW4pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBtZXRob2QgdGhhdCBzdG9wcyB0aGUgY3VycmVudGx5IHBsYXlpbmcgZmFkZSB3aGVuXG4gICAgICogYSBuZXcgZmFkZSBzdGFydHMsIHZvbHVtZSBpcyBjaGFuZ2VkIG9yIHRoZSBzb3VuZCBpcyBzdG9wcGVkLlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gaWQgVGhlIHNvdW5kIGlkLlxuICAgICAqIEByZXR1cm4ge0hvd2x9XG4gICAgICovXG4gICAgX3N0b3BGYWRlOiBmdW5jdGlvbihpZCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIHNvdW5kID0gc2VsZi5fc291bmRCeUlkKGlkKTtcblxuICAgICAgaWYgKHNvdW5kICYmIHNvdW5kLl9pbnRlcnZhbCkge1xuICAgICAgICBpZiAoc2VsZi5fd2ViQXVkaW8pIHtcbiAgICAgICAgICBzb3VuZC5fbm9kZS5nYWluLmNhbmNlbFNjaGVkdWxlZFZhbHVlcyhIb3dsZXIuY3R4LmN1cnJlbnRUaW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNsZWFySW50ZXJ2YWwoc291bmQuX2ludGVydmFsKTtcbiAgICAgICAgc291bmQuX2ludGVydmFsID0gbnVsbDtcbiAgICAgICAgc2VsZi5fZW1pdCgnZmFkZScsIGlkKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldC9zZXQgdGhlIGxvb3AgcGFyYW1ldGVyIG9uIGEgc291bmQuIFRoaXMgbWV0aG9kIGNhbiBvcHRpb25hbGx5IHRha2UgMCwgMSBvciAyIGFyZ3VtZW50cy5cbiAgICAgKiAgIGxvb3AoKSAtPiBSZXR1cm5zIHRoZSBncm91cCdzIGxvb3AgdmFsdWUuXG4gICAgICogICBsb29wKGlkKSAtPiBSZXR1cm5zIHRoZSBzb3VuZCBpZCdzIGxvb3AgdmFsdWUuXG4gICAgICogICBsb29wKGxvb3ApIC0+IFNldHMgdGhlIGxvb3AgdmFsdWUgZm9yIGFsbCBzb3VuZHMgaW4gdGhpcyBIb3dsIGdyb3VwLlxuICAgICAqICAgbG9vcChsb29wLCBpZCkgLT4gU2V0cyB0aGUgbG9vcCB2YWx1ZSBvZiBwYXNzZWQgc291bmQgaWQuXG4gICAgICogQHJldHVybiB7SG93bC9Cb29sZWFufSBSZXR1cm5zIHNlbGYgb3IgY3VycmVudCBsb29wIHZhbHVlLlxuICAgICAqL1xuICAgIGxvb3A6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICB2YXIgbG9vcCwgaWQsIHNvdW5kO1xuXG4gICAgICAvLyBEZXRlcm1pbmUgdGhlIHZhbHVlcyBmb3IgbG9vcCBhbmQgaWQuXG4gICAgICBpZiAoYXJncy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgLy8gUmV0dXJuIHRoZSBncm91J3MgbG9vcCB2YWx1ZS5cbiAgICAgICAgcmV0dXJuIHNlbGYuX2xvb3A7XG4gICAgICB9IGVsc2UgaWYgKGFyZ3MubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYXJnc1swXSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgbG9vcCA9IGFyZ3NbMF07XG4gICAgICAgICAgc2VsZi5fbG9vcCA9IGxvb3A7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gUmV0dXJuIHRoaXMgc291bmQncyBsb29wIHZhbHVlLlxuICAgICAgICAgIHNvdW5kID0gc2VsZi5fc291bmRCeUlkKHBhcnNlSW50KGFyZ3NbMF0sIDEwKSk7XG4gICAgICAgICAgcmV0dXJuIHNvdW5kID8gc291bmQuX2xvb3AgOiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChhcmdzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICBsb29wID0gYXJnc1swXTtcbiAgICAgICAgaWQgPSBwYXJzZUludChhcmdzWzFdLCAxMCk7XG4gICAgICB9XG5cbiAgICAgIC8vIElmIG5vIGlkIGlzIHBhc3NlZCwgZ2V0IGFsbCBJRCdzIHRvIGJlIGxvb3BlZC5cbiAgICAgIHZhciBpZHMgPSBzZWxmLl9nZXRTb3VuZElkcyhpZCk7XG4gICAgICBmb3IgKHZhciBpPTA7IGk8aWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHNvdW5kID0gc2VsZi5fc291bmRCeUlkKGlkc1tpXSk7XG5cbiAgICAgICAgaWYgKHNvdW5kKSB7XG4gICAgICAgICAgc291bmQuX2xvb3AgPSBsb29wO1xuICAgICAgICAgIGlmIChzZWxmLl93ZWJBdWRpbyAmJiBzb3VuZC5fbm9kZSAmJiBzb3VuZC5fbm9kZS5idWZmZXJTb3VyY2UpIHtcbiAgICAgICAgICAgIHNvdW5kLl9ub2RlLmJ1ZmZlclNvdXJjZS5sb29wID0gbG9vcDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldC9zZXQgdGhlIHBsYXliYWNrIHJhdGUgb2YgYSBzb3VuZC4gVGhpcyBtZXRob2QgY2FuIG9wdGlvbmFsbHkgdGFrZSAwLCAxIG9yIDIgYXJndW1lbnRzLlxuICAgICAqICAgcmF0ZSgpIC0+IFJldHVybnMgdGhlIGZpcnN0IHNvdW5kIG5vZGUncyBjdXJyZW50IHBsYXliYWNrIHJhdGUuXG4gICAgICogICByYXRlKGlkKSAtPiBSZXR1cm5zIHRoZSBzb3VuZCBpZCdzIGN1cnJlbnQgcGxheWJhY2sgcmF0ZS5cbiAgICAgKiAgIHJhdGUocmF0ZSkgLT4gU2V0cyB0aGUgcGxheWJhY2sgcmF0ZSBvZiBhbGwgc291bmRzIGluIHRoaXMgSG93bCBncm91cC5cbiAgICAgKiAgIHJhdGUocmF0ZSwgaWQpIC0+IFNldHMgdGhlIHBsYXliYWNrIHJhdGUgb2YgcGFzc2VkIHNvdW5kIGlkLlxuICAgICAqIEByZXR1cm4ge0hvd2wvTnVtYmVyfSBSZXR1cm5zIHNlbGYgb3IgdGhlIGN1cnJlbnQgcGxheWJhY2sgcmF0ZS5cbiAgICAgKi9cbiAgICByYXRlOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgdmFyIHJhdGUsIGlkO1xuXG4gICAgICAvLyBEZXRlcm1pbmUgdGhlIHZhbHVlcyBiYXNlZCBvbiBhcmd1bWVudHMuXG4gICAgICBpZiAoYXJncy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgLy8gV2Ugd2lsbCBzaW1wbHkgcmV0dXJuIHRoZSBjdXJyZW50IHJhdGUgb2YgdGhlIGZpcnN0IG5vZGUuXG4gICAgICAgIGlkID0gc2VsZi5fc291bmRzWzBdLl9pZDtcbiAgICAgIH0gZWxzZSBpZiAoYXJncy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgLy8gRmlyc3QgY2hlY2sgaWYgdGhpcyBpcyBhbiBJRCwgYW5kIGlmIG5vdCwgYXNzdW1lIGl0IGlzIGEgbmV3IHJhdGUgdmFsdWUuXG4gICAgICAgIHZhciBpZHMgPSBzZWxmLl9nZXRTb3VuZElkcygpO1xuICAgICAgICB2YXIgaW5kZXggPSBpZHMuaW5kZXhPZihhcmdzWzBdKTtcbiAgICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgICBpZCA9IHBhcnNlSW50KGFyZ3NbMF0sIDEwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByYXRlID0gcGFyc2VGbG9hdChhcmdzWzBdKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChhcmdzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICByYXRlID0gcGFyc2VGbG9hdChhcmdzWzBdKTtcbiAgICAgICAgaWQgPSBwYXJzZUludChhcmdzWzFdLCAxMCk7XG4gICAgICB9XG5cbiAgICAgIC8vIFVwZGF0ZSB0aGUgcGxheWJhY2sgcmF0ZSBvciByZXR1cm4gdGhlIGN1cnJlbnQgdmFsdWUuXG4gICAgICB2YXIgc291bmQ7XG4gICAgICBpZiAodHlwZW9mIHJhdGUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIC8vIElmIHRoZSBzb3VuZCBoYXNuJ3QgbG9hZGVkLCBhZGQgaXQgdG8gdGhlIGxvYWQgcXVldWUgdG8gY2hhbmdlIHBsYXliYWNrIHJhdGUgd2hlbiBjYXBhYmxlLlxuICAgICAgICBpZiAoc2VsZi5fc3RhdGUgIT09ICdsb2FkZWQnKSB7XG4gICAgICAgICAgc2VsZi5fcXVldWUucHVzaCh7XG4gICAgICAgICAgICBldmVudDogJ3JhdGUnLFxuICAgICAgICAgICAgYWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgc2VsZi5yYXRlLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTZXQgdGhlIGdyb3VwIHJhdGUuXG4gICAgICAgIGlmICh0eXBlb2YgaWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgc2VsZi5fcmF0ZSA9IHJhdGU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBVcGRhdGUgb25lIG9yIGFsbCB2b2x1bWVzLlxuICAgICAgICBpZCA9IHNlbGYuX2dldFNvdW5kSWRzKGlkKTtcbiAgICAgICAgZm9yICh2YXIgaT0wOyBpPGlkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgLy8gR2V0IHRoZSBzb3VuZC5cbiAgICAgICAgICBzb3VuZCA9IHNlbGYuX3NvdW5kQnlJZChpZFtpXSk7XG5cbiAgICAgICAgICBpZiAoc291bmQpIHtcbiAgICAgICAgICAgIC8vIEtlZXAgdHJhY2sgb2Ygb3VyIHBvc2l0aW9uIHdoZW4gdGhlIHJhdGUgY2hhbmdlZCBhbmQgdXBkYXRlIHRoZSBwbGF5YmFja1xuICAgICAgICAgICAgLy8gc3RhcnQgcG9zaXRpb24gc28gd2UgY2FuIHByb3Blcmx5IGFkanVzdCB0aGUgc2VlayBwb3NpdGlvbiBmb3IgdGltZSBlbGFwc2VkLlxuICAgICAgICAgICAgc291bmQuX3JhdGVTZWVrID0gc2VsZi5zZWVrKGlkW2ldKTtcbiAgICAgICAgICAgIHNvdW5kLl9wbGF5U3RhcnQgPSBzZWxmLl93ZWJBdWRpbyA/IEhvd2xlci5jdHguY3VycmVudFRpbWUgOiBzb3VuZC5fcGxheVN0YXJ0O1xuICAgICAgICAgICAgc291bmQuX3JhdGUgPSByYXRlO1xuXG4gICAgICAgICAgICAvLyBDaGFuZ2UgdGhlIHBsYXliYWNrIHJhdGUuXG4gICAgICAgICAgICBpZiAoc2VsZi5fd2ViQXVkaW8gJiYgc291bmQuX25vZGUgJiYgc291bmQuX25vZGUuYnVmZmVyU291cmNlKSB7XG4gICAgICAgICAgICAgIHNvdW5kLl9ub2RlLmJ1ZmZlclNvdXJjZS5wbGF5YmFja1JhdGUudmFsdWUgPSByYXRlO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzb3VuZC5fbm9kZSkge1xuICAgICAgICAgICAgICBzb3VuZC5fbm9kZS5wbGF5YmFja1JhdGUgPSByYXRlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBSZXNldCB0aGUgdGltZXJzLlxuICAgICAgICAgICAgdmFyIHNlZWsgPSBzZWxmLnNlZWsoaWRbaV0pO1xuICAgICAgICAgICAgdmFyIGR1cmF0aW9uID0gKChzZWxmLl9zcHJpdGVbc291bmQuX3Nwcml0ZV1bMF0gKyBzZWxmLl9zcHJpdGVbc291bmQuX3Nwcml0ZV1bMV0pIC8gMTAwMCkgLSBzZWVrO1xuICAgICAgICAgICAgdmFyIHRpbWVvdXQgPSAoZHVyYXRpb24gKiAxMDAwKSAvIE1hdGguYWJzKHNvdW5kLl9yYXRlKTtcblxuICAgICAgICAgICAgLy8gU3RhcnQgYSBuZXcgZW5kIHRpbWVyIGlmIHNvdW5kIGlzIGFscmVhZHkgcGxheWluZy5cbiAgICAgICAgICAgIGlmIChzZWxmLl9lbmRUaW1lcnNbaWRbaV1dIHx8ICFzb3VuZC5fcGF1c2VkKSB7XG4gICAgICAgICAgICAgIHNlbGYuX2NsZWFyVGltZXIoaWRbaV0pO1xuICAgICAgICAgICAgICBzZWxmLl9lbmRUaW1lcnNbaWRbaV1dID0gc2V0VGltZW91dChzZWxmLl9lbmRlZC5iaW5kKHNlbGYsIHNvdW5kKSwgdGltZW91dCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNlbGYuX2VtaXQoJ3JhdGUnLCBzb3VuZC5faWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc291bmQgPSBzZWxmLl9zb3VuZEJ5SWQoaWQpO1xuICAgICAgICByZXR1cm4gc291bmQgPyBzb3VuZC5fcmF0ZSA6IHNlbGYuX3JhdGU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQvc2V0IHRoZSBzZWVrIHBvc2l0aW9uIG9mIGEgc291bmQuIFRoaXMgbWV0aG9kIGNhbiBvcHRpb25hbGx5IHRha2UgMCwgMSBvciAyIGFyZ3VtZW50cy5cbiAgICAgKiAgIHNlZWsoKSAtPiBSZXR1cm5zIHRoZSBmaXJzdCBzb3VuZCBub2RlJ3MgY3VycmVudCBzZWVrIHBvc2l0aW9uLlxuICAgICAqICAgc2VlayhpZCkgLT4gUmV0dXJucyB0aGUgc291bmQgaWQncyBjdXJyZW50IHNlZWsgcG9zaXRpb24uXG4gICAgICogICBzZWVrKHNlZWspIC0+IFNldHMgdGhlIHNlZWsgcG9zaXRpb24gb2YgdGhlIGZpcnN0IHNvdW5kIG5vZGUuXG4gICAgICogICBzZWVrKHNlZWssIGlkKSAtPiBTZXRzIHRoZSBzZWVrIHBvc2l0aW9uIG9mIHBhc3NlZCBzb3VuZCBpZC5cbiAgICAgKiBAcmV0dXJuIHtIb3dsL051bWJlcn0gUmV0dXJucyBzZWxmIG9yIHRoZSBjdXJyZW50IHNlZWsgcG9zaXRpb24uXG4gICAgICovXG4gICAgc2VlazogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgIHZhciBzZWVrLCBpZDtcblxuICAgICAgLy8gRGV0ZXJtaW5lIHRoZSB2YWx1ZXMgYmFzZWQgb24gYXJndW1lbnRzLlxuICAgICAgaWYgKGFyZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIC8vIFdlIHdpbGwgc2ltcGx5IHJldHVybiB0aGUgY3VycmVudCBwb3NpdGlvbiBvZiB0aGUgZmlyc3Qgbm9kZS5cbiAgICAgICAgaWQgPSBzZWxmLl9zb3VuZHNbMF0uX2lkO1xuICAgICAgfSBlbHNlIGlmIChhcmdzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAvLyBGaXJzdCBjaGVjayBpZiB0aGlzIGlzIGFuIElELCBhbmQgaWYgbm90LCBhc3N1bWUgaXQgaXMgYSBuZXcgc2VlayBwb3NpdGlvbi5cbiAgICAgICAgdmFyIGlkcyA9IHNlbGYuX2dldFNvdW5kSWRzKCk7XG4gICAgICAgIHZhciBpbmRleCA9IGlkcy5pbmRleE9mKGFyZ3NbMF0pO1xuICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICAgIGlkID0gcGFyc2VJbnQoYXJnc1swXSwgMTApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlkID0gc2VsZi5fc291bmRzWzBdLl9pZDtcbiAgICAgICAgICBzZWVrID0gcGFyc2VGbG9hdChhcmdzWzBdKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChhcmdzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICBzZWVrID0gcGFyc2VGbG9hdChhcmdzWzBdKTtcbiAgICAgICAgaWQgPSBwYXJzZUludChhcmdzWzFdLCAxMCk7XG4gICAgICB9XG5cbiAgICAgIC8vIElmIHRoZXJlIGlzIG5vIElELCBiYWlsIG91dC5cbiAgICAgIGlmICh0eXBlb2YgaWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiB0aGUgc291bmQgaGFzbid0IGxvYWRlZCwgYWRkIGl0IHRvIHRoZSBsb2FkIHF1ZXVlIHRvIHNlZWsgd2hlbiBjYXBhYmxlLlxuICAgICAgaWYgKHNlbGYuX3N0YXRlICE9PSAnbG9hZGVkJykge1xuICAgICAgICBzZWxmLl9xdWV1ZS5wdXNoKHtcbiAgICAgICAgICBldmVudDogJ3NlZWsnLFxuICAgICAgICAgIGFjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBzZWxmLnNlZWsuYXBwbHkoc2VsZiwgYXJncyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgIH1cblxuICAgICAgLy8gR2V0IHRoZSBzb3VuZC5cbiAgICAgIHZhciBzb3VuZCA9IHNlbGYuX3NvdW5kQnlJZChpZCk7XG5cbiAgICAgIGlmIChzb3VuZCkge1xuICAgICAgICBpZiAodHlwZW9mIHNlZWsgPT09ICdudW1iZXInICYmIHNlZWsgPj0gMCkge1xuICAgICAgICAgIC8vIFBhdXNlIHRoZSBzb3VuZCBhbmQgdXBkYXRlIHBvc2l0aW9uIGZvciByZXN0YXJ0aW5nIHBsYXliYWNrLlxuICAgICAgICAgIHZhciBwbGF5aW5nID0gc2VsZi5wbGF5aW5nKGlkKTtcbiAgICAgICAgICBpZiAocGxheWluZykge1xuICAgICAgICAgICAgc2VsZi5wYXVzZShpZCwgdHJ1ZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gTW92ZSB0aGUgcG9zaXRpb24gb2YgdGhlIHRyYWNrIGFuZCBjYW5jZWwgdGltZXIuXG4gICAgICAgICAgc291bmQuX3NlZWsgPSBzZWVrO1xuICAgICAgICAgIHNvdW5kLl9lbmRlZCA9IGZhbHNlO1xuICAgICAgICAgIHNlbGYuX2NsZWFyVGltZXIoaWQpO1xuXG4gICAgICAgICAgLy8gUmVzdGFydCB0aGUgcGxheWJhY2sgaWYgdGhlIHNvdW5kIHdhcyBwbGF5aW5nLlxuICAgICAgICAgIGlmIChwbGF5aW5nKSB7XG4gICAgICAgICAgICBzZWxmLnBsYXkoaWQsIHRydWUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgc2VlayBwb3NpdGlvbiBmb3IgSFRNTDUgQXVkaW8uXG4gICAgICAgICAgaWYgKCFzZWxmLl93ZWJBdWRpbyAmJiBzb3VuZC5fbm9kZSkge1xuICAgICAgICAgICAgc291bmQuX25vZGUuY3VycmVudFRpbWUgPSBzZWVrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHNlbGYuX2VtaXQoJ3NlZWsnLCBpZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHNlbGYuX3dlYkF1ZGlvKSB7XG4gICAgICAgICAgICB2YXIgcmVhbFRpbWUgPSBzZWxmLnBsYXlpbmcoaWQpID8gSG93bGVyLmN0eC5jdXJyZW50VGltZSAtIHNvdW5kLl9wbGF5U3RhcnQgOiAwO1xuICAgICAgICAgICAgdmFyIHJhdGVTZWVrID0gc291bmQuX3JhdGVTZWVrID8gc291bmQuX3JhdGVTZWVrIC0gc291bmQuX3NlZWsgOiAwO1xuICAgICAgICAgICAgcmV0dXJuIHNvdW5kLl9zZWVrICsgKHJhdGVTZWVrICsgcmVhbFRpbWUgKiBNYXRoLmFicyhzb3VuZC5fcmF0ZSkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gc291bmQuX25vZGUuY3VycmVudFRpbWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBhIHNwZWNpZmljIHNvdW5kIGlzIGN1cnJlbnRseSBwbGF5aW5nIG9yIG5vdCAoaWYgaWQgaXMgcHJvdmlkZWQpLCBvciBjaGVjayBpZiBhdCBsZWFzdCBvbmUgb2YgdGhlIHNvdW5kcyBpbiB0aGUgZ3JvdXAgaXMgcGxheWluZyBvciBub3QuXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSAgaWQgVGhlIHNvdW5kIGlkIHRvIGNoZWNrLiBJZiBub25lIGlzIHBhc3NlZCwgdGhlIHdob2xlIHNvdW5kIGdyb3VwIGlzIGNoZWNrZWQuXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gVHJ1ZSBpZiBwbGF5aW5nIGFuZCBmYWxzZSBpZiBub3QuXG4gICAgICovXG4gICAgcGxheWluZzogZnVuY3Rpb24oaWQpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgLy8gQ2hlY2sgdGhlIHBhc3NlZCBzb3VuZCBJRCAoaWYgYW55KS5cbiAgICAgIGlmICh0eXBlb2YgaWQgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHZhciBzb3VuZCA9IHNlbGYuX3NvdW5kQnlJZChpZCk7XG4gICAgICAgIHJldHVybiBzb3VuZCA/ICFzb3VuZC5fcGF1c2VkIDogZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8vIE90aGVyd2lzZSwgbG9vcCB0aHJvdWdoIGFsbCBzb3VuZHMgYW5kIGNoZWNrIGlmIGFueSBhcmUgcGxheWluZy5cbiAgICAgIGZvciAodmFyIGk9MDsgaTxzZWxmLl9zb3VuZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKCFzZWxmLl9zb3VuZHNbaV0uX3BhdXNlZCkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBkdXJhdGlvbiBvZiB0aGlzIHNvdW5kLiBQYXNzaW5nIGEgc291bmQgaWQgd2lsbCByZXR1cm4gdGhlIHNwcml0ZSBkdXJhdGlvbi5cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGlkIFRoZSBzb3VuZCBpZCB0byBjaGVjay4gSWYgbm9uZSBpcyBwYXNzZWQsIHJldHVybiBmdWxsIHNvdXJjZSBkdXJhdGlvbi5cbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IEF1ZGlvIGR1cmF0aW9uIGluIHNlY29uZHMuXG4gICAgICovXG4gICAgZHVyYXRpb246IGZ1bmN0aW9uKGlkKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgZHVyYXRpb24gPSBzZWxmLl9kdXJhdGlvbjtcblxuICAgICAgLy8gSWYgd2UgcGFzcyBhbiBJRCwgZ2V0IHRoZSBzb3VuZCBhbmQgcmV0dXJuIHRoZSBzcHJpdGUgbGVuZ3RoLlxuICAgICAgdmFyIHNvdW5kID0gc2VsZi5fc291bmRCeUlkKGlkKTtcbiAgICAgIGlmIChzb3VuZCkge1xuICAgICAgICBkdXJhdGlvbiA9IHNlbGYuX3Nwcml0ZVtzb3VuZC5fc3ByaXRlXVsxXSAvIDEwMDA7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkdXJhdGlvbjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY3VycmVudCBsb2FkZWQgc3RhdGUgb2YgdGhpcyBIb3dsLlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gJ3VubG9hZGVkJywgJ2xvYWRpbmcnLCAnbG9hZGVkJ1xuICAgICAqL1xuICAgIHN0YXRlOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zdGF0ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVW5sb2FkIGFuZCBkZXN0cm95IHRoZSBjdXJyZW50IEhvd2wgb2JqZWN0LlxuICAgICAqIFRoaXMgd2lsbCBpbW1lZGlhdGVseSBzdG9wIGFsbCBzb3VuZCBpbnN0YW5jZXMgYXR0YWNoZWQgdG8gdGhpcyBncm91cC5cbiAgICAgKi9cbiAgICB1bmxvYWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAvLyBTdG9wIHBsYXlpbmcgYW55IGFjdGl2ZSBzb3VuZHMuXG4gICAgICB2YXIgc291bmRzID0gc2VsZi5fc291bmRzO1xuICAgICAgZm9yICh2YXIgaT0wOyBpPHNvdW5kcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAvLyBTdG9wIHRoZSBzb3VuZCBpZiBpdCBpcyBjdXJyZW50bHkgcGxheWluZy5cbiAgICAgICAgaWYgKCFzb3VuZHNbaV0uX3BhdXNlZCkge1xuICAgICAgICAgIHNlbGYuc3RvcChzb3VuZHNbaV0uX2lkKTtcbiAgICAgICAgICBzZWxmLl9lbWl0KCdlbmQnLCBzb3VuZHNbaV0uX2lkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlbW92ZSB0aGUgc291cmNlIG9yIGRpc2Nvbm5lY3QuXG4gICAgICAgIGlmICghc2VsZi5fd2ViQXVkaW8pIHtcbiAgICAgICAgICAvLyBTZXQgdGhlIHNvdXJjZSB0byAwLXNlY29uZCBzaWxlbmNlIHRvIHN0b3AgYW55IGRvd25sb2FkaW5nLlxuICAgICAgICAgIHNvdW5kc1tpXS5fbm9kZS5zcmMgPSAnZGF0YTphdWRpby93YXY7YmFzZTY0LFVrbEdSaVFBQUFCWFFWWkZabTEwSUJBQUFBQUJBQUVBUkt3QUFJaFlBUUFDQUJBQVpHRjBZUUFBQUFBPSc7XG5cbiAgICAgICAgICAvLyBSZW1vdmUgYW55IGV2ZW50IGxpc3RlbmVycy5cbiAgICAgICAgICBzb3VuZHNbaV0uX25vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXJyb3InLCBzb3VuZHNbaV0uX2Vycm9yRm4sIGZhbHNlKTtcbiAgICAgICAgICBzb3VuZHNbaV0uX25vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihIb3dsZXIuX2NhblBsYXlFdmVudCwgc291bmRzW2ldLl9sb2FkRm4sIGZhbHNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEVtcHR5IG91dCBhbGwgb2YgdGhlIG5vZGVzLlxuICAgICAgICBkZWxldGUgc291bmRzW2ldLl9ub2RlO1xuXG4gICAgICAgIC8vIE1ha2Ugc3VyZSBhbGwgdGltZXJzIGFyZSBjbGVhcmVkIG91dC5cbiAgICAgICAgc2VsZi5fY2xlYXJUaW1lcihzb3VuZHNbaV0uX2lkKTtcblxuICAgICAgICAvLyBSZW1vdmUgdGhlIHJlZmVyZW5jZXMgaW4gdGhlIGdsb2JhbCBIb3dsZXIgb2JqZWN0LlxuICAgICAgICB2YXIgaW5kZXggPSBIb3dsZXIuX2hvd2xzLmluZGV4T2Yoc2VsZik7XG4gICAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgICAgSG93bGVyLl9ob3dscy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIERlbGV0ZSB0aGlzIHNvdW5kIGZyb20gdGhlIGNhY2hlIChpZiBubyBvdGhlciBIb3dsIGlzIHVzaW5nIGl0KS5cbiAgICAgIHZhciByZW1DYWNoZSA9IHRydWU7XG4gICAgICBmb3IgKGk9MDsgaTxIb3dsZXIuX2hvd2xzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChIb3dsZXIuX2hvd2xzW2ldLl9zcmMgPT09IHNlbGYuX3NyYykge1xuICAgICAgICAgIHJlbUNhY2hlID0gZmFsc2U7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGNhY2hlICYmIHJlbUNhY2hlKSB7XG4gICAgICAgIGRlbGV0ZSBjYWNoZVtzZWxmLl9zcmNdO1xuICAgICAgfVxuXG4gICAgICAvLyBDbGVhciBvdXQgYHNlbGZgLlxuICAgICAgc2VsZi5fc3RhdGUgPSAndW5sb2FkZWQnO1xuICAgICAgc2VsZi5fc291bmRzID0gW107XG4gICAgICBzZWxmID0gbnVsbDtcblxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIExpc3RlbiB0byBhIGN1c3RvbSBldmVudC5cbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9ICAgZXZlbnQgRXZlbnQgbmFtZS5cbiAgICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gZm4gICAgTGlzdGVuZXIgdG8gY2FsbC5cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9ICAgaWQgICAgKG9wdGlvbmFsKSBPbmx5IGxpc3RlbiB0byBldmVudHMgZm9yIHRoaXMgc291bmQuXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSAgIG9uY2UgIChJTlRFUk5BTCkgTWFya3MgZXZlbnQgdG8gZmlyZSBvbmx5IG9uY2UuXG4gICAgICogQHJldHVybiB7SG93bH1cbiAgICAgKi9cbiAgICBvbjogZnVuY3Rpb24oZXZlbnQsIGZuLCBpZCwgb25jZSkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIGV2ZW50cyA9IHNlbGZbJ19vbicgKyBldmVudF07XG5cbiAgICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZXZlbnRzLnB1c2gob25jZSA/IHtpZDogaWQsIGZuOiBmbiwgb25jZTogb25jZX0gOiB7aWQ6IGlkLCBmbjogZm59KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhIGN1c3RvbSBldmVudC4gQ2FsbCB3aXRob3V0IHBhcmFtZXRlcnMgdG8gcmVtb3ZlIGFsbCBldmVudHMuXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSAgIGV2ZW50IEV2ZW50IG5hbWUuXG4gICAgICogQHBhcmFtICB7RnVuY3Rpb259IGZuICAgIExpc3RlbmVyIHRvIHJlbW92ZS4gTGVhdmUgZW1wdHkgdG8gcmVtb3ZlIGFsbC5cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9ICAgaWQgICAgKG9wdGlvbmFsKSBPbmx5IHJlbW92ZSBldmVudHMgZm9yIHRoaXMgc291bmQuXG4gICAgICogQHJldHVybiB7SG93bH1cbiAgICAgKi9cbiAgICBvZmY6IGZ1bmN0aW9uKGV2ZW50LCBmbiwgaWQpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBldmVudHMgPSBzZWxmWydfb24nICsgZXZlbnRdO1xuICAgICAgdmFyIGkgPSAwO1xuXG4gICAgICBpZiAoZm4pIHtcbiAgICAgICAgLy8gTG9vcCB0aHJvdWdoIGV2ZW50IHN0b3JlIGFuZCByZW1vdmUgdGhlIHBhc3NlZCBmdW5jdGlvbi5cbiAgICAgICAgZm9yIChpPTA7IGk8ZXZlbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKGZuID09PSBldmVudHNbaV0uZm4gJiYgaWQgPT09IGV2ZW50c1tpXS5pZCkge1xuICAgICAgICAgICAgZXZlbnRzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChldmVudCkge1xuICAgICAgICAvLyBDbGVhciBvdXQgYWxsIGV2ZW50cyBvZiB0aGlzIHR5cGUuXG4gICAgICAgIHNlbGZbJ19vbicgKyBldmVudF0gPSBbXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIENsZWFyIG91dCBhbGwgZXZlbnRzIG9mIGV2ZXJ5IHR5cGUuXG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoc2VsZik7XG4gICAgICAgIGZvciAoaT0wOyBpPGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAoKGtleXNbaV0uaW5kZXhPZignX29uJykgPT09IDApICYmIEFycmF5LmlzQXJyYXkoc2VsZltrZXlzW2ldXSkpIHtcbiAgICAgICAgICAgIHNlbGZba2V5c1tpXV0gPSBbXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIExpc3RlbiB0byBhIGN1c3RvbSBldmVudCBhbmQgcmVtb3ZlIGl0IG9uY2UgZmlyZWQuXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSAgIGV2ZW50IEV2ZW50IG5hbWUuXG4gICAgICogQHBhcmFtICB7RnVuY3Rpb259IGZuICAgIExpc3RlbmVyIHRvIGNhbGwuXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSAgIGlkICAgIChvcHRpb25hbCkgT25seSBsaXN0ZW4gdG8gZXZlbnRzIGZvciB0aGlzIHNvdW5kLlxuICAgICAqIEByZXR1cm4ge0hvd2x9XG4gICAgICovXG4gICAgb25jZTogZnVuY3Rpb24oZXZlbnQsIGZuLCBpZCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAvLyBTZXR1cCB0aGUgZXZlbnQgbGlzdGVuZXIuXG4gICAgICBzZWxmLm9uKGV2ZW50LCBmbiwgaWQsIDEpO1xuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRW1pdCBhbGwgZXZlbnRzIG9mIGEgc3BlY2lmaWMgdHlwZSBhbmQgcGFzcyB0aGUgc291bmQgaWQuXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBldmVudCBFdmVudCBuYW1lLlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gaWQgICAgU291bmQgSUQuXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBtc2cgICBNZXNzYWdlIHRvIGdvIHdpdGggZXZlbnQuXG4gICAgICogQHJldHVybiB7SG93bH1cbiAgICAgKi9cbiAgICBfZW1pdDogZnVuY3Rpb24oZXZlbnQsIGlkLCBtc2cpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBldmVudHMgPSBzZWxmWydfb24nICsgZXZlbnRdO1xuXG4gICAgICAvLyBMb29wIHRocm91Z2ggZXZlbnQgc3RvcmUgYW5kIGZpcmUgYWxsIGZ1bmN0aW9ucy5cbiAgICAgIGZvciAodmFyIGk9ZXZlbnRzLmxlbmd0aC0xOyBpPj0wOyBpLS0pIHtcbiAgICAgICAgaWYgKCFldmVudHNbaV0uaWQgfHwgZXZlbnRzW2ldLmlkID09PSBpZCB8fCBldmVudCA9PT0gJ2xvYWQnKSB7XG4gICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbihmbikge1xuICAgICAgICAgICAgZm4uY2FsbCh0aGlzLCBpZCwgbXNnKTtcbiAgICAgICAgICB9LmJpbmQoc2VsZiwgZXZlbnRzW2ldLmZuKSwgMCk7XG5cbiAgICAgICAgICAvLyBJZiB0aGlzIGV2ZW50IHdhcyBzZXR1cCB3aXRoIGBvbmNlYCwgcmVtb3ZlIGl0LlxuICAgICAgICAgIGlmIChldmVudHNbaV0ub25jZSkge1xuICAgICAgICAgICAgc2VsZi5vZmYoZXZlbnQsIGV2ZW50c1tpXS5mbiwgZXZlbnRzW2ldLmlkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFF1ZXVlIG9mIGFjdGlvbnMgaW5pdGlhdGVkIGJlZm9yZSB0aGUgc291bmQgaGFzIGxvYWRlZC5cbiAgICAgKiBUaGVzZSB3aWxsIGJlIGNhbGxlZCBpbiBzZXF1ZW5jZSwgd2l0aCB0aGUgbmV4dCBvbmx5IGZpcmluZ1xuICAgICAqIGFmdGVyIHRoZSBwcmV2aW91cyBoYXMgZmluaXNoZWQgZXhlY3V0aW5nIChldmVuIGlmIGFzeW5jIGxpa2UgcGxheSkuXG4gICAgICogQHJldHVybiB7SG93bH1cbiAgICAgKi9cbiAgICBfbG9hZFF1ZXVlOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgaWYgKHNlbGYuX3F1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIHRhc2sgPSBzZWxmLl9xdWV1ZVswXTtcblxuICAgICAgICAvLyBkb24ndCBtb3ZlIG9udG8gdGhlIG5leHQgdGFzayB1bnRpbCB0aGlzIG9uZSBpcyBkb25lXG4gICAgICAgIHNlbGYub25jZSh0YXNrLmV2ZW50LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICBzZWxmLl9xdWV1ZS5zaGlmdCgpO1xuICAgICAgICAgIHNlbGYuX2xvYWRRdWV1ZSgpO1xuICAgICAgICB9KTtcblxuICAgICAgICB0YXNrLmFjdGlvbigpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmlyZWQgd2hlbiBwbGF5YmFjayBlbmRzIGF0IHRoZSBlbmQgb2YgdGhlIGR1cmF0aW9uLlxuICAgICAqIEBwYXJhbSAge1NvdW5kfSBzb3VuZCBUaGUgc291bmQgb2JqZWN0IHRvIHdvcmsgd2l0aC5cbiAgICAgKiBAcmV0dXJuIHtIb3dsfVxuICAgICAqL1xuICAgIF9lbmRlZDogZnVuY3Rpb24oc291bmQpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBzcHJpdGUgPSBzb3VuZC5fc3ByaXRlO1xuXG4gICAgICAvLyBTaG91bGQgdGhpcyBzb3VuZCBsb29wP1xuICAgICAgdmFyIGxvb3AgPSAhIShzb3VuZC5fbG9vcCB8fCBzZWxmLl9zcHJpdGVbc3ByaXRlXVsyXSk7XG5cbiAgICAgIC8vIEZpcmUgdGhlIGVuZGVkIGV2ZW50LlxuICAgICAgc2VsZi5fZW1pdCgnZW5kJywgc291bmQuX2lkKTtcblxuICAgICAgLy8gUmVzdGFydCB0aGUgcGxheWJhY2sgZm9yIEhUTUw1IEF1ZGlvIGxvb3AuXG4gICAgICBpZiAoIXNlbGYuX3dlYkF1ZGlvICYmIGxvb3ApIHtcbiAgICAgICAgc2VsZi5zdG9wKHNvdW5kLl9pZCwgdHJ1ZSkucGxheShzb3VuZC5faWQpO1xuICAgICAgfVxuXG4gICAgICAvLyBSZXN0YXJ0IHRoaXMgdGltZXIgaWYgb24gYSBXZWIgQXVkaW8gbG9vcC5cbiAgICAgIGlmIChzZWxmLl93ZWJBdWRpbyAmJiBsb29wKSB7XG4gICAgICAgIHNlbGYuX2VtaXQoJ3BsYXknLCBzb3VuZC5faWQpO1xuICAgICAgICBzb3VuZC5fc2VlayA9IHNvdW5kLl9zdGFydCB8fCAwO1xuICAgICAgICBzb3VuZC5fcmF0ZVNlZWsgPSAwO1xuICAgICAgICBzb3VuZC5fcGxheVN0YXJ0ID0gSG93bGVyLmN0eC5jdXJyZW50VGltZTtcblxuICAgICAgICB2YXIgdGltZW91dCA9ICgoc291bmQuX3N0b3AgLSBzb3VuZC5fc3RhcnQpICogMTAwMCkgLyBNYXRoLmFicyhzb3VuZC5fcmF0ZSk7XG4gICAgICAgIHNlbGYuX2VuZFRpbWVyc1tzb3VuZC5faWRdID0gc2V0VGltZW91dChzZWxmLl9lbmRlZC5iaW5kKHNlbGYsIHNvdW5kKSwgdGltZW91dCk7XG4gICAgICB9XG5cbiAgICAgIC8vIE1hcmsgdGhlIG5vZGUgYXMgcGF1c2VkLlxuICAgICAgaWYgKHNlbGYuX3dlYkF1ZGlvICYmICFsb29wKSB7XG4gICAgICAgIHNvdW5kLl9wYXVzZWQgPSB0cnVlO1xuICAgICAgICBzb3VuZC5fZW5kZWQgPSB0cnVlO1xuICAgICAgICBzb3VuZC5fc2VlayA9IHNvdW5kLl9zdGFydCB8fCAwO1xuICAgICAgICBzb3VuZC5fcmF0ZVNlZWsgPSAwO1xuICAgICAgICBzZWxmLl9jbGVhclRpbWVyKHNvdW5kLl9pZCk7XG5cbiAgICAgICAgLy8gQ2xlYW4gdXAgdGhlIGJ1ZmZlciBzb3VyY2UuXG4gICAgICAgIHNlbGYuX2NsZWFuQnVmZmVyKHNvdW5kLl9ub2RlKTtcblxuICAgICAgICAvLyBBdHRlbXB0IHRvIGF1dG8tc3VzcGVuZCBBdWRpb0NvbnRleHQgaWYgbm8gc291bmRzIGFyZSBzdGlsbCBwbGF5aW5nLlxuICAgICAgICBIb3dsZXIuX2F1dG9TdXNwZW5kKCk7XG4gICAgICB9XG5cbiAgICAgIC8vIFdoZW4gdXNpbmcgYSBzcHJpdGUsIGVuZCB0aGUgdHJhY2suXG4gICAgICBpZiAoIXNlbGYuX3dlYkF1ZGlvICYmICFsb29wKSB7XG4gICAgICAgIHNlbGYuc3RvcChzb3VuZC5faWQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2xlYXIgdGhlIGVuZCB0aW1lciBmb3IgYSBzb3VuZCBwbGF5YmFjay5cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGlkIFRoZSBzb3VuZCBJRC5cbiAgICAgKiBAcmV0dXJuIHtIb3dsfVxuICAgICAqL1xuICAgIF9jbGVhclRpbWVyOiBmdW5jdGlvbihpZCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICBpZiAoc2VsZi5fZW5kVGltZXJzW2lkXSkge1xuICAgICAgICBjbGVhclRpbWVvdXQoc2VsZi5fZW5kVGltZXJzW2lkXSk7XG4gICAgICAgIGRlbGV0ZSBzZWxmLl9lbmRUaW1lcnNbaWRdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBzb3VuZCBpZGVudGlmaWVkIGJ5IHRoaXMgSUQsIG9yIHJldHVybiBudWxsLlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gaWQgU291bmQgSURcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9ICAgIFNvdW5kIG9iamVjdCBvciBudWxsLlxuICAgICAqL1xuICAgIF9zb3VuZEJ5SWQ6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgIC8vIExvb3AgdGhyb3VnaCBhbGwgc291bmRzIGFuZCBmaW5kIHRoZSBvbmUgd2l0aCB0aGlzIElELlxuICAgICAgZm9yICh2YXIgaT0wOyBpPHNlbGYuX3NvdW5kcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaWQgPT09IHNlbGYuX3NvdW5kc1tpXS5faWQpIHtcbiAgICAgICAgICByZXR1cm4gc2VsZi5fc291bmRzW2ldO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYW4gaW5hY3RpdmUgc291bmQgZnJvbSB0aGUgcG9vbCBvciBjcmVhdGUgYSBuZXcgb25lLlxuICAgICAqIEByZXR1cm4ge1NvdW5kfSBTb3VuZCBwbGF5YmFjayBvYmplY3QuXG4gICAgICovXG4gICAgX2luYWN0aXZlU291bmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICBzZWxmLl9kcmFpbigpO1xuXG4gICAgICAvLyBGaW5kIHRoZSBmaXJzdCBpbmFjdGl2ZSBub2RlIHRvIHJlY3ljbGUuXG4gICAgICBmb3IgKHZhciBpPTA7IGk8c2VsZi5fc291bmRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChzZWxmLl9zb3VuZHNbaV0uX2VuZGVkKSB7XG4gICAgICAgICAgcmV0dXJuIHNlbGYuX3NvdW5kc1tpXS5yZXNldCgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIElmIG5vIGluYWN0aXZlIG5vZGUgd2FzIGZvdW5kLCBjcmVhdGUgYSBuZXcgb25lLlxuICAgICAgcmV0dXJuIG5ldyBTb3VuZChzZWxmKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRHJhaW4gZXhjZXNzIGluYWN0aXZlIHNvdW5kcyBmcm9tIHRoZSBwb29sLlxuICAgICAqL1xuICAgIF9kcmFpbjogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgbGltaXQgPSBzZWxmLl9wb29sO1xuICAgICAgdmFyIGNudCA9IDA7XG4gICAgICB2YXIgaSA9IDA7XG5cbiAgICAgIC8vIElmIHRoZXJlIGFyZSBsZXNzIHNvdW5kcyB0aGFuIHRoZSBtYXggcG9vbCBzaXplLCB3ZSBhcmUgZG9uZS5cbiAgICAgIGlmIChzZWxmLl9zb3VuZHMubGVuZ3RoIDwgbGltaXQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBDb3VudCB0aGUgbnVtYmVyIG9mIGluYWN0aXZlIHNvdW5kcy5cbiAgICAgIGZvciAoaT0wOyBpPHNlbGYuX3NvdW5kcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoc2VsZi5fc291bmRzW2ldLl9lbmRlZCkge1xuICAgICAgICAgIGNudCsrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFJlbW92ZSBleGNlc3MgaW5hY3RpdmUgc291bmRzLCBnb2luZyBpbiByZXZlcnNlIG9yZGVyLlxuICAgICAgZm9yIChpPXNlbGYuX3NvdW5kcy5sZW5ndGggLSAxOyBpPj0wOyBpLS0pIHtcbiAgICAgICAgaWYgKGNudCA8PSBsaW1pdCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzZWxmLl9zb3VuZHNbaV0uX2VuZGVkKSB7XG4gICAgICAgICAgLy8gRGlzY29ubmVjdCB0aGUgYXVkaW8gc291cmNlIHdoZW4gdXNpbmcgV2ViIEF1ZGlvLlxuICAgICAgICAgIGlmIChzZWxmLl93ZWJBdWRpbyAmJiBzZWxmLl9zb3VuZHNbaV0uX25vZGUpIHtcbiAgICAgICAgICAgIHNlbGYuX3NvdW5kc1tpXS5fbm9kZS5kaXNjb25uZWN0KDApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFJlbW92ZSBzb3VuZHMgdW50aWwgd2UgaGF2ZSB0aGUgcG9vbCBzaXplLlxuICAgICAgICAgIHNlbGYuX3NvdW5kcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgY250LS07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IGFsbCBJRCdzIGZyb20gdGhlIHNvdW5kcyBwb29sLlxuICAgICAqIEBwYXJhbSAge051bWJlcn0gaWQgT25seSByZXR1cm4gb25lIElEIGlmIG9uZSBpcyBwYXNzZWQuXG4gICAgICogQHJldHVybiB7QXJyYXl9ICAgIEFycmF5IG9mIElEcy5cbiAgICAgKi9cbiAgICBfZ2V0U291bmRJZHM6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgIGlmICh0eXBlb2YgaWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHZhciBpZHMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaT0wOyBpPHNlbGYuX3NvdW5kcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlkcy5wdXNoKHNlbGYuX3NvdW5kc1tpXS5faWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGlkcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBbaWRdO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBMb2FkIHRoZSBzb3VuZCBiYWNrIGludG8gdGhlIGJ1ZmZlciBzb3VyY2UuXG4gICAgICogQHBhcmFtICB7U291bmR9IHNvdW5kIFRoZSBzb3VuZCBvYmplY3QgdG8gd29yayB3aXRoLlxuICAgICAqIEByZXR1cm4ge0hvd2x9XG4gICAgICovXG4gICAgX3JlZnJlc2hCdWZmZXI6IGZ1bmN0aW9uKHNvdW5kKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgIC8vIFNldHVwIHRoZSBidWZmZXIgc291cmNlIGZvciBwbGF5YmFjay5cbiAgICAgIHNvdW5kLl9ub2RlLmJ1ZmZlclNvdXJjZSA9IEhvd2xlci5jdHguY3JlYXRlQnVmZmVyU291cmNlKCk7XG4gICAgICBzb3VuZC5fbm9kZS5idWZmZXJTb3VyY2UuYnVmZmVyID0gY2FjaGVbc2VsZi5fc3JjXTtcblxuICAgICAgLy8gQ29ubmVjdCB0byB0aGUgY29ycmVjdCBub2RlLlxuICAgICAgaWYgKHNvdW5kLl9wYW5uZXIpIHtcbiAgICAgICAgc291bmQuX25vZGUuYnVmZmVyU291cmNlLmNvbm5lY3Qoc291bmQuX3Bhbm5lcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzb3VuZC5fbm9kZS5idWZmZXJTb3VyY2UuY29ubmVjdChzb3VuZC5fbm9kZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFNldHVwIGxvb3BpbmcgYW5kIHBsYXliYWNrIHJhdGUuXG4gICAgICBzb3VuZC5fbm9kZS5idWZmZXJTb3VyY2UubG9vcCA9IHNvdW5kLl9sb29wO1xuICAgICAgaWYgKHNvdW5kLl9sb29wKSB7XG4gICAgICAgIHNvdW5kLl9ub2RlLmJ1ZmZlclNvdXJjZS5sb29wU3RhcnQgPSBzb3VuZC5fc3RhcnQgfHwgMDtcbiAgICAgICAgc291bmQuX25vZGUuYnVmZmVyU291cmNlLmxvb3BFbmQgPSBzb3VuZC5fc3RvcDtcbiAgICAgIH1cbiAgICAgIHNvdW5kLl9ub2RlLmJ1ZmZlclNvdXJjZS5wbGF5YmFja1JhdGUudmFsdWUgPSBzb3VuZC5fcmF0ZTtcblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFByZXZlbnQgbWVtb3J5IGxlYWtzIGJ5IGNsZWFuaW5nIHVwIHRoZSBidWZmZXIgc291cmNlIGFmdGVyIHBsYXliYWNrLlxuICAgICAqIEBwYXJhbSAge09iamVjdH0gbm9kZSBTb3VuZCdzIGF1ZGlvIG5vZGUgY29udGFpbmluZyB0aGUgYnVmZmVyIHNvdXJjZS5cbiAgICAgKiBAcmV0dXJuIHtIb3dsfVxuICAgICAqL1xuICAgIF9jbGVhbkJ1ZmZlcjogZnVuY3Rpb24obm9kZSkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICBpZiAoc2VsZi5fc2NyYXRjaEJ1ZmZlcikge1xuICAgICAgICBub2RlLmJ1ZmZlclNvdXJjZS5vbmVuZGVkID0gbnVsbDtcbiAgICAgICAgbm9kZS5idWZmZXJTb3VyY2UuZGlzY29ubmVjdCgwKTtcbiAgICAgICAgdHJ5IHsgbm9kZS5idWZmZXJTb3VyY2UuYnVmZmVyID0gc2VsZi5fc2NyYXRjaEJ1ZmZlcjsgfSBjYXRjaChlKSB7fVxuICAgICAgfVxuICAgICAgbm9kZS5idWZmZXJTb3VyY2UgPSBudWxsO1xuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG4gIH07XG5cbiAgLyoqIFNpbmdsZSBTb3VuZCBNZXRob2RzICoqL1xuICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gIC8qKlxuICAgKiBTZXR1cCB0aGUgc291bmQgb2JqZWN0LCB3aGljaCBlYWNoIG5vZGUgYXR0YWNoZWQgdG8gYSBIb3dsIGdyb3VwIGlzIGNvbnRhaW5lZCBpbi5cbiAgICogQHBhcmFtIHtPYmplY3R9IGhvd2wgVGhlIEhvd2wgcGFyZW50IGdyb3VwLlxuICAgKi9cbiAgdmFyIFNvdW5kID0gZnVuY3Rpb24oaG93bCkge1xuICAgIHRoaXMuX3BhcmVudCA9IGhvd2w7XG4gICAgdGhpcy5pbml0KCk7XG4gIH07XG4gIFNvdW5kLnByb3RvdHlwZSA9IHtcbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplIGEgbmV3IFNvdW5kIG9iamVjdC5cbiAgICAgKiBAcmV0dXJuIHtTb3VuZH1cbiAgICAgKi9cbiAgICBpbml0OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBwYXJlbnQgPSBzZWxmLl9wYXJlbnQ7XG5cbiAgICAgIC8vIFNldHVwIHRoZSBkZWZhdWx0IHBhcmFtZXRlcnMuXG4gICAgICBzZWxmLl9tdXRlZCA9IHBhcmVudC5fbXV0ZWQ7XG4gICAgICBzZWxmLl9sb29wID0gcGFyZW50Ll9sb29wO1xuICAgICAgc2VsZi5fdm9sdW1lID0gcGFyZW50Ll92b2x1bWU7XG4gICAgICBzZWxmLl9tdXRlZCA9IHBhcmVudC5fbXV0ZWQ7XG4gICAgICBzZWxmLl9yYXRlID0gcGFyZW50Ll9yYXRlO1xuICAgICAgc2VsZi5fc2VlayA9IDA7XG4gICAgICBzZWxmLl9wYXVzZWQgPSB0cnVlO1xuICAgICAgc2VsZi5fZW5kZWQgPSB0cnVlO1xuICAgICAgc2VsZi5fc3ByaXRlID0gJ19fZGVmYXVsdCc7XG5cbiAgICAgIC8vIEdlbmVyYXRlIGEgdW5pcXVlIElEIGZvciB0aGlzIHNvdW5kLlxuICAgICAgc2VsZi5faWQgPSBNYXRoLnJvdW5kKERhdGUubm93KCkgKiBNYXRoLnJhbmRvbSgpKTtcblxuICAgICAgLy8gQWRkIGl0c2VsZiB0byB0aGUgcGFyZW50J3MgcG9vbC5cbiAgICAgIHBhcmVudC5fc291bmRzLnB1c2goc2VsZik7XG5cbiAgICAgIC8vIENyZWF0ZSB0aGUgbmV3IG5vZGUuXG4gICAgICBzZWxmLmNyZWF0ZSgpO1xuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGFuZCBzZXR1cCBhIG5ldyBzb3VuZCBvYmplY3QsIHdoZXRoZXIgSFRNTDUgQXVkaW8gb3IgV2ViIEF1ZGlvLlxuICAgICAqIEByZXR1cm4ge1NvdW5kfVxuICAgICAqL1xuICAgIGNyZWF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgcGFyZW50ID0gc2VsZi5fcGFyZW50O1xuICAgICAgdmFyIHZvbHVtZSA9IChIb3dsZXIuX211dGVkIHx8IHNlbGYuX211dGVkIHx8IHNlbGYuX3BhcmVudC5fbXV0ZWQpID8gMCA6IHNlbGYuX3ZvbHVtZTtcblxuICAgICAgaWYgKHBhcmVudC5fd2ViQXVkaW8pIHtcbiAgICAgICAgLy8gQ3JlYXRlIHRoZSBnYWluIG5vZGUgZm9yIGNvbnRyb2xsaW5nIHZvbHVtZSAodGhlIHNvdXJjZSB3aWxsIGNvbm5lY3QgdG8gdGhpcykuXG4gICAgICAgIHNlbGYuX25vZGUgPSAodHlwZW9mIEhvd2xlci5jdHguY3JlYXRlR2FpbiA9PT0gJ3VuZGVmaW5lZCcpID8gSG93bGVyLmN0eC5jcmVhdGVHYWluTm9kZSgpIDogSG93bGVyLmN0eC5jcmVhdGVHYWluKCk7XG4gICAgICAgIHNlbGYuX25vZGUuZ2Fpbi5zZXRWYWx1ZUF0VGltZSh2b2x1bWUsIEhvd2xlci5jdHguY3VycmVudFRpbWUpO1xuICAgICAgICBzZWxmLl9ub2RlLnBhdXNlZCA9IHRydWU7XG4gICAgICAgIHNlbGYuX25vZGUuY29ubmVjdChIb3dsZXIubWFzdGVyR2Fpbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxmLl9ub2RlID0gbmV3IEF1ZGlvKCk7XG5cbiAgICAgICAgLy8gTGlzdGVuIGZvciBlcnJvcnMgKGh0dHA6Ly9kZXYudzMub3JnL2h0bWw1L3NwZWMtYXV0aG9yLXZpZXcvc3BlYy5odG1sI21lZGlhZXJyb3IpLlxuICAgICAgICBzZWxmLl9lcnJvckZuID0gc2VsZi5fZXJyb3JMaXN0ZW5lci5iaW5kKHNlbGYpO1xuICAgICAgICBzZWxmLl9ub2RlLmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgc2VsZi5fZXJyb3JGbiwgZmFsc2UpO1xuXG4gICAgICAgIC8vIExpc3RlbiBmb3IgJ2NhbnBsYXl0aHJvdWdoJyBldmVudCB0byBsZXQgdXMga25vdyB0aGUgc291bmQgaXMgcmVhZHkuXG4gICAgICAgIHNlbGYuX2xvYWRGbiA9IHNlbGYuX2xvYWRMaXN0ZW5lci5iaW5kKHNlbGYpO1xuICAgICAgICBzZWxmLl9ub2RlLmFkZEV2ZW50TGlzdGVuZXIoSG93bGVyLl9jYW5QbGF5RXZlbnQsIHNlbGYuX2xvYWRGbiwgZmFsc2UpO1xuXG4gICAgICAgIC8vIFNldHVwIHRoZSBuZXcgYXVkaW8gbm9kZS5cbiAgICAgICAgc2VsZi5fbm9kZS5zcmMgPSBwYXJlbnQuX3NyYztcbiAgICAgICAgc2VsZi5fbm9kZS5wcmVsb2FkID0gJ2F1dG8nO1xuICAgICAgICBzZWxmLl9ub2RlLnZvbHVtZSA9IHZvbHVtZSAqIEhvd2xlci52b2x1bWUoKTtcblxuICAgICAgICAvLyBCZWdpbiBsb2FkaW5nIHRoZSBzb3VyY2UuXG4gICAgICAgIHNlbGYuX25vZGUubG9hZCgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVzZXQgdGhlIHBhcmFtZXRlcnMgb2YgdGhpcyBzb3VuZCB0byB0aGUgb3JpZ2luYWwgc3RhdGUgKGZvciByZWN5Y2xlKS5cbiAgICAgKiBAcmV0dXJuIHtTb3VuZH1cbiAgICAgKi9cbiAgICByZXNldDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgcGFyZW50ID0gc2VsZi5fcGFyZW50O1xuXG4gICAgICAvLyBSZXNldCBhbGwgb2YgdGhlIHBhcmFtZXRlcnMgb2YgdGhpcyBzb3VuZC5cbiAgICAgIHNlbGYuX211dGVkID0gcGFyZW50Ll9tdXRlZDtcbiAgICAgIHNlbGYuX2xvb3AgPSBwYXJlbnQuX2xvb3A7XG4gICAgICBzZWxmLl92b2x1bWUgPSBwYXJlbnQuX3ZvbHVtZTtcbiAgICAgIHNlbGYuX211dGVkID0gcGFyZW50Ll9tdXRlZDtcbiAgICAgIHNlbGYuX3JhdGUgPSBwYXJlbnQuX3JhdGU7XG4gICAgICBzZWxmLl9zZWVrID0gMDtcbiAgICAgIHNlbGYuX3JhdGVTZWVrID0gMDtcbiAgICAgIHNlbGYuX3BhdXNlZCA9IHRydWU7XG4gICAgICBzZWxmLl9lbmRlZCA9IHRydWU7XG4gICAgICBzZWxmLl9zcHJpdGUgPSAnX19kZWZhdWx0JztcblxuICAgICAgLy8gR2VuZXJhdGUgYSBuZXcgSUQgc28gdGhhdCBpdCBpc24ndCBjb25mdXNlZCB3aXRoIHRoZSBwcmV2aW91cyBzb3VuZC5cbiAgICAgIHNlbGYuX2lkID0gTWF0aC5yb3VuZChEYXRlLm5vdygpICogTWF0aC5yYW5kb20oKSk7XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBIVE1MNSBBdWRpbyBlcnJvciBsaXN0ZW5lciBjYWxsYmFjay5cbiAgICAgKi9cbiAgICBfZXJyb3JMaXN0ZW5lcjogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgIGlmIChzZWxmLl9ub2RlLmVycm9yICYmIHNlbGYuX25vZGUuZXJyb3IuY29kZSA9PT0gNCkge1xuICAgICAgICBIb3dsZXIubm9BdWRpbyA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8vIEZpcmUgYW4gZXJyb3IgZXZlbnQgYW5kIHBhc3MgYmFjayB0aGUgY29kZS5cbiAgICAgIHNlbGYuX3BhcmVudC5fZW1pdCgnbG9hZGVycm9yJywgc2VsZi5faWQsIHNlbGYuX25vZGUuZXJyb3IgPyBzZWxmLl9ub2RlLmVycm9yLmNvZGUgOiAwKTtcblxuICAgICAgLy8gQ2xlYXIgdGhlIGV2ZW50IGxpc3RlbmVyLlxuICAgICAgc2VsZi5fbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCdlcnJvcicsIHNlbGYuX2Vycm9yTGlzdGVuZXIsIGZhbHNlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSFRNTDUgQXVkaW8gY2FucGxheXRocm91Z2ggbGlzdGVuZXIgY2FsbGJhY2suXG4gICAgICovXG4gICAgX2xvYWRMaXN0ZW5lcjogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgcGFyZW50ID0gc2VsZi5fcGFyZW50O1xuXG4gICAgICAvLyBSb3VuZCB1cCB0aGUgZHVyYXRpb24gdG8gYWNjb3VudCBmb3IgdGhlIGxvd2VyIHByZWNpc2lvbiBpbiBIVE1MNSBBdWRpby5cbiAgICAgIHBhcmVudC5fZHVyYXRpb24gPSBNYXRoLmNlaWwoc2VsZi5fbm9kZS5kdXJhdGlvbiAqIDEwKSAvIDEwO1xuXG4gICAgICAvLyBTZXR1cCBhIHNwcml0ZSBpZiBub25lIGlzIGRlZmluZWQuXG4gICAgICBpZiAoT2JqZWN0LmtleXMocGFyZW50Ll9zcHJpdGUpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBwYXJlbnQuX3Nwcml0ZSA9IHtfX2RlZmF1bHQ6IFswLCBwYXJlbnQuX2R1cmF0aW9uICogMTAwMF19O1xuICAgICAgfVxuXG4gICAgICBpZiAocGFyZW50Ll9zdGF0ZSAhPT0gJ2xvYWRlZCcpIHtcbiAgICAgICAgcGFyZW50Ll9zdGF0ZSA9ICdsb2FkZWQnO1xuICAgICAgICBwYXJlbnQuX2VtaXQoJ2xvYWQnKTtcbiAgICAgICAgcGFyZW50Ll9sb2FkUXVldWUoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHBhcmVudC5fYXV0b3BsYXkpIHtcbiAgICAgICAgcGFyZW50LnBsYXkoKTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2xlYXIgdGhlIGV2ZW50IGxpc3RlbmVyLlxuICAgICAgc2VsZi5fbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKEhvd2xlci5fY2FuUGxheUV2ZW50LCBzZWxmLl9sb2FkRm4sIGZhbHNlKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqIEhlbHBlciBNZXRob2RzICoqL1xuICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gIHZhciBjYWNoZSA9IHt9O1xuXG4gIC8qKlxuICAgKiBCdWZmZXIgYSBzb3VuZCBmcm9tIFVSTCwgRGF0YSBVUkkgb3IgY2FjaGUgYW5kIGRlY29kZSB0byBhdWRpbyBzb3VyY2UgKFdlYiBBdWRpbyBBUEkpLlxuICAgKiBAcGFyYW0gIHtIb3dsfSBzZWxmXG4gICAqL1xuICB2YXIgbG9hZEJ1ZmZlciA9IGZ1bmN0aW9uKHNlbGYpIHtcbiAgICB2YXIgdXJsID0gc2VsZi5fc3JjO1xuXG4gICAgLy8gQ2hlY2sgaWYgdGhlIGJ1ZmZlciBoYXMgYWxyZWFkeSBiZWVuIGNhY2hlZCBhbmQgdXNlIGl0IGluc3RlYWQuXG4gICAgaWYgKGNhY2hlW3VybF0pIHtcbiAgICAgIC8vIFNldCB0aGUgZHVyYXRpb24gZnJvbSB0aGUgY2FjaGUuXG4gICAgICBzZWxmLl9kdXJhdGlvbiA9IGNhY2hlW3VybF0uZHVyYXRpb247XG5cbiAgICAgIC8vIExvYWQgdGhlIHNvdW5kIGludG8gdGhpcyBIb3dsLlxuICAgICAgbG9hZFNvdW5kKHNlbGYpO1xuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKC9eZGF0YTpbXjtdKztiYXNlNjQsLy50ZXN0KHVybCkpIHtcbiAgICAgIC8vIERlY29kZSB0aGUgYmFzZTY0IGRhdGEgVVJJIHdpdGhvdXQgWEhSLCBzaW5jZSBzb21lIGJyb3dzZXJzIGRvbid0IHN1cHBvcnQgaXQuXG4gICAgICB2YXIgZGF0YSA9IGF0b2IodXJsLnNwbGl0KCcsJylbMV0pO1xuICAgICAgdmFyIGRhdGFWaWV3ID0gbmV3IFVpbnQ4QXJyYXkoZGF0YS5sZW5ndGgpO1xuICAgICAgZm9yICh2YXIgaT0wOyBpPGRhdGEubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgZGF0YVZpZXdbaV0gPSBkYXRhLmNoYXJDb2RlQXQoaSk7XG4gICAgICB9XG5cbiAgICAgIGRlY29kZUF1ZGlvRGF0YShkYXRhVmlldy5idWZmZXIsIHNlbGYpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBMb2FkIHRoZSBidWZmZXIgZnJvbSB0aGUgVVJMLlxuICAgICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgeGhyLm9wZW4oJ0dFVCcsIHVybCwgdHJ1ZSk7XG4gICAgICB4aHIucmVzcG9uc2VUeXBlID0gJ2FycmF5YnVmZmVyJztcbiAgICAgIHhoci5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gTWFrZSBzdXJlIHdlIGdldCBhIHN1Y2Nlc3NmdWwgcmVzcG9uc2UgYmFjay5cbiAgICAgICAgdmFyIGNvZGUgPSAoeGhyLnN0YXR1cyArICcnKVswXTtcbiAgICAgICAgaWYgKGNvZGUgIT09ICcwJyAmJiBjb2RlICE9PSAnMicgJiYgY29kZSAhPT0gJzMnKSB7XG4gICAgICAgICAgc2VsZi5fZW1pdCgnbG9hZGVycm9yJywgbnVsbCwgJ0ZhaWxlZCBsb2FkaW5nIGF1ZGlvIGZpbGUgd2l0aCBzdGF0dXM6ICcgKyB4aHIuc3RhdHVzICsgJy4nKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBkZWNvZGVBdWRpb0RhdGEoeGhyLnJlc3BvbnNlLCBzZWxmKTtcbiAgICAgIH07XG4gICAgICB4aHIub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBJZiB0aGVyZSBpcyBhbiBlcnJvciwgc3dpdGNoIHRvIEhUTUw1IEF1ZGlvLlxuICAgICAgICBpZiAoc2VsZi5fd2ViQXVkaW8pIHtcbiAgICAgICAgICBzZWxmLl9odG1sNSA9IHRydWU7XG4gICAgICAgICAgc2VsZi5fd2ViQXVkaW8gPSBmYWxzZTtcbiAgICAgICAgICBzZWxmLl9zb3VuZHMgPSBbXTtcbiAgICAgICAgICBkZWxldGUgY2FjaGVbdXJsXTtcbiAgICAgICAgICBzZWxmLmxvYWQoKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHNhZmVYaHJTZW5kKHhocik7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBTZW5kIHRoZSBYSFIgcmVxdWVzdCB3cmFwcGVkIGluIGEgdHJ5L2NhdGNoLlxuICAgKiBAcGFyYW0gIHtPYmplY3R9IHhociBYSFIgdG8gc2VuZC5cbiAgICovXG4gIHZhciBzYWZlWGhyU2VuZCA9IGZ1bmN0aW9uKHhocikge1xuICAgIHRyeSB7XG4gICAgICB4aHIuc2VuZCgpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHhoci5vbmVycm9yKCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBEZWNvZGUgYXVkaW8gZGF0YSBmcm9tIGFuIGFycmF5IGJ1ZmZlci5cbiAgICogQHBhcmFtICB7QXJyYXlCdWZmZXJ9IGFycmF5YnVmZmVyIFRoZSBhdWRpbyBkYXRhLlxuICAgKiBAcGFyYW0gIHtIb3dsfSAgICAgICAgc2VsZlxuICAgKi9cbiAgdmFyIGRlY29kZUF1ZGlvRGF0YSA9IGZ1bmN0aW9uKGFycmF5YnVmZmVyLCBzZWxmKSB7XG4gICAgLy8gRGVjb2RlIHRoZSBidWZmZXIgaW50byBhbiBhdWRpbyBzb3VyY2UuXG4gICAgSG93bGVyLmN0eC5kZWNvZGVBdWRpb0RhdGEoYXJyYXlidWZmZXIsIGZ1bmN0aW9uKGJ1ZmZlcikge1xuICAgICAgaWYgKGJ1ZmZlciAmJiBzZWxmLl9zb3VuZHMubGVuZ3RoID4gMCkge1xuICAgICAgICBjYWNoZVtzZWxmLl9zcmNdID0gYnVmZmVyO1xuICAgICAgICBsb2FkU291bmQoc2VsZiwgYnVmZmVyKTtcbiAgICAgIH1cbiAgICB9LCBmdW5jdGlvbigpIHtcbiAgICAgIHNlbGYuX2VtaXQoJ2xvYWRlcnJvcicsIG51bGwsICdEZWNvZGluZyBhdWRpbyBkYXRhIGZhaWxlZC4nKTtcbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogU291bmQgaXMgbm93IGxvYWRlZCwgc28gZmluaXNoIHNldHRpbmcgZXZlcnl0aGluZyB1cCBhbmQgZmlyZSB0aGUgbG9hZGVkIGV2ZW50LlxuICAgKiBAcGFyYW0gIHtIb3dsfSBzZWxmXG4gICAqIEBwYXJhbSAge09iamVjdH0gYnVmZmVyIFRoZSBkZWNvZGVkIGJ1ZmZlciBzb3VuZCBzb3VyY2UuXG4gICAqL1xuICB2YXIgbG9hZFNvdW5kID0gZnVuY3Rpb24oc2VsZiwgYnVmZmVyKSB7XG4gICAgLy8gU2V0IHRoZSBkdXJhdGlvbi5cbiAgICBpZiAoYnVmZmVyICYmICFzZWxmLl9kdXJhdGlvbikge1xuICAgICAgc2VsZi5fZHVyYXRpb24gPSBidWZmZXIuZHVyYXRpb247XG4gICAgfVxuXG4gICAgLy8gU2V0dXAgYSBzcHJpdGUgaWYgbm9uZSBpcyBkZWZpbmVkLlxuICAgIGlmIChPYmplY3Qua2V5cyhzZWxmLl9zcHJpdGUpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgc2VsZi5fc3ByaXRlID0ge19fZGVmYXVsdDogWzAsIHNlbGYuX2R1cmF0aW9uICogMTAwMF19O1xuICAgIH1cblxuICAgIC8vIEZpcmUgdGhlIGxvYWRlZCBldmVudC5cbiAgICBpZiAoc2VsZi5fc3RhdGUgIT09ICdsb2FkZWQnKSB7XG4gICAgICBzZWxmLl9zdGF0ZSA9ICdsb2FkZWQnO1xuICAgICAgc2VsZi5fZW1pdCgnbG9hZCcpO1xuICAgICAgc2VsZi5fbG9hZFF1ZXVlKCk7XG4gICAgfVxuXG4gICAgLy8gQmVnaW4gcGxheWJhY2sgaWYgc3BlY2lmaWVkLlxuICAgIGlmIChzZWxmLl9hdXRvcGxheSkge1xuICAgICAgc2VsZi5wbGF5KCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBTZXR1cCB0aGUgYXVkaW8gY29udGV4dCB3aGVuIGF2YWlsYWJsZSwgb3Igc3dpdGNoIHRvIEhUTUw1IEF1ZGlvIG1vZGUuXG4gICAqL1xuICB2YXIgc2V0dXBBdWRpb0NvbnRleHQgPSBmdW5jdGlvbigpIHtcbiAgICBIb3dsZXIubm9BdWRpbyA9IGZhbHNlO1xuXG4gICAgLy8gQ2hlY2sgaWYgd2UgYXJlIHVzaW5nIFdlYiBBdWRpbyBhbmQgc2V0dXAgdGhlIEF1ZGlvQ29udGV4dCBpZiB3ZSBhcmUuXG4gICAgdHJ5IHtcbiAgICAgIGlmICh0eXBlb2YgQXVkaW9Db250ZXh0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBIb3dsZXIuY3R4ID0gbmV3IEF1ZGlvQ29udGV4dCgpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygd2Via2l0QXVkaW9Db250ZXh0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBIb3dsZXIuY3R4ID0gbmV3IHdlYmtpdEF1ZGlvQ29udGV4dCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgSG93bGVyLnVzaW5nV2ViQXVkaW8gPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGNhdGNoKGUpIHtcbiAgICAgIEhvd2xlci51c2luZ1dlYkF1ZGlvID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKCFIb3dsZXIudXNpbmdXZWJBdWRpbykge1xuICAgICAgLy8gTm8gYXVkaW8gaXMgYXZhaWxhYmxlIG9uIHRoaXMgc3lzdGVtIGlmIG5vQXVkaW8gaXMgc2V0IHRvIHRydWUuXG4gICAgICBpZiAodHlwZW9mIEF1ZGlvICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhciB0ZXN0ID0gbmV3IEF1ZGlvKCk7XG5cbiAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgY2FucGxheXRocm91Z2ggZXZlbnQgaXMgYXZhaWxhYmxlLlxuICAgICAgICAgIGlmICh0eXBlb2YgdGVzdC5vbmNhbnBsYXl0aHJvdWdoID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgSG93bGVyLl9jYW5QbGF5RXZlbnQgPSAnY2FucGxheSc7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgICBIb3dsZXIubm9BdWRpbyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIEhvd2xlci5ub0F1ZGlvID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUZXN0IHRvIG1ha2Ugc3VyZSBhdWRpbyBpc24ndCBkaXNhYmxlZCBpbiBJbnRlcm5ldCBFeHBsb3JlclxuICAgIHRyeSB7XG4gICAgICB2YXIgdGVzdCA9IG5ldyBBdWRpbygpO1xuICAgICAgaWYgKHRlc3QubXV0ZWQpIHtcbiAgICAgICAgSG93bGVyLm5vQXVkaW8gPSB0cnVlO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHt9XG5cbiAgICAvLyBDaGVjayBpZiBhIHdlYnZpZXcgaXMgYmVpbmcgdXNlZCBvbiBpT1M4IG9yIGVhcmxpZXIgKHJhdGhlciB0aGFuIHRoZSBicm93c2VyKS5cbiAgICAvLyBJZiBpdCBpcywgZGlzYWJsZSBXZWIgQXVkaW8gYXMgaXQgY2F1c2VzIGNyYXNoaW5nLlxuICAgIHZhciBpT1MgPSAoL2lQKGhvbmV8b2R8YWQpLy50ZXN0KEhvd2xlci5fbmF2aWdhdG9yICYmIEhvd2xlci5fbmF2aWdhdG9yLnBsYXRmb3JtKSk7XG4gICAgdmFyIGFwcFZlcnNpb24gPSBIb3dsZXIuX25hdmlnYXRvciAmJiBIb3dsZXIuX25hdmlnYXRvci5hcHBWZXJzaW9uLm1hdGNoKC9PUyAoXFxkKylfKFxcZCspXz8oXFxkKyk/Lyk7XG4gICAgdmFyIHZlcnNpb24gPSBhcHBWZXJzaW9uID8gcGFyc2VJbnQoYXBwVmVyc2lvblsxXSwgMTApIDogbnVsbDtcbiAgICBpZiAoaU9TICYmIHZlcnNpb24gJiYgdmVyc2lvbiA8IDkpIHtcbiAgICAgIHZhciBzYWZhcmkgPSAvc2FmYXJpLy50ZXN0KEhvd2xlci5fbmF2aWdhdG9yICYmIEhvd2xlci5fbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpKTtcbiAgICAgIGlmIChIb3dsZXIuX25hdmlnYXRvciAmJiBIb3dsZXIuX25hdmlnYXRvci5zdGFuZGFsb25lICYmICFzYWZhcmkgfHwgSG93bGVyLl9uYXZpZ2F0b3IgJiYgIUhvd2xlci5fbmF2aWdhdG9yLnN0YW5kYWxvbmUgJiYgIXNhZmFyaSkge1xuICAgICAgICBIb3dsZXIudXNpbmdXZWJBdWRpbyA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIENyZWF0ZSBhbmQgZXhwb3NlIHRoZSBtYXN0ZXIgR2Fpbk5vZGUgd2hlbiB1c2luZyBXZWIgQXVkaW8gKHVzZWZ1bCBmb3IgcGx1Z2lucyBvciBhZHZhbmNlZCB1c2FnZSkuXG4gICAgaWYgKEhvd2xlci51c2luZ1dlYkF1ZGlvKSB7XG4gICAgICBIb3dsZXIubWFzdGVyR2FpbiA9ICh0eXBlb2YgSG93bGVyLmN0eC5jcmVhdGVHYWluID09PSAndW5kZWZpbmVkJykgPyBIb3dsZXIuY3R4LmNyZWF0ZUdhaW5Ob2RlKCkgOiBIb3dsZXIuY3R4LmNyZWF0ZUdhaW4oKTtcbiAgICAgIEhvd2xlci5tYXN0ZXJHYWluLmdhaW4udmFsdWUgPSAxO1xuICAgICAgSG93bGVyLm1hc3RlckdhaW4uY29ubmVjdChIb3dsZXIuY3R4LmRlc3RpbmF0aW9uKTtcbiAgICB9XG5cbiAgICAvLyBSZS1ydW4gdGhlIHNldHVwIG9uIEhvd2xlci5cbiAgICBIb3dsZXIuX3NldHVwKCk7XG4gIH07XG5cbiAgLy8gQWRkIHN1cHBvcnQgZm9yIEFNRCAoQXN5bmNocm9ub3VzIE1vZHVsZSBEZWZpbml0aW9uKSBsaWJyYXJpZXMgc3VjaCBhcyByZXF1aXJlLmpzLlxuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgZGVmaW5lKFtdLCBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIEhvd2xlcjogSG93bGVyLFxuICAgICAgICBIb3dsOiBIb3dsXG4gICAgICB9O1xuICAgIH0pO1xuICB9XG5cbiAgLy8gQWRkIHN1cHBvcnQgZm9yIENvbW1vbkpTIGxpYnJhcmllcyBzdWNoIGFzIGJyb3dzZXJpZnkuXG4gIGlmICh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBleHBvcnRzLkhvd2xlciA9IEhvd2xlcjtcbiAgICBleHBvcnRzLkhvd2wgPSBIb3dsO1xuICB9XG5cbiAgLy8gRGVmaW5lIGdsb2JhbGx5IGluIGNhc2UgQU1EIGlzIG5vdCBhdmFpbGFibGUgb3IgdW51c2VkLlxuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB3aW5kb3cuSG93bGVyR2xvYmFsID0gSG93bGVyR2xvYmFsO1xuICAgIHdpbmRvdy5Ib3dsZXIgPSBIb3dsZXI7XG4gICAgd2luZG93Lkhvd2wgPSBIb3dsO1xuICAgIHdpbmRvdy5Tb3VuZCA9IFNvdW5kO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnKSB7IC8vIEFkZCB0byBnbG9iYWwgaW4gTm9kZS5qcyAoZm9yIHRlc3RpbmcsIGV0YykuXG4gICAgZ2xvYmFsLkhvd2xlckdsb2JhbCA9IEhvd2xlckdsb2JhbDtcbiAgICBnbG9iYWwuSG93bGVyID0gSG93bGVyO1xuICAgIGdsb2JhbC5Ib3dsID0gSG93bDtcbiAgICBnbG9iYWwuU291bmQgPSBTb3VuZDtcbiAgfVxufSkoKTtcblxuXG4vKiFcbiAqICBTcGF0aWFsIFBsdWdpbiAtIEFkZHMgc3VwcG9ydCBmb3Igc3RlcmVvIGFuZCAzRCBhdWRpbyB3aGVyZSBXZWIgQXVkaW8gaXMgc3VwcG9ydGVkLlxuICogIFxuICogIGhvd2xlci5qcyB2Mi4wLjBcbiAqICBob3dsZXJqcy5jb21cbiAqXG4gKiAgKGMpIDIwMTMtMjAxNiwgSmFtZXMgU2ltcHNvbiBvZiBHb2xkRmlyZSBTdHVkaW9zXG4gKiAgZ29sZGZpcmVzdHVkaW9zLmNvbVxuICpcbiAqICBNSVQgTGljZW5zZVxuICovXG5cbihmdW5jdGlvbigpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgLy8gU2V0dXAgZGVmYXVsdCBwcm9wZXJ0aWVzLlxuICBIb3dsZXJHbG9iYWwucHJvdG90eXBlLl9wb3MgPSBbMCwgMCwgMF07XG4gIEhvd2xlckdsb2JhbC5wcm90b3R5cGUuX29yaWVudGF0aW9uID0gWzAsIDAsIC0xLCAwLCAxLCAwXTtcbiAgXG4gIC8qKiBHbG9iYWwgTWV0aG9kcyAqKi9cbiAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAvKipcbiAgICogSGVscGVyIG1ldGhvZCB0byB1cGRhdGUgdGhlIHN0ZXJlbyBwYW5uaW5nIHBvc2l0aW9uIG9mIGFsbCBjdXJyZW50IEhvd2xzLlxuICAgKiBGdXR1cmUgSG93bHMgd2lsbCBub3QgdXNlIHRoaXMgdmFsdWUgdW5sZXNzIGV4cGxpY2l0ZWx5IHNldC5cbiAgICogQHBhcmFtICB7TnVtYmVyfSBwYW4gQSB2YWx1ZSBvZiAtMS4wIGlzIGFsbCB0aGUgd2F5IGxlZnQgYW5kIDEuMCBpcyBhbGwgdGhlIHdheSByaWdodC5cbiAgICogQHJldHVybiB7SG93bGVyL051bWJlcn0gICAgIFNlbGYgb3IgY3VycmVudCBzdGVyZW8gcGFubmluZyB2YWx1ZS5cbiAgICovXG4gIEhvd2xlckdsb2JhbC5wcm90b3R5cGUuc3RlcmVvID0gZnVuY3Rpb24ocGFuKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgLy8gU3RvcCByaWdodCBoZXJlIGlmIG5vdCB1c2luZyBXZWIgQXVkaW8uXG4gICAgaWYgKCFzZWxmLmN0eCB8fCAhc2VsZi5jdHgubGlzdGVuZXIpIHtcbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cblxuICAgIC8vIExvb3AgdGhyb3VnaCBhbGwgSG93bHMgYW5kIHVwZGF0ZSB0aGVpciBzdGVyZW8gcGFubmluZy5cbiAgICBmb3IgKHZhciBpPXNlbGYuX2hvd2xzLmxlbmd0aC0xOyBpPj0wOyBpLS0pIHtcbiAgICAgIHNlbGYuX2hvd2xzW2ldLnN0ZXJlbyhwYW4pO1xuICAgIH1cblxuICAgIHJldHVybiBzZWxmO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQvc2V0IHRoZSBwb3NpdGlvbiBvZiB0aGUgbGlzdGVuZXIgaW4gM0QgY2FydGVzaWFuIHNwYWNlLiBTb3VuZHMgdXNpbmdcbiAgICogM0QgcG9zaXRpb24gd2lsbCBiZSByZWxhdGl2ZSB0byB0aGUgbGlzdGVuZXIncyBwb3NpdGlvbi5cbiAgICogQHBhcmFtICB7TnVtYmVyfSB4IFRoZSB4LXBvc2l0aW9uIG9mIHRoZSBsaXN0ZW5lci5cbiAgICogQHBhcmFtICB7TnVtYmVyfSB5IFRoZSB5LXBvc2l0aW9uIG9mIHRoZSBsaXN0ZW5lci5cbiAgICogQHBhcmFtICB7TnVtYmVyfSB6IFRoZSB6LXBvc2l0aW9uIG9mIHRoZSBsaXN0ZW5lci5cbiAgICogQHJldHVybiB7SG93bGVyL0FycmF5fSAgIFNlbGYgb3IgY3VycmVudCBsaXN0ZW5lciBwb3NpdGlvbi5cbiAgICovXG4gIEhvd2xlckdsb2JhbC5wcm90b3R5cGUucG9zID0gZnVuY3Rpb24oeCwgeSwgeikge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIC8vIFN0b3AgcmlnaHQgaGVyZSBpZiBub3QgdXNpbmcgV2ViIEF1ZGlvLlxuICAgIGlmICghc2VsZi5jdHggfHwgIXNlbGYuY3R4Lmxpc3RlbmVyKSB7XG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG5cbiAgICAvLyBTZXQgdGhlIGRlZmF1bHRzIGZvciBvcHRpb25hbCAneScgJiAneicuXG4gICAgeSA9ICh0eXBlb2YgeSAhPT0gJ251bWJlcicpID8gc2VsZi5fcG9zWzFdIDogeTtcbiAgICB6ID0gKHR5cGVvZiB6ICE9PSAnbnVtYmVyJykgPyBzZWxmLl9wb3NbMl0gOiB6O1xuXG4gICAgaWYgKHR5cGVvZiB4ID09PSAnbnVtYmVyJykge1xuICAgICAgc2VsZi5fcG9zID0gW3gsIHksIHpdO1xuICAgICAgc2VsZi5jdHgubGlzdGVuZXIuc2V0UG9zaXRpb24oc2VsZi5fcG9zWzBdLCBzZWxmLl9wb3NbMV0sIHNlbGYuX3Bvc1syXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBzZWxmLl9wb3M7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNlbGY7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldC9zZXQgdGhlIGRpcmVjdGlvbiB0aGUgbGlzdGVuZXIgaXMgcG9pbnRpbmcgaW4gdGhlIDNEIGNhcnRlc2lhbiBzcGFjZS5cbiAgICogQSBmcm9udCBhbmQgdXAgdmVjdG9yIG11c3QgYmUgcHJvdmlkZWQuIFRoZSBmcm9udCBpcyB0aGUgZGlyZWN0aW9uIHRoZVxuICAgKiBmYWNlIG9mIHRoZSBsaXN0ZW5lciBpcyBwb2ludGluZywgYW5kIHVwIGlzIHRoZSBkaXJlY3Rpb24gdGhlIHRvcCBvZiB0aGVcbiAgICogbGlzdGVuZXIgaXMgcG9pbnRpbmcuIFRodXMsIHRoZXNlIHZhbHVlcyBhcmUgZXhwZWN0ZWQgdG8gYmUgYXQgcmlnaHQgYW5nbGVzXG4gICAqIGZyb20gZWFjaCBvdGhlci5cbiAgICogQHBhcmFtICB7TnVtYmVyfSB4ICAgVGhlIHgtb3JpZW50YXRpb24gb2YgdGhlIGxpc3RlbmVyLlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHkgICBUaGUgeS1vcmllbnRhdGlvbiBvZiB0aGUgbGlzdGVuZXIuXG4gICAqIEBwYXJhbSAge051bWJlcn0geiAgIFRoZSB6LW9yaWVudGF0aW9uIG9mIHRoZSBsaXN0ZW5lci5cbiAgICogQHBhcmFtICB7TnVtYmVyfSB4VXAgVGhlIHgtb3JpZW50YXRpb24gb2YgdGhlIHRvcCBvZiB0aGUgbGlzdGVuZXIuXG4gICAqIEBwYXJhbSAge051bWJlcn0geVVwIFRoZSB5LW9yaWVudGF0aW9uIG9mIHRoZSB0b3Agb2YgdGhlIGxpc3RlbmVyLlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHpVcCBUaGUgei1vcmllbnRhdGlvbiBvZiB0aGUgdG9wIG9mIHRoZSBsaXN0ZW5lci5cbiAgICogQHJldHVybiB7SG93bGVyL0FycmF5fSAgICAgUmV0dXJucyBzZWxmIG9yIHRoZSBjdXJyZW50IG9yaWVudGF0aW9uIHZlY3RvcnMuXG4gICAqL1xuICBIb3dsZXJHbG9iYWwucHJvdG90eXBlLm9yaWVudGF0aW9uID0gZnVuY3Rpb24oeCwgeSwgeiwgeFVwLCB5VXAsIHpVcCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIC8vIFN0b3AgcmlnaHQgaGVyZSBpZiBub3QgdXNpbmcgV2ViIEF1ZGlvLlxuICAgIGlmICghc2VsZi5jdHggfHwgIXNlbGYuY3R4Lmxpc3RlbmVyKSB7XG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG5cbiAgICAvLyBTZXQgdGhlIGRlZmF1bHRzIGZvciBvcHRpb25hbCAneScgJiAneicuXG4gICAgdmFyIG9yID0gc2VsZi5fb3JpZW50YXRpb247XG4gICAgeSA9ICh0eXBlb2YgeSAhPT0gJ251bWJlcicpID8gb3JbMV0gOiB5O1xuICAgIHogPSAodHlwZW9mIHogIT09ICdudW1iZXInKSA/IG9yWzJdIDogejtcbiAgICB4VXAgPSAodHlwZW9mIHhVcCAhPT0gJ251bWJlcicpID8gb3JbM10gOiB4VXA7XG4gICAgeVVwID0gKHR5cGVvZiB5VXAgIT09ICdudW1iZXInKSA/IG9yWzRdIDogeVVwO1xuICAgIHpVcCA9ICh0eXBlb2YgelVwICE9PSAnbnVtYmVyJykgPyBvcls1XSA6IHpVcDtcblxuICAgIGlmICh0eXBlb2YgeCA9PT0gJ251bWJlcicpIHtcbiAgICAgIHNlbGYuX29yaWVudGF0aW9uID0gW3gsIHksIHosIHhVcCwgeVVwLCB6VXBdO1xuICAgICAgc2VsZi5jdHgubGlzdGVuZXIuc2V0T3JpZW50YXRpb24oeCwgeSwgeiwgeFVwLCB5VXAsIHpVcCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBvcjtcbiAgICB9XG5cbiAgICByZXR1cm4gc2VsZjtcbiAgfTtcblxuICAvKiogR3JvdXAgTWV0aG9kcyAqKi9cbiAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAvKipcbiAgICogQWRkIG5ldyBwcm9wZXJ0aWVzIHRvIHRoZSBjb3JlIGluaXQuXG4gICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBfc3VwZXIgQ29yZSBpbml0IG1ldGhvZC5cbiAgICogQHJldHVybiB7SG93bH1cbiAgICovXG4gIEhvd2wucHJvdG90eXBlLmluaXQgPSAoZnVuY3Rpb24oX3N1cGVyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKG8pIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgLy8gU2V0dXAgdXNlci1kZWZpbmVkIGRlZmF1bHQgcHJvcGVydGllcy5cbiAgICAgIHNlbGYuX29yaWVudGF0aW9uID0gby5vcmllbnRhdGlvbiB8fCBbMSwgMCwgMF07XG4gICAgICBzZWxmLl9zdGVyZW8gPSBvLnN0ZXJlbyB8fCBudWxsO1xuICAgICAgc2VsZi5fcG9zID0gby5wb3MgfHwgbnVsbDtcbiAgICAgIHNlbGYuX3Bhbm5lckF0dHIgPSB7XG4gICAgICAgIGNvbmVJbm5lckFuZ2xlOiB0eXBlb2Ygby5jb25lSW5uZXJBbmdsZSAhPT0gJ3VuZGVmaW5lZCcgPyBvLmNvbmVJbm5lckFuZ2xlIDogMzYwLFxuICAgICAgICBjb25lT3V0ZXJBbmdsZTogdHlwZW9mIG8uY29uZU91dGVyQW5nbGUgIT09ICd1bmRlZmluZWQnID8gby5jb25lT3V0ZXJBbmdsZSA6IDM2MCxcbiAgICAgICAgY29uZU91dGVyR2FpbjogdHlwZW9mIG8uY29uZU91dGVyR2FpbiAhPT0gJ3VuZGVmaW5lZCcgPyBvLmNvbmVPdXRlckdhaW4gOiAwLFxuICAgICAgICBkaXN0YW5jZU1vZGVsOiB0eXBlb2Ygby5kaXN0YW5jZU1vZGVsICE9PSAndW5kZWZpbmVkJyA/IG8uZGlzdGFuY2VNb2RlbCA6ICdpbnZlcnNlJyxcbiAgICAgICAgbWF4RGlzdGFuY2U6IHR5cGVvZiBvLm1heERpc3RhbmNlICE9PSAndW5kZWZpbmVkJyA/IG8ubWF4RGlzdGFuY2UgOiAxMDAwMCxcbiAgICAgICAgcGFubmluZ01vZGVsOiB0eXBlb2Ygby5wYW5uaW5nTW9kZWwgIT09ICd1bmRlZmluZWQnID8gby5wYW5uaW5nTW9kZWwgOiAnSFJURicsXG4gICAgICAgIHJlZkRpc3RhbmNlOiB0eXBlb2Ygby5yZWZEaXN0YW5jZSAhPT0gJ3VuZGVmaW5lZCcgPyBvLnJlZkRpc3RhbmNlIDogMSxcbiAgICAgICAgcm9sbG9mZkZhY3RvcjogdHlwZW9mIG8ucm9sbG9mZkZhY3RvciAhPT0gJ3VuZGVmaW5lZCcgPyBvLnJvbGxvZmZGYWN0b3IgOiAxXG4gICAgICB9O1xuXG4gICAgICAvLyBTZXR1cCBldmVudCBsaXN0ZW5lcnMuXG4gICAgICBzZWxmLl9vbnN0ZXJlbyA9IG8ub25zdGVyZW8gPyBbe2ZuOiBvLm9uc3RlcmVvfV0gOiBbXTtcbiAgICAgIHNlbGYuX29ucG9zID0gby5vbnBvcyA/IFt7Zm46IG8ub25wb3N9XSA6IFtdO1xuICAgICAgc2VsZi5fb25vcmllbnRhdGlvbiA9IG8ub25vcmllbnRhdGlvbiA/IFt7Zm46IG8ub25vcmllbnRhdGlvbn1dIDogW107XG5cbiAgICAgIC8vIENvbXBsZXRlIGluaXRpbGl6YXRpb24gd2l0aCBob3dsZXIuanMgY29yZSdzIGluaXQgZnVuY3Rpb24uXG4gICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgbyk7XG4gICAgfTtcbiAgfSkoSG93bC5wcm90b3R5cGUuaW5pdCk7XG5cbiAgLyoqXG4gICAqIEdldC9zZXQgdGhlIHN0ZXJlbyBwYW5uaW5nIG9mIHRoZSBhdWRpbyBzb3VyY2UgZm9yIHRoaXMgc291bmQgb3IgYWxsIGluIHRoZSBncm91cC5cbiAgICogQHBhcmFtICB7TnVtYmVyfSBwYW4gIEEgdmFsdWUgb2YgLTEuMCBpcyBhbGwgdGhlIHdheSBsZWZ0IGFuZCAxLjAgaXMgYWxsIHRoZSB3YXkgcmlnaHQuXG4gICAqIEBwYXJhbSAge051bWJlcn0gaWQgKG9wdGlvbmFsKSBUaGUgc291bmQgSUQuIElmIG5vbmUgaXMgcGFzc2VkLCBhbGwgaW4gZ3JvdXAgd2lsbCBiZSB1cGRhdGVkLlxuICAgKiBAcmV0dXJuIHtIb3dsL051bWJlcn0gICAgUmV0dXJucyBzZWxmIG9yIHRoZSBjdXJyZW50IHN0ZXJlbyBwYW5uaW5nIHZhbHVlLlxuICAgKi9cbiAgSG93bC5wcm90b3R5cGUuc3RlcmVvID0gZnVuY3Rpb24ocGFuLCBpZCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIC8vIFN0b3AgcmlnaHQgaGVyZSBpZiBub3QgdXNpbmcgV2ViIEF1ZGlvLlxuICAgIGlmICghc2VsZi5fd2ViQXVkaW8pIHtcbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cblxuICAgIC8vIElmIHRoZSBzb3VuZCBoYXNuJ3QgbG9hZGVkLCBhZGQgaXQgdG8gdGhlIGxvYWQgcXVldWUgdG8gY2hhbmdlIHN0ZXJlbyBwYW4gd2hlbiBjYXBhYmxlLlxuICAgIGlmIChzZWxmLl9zdGF0ZSAhPT0gJ2xvYWRlZCcpIHtcbiAgICAgIHNlbGYuX3F1ZXVlLnB1c2goe1xuICAgICAgICBldmVudDogJ3N0ZXJlbycsXG4gICAgICAgIGFjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgc2VsZi5zdGVyZW8ocGFuLCBpZCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBmb3IgUGFubmVyU3RlcmVvTm9kZSBzdXBwb3J0IGFuZCBmYWxsYmFjayB0byBQYW5uZXJOb2RlIGlmIGl0IGRvZXNuJ3QgZXhpc3QuXG4gICAgdmFyIHBhbm5lclR5cGUgPSAodHlwZW9mIEhvd2xlci5jdHguY3JlYXRlU3RlcmVvUGFubmVyID09PSAndW5kZWZpbmVkJykgPyAnc3BhdGlhbCcgOiAnc3RlcmVvJztcblxuICAgIC8vIFNldHVwIHRoZSBncm91cCdzIHN0ZXJlbyBwYW5uaW5nIGlmIG5vIElEIGlzIHBhc3NlZC5cbiAgICBpZiAodHlwZW9mIGlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgLy8gUmV0dXJuIHRoZSBncm91cCdzIHN0ZXJlbyBwYW5uaW5nIGlmIG5vIHBhcmFtZXRlcnMgYXJlIHBhc3NlZC5cbiAgICAgIGlmICh0eXBlb2YgcGFuID09PSAnbnVtYmVyJykge1xuICAgICAgICBzZWxmLl9zdGVyZW8gPSBwYW47XG4gICAgICAgIHNlbGYuX3BvcyA9IFtwYW4sIDAsIDBdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuX3N0ZXJlbztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDaGFuZ2UgdGhlIHN0cmVvIHBhbm5pbmcgb2Ygb25lIG9yIGFsbCBzb3VuZHMgaW4gZ3JvdXAuXG4gICAgdmFyIGlkcyA9IHNlbGYuX2dldFNvdW5kSWRzKGlkKTtcbiAgICBmb3IgKHZhciBpPTA7IGk8aWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAvLyBHZXQgdGhlIHNvdW5kLlxuICAgICAgdmFyIHNvdW5kID0gc2VsZi5fc291bmRCeUlkKGlkc1tpXSk7XG5cbiAgICAgIGlmIChzb3VuZCkge1xuICAgICAgICBpZiAodHlwZW9mIHBhbiA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICBzb3VuZC5fc3RlcmVvID0gcGFuO1xuICAgICAgICAgIHNvdW5kLl9wb3MgPSBbcGFuLCAwLCAwXTtcblxuICAgICAgICAgIGlmIChzb3VuZC5fbm9kZSkge1xuICAgICAgICAgICAgLy8gSWYgd2UgYXJlIGZhbGxpbmcgYmFjaywgbWFrZSBzdXJlIHRoZSBwYW5uaW5nTW9kZWwgaXMgZXF1YWxwb3dlci5cbiAgICAgICAgICAgIHNvdW5kLl9wYW5uZXJBdHRyLnBhbm5pbmdNb2RlbCA9ICdlcXVhbHBvd2VyJztcblxuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlcmUgaXMgYSBwYW5uZXIgc2V0dXAgYW5kIGNyZWF0ZSBhIG5ldyBvbmUgaWYgbm90LlxuICAgICAgICAgICAgaWYgKCFzb3VuZC5fcGFubmVyIHx8ICFzb3VuZC5fcGFubmVyLnBhbikge1xuICAgICAgICAgICAgICBzZXR1cFBhbm5lcihzb3VuZCwgcGFubmVyVHlwZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwYW5uZXJUeXBlID09PSAnc3BhdGlhbCcpIHtcbiAgICAgICAgICAgICAgc291bmQuX3Bhbm5lci5zZXRQb3NpdGlvbihwYW4sIDAsIDApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc291bmQuX3Bhbm5lci5wYW4udmFsdWUgPSBwYW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc2VsZi5fZW1pdCgnc3RlcmVvJywgc291bmQuX2lkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gc291bmQuX3N0ZXJlbztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzZWxmO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQvc2V0IHRoZSAzRCBzcGF0aWFsIHBvc2l0aW9uIG9mIHRoZSBhdWRpbyBzb3VyY2UgZm9yIHRoaXMgc291bmQgb3JcbiAgICogYWxsIGluIHRoZSBncm91cC4gVGhlIG1vc3QgY29tbW9uIHVzYWdlIGlzIHRvIHNldCB0aGUgJ3gnIHBvc2l0aW9uIGZvclxuICAgKiBsZWZ0L3JpZ2h0IHBhbm5pbmcuIFNldHRpbmcgYW55IHZhbHVlIGhpZ2hlciB0aGFuIDEuMCB3aWxsIGJlZ2luIHRvXG4gICAqIGRlY3JlYXNlIHRoZSB2b2x1bWUgb2YgdGhlIHNvdW5kIGFzIGl0IG1vdmVzIGZ1cnRoZXIgYXdheS5cbiAgICogQHBhcmFtICB7TnVtYmVyfSB4ICBUaGUgeC1wb3NpdGlvbiBvZiB0aGUgYXVkaW8gZnJvbSAtMTAwMC4wIHRvIDEwMDAuMC5cbiAgICogQHBhcmFtICB7TnVtYmVyfSB5ICBUaGUgeS1wb3NpdGlvbiBvZiB0aGUgYXVkaW8gZnJvbSAtMTAwMC4wIHRvIDEwMDAuMC5cbiAgICogQHBhcmFtICB7TnVtYmVyfSB6ICBUaGUgei1wb3NpdGlvbiBvZiB0aGUgYXVkaW8gZnJvbSAtMTAwMC4wIHRvIDEwMDAuMC5cbiAgICogQHBhcmFtICB7TnVtYmVyfSBpZCAob3B0aW9uYWwpIFRoZSBzb3VuZCBJRC4gSWYgbm9uZSBpcyBwYXNzZWQsIGFsbCBpbiBncm91cCB3aWxsIGJlIHVwZGF0ZWQuXG4gICAqIEByZXR1cm4ge0hvd2wvQXJyYXl9ICAgIFJldHVybnMgc2VsZiBvciB0aGUgY3VycmVudCAzRCBzcGF0aWFsIHBvc2l0aW9uOiBbeCwgeSwgel0uXG4gICAqL1xuICBIb3dsLnByb3RvdHlwZS5wb3MgPSBmdW5jdGlvbih4LCB5LCB6LCBpZCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIC8vIFN0b3AgcmlnaHQgaGVyZSBpZiBub3QgdXNpbmcgV2ViIEF1ZGlvLlxuICAgIGlmICghc2VsZi5fd2ViQXVkaW8pIHtcbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cblxuICAgIC8vIElmIHRoZSBzb3VuZCBoYXNuJ3QgbG9hZGVkLCBhZGQgaXQgdG8gdGhlIGxvYWQgcXVldWUgdG8gY2hhbmdlIHBvc2l0aW9uIHdoZW4gY2FwYWJsZS5cbiAgICBpZiAoc2VsZi5fc3RhdGUgIT09ICdsb2FkZWQnKSB7XG4gICAgICBzZWxmLl9xdWV1ZS5wdXNoKHtcbiAgICAgICAgZXZlbnQ6ICdwb3MnLFxuICAgICAgICBhY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHNlbGYucG9zKHgsIHksIHosIGlkKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cblxuICAgIC8vIFNldCB0aGUgZGVmYXVsdHMgZm9yIG9wdGlvbmFsICd5JyAmICd6Jy5cbiAgICB5ID0gKHR5cGVvZiB5ICE9PSAnbnVtYmVyJykgPyAwIDogeTtcbiAgICB6ID0gKHR5cGVvZiB6ICE9PSAnbnVtYmVyJykgPyAtMC41IDogejtcblxuICAgIC8vIFNldHVwIHRoZSBncm91cCdzIHNwYXRpYWwgcG9zaXRpb24gaWYgbm8gSUQgaXMgcGFzc2VkLlxuICAgIGlmICh0eXBlb2YgaWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAvLyBSZXR1cm4gdGhlIGdyb3VwJ3Mgc3BhdGlhbCBwb3NpdGlvbiBpZiBubyBwYXJhbWV0ZXJzIGFyZSBwYXNzZWQuXG4gICAgICBpZiAodHlwZW9mIHggPT09ICdudW1iZXInKSB7XG4gICAgICAgIHNlbGYuX3BvcyA9IFt4LCB5LCB6XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBzZWxmLl9wb3M7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ2hhbmdlIHRoZSBzcGF0aWFsIHBvc2l0aW9uIG9mIG9uZSBvciBhbGwgc291bmRzIGluIGdyb3VwLlxuICAgIHZhciBpZHMgPSBzZWxmLl9nZXRTb3VuZElkcyhpZCk7XG4gICAgZm9yICh2YXIgaT0wOyBpPGlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgLy8gR2V0IHRoZSBzb3VuZC5cbiAgICAgIHZhciBzb3VuZCA9IHNlbGYuX3NvdW5kQnlJZChpZHNbaV0pO1xuXG4gICAgICBpZiAoc291bmQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB4ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIHNvdW5kLl9wb3MgPSBbeCwgeSwgel07XG5cbiAgICAgICAgICBpZiAoc291bmQuX25vZGUpIHtcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZXJlIGlzIGEgcGFubmVyIHNldHVwIGFuZCBjcmVhdGUgYSBuZXcgb25lIGlmIG5vdC5cbiAgICAgICAgICAgIGlmICghc291bmQuX3Bhbm5lciB8fCBzb3VuZC5fcGFubmVyLnBhbikge1xuICAgICAgICAgICAgICBzZXR1cFBhbm5lcihzb3VuZCwgJ3NwYXRpYWwnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc291bmQuX3Bhbm5lci5zZXRQb3NpdGlvbih4LCB5LCB6KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzZWxmLl9lbWl0KCdwb3MnLCBzb3VuZC5faWQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBzb3VuZC5fcG9zO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHNlbGY7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldC9zZXQgdGhlIGRpcmVjdGlvbiB0aGUgYXVkaW8gc291cmNlIGlzIHBvaW50aW5nIGluIHRoZSAzRCBjYXJ0ZXNpYW4gY29vcmRpbmF0ZVxuICAgKiBzcGFjZS4gRGVwZW5kaW5nIG9uIGhvdyBkaXJlY3Rpb24gdGhlIHNvdW5kIGlzLCBiYXNlZCBvbiB0aGUgYGNvbmVgIGF0dHJpYnV0ZXMsXG4gICAqIGEgc291bmQgcG9pbnRpbmcgYXdheSBmcm9tIHRoZSBsaXN0ZW5lciBjYW4gYmUgcXVpZXQgb3Igc2lsZW50LlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHggIFRoZSB4LW9yaWVudGF0aW9uIG9mIHRoZSBzb3VyY2UuXG4gICAqIEBwYXJhbSAge051bWJlcn0geSAgVGhlIHktb3JpZW50YXRpb24gb2YgdGhlIHNvdXJjZS5cbiAgICogQHBhcmFtICB7TnVtYmVyfSB6ICBUaGUgei1vcmllbnRhdGlvbiBvZiB0aGUgc291cmNlLlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGlkIChvcHRpb25hbCkgVGhlIHNvdW5kIElELiBJZiBub25lIGlzIHBhc3NlZCwgYWxsIGluIGdyb3VwIHdpbGwgYmUgdXBkYXRlZC5cbiAgICogQHJldHVybiB7SG93bC9BcnJheX0gICAgUmV0dXJucyBzZWxmIG9yIHRoZSBjdXJyZW50IDNEIHNwYXRpYWwgb3JpZW50YXRpb246IFt4LCB5LCB6XS5cbiAgICovXG4gIEhvd2wucHJvdG90eXBlLm9yaWVudGF0aW9uID0gZnVuY3Rpb24oeCwgeSwgeiwgaWQpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAvLyBTdG9wIHJpZ2h0IGhlcmUgaWYgbm90IHVzaW5nIFdlYiBBdWRpby5cbiAgICBpZiAoIXNlbGYuX3dlYkF1ZGlvKSB7XG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgc291bmQgaGFzbid0IGxvYWRlZCwgYWRkIGl0IHRvIHRoZSBsb2FkIHF1ZXVlIHRvIGNoYW5nZSBvcmllbnRhdGlvbiB3aGVuIGNhcGFibGUuXG4gICAgaWYgKHNlbGYuX3N0YXRlICE9PSAnbG9hZGVkJykge1xuICAgICAgc2VsZi5fcXVldWUucHVzaCh7XG4gICAgICAgIGV2ZW50OiAnb3JpZW50YXRpb24nLFxuICAgICAgICBhY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHNlbGYub3JpZW50YXRpb24oeCwgeSwgeiwgaWQpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuXG4gICAgLy8gU2V0IHRoZSBkZWZhdWx0cyBmb3Igb3B0aW9uYWwgJ3knICYgJ3onLlxuICAgIHkgPSAodHlwZW9mIHkgIT09ICdudW1iZXInKSA/IHNlbGYuX29yaWVudGF0aW9uWzFdIDogeTtcbiAgICB6ID0gKHR5cGVvZiB6ICE9PSAnbnVtYmVyJykgPyBzZWxmLl9vcmllbnRhdGlvblsyXSA6IHo7XG5cbiAgICAvLyBTZXR1cCB0aGUgZ3JvdXAncyBzcGF0aWFsIG9yaWVudGF0aW9uIGlmIG5vIElEIGlzIHBhc3NlZC5cbiAgICBpZiAodHlwZW9mIGlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgLy8gUmV0dXJuIHRoZSBncm91cCdzIHNwYXRpYWwgb3JpZW50YXRpb24gaWYgbm8gcGFyYW1ldGVycyBhcmUgcGFzc2VkLlxuICAgICAgaWYgKHR5cGVvZiB4ID09PSAnbnVtYmVyJykge1xuICAgICAgICBzZWxmLl9vcmllbnRhdGlvbiA9IFt4LCB5LCB6XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBzZWxmLl9vcmllbnRhdGlvbjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDaGFuZ2UgdGhlIHNwYXRpYWwgb3JpZW50YXRpb24gb2Ygb25lIG9yIGFsbCBzb3VuZHMgaW4gZ3JvdXAuXG4gICAgdmFyIGlkcyA9IHNlbGYuX2dldFNvdW5kSWRzKGlkKTtcbiAgICBmb3IgKHZhciBpPTA7IGk8aWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAvLyBHZXQgdGhlIHNvdW5kLlxuICAgICAgdmFyIHNvdW5kID0gc2VsZi5fc291bmRCeUlkKGlkc1tpXSk7XG5cbiAgICAgIGlmIChzb3VuZCkge1xuICAgICAgICBpZiAodHlwZW9mIHggPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgc291bmQuX29yaWVudGF0aW9uID0gW3gsIHksIHpdO1xuXG4gICAgICAgICAgaWYgKHNvdW5kLl9ub2RlKSB7XG4gICAgICAgICAgICAvLyBDaGVjayBpZiB0aGVyZSBpcyBhIHBhbm5lciBzZXR1cCBhbmQgY3JlYXRlIGEgbmV3IG9uZSBpZiBub3QuXG4gICAgICAgICAgICBpZiAoIXNvdW5kLl9wYW5uZXIpIHtcbiAgICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHdlIGhhdmUgYSBwb3NpdGlvbiB0byBzZXR1cCB0aGUgbm9kZSB3aXRoLlxuICAgICAgICAgICAgICBpZiAoIXNvdW5kLl9wb3MpIHtcbiAgICAgICAgICAgICAgICBzb3VuZC5fcG9zID0gc2VsZi5fcG9zIHx8IFswLCAwLCAtMC41XTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHNldHVwUGFubmVyKHNvdW5kLCAnc3BhdGlhbCcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzb3VuZC5fcGFubmVyLnNldE9yaWVudGF0aW9uKHgsIHksIHopO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHNlbGYuX2VtaXQoJ29yaWVudGF0aW9uJywgc291bmQuX2lkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gc291bmQuX29yaWVudGF0aW9uO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHNlbGY7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldC9zZXQgdGhlIHBhbm5lciBub2RlJ3MgYXR0cmlidXRlcyBmb3IgYSBzb3VuZCBvciBncm91cCBvZiBzb3VuZHMuXG4gICAqIFRoaXMgbWV0aG9kIGNhbiBvcHRpb25hbGwgdGFrZSAwLCAxIG9yIDIgYXJndW1lbnRzLlxuICAgKiAgIHBhbm5lckF0dHIoKSAtPiBSZXR1cm5zIHRoZSBncm91cCdzIHZhbHVlcy5cbiAgICogICBwYW5uZXJBdHRyKGlkKSAtPiBSZXR1cm5zIHRoZSBzb3VuZCBpZCdzIHZhbHVlcy5cbiAgICogICBwYW5uZXJBdHRyKG8pIC0+IFNldCdzIHRoZSB2YWx1ZXMgb2YgYWxsIHNvdW5kcyBpbiB0aGlzIEhvd2wgZ3JvdXAuXG4gICAqICAgcGFubmVyQXR0cihvLCBpZCkgLT4gU2V0J3MgdGhlIHZhbHVlcyBvZiBwYXNzZWQgc291bmQgaWQuXG4gICAqXG4gICAqICAgQXR0cmlidXRlczpcbiAgICogICAgIGNvbmVJbm5lckFuZ2xlIC0gKDM2MCBieSBkZWZhdWx0KSBUaGVyZSB3aWxsIGJlIG5vIHZvbHVtZSByZWR1Y3Rpb24gaW5zaWRlIHRoaXMgYW5nbGUuXG4gICAqICAgICBjb25lT3V0ZXJBbmdsZSAtICgzNjAgYnkgZGVmYXVsdCkgVGhlIHZvbHVtZSB3aWxsIGJlIHJlZHVjZWQgdG8gYSBjb25zdGFudCB2YWx1ZSBvZlxuICAgKiAgICAgICAgICAgICAgICAgICAgICBgY29uZU91dGVyR2FpbmAgb3V0c2lkZSB0aGlzIGFuZ2xlLlxuICAgKiAgICAgY29uZU91dGVyR2FpbiAtICgwIGJ5IGRlZmF1bHQpIFRoZSBhbW91bnQgb2Ygdm9sdW1lIHJlZHVjdGlvbiBvdXRzaWRlIG9mIGBjb25lT3V0ZXJBbmdsZWAuXG4gICAqICAgICBkaXN0YW5jZU1vZGVsIC0gKCdpbnZlcnNlJyBieSBkZWZhdWx0KSBEZXRlcm1pbmVzIGFsZ29yaXRobSB0byB1c2UgdG8gcmVkdWNlIHZvbHVtZSBhcyBhdWRpbyBtb3Zlc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICBhd2F5IGZyb20gbGlzdGVuZXIuIENhbiBiZSBgbGluZWFyYCwgYGludmVyc2VgIG9yIGBleHBvbmVudGlhbGAuXG4gICAqICAgICBtYXhEaXN0YW5jZSAtICgxMDAwMCBieSBkZWZhdWx0KSBWb2x1bWUgd29uJ3QgcmVkdWNlIGJldHdlZW4gc291cmNlL2xpc3RlbmVyIGJleW9uZCB0aGlzIGRpc3RhbmNlLlxuICAgKiAgICAgcGFubmluZ01vZGVsIC0gKCdIUlRGJyBieSBkZWZhdWx0KSBEZXRlcm1pbmVzIHdoaWNoIHNwYXRpYWxpemF0aW9uIGFsZ29yaXRobSBpcyB1c2VkIHRvIHBvc2l0aW9uIGF1ZGlvLlxuICAgKiAgICAgICAgICAgICAgICAgICAgIENhbiBiZSBgSFJURmAgb3IgYGVxdWFscG93ZXJgLlxuICAgKiAgICAgcmVmRGlzdGFuY2UgLSAoMSBieSBkZWZhdWx0KSBBIHJlZmVyZW5jZSBkaXN0YW5jZSBmb3IgcmVkdWNpbmcgdm9sdW1lIGFzIHRoZSBzb3VyY2VcbiAgICogICAgICAgICAgICAgICAgICAgIG1vdmVzIGF3YXkgZnJvbSB0aGUgbGlzdGVuZXIuXG4gICAqICAgICByb2xsb2ZmRmFjdG9yIC0gKDEgYnkgZGVmYXVsdCkgSG93IHF1aWNrbHkgdGhlIHZvbHVtZSByZWR1Y2VzIGFzIHNvdXJjZSBtb3ZlcyBmcm9tIGxpc3RlbmVyLlxuICAgKiBcbiAgICogQHJldHVybiB7SG93bC9PYmplY3R9IFJldHVybnMgc2VsZiBvciBjdXJyZW50IHBhbm5lciBhdHRyaWJ1dGVzLlxuICAgKi9cbiAgSG93bC5wcm90b3R5cGUucGFubmVyQXR0ciA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICB2YXIgbywgaWQsIHNvdW5kO1xuXG4gICAgLy8gU3RvcCByaWdodCBoZXJlIGlmIG5vdCB1c2luZyBXZWIgQXVkaW8uXG4gICAgaWYgKCFzZWxmLl93ZWJBdWRpbykge1xuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuXG4gICAgLy8gRGV0ZXJtaW5lIHRoZSB2YWx1ZXMgYmFzZWQgb24gYXJndW1lbnRzLlxuICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgLy8gUmV0dXJuIHRoZSBncm91cCdzIHBhbm5lciBhdHRyaWJ1dGUgdmFsdWVzLlxuICAgICAgcmV0dXJuIHNlbGYuX3Bhbm5lckF0dHI7XG4gICAgfSBlbHNlIGlmIChhcmdzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgaWYgKHR5cGVvZiBhcmdzWzBdID09PSAnb2JqZWN0Jykge1xuICAgICAgICBvID0gYXJnc1swXTtcblxuICAgICAgICAvLyBTZXQgdGhlIGdyb3UncyBwYW5uZXIgYXR0cmlidXRlIHZhbHVlcy5cbiAgICAgICAgaWYgKHR5cGVvZiBpZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBzZWxmLl9wYW5uZXJBdHRyID0ge1xuICAgICAgICAgICAgY29uZUlubmVyQW5nbGU6IHR5cGVvZiBvLmNvbmVJbm5lckFuZ2xlICE9PSAndW5kZWZpbmVkJyA/IG8uY29uZUlubmVyQW5nbGUgOiBzZWxmLl9jb25lSW5uZXJBbmdsZSxcbiAgICAgICAgICAgIGNvbmVPdXRlckFuZ2xlOiB0eXBlb2Ygby5jb25lT3V0ZXJBbmdsZSAhPT0gJ3VuZGVmaW5lZCcgPyBvLmNvbmVPdXRlckFuZ2xlIDogc2VsZi5fY29uZU91dGVyQW5nbGUsXG4gICAgICAgICAgICBjb25lT3V0ZXJHYWluOiB0eXBlb2Ygby5jb25lT3V0ZXJHYWluICE9PSAndW5kZWZpbmVkJyA/IG8uY29uZU91dGVyR2FpbiA6IHNlbGYuX2NvbmVPdXRlckdhaW4sXG4gICAgICAgICAgICBkaXN0YW5jZU1vZGVsOiB0eXBlb2Ygby5kaXN0YW5jZU1vZGVsICE9PSAndW5kZWZpbmVkJyA/IG8uZGlzdGFuY2VNb2RlbCA6IHNlbGYuX2Rpc3RhbmNlTW9kZWwsXG4gICAgICAgICAgICBtYXhEaXN0YW5jZTogdHlwZW9mIG8ubWF4RGlzdGFuY2UgIT09ICd1bmRlZmluZWQnID8gby5tYXhEaXN0YW5jZSA6IHNlbGYuX21heERpc3RhbmNlLFxuICAgICAgICAgICAgcGFubmluZ01vZGVsOiB0eXBlb2Ygby5wYW5uaW5nTW9kZWwgIT09ICd1bmRlZmluZWQnID8gby5wYW5uaW5nTW9kZWwgOiBzZWxmLl9wYW5uaW5nTW9kZWwsXG4gICAgICAgICAgICByZWZEaXN0YW5jZTogdHlwZW9mIG8ucmVmRGlzdGFuY2UgIT09ICd1bmRlZmluZWQnID8gby5yZWZEaXN0YW5jZSA6IHNlbGYuX3JlZkRpc3RhbmNlLFxuICAgICAgICAgICAgcm9sbG9mZkZhY3RvcjogdHlwZW9mIG8ucm9sbG9mZkZhY3RvciAhPT0gJ3VuZGVmaW5lZCcgPyBvLnJvbGxvZmZGYWN0b3IgOiBzZWxmLl9yb2xsb2ZmRmFjdG9yXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gUmV0dXJuIHRoaXMgc291bmQncyBwYW5uZXIgYXR0cmlidXRlIHZhbHVlcy5cbiAgICAgICAgc291bmQgPSBzZWxmLl9zb3VuZEJ5SWQocGFyc2VJbnQoYXJnc1swXSwgMTApKTtcbiAgICAgICAgcmV0dXJuIHNvdW5kID8gc291bmQuX3Bhbm5lckF0dHIgOiBzZWxmLl9wYW5uZXJBdHRyO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoYXJncy5sZW5ndGggPT09IDIpIHtcbiAgICAgIG8gPSBhcmdzWzBdO1xuICAgICAgaWQgPSBwYXJzZUludChhcmdzWzFdLCAxMCk7XG4gICAgfVxuXG4gICAgLy8gVXBkYXRlIHRoZSB2YWx1ZXMgb2YgdGhlIHNwZWNpZmllZCBzb3VuZHMuXG4gICAgdmFyIGlkcyA9IHNlbGYuX2dldFNvdW5kSWRzKGlkKTtcbiAgICBmb3IgKHZhciBpPTA7IGk8aWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBzb3VuZCA9IHNlbGYuX3NvdW5kQnlJZChpZHNbaV0pO1xuXG4gICAgICBpZiAoc291bmQpIHtcbiAgICAgICAgLy8gTWVyZ2UgdGhlIG5ldyB2YWx1ZXMgaW50byB0aGUgc291bmQuXG4gICAgICAgIHZhciBwYSA9IHNvdW5kLl9wYW5uZXJBdHRyO1xuICAgICAgICBwYSA9IHtcbiAgICAgICAgICBjb25lSW5uZXJBbmdsZTogdHlwZW9mIG8uY29uZUlubmVyQW5nbGUgIT09ICd1bmRlZmluZWQnID8gby5jb25lSW5uZXJBbmdsZSA6IHBhLmNvbmVJbm5lckFuZ2xlLFxuICAgICAgICAgIGNvbmVPdXRlckFuZ2xlOiB0eXBlb2Ygby5jb25lT3V0ZXJBbmdsZSAhPT0gJ3VuZGVmaW5lZCcgPyBvLmNvbmVPdXRlckFuZ2xlIDogcGEuY29uZU91dGVyQW5nbGUsXG4gICAgICAgICAgY29uZU91dGVyR2FpbjogdHlwZW9mIG8uY29uZU91dGVyR2FpbiAhPT0gJ3VuZGVmaW5lZCcgPyBvLmNvbmVPdXRlckdhaW4gOiBwYS5jb25lT3V0ZXJHYWluLFxuICAgICAgICAgIGRpc3RhbmNlTW9kZWw6IHR5cGVvZiBvLmRpc3RhbmNlTW9kZWwgIT09ICd1bmRlZmluZWQnID8gby5kaXN0YW5jZU1vZGVsIDogcGEuZGlzdGFuY2VNb2RlbCxcbiAgICAgICAgICBtYXhEaXN0YW5jZTogdHlwZW9mIG8ubWF4RGlzdGFuY2UgIT09ICd1bmRlZmluZWQnID8gby5tYXhEaXN0YW5jZSA6IHBhLm1heERpc3RhbmNlLFxuICAgICAgICAgIHBhbm5pbmdNb2RlbDogdHlwZW9mIG8ucGFubmluZ01vZGVsICE9PSAndW5kZWZpbmVkJyA/IG8ucGFubmluZ01vZGVsIDogcGEucGFubmluZ01vZGVsLFxuICAgICAgICAgIHJlZkRpc3RhbmNlOiB0eXBlb2Ygby5yZWZEaXN0YW5jZSAhPT0gJ3VuZGVmaW5lZCcgPyBvLnJlZkRpc3RhbmNlIDogcGEucmVmRGlzdGFuY2UsXG4gICAgICAgICAgcm9sbG9mZkZhY3RvcjogdHlwZW9mIG8ucm9sbG9mZkZhY3RvciAhPT0gJ3VuZGVmaW5lZCcgPyBvLnJvbGxvZmZGYWN0b3IgOiBwYS5yb2xsb2ZmRmFjdG9yXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gVXBkYXRlIHRoZSBwYW5uZXIgdmFsdWVzIG9yIGNyZWF0ZSBhIG5ldyBwYW5uZXIgaWYgbm9uZSBleGlzdHMuXG4gICAgICAgIHZhciBwYW5uZXIgPSBzb3VuZC5fcGFubmVyO1xuICAgICAgICBpZiAocGFubmVyKSB7XG4gICAgICAgICAgcGFubmVyLmNvbmVJbm5lckFuZ2xlID0gcGEuY29uZUlubmVyQW5nbGU7XG4gICAgICAgICAgcGFubmVyLmNvbmVPdXRlckFuZ2xlID0gcGEuY29uZU91dGVyQW5nbGU7XG4gICAgICAgICAgcGFubmVyLmNvbmVPdXRlckdhaW4gPSBwYS5jb25lT3V0ZXJHYWluO1xuICAgICAgICAgIHBhbm5lci5kaXN0YW5jZU1vZGVsID0gcGEuZGlzdGFuY2VNb2RlbDtcbiAgICAgICAgICBwYW5uZXIubWF4RGlzdGFuY2UgPSBwYS5tYXhEaXN0YW5jZTtcbiAgICAgICAgICBwYW5uZXIucGFubmluZ01vZGVsID0gcGEucGFubmluZ01vZGVsO1xuICAgICAgICAgIHBhbm5lci5yZWZEaXN0YW5jZSA9IHBhLnJlZkRpc3RhbmNlO1xuICAgICAgICAgIHBhbm5lci5yb2xsb2ZmRmFjdG9yID0gcGEucm9sbG9mZkZhY3RvcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBNYWtlIHN1cmUgd2UgaGF2ZSBhIHBvc2l0aW9uIHRvIHNldHVwIHRoZSBub2RlIHdpdGguXG4gICAgICAgICAgaWYgKCFzb3VuZC5fcG9zKSB7XG4gICAgICAgICAgICBzb3VuZC5fcG9zID0gc2VsZi5fcG9zIHx8IFswLCAwLCAtMC41XTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBDcmVhdGUgYSBuZXcgcGFubmVyIG5vZGUuXG4gICAgICAgICAgc2V0dXBQYW5uZXIoc291bmQsICdzcGF0aWFsJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc2VsZjtcbiAgfTtcblxuICAvKiogU2luZ2xlIFNvdW5kIE1ldGhvZHMgKiovXG4gIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgLyoqXG4gICAqIEFkZCBuZXcgcHJvcGVydGllcyB0byB0aGUgY29yZSBTb3VuZCBpbml0LlxuICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gX3N1cGVyIENvcmUgU291bmQgaW5pdCBtZXRob2QuXG4gICAqIEByZXR1cm4ge1NvdW5kfVxuICAgKi9cbiAgU291bmQucHJvdG90eXBlLmluaXQgPSAoZnVuY3Rpb24oX3N1cGVyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIHBhcmVudCA9IHNlbGYuX3BhcmVudDtcblxuICAgICAgLy8gU2V0dXAgdXNlci1kZWZpbmVkIGRlZmF1bHQgcHJvcGVydGllcy5cbiAgICAgIHNlbGYuX29yaWVudGF0aW9uID0gcGFyZW50Ll9vcmllbnRhdGlvbjtcbiAgICAgIHNlbGYuX3N0ZXJlbyA9IHBhcmVudC5fc3RlcmVvO1xuICAgICAgc2VsZi5fcG9zID0gcGFyZW50Ll9wb3M7XG4gICAgICBzZWxmLl9wYW5uZXJBdHRyID0gcGFyZW50Ll9wYW5uZXJBdHRyO1xuXG4gICAgICAvLyBDb21wbGV0ZSBpbml0aWxpemF0aW9uIHdpdGggaG93bGVyLmpzIGNvcmUgU291bmQncyBpbml0IGZ1bmN0aW9uLlxuICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG5cbiAgICAgIC8vIElmIGEgc3RlcmVvIG9yIHBvc2l0aW9uIHdhcyBzcGVjaWZpZWQsIHNldCBpdCB1cC5cbiAgICAgIGlmIChzZWxmLl9zdGVyZW8pIHtcbiAgICAgICAgcGFyZW50LnN0ZXJlbyhzZWxmLl9zdGVyZW8pO1xuICAgICAgfSBlbHNlIGlmIChzZWxmLl9wb3MpIHtcbiAgICAgICAgcGFyZW50LnBvcyhzZWxmLl9wb3NbMF0sIHNlbGYuX3Bvc1sxXSwgc2VsZi5fcG9zWzJdLCBzZWxmLl9pZCk7XG4gICAgICB9XG4gICAgfTtcbiAgfSkoU291bmQucHJvdG90eXBlLmluaXQpO1xuXG4gIC8qKlxuICAgKiBPdmVycmlkZSB0aGUgU291bmQucmVzZXQgbWV0aG9kIHRvIGNsZWFuIHVwIHByb3BlcnRpZXMgZnJvbSB0aGUgc3BhdGlhbCBwbHVnaW4uXG4gICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBfc3VwZXIgU291bmQgcmVzZXQgbWV0aG9kLlxuICAgKiBAcmV0dXJuIHtTb3VuZH1cbiAgICovXG4gIFNvdW5kLnByb3RvdHlwZS5yZXNldCA9IChmdW5jdGlvbihfc3VwZXIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgcGFyZW50ID0gc2VsZi5fcGFyZW50O1xuXG4gICAgICAvLyBSZXNldCBhbGwgc3BhdGlhbCBwbHVnaW4gcHJvcGVydGllcyBvbiB0aGlzIHNvdW5kLlxuICAgICAgc2VsZi5fb3JpZW50YXRpb24gPSBwYXJlbnQuX29yaWVudGF0aW9uO1xuICAgICAgc2VsZi5fcG9zID0gcGFyZW50Ll9wb3M7XG4gICAgICBzZWxmLl9wYW5uZXJBdHRyID0gcGFyZW50Ll9wYW5uZXJBdHRyO1xuXG4gICAgICAvLyBDb21wbGV0ZSByZXNldHRpbmcgb2YgdGhlIHNvdW5kLlxuICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgIH07XG4gIH0pKFNvdW5kLnByb3RvdHlwZS5yZXNldCk7XG5cbiAgLyoqIEhlbHBlciBNZXRob2RzICoqL1xuICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgcGFubmVyIG5vZGUgYW5kIHNhdmUgaXQgb24gdGhlIHNvdW5kLlxuICAgKiBAcGFyYW0gIHtTb3VuZH0gc291bmQgU3BlY2lmaWMgc291bmQgdG8gc2V0dXAgcGFubmluZyBvbi5cbiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVHlwZSBvZiBwYW5uZXIgdG8gY3JlYXRlOiAnc3RlcmVvJyBvciAnc3BhdGlhbCcuXG4gICAqL1xuICB2YXIgc2V0dXBQYW5uZXIgPSBmdW5jdGlvbihzb3VuZCwgdHlwZSkge1xuICAgIHR5cGUgPSB0eXBlIHx8ICdzcGF0aWFsJztcblxuICAgIC8vIENyZWF0ZSB0aGUgbmV3IHBhbm5lciBub2RlLlxuICAgIGlmICh0eXBlID09PSAnc3BhdGlhbCcpIHtcbiAgICAgIHNvdW5kLl9wYW5uZXIgPSBIb3dsZXIuY3R4LmNyZWF0ZVBhbm5lcigpO1xuICAgICAgc291bmQuX3Bhbm5lci5jb25lSW5uZXJBbmdsZSA9IHNvdW5kLl9wYW5uZXJBdHRyLmNvbmVJbm5lckFuZ2xlO1xuICAgICAgc291bmQuX3Bhbm5lci5jb25lT3V0ZXJBbmdsZSA9IHNvdW5kLl9wYW5uZXJBdHRyLmNvbmVPdXRlckFuZ2xlO1xuICAgICAgc291bmQuX3Bhbm5lci5jb25lT3V0ZXJHYWluID0gc291bmQuX3Bhbm5lckF0dHIuY29uZU91dGVyR2FpbjtcbiAgICAgIHNvdW5kLl9wYW5uZXIuZGlzdGFuY2VNb2RlbCA9IHNvdW5kLl9wYW5uZXJBdHRyLmRpc3RhbmNlTW9kZWw7XG4gICAgICBzb3VuZC5fcGFubmVyLm1heERpc3RhbmNlID0gc291bmQuX3Bhbm5lckF0dHIubWF4RGlzdGFuY2U7XG4gICAgICBzb3VuZC5fcGFubmVyLnBhbm5pbmdNb2RlbCA9IHNvdW5kLl9wYW5uZXJBdHRyLnBhbm5pbmdNb2RlbDtcbiAgICAgIHNvdW5kLl9wYW5uZXIucmVmRGlzdGFuY2UgPSBzb3VuZC5fcGFubmVyQXR0ci5yZWZEaXN0YW5jZTtcbiAgICAgIHNvdW5kLl9wYW5uZXIucm9sbG9mZkZhY3RvciA9IHNvdW5kLl9wYW5uZXJBdHRyLnJvbGxvZmZGYWN0b3I7XG4gICAgICBzb3VuZC5fcGFubmVyLnNldFBvc2l0aW9uKHNvdW5kLl9wb3NbMF0sIHNvdW5kLl9wb3NbMV0sIHNvdW5kLl9wb3NbMl0pO1xuICAgICAgc291bmQuX3Bhbm5lci5zZXRPcmllbnRhdGlvbihzb3VuZC5fb3JpZW50YXRpb25bMF0sIHNvdW5kLl9vcmllbnRhdGlvblsxXSwgc291bmQuX29yaWVudGF0aW9uWzJdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc291bmQuX3Bhbm5lciA9IEhvd2xlci5jdHguY3JlYXRlU3RlcmVvUGFubmVyKCk7XG4gICAgICBzb3VuZC5fcGFubmVyLnBhbi52YWx1ZSA9IHNvdW5kLl9zdGVyZW87XG4gICAgfVxuXG4gICAgc291bmQuX3Bhbm5lci5jb25uZWN0KHNvdW5kLl9ub2RlKTtcblxuICAgIC8vIFVwZGF0ZSB0aGUgY29ubmVjdGlvbnMuXG4gICAgaWYgKCFzb3VuZC5fcGF1c2VkKSB7XG4gICAgICBzb3VuZC5fcGFyZW50LnBhdXNlKHNvdW5kLl9pZCwgdHJ1ZSkucGxheShzb3VuZC5faWQpO1xuICAgIH1cbiAgfTtcbn0pKCk7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9ob3dsZXIvZGlzdC9ob3dsZXIuanNcbiAqKiBtb2R1bGUgaWQgPSA0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgUHViU3ViID0ge307XHJcblxyXG4oZnVuY3Rpb24ocCl7XHJcblx0XHJcblx0dmFyIGV2ZW50cyA9IHt9LFxyXG5cdFx0aWRSZWdpc3RyeSA9IDkxMDA7XHJcblx0XHJcblx0XHJcblx0cC5zdWJzY3JpYmUgPSBmdW5jdGlvbihldmVudCwgZnVuYyl7XHJcblx0XHRpZighZXZlbnRzLmhhc093blByb3BlcnR5KGV2ZW50KSl7XHJcblx0XHRcdGV2ZW50c1tldmVudF0gPSBbXTtcclxuXHRcdH1cclxuXHRcdFxyXG5cdFx0dmFyIGV2ZW50SUQgPSArK2lkUmVnaXN0cnk7XHJcblx0XHRcclxuXHRcdGV2ZW50c1tldmVudF0ucHVzaCh7XHJcblx0XHRcdFxyXG5cdFx0XHRpZCA6IGV2ZW50SUQsXHJcblx0XHRcdGhhbmRsZXIgOiBmdW5jXHJcblx0XHRcdFx0XHRcdCAgIFxyXG5cdFx0XHR9KTtcclxuXHRcdFxyXG5cdFx0cmV0dXJuIGV2ZW50SUQ7XHJcblxyXG5cdH07XHJcblx0XHJcblx0cC5wdWJsaXNoID0gZnVuY3Rpb24oZXZlbnQsIGRhdGEpe1xyXG5cdFx0XHJcblx0XHRmb3IodmFyIGV2ZW50IGluIGV2ZW50cyl7XHJcblx0XHRcdGlmKCFldmVudHMuaGFzT3duUHJvcGVydHkoZXZlbnQpKXtcclxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdFx0XHJcblx0XHR2YXIgc3VicyA9IGV2ZW50c1tldmVudF07XHJcblxyXG5cdFx0Zm9yKHZhciBpID0gMCwgaiA9IHN1YnMubGVuZ3RoOyBpPGo7IGkrKyl7XHJcblx0XHRcdFxyXG5cdFx0XHRzdWJzW2ldLmhhbmRsZXIoZXZlbnQsIGRhdGEpO1xyXG5cdFx0XHRcclxuXHRcdH1cclxuXHRcdFxyXG5cdH07XHJcblx0XHJcblx0cC51bnN1YnNjcmliZSA9IGZ1bmN0aW9uKGlkKXtcclxuXHRcdFxyXG5cdFx0Zm9yKHZhciBldmVudCBpbiBldmVudHMpe1xyXG5cdFx0XHRpZihldmVudHMuaGFzT3duUHJvcGVydHkoZXZlbnQpKXtcclxuXHRcdFx0XHRmb3IodmFyIGkgPSAwLCBqID0gZXZlbnRzW2V2ZW50XS5sZW5ndGg7IGk8ajsgaSsrKXtcclxuXHRcdFx0XHRcdGlmKGV2ZW50c1tldmVudF1baV0uaWQgPT09IGlkKXtcclxuXHRcdFx0XHRcdFx0ZXZlbnRzW2V2ZW50XS5zcGxpY2UoaSwgMSk7XHJcblx0XHRcdFx0XHRcdHJldHVybiBpZDtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdFxyXG5cdH07XHJcblxyXG59KShQdWJTdWIpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBQdWJTdWI7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2pzL1B1YlN1Yi5qc1xuICoqIG1vZHVsZSBpZCA9IDVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlxyXG52YXIgUHViU3ViID0gcmVxdWlyZSgnLi9QdWJTdWIuanMnKTtcclxuXHJcbnZhciBrZXlib2FyZENvbnRyb2wgPSBmdW5jdGlvbigpe1xyXG5cdFxyXG5cdC8vY29udHJvbCBrZXlzXHJcblx0Y29uc3QgVVBfQVJST1cgPSAzOCxcclxuXHRcdExFRlRfQVJST1cgPSAzNyxcclxuXHRcdFJJR0hUX0FSUk9XID0gMzksXHJcblx0XHRET1dOX0FSUk9XID0gNDAsXHJcblx0XHRYX0tFWSA9IDg4LFxyXG5cdFx0U1BBQ0VfQkFSID0gMzIsXHJcblx0XHRMRVRURVJfUCA9IDgwO1xyXG5cdFxyXG5cdC8vYXJyYXkgb2YgYWN0aXZlIGFuZCBkZWFjdGl2ZSBrZXlzXHJcblx0dmFyIGtleVByZXNzTGlzdCA9IFtdLFxyXG5cdFx0b2JqZWN0cyA9IFtdLFxyXG5cdFx0aW5pdGlhbGl6ZWQgPSBmYWxzZSxcclxuXHRcdGluR2FtZVBsYXkgPSBmYWxzZTtcclxuXHRcclxuXHRmdW5jdGlvbiBpbml0KG9iamVjdHNUb0NvbnRyb2wpe1xyXG5cdFx0XHJcblx0XHQvL3B1c2hlcyB0aGUgZWxlbWVudHMgdG8gYmUgbWFuaXB1bGF0ZWQgYnkgdGhlIGtleXdvcmQga2V5c1xyXG5cdFx0aWYoIW9iamVjdHMubGVuZ3RoKXtcclxuXHRcdFx0Zm9yKGVsZW1lbnQgaW4gYXJndW1lbnRzKXtcclxuXHRcdFx0XHRvYmplY3RzLnB1c2goYXJndW1lbnRzW2VsZW1lbnRdKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0XHJcblx0XHRQdWJTdWIuc3Vic2NyaWJlKCdzdGF0ZWNoYW5nZScsIGhhbmRsZVN0YXRlQ2hhbmdlKTtcclxuXHRcclxuXHRcdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywgb25LZXlVcCwgZmFsc2UpO1xyXG5cdFx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIG9uS2V5RG93biwgZmFsc2UpO1xyXG5cdFx0aW5pdGlhbGl6ZWQgPSB0cnVlO1xyXG5cdFx0Y29uc29sZS5sb2coJ0tleXdvcmQgQ29udHJvbCBNb2R1bGUgSW5pdGlhbGl6ZWQnKTtcclxuXHRcdFxyXG5cdH1cclxuXHRcclxuXHRmdW5jdGlvbiBoYW5kbGVTdGF0ZUNoYW5nZShldmVudCwgZGF0YSl7XHJcblx0XHRpbkdhbWVQbGF5ID0gKGRhdGEgIT0gXCJnYW1lcGxheVwiKT8gZmFsc2UgOiB0cnVlO1xyXG5cdH1cclxuXHRcclxuXHRmdW5jdGlvbiBvbktleVVwKGUpe1xyXG5cdFx0aWYoIWluaXRpYWxpemVkKSByZXR1cm4oY29uc29sZS5sb2coJ0tleXdvcmQgTW9kdWxlIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZC4uLicpKTtcclxuXHRcdGUucHJldmVudERlZmF1bHQoKTtcclxuXHRcdGtleVByZXNzTGlzdFtlLmtleUNvZGVdID0gZmFsc2U7XHJcblx0fVxyXG5cdFxyXG5cdGZ1bmN0aW9uIG9uS2V5RG93bihlKXtcclxuXHRcdGlmKCFpbml0aWFsaXplZCkgcmV0dXJuKGNvbnNvbGUubG9nKCdLZXl3b3JkIE1vZHVsZSBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQuLi4nKSk7XHJcblx0XHRlLnByZXZlbnREZWZhdWx0KCk7XHJcblx0XHRrZXlQcmVzc0xpc3RbZS5rZXlDb2RlXSA9IHRydWU7IFxyXG5cdH1cclxuXHRcclxuXHRmdW5jdGlvbiBydW5LZXlzKCl7XHJcblx0XHRcclxuXHRcdHZhciBsZW5ndGggPSBvYmplY3RzLmxlbmd0aDtcclxuXHRcdFxyXG5cdFx0XHJcblx0XHRmb3IodmFyIGkgPSAwOyBpPGxlbmd0aDsgaSsrKXtcclxuXHRcdFx0XHJcblx0XHRcdHZhciBvYmplY3QgPSBvYmplY3RzW2ldO1xyXG5cdFx0XHRcclxuXHRcdFx0aWYoa2V5UHJlc3NMaXN0W0xFRlRfQVJST1ddKXtcclxuXHRcdFx0XHRvYmplY3QuYW5nbGUgLT0gNSpNYXRoLlBJLzE4MDtcclxuXHRcdFx0fWVsc2UgaWYoa2V5UHJlc3NMaXN0W1JJR0hUX0FSUk9XXSl7XHJcblx0XHRcdFx0b2JqZWN0LmFuZ2xlICs9IDUqTWF0aC5QSS8xODA7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYoa2V5UHJlc3NMaXN0W1VQX0FSUk9XXSl7XHJcblx0XHRcdFx0b2JqZWN0LnRocnVzdCA9IHRydWU7XHJcblx0XHRcdFx0dmFyIGZhY2VYID0gTWF0aC5jb3Mob2JqZWN0LmFuZ2xlKTtcclxuXHRcdFx0XHR2YXIgZmFjZVkgPSBNYXRoLnNpbihvYmplY3QuYW5nbGUpO1xyXG5cdFx0XHRcdHZhciBuZXdWZWxYID0gb2JqZWN0LnZlbFgrZmFjZVgqb2JqZWN0LnRocnVzdEFjY2VsO1xyXG5cdFx0XHRcdHZhciBuZXdWZWxZID0gb2JqZWN0LnZlbFkrZmFjZVkqb2JqZWN0LnRocnVzdEFjY2VsO1xyXG5cclxuXHRcdFx0XHR2YXIgZnV0dXJlVmVsb2NpdHkgPSBNYXRoLnNxcnQoKG5ld1ZlbFgqbmV3VmVsWCkrKG5ld1ZlbFkqbmV3VmVsWSkpO1xyXG5cclxuXHRcdFx0XHRpZihmdXR1cmVWZWxvY2l0eSA+IG9iamVjdC5tYXhWZWxvY2l0eSl7XHJcblx0XHRcdFx0XHRuZXdWZWxYID0gb2JqZWN0LnZlbFg7XHJcblx0XHRcdFx0XHRuZXdWZWxZID0gb2JqZWN0LnZlbFk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRvYmplY3QudmVsWCA9IG5ld1ZlbFg7XHJcblx0XHRcdFx0b2JqZWN0LnZlbFkgPSBuZXdWZWxZO1x0XHJcblxyXG5cdFx0XHR9ZWxzZXtcclxuXHRcdFx0XHRvYmplY3QudGhydXN0ID0gZmFsc2U7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYoa2V5UHJlc3NMaXN0W1NQQUNFX0JBUl0gPT0gZmFsc2Upe1xyXG5cdFx0XHRcdGtleVByZXNzTGlzdFtTUEFDRV9CQVJdID0gdHJ1ZTtcclxuXHRcdFx0XHRpZighb2JqZWN0LnNoaWVsZC5hY3RpdmUpe1xyXG5cdFx0XHRcdG9iamVjdC5zaG9vdCgpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRjb25zb2xlLmxvZyhvYmplY3QubWlzc2lsZXMucG9vbC5sZW5ndGgpO1xyXG5cdFx0XHRcdC8vUHViU3ViLnB1Ymxpc2goJ2dhbWVzdGF0ZScsICdwYXVzZWQnKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZihrZXlQcmVzc0xpc3RbWF9LRVldKXtcclxuXHRcdFx0XHRvYmplY3Quc2hpZWxkLmFjdGl2ZSA9IHRydWU7XHJcblxyXG5cdFx0XHR9ZWxzZSBpZihrZXlQcmVzc0xpc3RbWF9LRVldID09IGZhbHNlKXtcclxuXHRcdFx0XHRvYmplY3Quc2hpZWxkLmFjdGl2ZSA9IGZhbHNlO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmKGtleVByZXNzTGlzdFtMRVRURVJfUF0gPT0gZmFsc2Upe1xyXG5cdFx0XHRcdGtleVByZXNzTGlzdFtMRVRURVJfUF0gPSB0cnVlO1xyXG5cdFx0XHRcdGNvbnNvbGUubG9nKCdMZXR0ZXIgUCBoYXMgYmVlbiBwcmVzc2VkJyk7XHJcblx0XHRcdFx0dmFyIHVuc3ViSUQgPSBQdWJTdWIudW5zdWJzY3JpYmUoOTEwMSk7XHJcblx0XHRcdFx0Y29uc29sZS5sb2codW5zdWJJRCk7XHJcblx0XHRcdH1cclxuXHRcdFx0XHJcblx0XHR9XHJcblx0XHRcclxuXHR9XHJcblx0XHJcblx0ZnVuY3Rpb24gZW5kKCl7XHJcblx0XHRkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXl1cCcsIG9uS2V5VXAsIGZhbHNlKTtcclxuXHRcdGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBvbktleURvd24sIGZhbHNlKTtcclxuXHRcdGluaXRpYWxpemVkID0gZmFsc2U7XHJcblx0XHRjb25zb2xlLmxvZygnS2V5d29yZCBNb2R1bGUgVGVybWluYXRlZCcpO1xyXG5cdH1cclxuXHRcclxuXHRyZXR1cm57XHJcblx0XHRpbml0IDogaW5pdCxcclxuXHRcdHVwZGF0ZSA6IHJ1bktleXMsXHJcblx0XHRlbmQgOiBlbmRcclxuXHR9XHJcblx0XHJcbn0oKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0ga2V5Ym9hcmRDb250cm9sO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9qcy9rZXlib2FyZENvbnRyb2wuanNcbiAqKiBtb2R1bGUgaWQgPSA2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9